Automated Lens Flare Removal

Floris Chabert

Abstract

1 Motivation

Lens ﬂare and ghosting can be prevalent
artifacts when taking pictures of a scene
with a direct bright light. Those artifacts
are usually caused by internal reﬂections of
the lens due to a thin anti reﬂective coating
and can easily ruin a beautiful picture.

This project aims at automatically remov-
ing those lens artifacts via post-processing
from a single input image to produce a re-
stored picture. We designed an algorithm
involving two steps: ﬂare detection and re-
covery of the damaged region.

2 Related Work

Previous work found in the image pro-
cessing literature around lens ﬂare detection
and generic ﬂares detection can be sepa-
rated in two categories: semi-automatic or
using multiple images. Some ﬂare detection
algorithms involve either having a manual
step where the user has to select the general
area where the ﬂare is present[1] or the
speciﬁc color of the ﬂare. This prevents
false positive and makes the algorithm more
robust.
The second kind uses multiple
pictures to detect ﬂares. They use images
with diﬀerent exposures to be able to ﬁnd
the spots that saturated the sensor. Others
use multiple frames with camera motion
in between to ﬁgure out where the artifact
is[2]. Another interesting category uses
pictures with and without ﬂash to detect
general ﬂares.

Various methods for recovery exist[3].
They are often referenced to as inpainting
algorithms. Two major kind of inpaint-
ing are extensively documented: non-texture
inpainting - often using partial diﬀerential
equations based on diﬀerent diﬀusion mod-
els[6][7] - and texture based methods[4]. Non
texture based techniques usually work very
well for small regions - especially when using
higher degree derivatives to preserve edges
- but have a tendency to produce blurred
patches. Texture based inpainiting works
better to ﬁll larger holes as they copy-paste
patches to recover the image by minimizing
an error metric.

3 Method

Here we aim at an automated detection of
the ﬂares using a single input image. This
involves a custom blob detection algorithm
based on a concept used in OpenCV[5] tuned
for the speciﬁc lens ﬂares we want to de-
tect and a hybrid inpainting method called
exemplare-based inpainting[8].

3.1 Detection

The chosen detection algorithm used

includes ﬁve main steps:

Figure 1: Flare detection algorithm

1

Automated Lens Flare Removal

Floris Chabert

Abstract

1 Motivation

Lens ﬂare and ghosting can be prevalent
artifacts when taking pictures of a scene
with a direct bright light. Those artifacts
are usually caused by internal reﬂections of
the lens due to a thin anti reﬂective coating
and can easily ruin a beautiful picture.

This project aims at automatically remov-
ing those lens artifacts via post-processing
from a single input image to produce a re-
stored picture. We designed an algorithm
involving two steps: ﬂare detection and re-
covery of the damaged region.

2 Related Work

Previous work found in the image pro-
cessing literature around lens ﬂare detection
and generic ﬂares detection can be sepa-
rated in two categories: semi-automatic or
using multiple images. Some ﬂare detection
algorithms involve either having a manual
step where the user has to select the general
area where the ﬂare is present[1] or the
speciﬁc color of the ﬂare. This prevents
false positive and makes the algorithm more
robust.
The second kind uses multiple
pictures to detect ﬂares. They use images
with diﬀerent exposures to be able to ﬁnd
the spots that saturated the sensor. Others
use multiple frames with camera motion
in between to ﬁgure out where the artifact
is[2]. Another interesting category uses
pictures with and without ﬂash to detect
general ﬂares.

Various methods for recovery exist[3].
They are often referenced to as inpainting
algorithms. Two major kind of inpaint-
ing are extensively documented: non-texture
inpainting - often using partial diﬀerential
equations based on diﬀerent diﬀusion mod-
els[6][7] - and texture based methods[4]. Non
texture based techniques usually work very
well for small regions - especially when using
higher degree derivatives to preserve edges
- but have a tendency to produce blurred
patches. Texture based inpainiting works
better to ﬁll larger holes as they copy-paste
patches to recover the image by minimizing
an error metric.

3 Method

Here we aim at an automated detection of
the ﬂares using a single input image. This
involves a custom blob detection algorithm
based on a concept used in OpenCV[5] tuned
for the speciﬁc lens ﬂares we want to de-
tect and a hybrid inpainting method called
exemplare-based inpainting[8].

3.1 Detection

The chosen detection algorithm used

includes ﬁve main steps:

Figure 1: Flare detection algorithm

1

Multiple Thresholding The image is
converted to grayscale and binarized using
a range of thresholds.

Contour Detection For each binary
image, we then ﬁnd the contours using a
border following method[9].

Blob Merging The center of each blob is
then computed and blobs from the diﬀerent
binary images are merged depending on
their distance and similarity. We ﬁnally
obtain a set of potential ﬂare candidates.

Flare Candidates Filtering The ﬂare
candidates are pruned using various metrics
which parameters have been tuned using a
set of images as to be robust while avoiding
false positive. Those metrics include circu-
larity of the blob, convexity, inertia and area.

Figure 3: Flare inpainting algorithm

the missing pixels - we execute the following
algorithm until all the pixels have been
recovered:

Identify Fill Front We ﬁrst ﬁnd the

contour of the region we want to ﬁll.

Identify Priority Patches Patches on
the ﬁll front are assigned priorities as to
privilege patches that continue strong edges
and are surrounded by high conﬁdence
pixels.

Find Best Exemplar By priority order,
we then search the window for known
patches that minimize the error.

Fill Region using Exemplar Patch We
ﬁnally select pixels from the best patch to
ﬁll the masked pixels in the current patch to
recover.

Figure 2: Impact of ﬁltering parameters for
blob detection[5]

Flare Mask Computation Finally the
mask selecting the ﬂares is computed for the
next step.

3.2 Recovery

Figure
steps[8]

4:

Exemplar-based inpainting

After the ﬂare mask has been computed
we can recover the damaged area using
exemplar-based inpainting.

4 Results

After selecting a window around the ﬂare
- to avoid searching over the whole image,
assuming good texture candidates are near

The described method show good results.
The detection is robust and ﬁnds the ﬂares
is the vast majority of picture from the test-

2

Automated Lens Flare Removal

Floris Chabert

Abstract

1 Motivation

Lens ﬂare and ghosting can be prevalent
artifacts when taking pictures of a scene
with a direct bright light. Those artifacts
are usually caused by internal reﬂections of
the lens due to a thin anti reﬂective coating
and can easily ruin a beautiful picture.

This project aims at automatically remov-
ing those lens artifacts via post-processing
from a single input image to produce a re-
stored picture. We designed an algorithm
involving two steps: ﬂare detection and re-
covery of the damaged region.

2 Related Work

Previous work found in the image pro-
cessing literature around lens ﬂare detection
and generic ﬂares detection can be sepa-
rated in two categories: semi-automatic or
using multiple images. Some ﬂare detection
algorithms involve either having a manual
step where the user has to select the general
area where the ﬂare is present[1] or the
speciﬁc color of the ﬂare. This prevents
false positive and makes the algorithm more
robust.
The second kind uses multiple
pictures to detect ﬂares. They use images
with diﬀerent exposures to be able to ﬁnd
the spots that saturated the sensor. Others
use multiple frames with camera motion
in between to ﬁgure out where the artifact
is[2]. Another interesting category uses
pictures with and without ﬂash to detect
general ﬂares.

Various methods for recovery exist[3].
They are often referenced to as inpainting
algorithms. Two major kind of inpaint-
ing are extensively documented: non-texture
inpainting - often using partial diﬀerential
equations based on diﬀerent diﬀusion mod-
els[6][7] - and texture based methods[4]. Non
texture based techniques usually work very
well for small regions - especially when using
higher degree derivatives to preserve edges
- but have a tendency to produce blurred
patches. Texture based inpainiting works
better to ﬁll larger holes as they copy-paste
patches to recover the image by minimizing
an error metric.

3 Method

Here we aim at an automated detection of
the ﬂares using a single input image. This
involves a custom blob detection algorithm
based on a concept used in OpenCV[5] tuned
for the speciﬁc lens ﬂares we want to de-
tect and a hybrid inpainting method called
exemplare-based inpainting[8].

3.1 Detection

The chosen detection algorithm used

includes ﬁve main steps:

Figure 1: Flare detection algorithm

1

Multiple Thresholding The image is
converted to grayscale and binarized using
a range of thresholds.

Contour Detection For each binary
image, we then ﬁnd the contours using a
border following method[9].

Blob Merging The center of each blob is
then computed and blobs from the diﬀerent
binary images are merged depending on
their distance and similarity. We ﬁnally
obtain a set of potential ﬂare candidates.

Flare Candidates Filtering The ﬂare
candidates are pruned using various metrics
which parameters have been tuned using a
set of images as to be robust while avoiding
false positive. Those metrics include circu-
larity of the blob, convexity, inertia and area.

Figure 3: Flare inpainting algorithm

the missing pixels - we execute the following
algorithm until all the pixels have been
recovered:

Identify Fill Front We ﬁrst ﬁnd the

contour of the region we want to ﬁll.

Identify Priority Patches Patches on
the ﬁll front are assigned priorities as to
privilege patches that continue strong edges
and are surrounded by high conﬁdence
pixels.

Find Best Exemplar By priority order,
we then search the window for known
patches that minimize the error.

Fill Region using Exemplar Patch We
ﬁnally select pixels from the best patch to
ﬁll the masked pixels in the current patch to
recover.

Figure 2: Impact of ﬁltering parameters for
blob detection[5]

Flare Mask Computation Finally the
mask selecting the ﬂares is computed for the
next step.

3.2 Recovery

Figure
steps[8]

4:

Exemplar-based inpainting

After the ﬂare mask has been computed
we can recover the damaged area using
exemplar-based inpainting.

4 Results

After selecting a window around the ﬂare
- to avoid searching over the whole image,
assuming good texture candidates are near

The described method show good results.
The detection is robust and ﬁnds the ﬂares
is the vast majority of picture from the test-

2

ing set. The exemplare-based technique for
recovery is also very solid and allows ﬁlling
of larger regions without blurring the image.

Figure 8: Image 2 after processing

It has also been
a Intel-core i5 processor.
ported to an arm64 platform and runs in less
than 10 seconds on an iPhone 6s.

Figure 5: Image 1 before processing

5 Discussion

Figure 6: Image 1 after processing

Diﬀerent detection algorithm have been
tried for this project. Circular detection
through Hough-transform has not been very
robust as most ﬂares are not fully circular.
A SIFT descriptor based method has also
been tested. A set of ﬂare descriptors
were learned from a training set and then
matched against keypoints in the target
image. Unfortunately this method was too
dependent on the training set.

The chosen blob detection method ends
up being quite robust.
Some issue exist
though. The main one being false positives
in speciﬁc scene. The following ﬁgure shows
a false detection were a green traﬃc light in
the fog is wrongly thought to be a ﬂare.

Restoration has also been tried using
non texture inpainting. Unfortunately the
large size of the ﬂares makes the recovered
area quite blurry. Here you can see the
diﬀerence between a non-texture recovery
(using Navier-stokes)
compared to the
exemplare-based method.

Figure 7: Image 2 before processing

The full algorithm has been implemented
in C++ and runs in less than 5 seconds on

Future work on this subject include bet-
ter detection methods to prevent the false
positive issue described above as well as bet-

3

Automated Lens Flare Removal

Floris Chabert

Abstract

1 Motivation

Lens ﬂare and ghosting can be prevalent
artifacts when taking pictures of a scene
with a direct bright light. Those artifacts
are usually caused by internal reﬂections of
the lens due to a thin anti reﬂective coating
and can easily ruin a beautiful picture.

This project aims at automatically remov-
ing those lens artifacts via post-processing
from a single input image to produce a re-
stored picture. We designed an algorithm
involving two steps: ﬂare detection and re-
covery of the damaged region.

2 Related Work

Previous work found in the image pro-
cessing literature around lens ﬂare detection
and generic ﬂares detection can be sepa-
rated in two categories: semi-automatic or
using multiple images. Some ﬂare detection
algorithms involve either having a manual
step where the user has to select the general
area where the ﬂare is present[1] or the
speciﬁc color of the ﬂare. This prevents
false positive and makes the algorithm more
robust.
The second kind uses multiple
pictures to detect ﬂares. They use images
with diﬀerent exposures to be able to ﬁnd
the spots that saturated the sensor. Others
use multiple frames with camera motion
in between to ﬁgure out where the artifact
is[2]. Another interesting category uses
pictures with and without ﬂash to detect
general ﬂares.

Various methods for recovery exist[3].
They are often referenced to as inpainting
algorithms. Two major kind of inpaint-
ing are extensively documented: non-texture
inpainting - often using partial diﬀerential
equations based on diﬀerent diﬀusion mod-
els[6][7] - and texture based methods[4]. Non
texture based techniques usually work very
well for small regions - especially when using
higher degree derivatives to preserve edges
- but have a tendency to produce blurred
patches. Texture based inpainiting works
better to ﬁll larger holes as they copy-paste
patches to recover the image by minimizing
an error metric.

3 Method

Here we aim at an automated detection of
the ﬂares using a single input image. This
involves a custom blob detection algorithm
based on a concept used in OpenCV[5] tuned
for the speciﬁc lens ﬂares we want to de-
tect and a hybrid inpainting method called
exemplare-based inpainting[8].

3.1 Detection

The chosen detection algorithm used

includes ﬁve main steps:

Figure 1: Flare detection algorithm

1

Multiple Thresholding The image is
converted to grayscale and binarized using
a range of thresholds.

Contour Detection For each binary
image, we then ﬁnd the contours using a
border following method[9].

Blob Merging The center of each blob is
then computed and blobs from the diﬀerent
binary images are merged depending on
their distance and similarity. We ﬁnally
obtain a set of potential ﬂare candidates.

Flare Candidates Filtering The ﬂare
candidates are pruned using various metrics
which parameters have been tuned using a
set of images as to be robust while avoiding
false positive. Those metrics include circu-
larity of the blob, convexity, inertia and area.

Figure 3: Flare inpainting algorithm

the missing pixels - we execute the following
algorithm until all the pixels have been
recovered:

Identify Fill Front We ﬁrst ﬁnd the

contour of the region we want to ﬁll.

Identify Priority Patches Patches on
the ﬁll front are assigned priorities as to
privilege patches that continue strong edges
and are surrounded by high conﬁdence
pixels.

Find Best Exemplar By priority order,
we then search the window for known
patches that minimize the error.

Fill Region using Exemplar Patch We
ﬁnally select pixels from the best patch to
ﬁll the masked pixels in the current patch to
recover.

Figure 2: Impact of ﬁltering parameters for
blob detection[5]

Flare Mask Computation Finally the
mask selecting the ﬂares is computed for the
next step.

3.2 Recovery

Figure
steps[8]

4:

Exemplar-based inpainting

After the ﬂare mask has been computed
we can recover the damaged area using
exemplar-based inpainting.

4 Results

After selecting a window around the ﬂare
- to avoid searching over the whole image,
assuming good texture candidates are near

The described method show good results.
The detection is robust and ﬁnds the ﬂares
is the vast majority of picture from the test-

2

ing set. The exemplare-based technique for
recovery is also very solid and allows ﬁlling
of larger regions without blurring the image.

Figure 8: Image 2 after processing

It has also been
a Intel-core i5 processor.
ported to an arm64 platform and runs in less
than 10 seconds on an iPhone 6s.

Figure 5: Image 1 before processing

5 Discussion

Figure 6: Image 1 after processing

Diﬀerent detection algorithm have been
tried for this project. Circular detection
through Hough-transform has not been very
robust as most ﬂares are not fully circular.
A SIFT descriptor based method has also
been tested. A set of ﬂare descriptors
were learned from a training set and then
matched against keypoints in the target
image. Unfortunately this method was too
dependent on the training set.

The chosen blob detection method ends
up being quite robust.
Some issue exist
though. The main one being false positives
in speciﬁc scene. The following ﬁgure shows
a false detection were a green traﬃc light in
the fog is wrongly thought to be a ﬂare.

Restoration has also been tried using
non texture inpainting. Unfortunately the
large size of the ﬂares makes the recovered
area quite blurry. Here you can see the
diﬀerence between a non-texture recovery
(using Navier-stokes)
compared to the
exemplare-based method.

Figure 7: Image 2 before processing

The full algorithm has been implemented
in C++ and runs in less than 5 seconds on

Future work on this subject include bet-
ter detection methods to prevent the false
positive issue described above as well as bet-

3

Figure 11: Recovery using exemplare based
inpainting

[3] arcelo Bertalmo, Vicent Caselles, Simon

Masnou, Guillermo Sapiro, Inpainting

[4] ajul Suthar, Mr. Krunal R. Patel, A Sur-
vey on Various Image Inpainting Tech-
niques to Restore Image, Int. Journal of
Engineering Research and Applications

[5] atya Mallick Blob Detection Using

OpenCV, learnopencv.com

[6] ony F. Chan, Jianhong Shen Mathemati-
cal Models for Local Nontexture Inpaint-
ings SIAM Journal on Applied Mathe-
matics, Vol. 62, No. 3

[7] ony F. Chan, Jianhong Shen, Non-
Texture Inpainting by Curvature-Driven-
Diﬀusions, Visual Comm Image Rep
06/2001

[8] iansheng Liu, Mingming Li, Fangfang He
Region Filling and Object Removal by
Exemplar-Based Image Inpainting, IEEE
Transactions on Image Processing, Vol.
13, No. 9, 2004

[9] uzuki, S. and Abe, K., Topological Struc-
tural Analysis of Digitized Binary Images
by Border Following CVGIP 30 1, pp 32-
46, 1985

Figure 9: Traﬃc light wrongly detected as a
ﬂare

Figure 10: Recovery using non-texture based
inpainting

ter inpainting using modern techniques. An-
other area of research would look at using
this method for other kind of ﬂares as well
as using the mask of the detected ﬂares to
ﬁnd nearby regions containing ﬂares.

References

[1] usan Psotny, Removing lens ﬂare from
digital photographs, Charles University in
Prague, Diploma Thesis

[2] ndreas Nussberger, Helmut Grabner,
Luc Van Gool, Robust Aerial Object
Tracking in Images with Lens Flare,
Comput. Vision Lab., ETH Zurich

4

