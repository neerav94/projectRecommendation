Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Constructor

b = new Bundle()

e.e[b 7! ?]

⇤

b

B.B

B.?

⇤

b

d

d

Adding int key-value pair

b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb

⇤

b

B.B

B.B

λB.βb

({MyInt},?,0,())(B)

d

d

B.B

1 public C o m p o n e n t N a m e

m a k e C o m p o n e n t N a m e () {

C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {

c = new C o m p o n e n t N a m e ( " c . d " ,

2
3
4

" a . b . MyClass " ) ;

} else {

" a . b . M y S e c o n d C l a s s " ) ; }

c = new C o m p o n e n t N a m e ( " c . d " ,

5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12

Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,

return c ; }

Copy constructor

b = new Bundle(d)

e.e[b 7! e(d)]

⇤

b

Clearing extra data keys

d.clear()

λe.ehd 7! βb

(?,?,1,())(e(d))i

⇤

b

d

⇤

B.B

B.B

B.B

B.B

B.B

⇤

b

d

⇤

b

b

λB.βb

(?,?,1,())(B)

d

d

Figure 6: Pointwise environment transformers for com-
mon Bundle operations

transformer t

the environment

require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.

The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.

We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges

environment
i.e.

transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).

ing studied.

of G∗,

assigns

to

this . m F i r s t N a m e ) ;

bundle . putAll ( b ) ;
bundle . remove ( " Surname " ) ;
return bundle ; }

Intent intent = new Intent () ;
intent . s e t C o m p o n t e n t ( m a k e C o m p o n e n t N a m e () ) ;
Bundle b = new Bundle () ;
b . p u t S t r i n g ( " Surname " , this . m S u r n a m e ) ;
intent . p u t E x t r a s ( m a k e B u n d l e ( b ) ) ;
r e g i s t e r M y R e c e i v e r () ;
s t a r t A c t i v i t y ( intent ) ; }

13
14
15
16
17 public void onClick ( View v ) {
18
19
20
21
22
23
24
25
26 public void r e g i s t e r M y R e c e i v e r () {
27
28
29
30
31

I n t e n t F i l t e r f = new I n t e n t F i l t e r () ;
f . a d d A c t i o n ( " a . b . ACTION " ) ;
f . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
r e g i s t e r R e c e i v e r ( new M y R e c e i v e r () ,

f , " a . b . P E R M I S S I O N " , null ) ; }
Figure 7: ICC objects example

Under certain conditions on the representation of
micro-functions, an IDE problem can be solved in time
O(ED3) [32]. For example, micro-functions should be
applied in constant time. In the model we present in Sec-
tion 5, we relax some of these constraints but ﬁnd that
the problem can still be solved efﬁciently in the average
case. When the problem is solved, we know the value as-
sociated with each symbol at important program points.

5 Reducing Intent ICC to an IDE problem

To solve the Intent ICC problem, we need to model
four different kinds of objects. First, ComponentName
objects contain a package name and a class name.
They can be used by explicit Intents. For example, in
method makeComponentName() of Figure 7, a Com-
ponentName object can take two different values de-
pending on which branch is executed.
In the ﬁrst
branch, it refers to class a.b.MyClass from applica-
tion package c.d. In the second one, it refers to class
a.b.MySecondClass. We want to know the possible
return values of makeComponentName().

Second, Bundle objects store data as key-value map-
pings. Method makeBundle() of Figure 7 creates a Bun-
dle and modiﬁes its value. We need to ﬁnd the possible
return values of makeBundle().

Third, Intent objects are the main ICC communica-

548  22nd USENIX Security Symposium 

USENIX Association

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Constructor

b = new Bundle()

e.e[b 7! ?]

⇤

b

B.B

B.?

⇤

b

d

d

Adding int key-value pair

b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb

⇤

b

B.B

B.B

λB.βb

({MyInt},?,0,())(B)

d

d

B.B

1 public C o m p o n e n t N a m e

m a k e C o m p o n e n t N a m e () {

C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {

c = new C o m p o n e n t N a m e ( " c . d " ,

2
3
4

" a . b . MyClass " ) ;

} else {

" a . b . M y S e c o n d C l a s s " ) ; }

c = new C o m p o n e n t N a m e ( " c . d " ,

5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12

Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,

return c ; }

Copy constructor

b = new Bundle(d)

e.e[b 7! e(d)]

⇤

b

Clearing extra data keys

d.clear()

λe.ehd 7! βb

(?,?,1,())(e(d))i

⇤

b

d

⇤

B.B

B.B

B.B

B.B

B.B

⇤

b

d

⇤

b

b

λB.βb

(?,?,1,())(B)

d

d

Figure 6: Pointwise environment transformers for com-
mon Bundle operations

transformer t

the environment

require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.

The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.

We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges

environment
i.e.

transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).

ing studied.

of G∗,

assigns

to

this . m F i r s t N a m e ) ;

bundle . putAll ( b ) ;
bundle . remove ( " Surname " ) ;
return bundle ; }

Intent intent = new Intent () ;
intent . s e t C o m p o n t e n t ( m a k e C o m p o n e n t N a m e () ) ;
Bundle b = new Bundle () ;
b . p u t S t r i n g ( " Surname " , this . m S u r n a m e ) ;
intent . p u t E x t r a s ( m a k e B u n d l e ( b ) ) ;
r e g i s t e r M y R e c e i v e r () ;
s t a r t A c t i v i t y ( intent ) ; }

13
14
15
16
17 public void onClick ( View v ) {
18
19
20
21
22
23
24
25
26 public void r e g i s t e r M y R e c e i v e r () {
27
28
29
30
31

I n t e n t F i l t e r f = new I n t e n t F i l t e r () ;
f . a d d A c t i o n ( " a . b . ACTION " ) ;
f . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
r e g i s t e r R e c e i v e r ( new M y R e c e i v e r () ,

f , " a . b . P E R M I S S I O N " , null ) ; }
Figure 7: ICC objects example

Under certain conditions on the representation of
micro-functions, an IDE problem can be solved in time
O(ED3) [32]. For example, micro-functions should be
applied in constant time. In the model we present in Sec-
tion 5, we relax some of these constraints but ﬁnd that
the problem can still be solved efﬁciently in the average
case. When the problem is solved, we know the value as-
sociated with each symbol at important program points.

5 Reducing Intent ICC to an IDE problem

To solve the Intent ICC problem, we need to model
four different kinds of objects. First, ComponentName
objects contain a package name and a class name.
They can be used by explicit Intents. For example, in
method makeComponentName() of Figure 7, a Com-
ponentName object can take two different values de-
pending on which branch is executed.
In the ﬁrst
branch, it refers to class a.b.MyClass from applica-
tion package c.d. In the second one, it refers to class
a.b.MySecondClass. We want to know the possible
return values of makeComponentName().

Second, Bundle objects store data as key-value map-
pings. Method makeBundle() of Figure 7 creates a Bun-
dle and modiﬁes its value. We need to ﬁnd the possible
return values of makeBundle().

Third, Intent objects are the main ICC communica-

548  22nd USENIX Security Symposium 

USENIX Association

the target class of intent

tion objects. They contain all the data that is used to
In method onClick() of Fig-
start other components.
is set using the re-
ure 7,
turn value of makeComponentName().
Its extra data
is set to the return value of makeBundle(). Finally,
a new Activity is started using the newly created In-
tent. We need to determine the value of intent at the
startActivity(intent) instruction.

Fourth,

IntentFilter objects are used for dynamic
Broadcast Receivers.
In registerMyReceiver() on Fig-
ure 7, an action and a category are added to IntentFil-
ter f . Then a Broadcast Receiver of type MyReceiver
(which we assume to be deﬁned) is registered us-
ing method registerReceiver().
It receives Intents that
have action a.b.ACTION and category a.b.CATEGORY
and that originate from applications with permission
a.b.PERMISSION. We want to determine the arguments
to the registerReceiver() call. That is, we want to
know that f contains action a.b.ACTION and category
a.b.CATEGORY. We also want to know that the type of
the Broadcast Receiver is MyReceiver.

In this section, we use the notations from Sagiv et
al. [32] summarized in Section 4. We assume that string
method arguments are available. We describe the string
analysis used in our implementation in Section 6.

5.1 ComponentName Model
In this section, we introduce the model we use for Com-
ponentName objects. We introduce the notion of a
branch ComponentName value. It represents the value
that a ComponentName object can take on a single
branch, given a single possible string argument value for
each method setting the ComponentName’s package and
class names, and in the absence of aliasing.
Deﬁnition 1. A branch ComponentName value is a tuple
c = (p,k), where p is a package name and k is a class
name.

In method makeComponentName() of Figure 7, two

branch ComponentName values are constructed:

(c.d, a.b.MyClass)

(1)

and

(c.d, a.b.MySecondClass)

(2)
The next deﬁnition introduces ComponentName val-
ues, which represent the possibly multiple values that a
ComponentName can have at a program point. A Com-
ponentName can take several values in different cases:
• After traversing different branches, as in method
• When a string argument can have several values at a
• When an object reference is a possible alias of an-

makeComponentName() of Figure 7.

other local reference or an object ﬁeld.

method call.

• When an object reference is a possible array element.
In the last two cases, in order to account for the possi-
bility of a false positive in the alias analysis, we keep
track of two branch ComponentName values. One con-
siders the inﬂuence of the call on the possible alias and
the other one does not.
Deﬁnition 2. A ComponentName value C is a set of
branch ComponentName values: C = {c1,c2,··· ,cm}.
The set of ComponentName values is denoted as Vc. We
deﬁne ⊥ = ∅ and (cid:26) as the ComponentName value that
is the set of all possible branch ComponentName val-
ues in the program. The operators ∪ and ⊆ are deﬁned
as traditional set union and comparison operators: for
C1,C2 ∈ Vc, C1 ⊆ C2 iff C1 ∪C2 = C2. Lc = (Vc,∪) is a
join semilattice.

Note that given the deﬁnitions of ⊥ and (cid:26) as speciﬁc
sets, ∪ and ⊆ naturally apply to them. For example, for
all C ∈ Vc, (cid:26)∪C = (cid:26).
In method makeComponentName() from Figure 7, the
value of c at the return statement is

{(c.d, a.b.MyClass) ,

(3)
It simply combines the values of c created in the two
branches, given by Equations (1) and (2).

(c.d, a.b.MySecondClass)} .

We deﬁne transformers from Vc to Vc that represent
the inﬂuence of a statement or a sequence of statements
on a ComponentName value. A pointwise branch Com-
ponentName transformer represents the inﬂuence of a
single branch, whereas a pointwise ComponentName
transformer represents the inﬂuence of possibly multiple
branches.
Deﬁnition 3. A pointwise branch ComponentName
transformer is a function δ c
(π,χ) : Vc → Vc, where π is a
package name and χ is a class name. It is such that, for
each C ∈ Vc,

δ c
(π,χ)(C) ={(π , χ)}

(4)

Note that δ c

(π,χ)(C) is independent of C, because API
methods for ComponentName objects systematically re-
place existing values for package and class names. In the
example from Figure 7, the pointwise branch Compo-
nentName transformer corresponding to the ﬁrst branch
is

δ c
(c.d,a.b.MyClass),
and the one for the second branch is

δ c
(c.d,a.b.MySecondClass).

(5)
Deﬁnition 4. A pointwise ComponentName transformer
is a function δ c
: Vc → Vc such that, for
each C ∈ Vc,

δ c
{(π1,χ1),··· ,(πn,χn)}(C) ={(π 1, χ1),··· , (πn, χn)}

{(π1,χ1),··· ,(πn,χn)}

A pointwise ComponentName transformer summa-

USENIX Association  

22nd USENIX Security Symposium  549

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Constructor

b = new Bundle()

e.e[b 7! ?]

⇤

b

B.B

B.?

⇤

b

d

d

Adding int key-value pair

b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb

⇤

b

B.B

B.B

λB.βb

({MyInt},?,0,())(B)

d

d

B.B

1 public C o m p o n e n t N a m e

m a k e C o m p o n e n t N a m e () {

C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {

c = new C o m p o n e n t N a m e ( " c . d " ,

2
3
4

" a . b . MyClass " ) ;

} else {

" a . b . M y S e c o n d C l a s s " ) ; }

c = new C o m p o n e n t N a m e ( " c . d " ,

5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12

Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,

return c ; }

Copy constructor

b = new Bundle(d)

e.e[b 7! e(d)]

⇤

b

Clearing extra data keys

d.clear()

λe.ehd 7! βb

(?,?,1,())(e(d))i

⇤

b

d

⇤

B.B

B.B

B.B

B.B

B.B

⇤

b

d

⇤

b

b

λB.βb

(?,?,1,())(B)

d

d

Figure 6: Pointwise environment transformers for com-
mon Bundle operations

transformer t

the environment

require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.

The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.

We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges

environment
i.e.

transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).

ing studied.

of G∗,

assigns

to

this . m F i r s t N a m e ) ;

bundle . putAll ( b ) ;
bundle . remove ( " Surname " ) ;
return bundle ; }

Intent intent = new Intent () ;
intent . s e t C o m p o n t e n t ( m a k e C o m p o n e n t N a m e () ) ;
Bundle b = new Bundle () ;
b . p u t S t r i n g ( " Surname " , this . m S u r n a m e ) ;
intent . p u t E x t r a s ( m a k e B u n d l e ( b ) ) ;
r e g i s t e r M y R e c e i v e r () ;
s t a r t A c t i v i t y ( intent ) ; }

13
14
15
16
17 public void onClick ( View v ) {
18
19
20
21
22
23
24
25
26 public void r e g i s t e r M y R e c e i v e r () {
27
28
29
30
31

I n t e n t F i l t e r f = new I n t e n t F i l t e r () ;
f . a d d A c t i o n ( " a . b . ACTION " ) ;
f . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
r e g i s t e r R e c e i v e r ( new M y R e c e i v e r () ,

f , " a . b . P E R M I S S I O N " , null ) ; }
Figure 7: ICC objects example

Under certain conditions on the representation of
micro-functions, an IDE problem can be solved in time
O(ED3) [32]. For example, micro-functions should be
applied in constant time. In the model we present in Sec-
tion 5, we relax some of these constraints but ﬁnd that
the problem can still be solved efﬁciently in the average
case. When the problem is solved, we know the value as-
sociated with each symbol at important program points.

5 Reducing Intent ICC to an IDE problem

To solve the Intent ICC problem, we need to model
four different kinds of objects. First, ComponentName
objects contain a package name and a class name.
They can be used by explicit Intents. For example, in
method makeComponentName() of Figure 7, a Com-
ponentName object can take two different values de-
pending on which branch is executed.
In the ﬁrst
branch, it refers to class a.b.MyClass from applica-
tion package c.d. In the second one, it refers to class
a.b.MySecondClass. We want to know the possible
return values of makeComponentName().

Second, Bundle objects store data as key-value map-
pings. Method makeBundle() of Figure 7 creates a Bun-
dle and modiﬁes its value. We need to ﬁnd the possible
return values of makeBundle().

Third, Intent objects are the main ICC communica-

548  22nd USENIX Security Symposium 

USENIX Association

the target class of intent

tion objects. They contain all the data that is used to
In method onClick() of Fig-
start other components.
is set using the re-
ure 7,
turn value of makeComponentName().
Its extra data
is set to the return value of makeBundle(). Finally,
a new Activity is started using the newly created In-
tent. We need to determine the value of intent at the
startActivity(intent) instruction.

Fourth,

IntentFilter objects are used for dynamic
Broadcast Receivers.
In registerMyReceiver() on Fig-
ure 7, an action and a category are added to IntentFil-
ter f . Then a Broadcast Receiver of type MyReceiver
(which we assume to be deﬁned) is registered us-
ing method registerReceiver().
It receives Intents that
have action a.b.ACTION and category a.b.CATEGORY
and that originate from applications with permission
a.b.PERMISSION. We want to determine the arguments
to the registerReceiver() call. That is, we want to
know that f contains action a.b.ACTION and category
a.b.CATEGORY. We also want to know that the type of
the Broadcast Receiver is MyReceiver.

In this section, we use the notations from Sagiv et
al. [32] summarized in Section 4. We assume that string
method arguments are available. We describe the string
analysis used in our implementation in Section 6.

5.1 ComponentName Model
In this section, we introduce the model we use for Com-
ponentName objects. We introduce the notion of a
branch ComponentName value. It represents the value
that a ComponentName object can take on a single
branch, given a single possible string argument value for
each method setting the ComponentName’s package and
class names, and in the absence of aliasing.
Deﬁnition 1. A branch ComponentName value is a tuple
c = (p,k), where p is a package name and k is a class
name.

In method makeComponentName() of Figure 7, two

branch ComponentName values are constructed:

(c.d, a.b.MyClass)

(1)

and

(c.d, a.b.MySecondClass)

(2)
The next deﬁnition introduces ComponentName val-
ues, which represent the possibly multiple values that a
ComponentName can have at a program point. A Com-
ponentName can take several values in different cases:
• After traversing different branches, as in method
• When a string argument can have several values at a
• When an object reference is a possible alias of an-

makeComponentName() of Figure 7.

other local reference or an object ﬁeld.

method call.

• When an object reference is a possible array element.
In the last two cases, in order to account for the possi-
bility of a false positive in the alias analysis, we keep
track of two branch ComponentName values. One con-
siders the inﬂuence of the call on the possible alias and
the other one does not.
Deﬁnition 2. A ComponentName value C is a set of
branch ComponentName values: C = {c1,c2,··· ,cm}.
The set of ComponentName values is denoted as Vc. We
deﬁne ⊥ = ∅ and (cid:26) as the ComponentName value that
is the set of all possible branch ComponentName val-
ues in the program. The operators ∪ and ⊆ are deﬁned
as traditional set union and comparison operators: for
C1,C2 ∈ Vc, C1 ⊆ C2 iff C1 ∪C2 = C2. Lc = (Vc,∪) is a
join semilattice.

Note that given the deﬁnitions of ⊥ and (cid:26) as speciﬁc
sets, ∪ and ⊆ naturally apply to them. For example, for
all C ∈ Vc, (cid:26)∪C = (cid:26).
In method makeComponentName() from Figure 7, the
value of c at the return statement is

{(c.d, a.b.MyClass) ,

(3)
It simply combines the values of c created in the two
branches, given by Equations (1) and (2).

(c.d, a.b.MySecondClass)} .

We deﬁne transformers from Vc to Vc that represent
the inﬂuence of a statement or a sequence of statements
on a ComponentName value. A pointwise branch Com-
ponentName transformer represents the inﬂuence of a
single branch, whereas a pointwise ComponentName
transformer represents the inﬂuence of possibly multiple
branches.
Deﬁnition 3. A pointwise branch ComponentName
transformer is a function δ c
(π,χ) : Vc → Vc, where π is a
package name and χ is a class name. It is such that, for
each C ∈ Vc,

δ c
(π,χ)(C) ={(π , χ)}

(4)

Note that δ c

(π,χ)(C) is independent of C, because API
methods for ComponentName objects systematically re-
place existing values for package and class names. In the
example from Figure 7, the pointwise branch Compo-
nentName transformer corresponding to the ﬁrst branch
is

δ c
(c.d,a.b.MyClass),
and the one for the second branch is

δ c
(c.d,a.b.MySecondClass).

(5)
Deﬁnition 4. A pointwise ComponentName transformer
is a function δ c
: Vc → Vc such that, for
each C ∈ Vc,

δ c
{(π1,χ1),··· ,(πn,χn)}(C) ={(π 1, χ1),··· , (πn, χn)}

{(π1,χ1),··· ,(πn,χn)}

A pointwise ComponentName transformer summa-

USENIX Association  

22nd USENIX Security Symposium  549

rizes the effect of multiple branches (or a single branch
with multiple possible string arguments, or with possi-
ble aliasing) on a ComponentName value. That is, given
the value C of a ComponentName right after statement
si and given transformer δ c
that sum-
marizes the inﬂuence of statements si+1,··· ,sk on C,
δ c
(C) represents all the possible values
{(π1,χ1),··· ,(πn,χn)}
of C right after sk. In method makeComponentName()
of Figure 7, the pointwise ComponentName transformer
that models the two branches is

{(π1,χ1),··· ,(πn,χn)}

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}.

(6)
It combines the transformers given by Equations (4)
and (5). In order to understand how this transformer is
applied in practice, we should mention that the algorithm
to solve IDE problems initially sets values to ⊥ [32].
Therefore, in method makeComponentName(), the value
associated with c is initially ⊥ = ∅. Using Deﬁnition 4,
we can easily see that if we apply the transformer given
by Equation (6), we get the value given by Equation (3).
This conﬁrms that the transformer models the inﬂuence
of the two branches:

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}(⊥)

= {(c.d, a.b.MyClass) ,

(c.d, a.b.MySecondClass)}

5.2 Bundle Model

The model of Bundle objects is deﬁned similarly to the
model of ComponentName objects. An additional difﬁ-
culty is introduced. The data in a Bundle can be modiﬁed
by adding the data in another Bundle to it, as shown in
method makeBundle() of Figure 7. In this example, the
data in Bundle b is added to the data in Bundle bundle.
Bundle bundle is later modiﬁed by removing the key-
value pair with key Surname. The issue is that when
the data ﬂow problem is being tackled, the value of b
is not known. Therefore, the inﬂuence of the call to
remove("Surname") is not known: if a key-value pair
with key Surname is part of b, then the call removes it
from bundle. Otherwise, it has no inﬂuence.

Our approach to deal with this object composition
problem is to perform two successive analyses. In Anal-
ysis I, we use placeholders for Bundles such as b in in-
struction bundle.putAll(b). We also record all subse-
quent method calls affecting bundle. After the problem
is solved, b’s key-value pairs at the putAll(b) method
call are known, as well as the subsequent method calls.
We then perform Analysis II, in which b’s key-value
pairs are added to bundle’s. The inﬂuence of the sub-
sequent method call is precisely evaluated and ﬁnally the
value of bundle at the return statement can be known.

b to V i

b, where V i

5.2.1 Analysis I
In the ﬁrst analysis, we consider intermediate values that
contain “placeholders” for Bundle values that are not
known when the problem is being solved.
Deﬁnition 5. An intermediate branch Bundle value is a
tuple bi = (E,O), where:
• E is a set of keys describing extra data.
• O is a tuple of two types of elements. O contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. O also contains functions
from V i
b is the set of intermediate Bun-
dle values deﬁned below. These functions represent a
sequence of method calls affecting a Bundle.
The difference with previous deﬁnitions is the intro-
duction of O, which models calls to putAll() as well as
subsequent calls affecting the same Bundle. In method
makeBundle() of Figure 7, at the return statement, the in-
termediate branch Bundle value associated with bundle
is (E,O), where
E ={FirstName}
O =((b, bundle.putAll(b)),β b

(7)
(8)
In O, (b, bundle.putAll(b)) is a reference to variable
b at instruction bundle.putAll(b). β b
(∅,Surname,0,())
models the remove() method call. It is deﬁned below.

(∅,{Surname},0,()))

b = (V i

b, Bi1 ⊆ Bi2 iff Bi1 ∪ Bi2 = Bi2. Li

We just deﬁned intermediate branch Bundle values.
As we did before, we need to consider multiple branches
and related issues (e.g., several possible string values):
Deﬁnition 6. An intermediate Bundle value Bi is a set of
intermediate branch Bundle values: Bi = {bi1,··· ,bim}.
The set of intermediate Bundle values is V i
b. We deﬁne
⊥ = ∅ and (cid:26) as the intermediate Bundle value that is
the set of all possible intermediate branch Bundle val-
ues in the program. We deﬁne ⊆ and ∪ as natural set
comparison and union operators. They are such that, for
Bi1,Bi2 ∈ V i
b,∪) is
a join semilattice.
In method makeBundle() from Figure 7, since there is
only a single branch, the intermediate Bundle value as-
sociated with bundle at the return statement is {(E,O)},
where E and O are given by Equations (7) and (8).
b to V i
b.
Similarly to the ComponentName model, we ﬁrst in-
troduce pointwise branch Bundle transformers before
deﬁning pointwise Bundle transformers.
In the def-
initions below, we use the \ notation for set differ-
ence, and ∪ is naturally extended to tuples such that
(a1,··· ,ak)∪ (ak+1,··· ,al) = (a1,··· ,ak,ak+1,··· ,al).
Deﬁnition 7. A pointwise branch Bundle transformer is
a function β b
• η + is a set of string keys describing extra data. It

Pointwise transformers are deﬁned from V i

(η +,η−,cl,Θ) : V i

models calls to putExtra() methods.

b → V i

b, where:

550  22nd USENIX Security Symposium 

USENIX Association

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Constructor

b = new Bundle()

e.e[b 7! ?]

⇤

b

B.B

B.?

⇤

b

d

d

Adding int key-value pair

b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb

⇤

b

B.B

B.B

λB.βb

({MyInt},?,0,())(B)

d

d

B.B

1 public C o m p o n e n t N a m e

m a k e C o m p o n e n t N a m e () {

C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {

c = new C o m p o n e n t N a m e ( " c . d " ,

2
3
4

" a . b . MyClass " ) ;

} else {

" a . b . M y S e c o n d C l a s s " ) ; }

c = new C o m p o n e n t N a m e ( " c . d " ,

5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12

Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,

return c ; }

Copy constructor

b = new Bundle(d)

e.e[b 7! e(d)]

⇤

b

Clearing extra data keys

d.clear()

λe.ehd 7! βb

(?,?,1,())(e(d))i

⇤

b

d

⇤

B.B

B.B

B.B

B.B

B.B

⇤

b

d

⇤

b

b

λB.βb

(?,?,1,())(B)

d

d

Figure 6: Pointwise environment transformers for com-
mon Bundle operations

transformer t

the environment

require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.

The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.

We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges

environment
i.e.

transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).

ing studied.

of G∗,

assigns

to

this . m F i r s t N a m e ) ;

bundle . putAll ( b ) ;
bundle . remove ( " Surname " ) ;
return bundle ; }

Intent intent = new Intent () ;
intent . s e t C o m p o n t e n t ( m a k e C o m p o n e n t N a m e () ) ;
Bundle b = new Bundle () ;
b . p u t S t r i n g ( " Surname " , this . m S u r n a m e ) ;
intent . p u t E x t r a s ( m a k e B u n d l e ( b ) ) ;
r e g i s t e r M y R e c e i v e r () ;
s t a r t A c t i v i t y ( intent ) ; }

13
14
15
16
17 public void onClick ( View v ) {
18
19
20
21
22
23
24
25
26 public void r e g i s t e r M y R e c e i v e r () {
27
28
29
30
31

I n t e n t F i l t e r f = new I n t e n t F i l t e r () ;
f . a d d A c t i o n ( " a . b . ACTION " ) ;
f . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
r e g i s t e r R e c e i v e r ( new M y R e c e i v e r () ,

f , " a . b . P E R M I S S I O N " , null ) ; }
Figure 7: ICC objects example

Under certain conditions on the representation of
micro-functions, an IDE problem can be solved in time
O(ED3) [32]. For example, micro-functions should be
applied in constant time. In the model we present in Sec-
tion 5, we relax some of these constraints but ﬁnd that
the problem can still be solved efﬁciently in the average
case. When the problem is solved, we know the value as-
sociated with each symbol at important program points.

5 Reducing Intent ICC to an IDE problem

To solve the Intent ICC problem, we need to model
four different kinds of objects. First, ComponentName
objects contain a package name and a class name.
They can be used by explicit Intents. For example, in
method makeComponentName() of Figure 7, a Com-
ponentName object can take two different values de-
pending on which branch is executed.
In the ﬁrst
branch, it refers to class a.b.MyClass from applica-
tion package c.d. In the second one, it refers to class
a.b.MySecondClass. We want to know the possible
return values of makeComponentName().

Second, Bundle objects store data as key-value map-
pings. Method makeBundle() of Figure 7 creates a Bun-
dle and modiﬁes its value. We need to ﬁnd the possible
return values of makeBundle().

Third, Intent objects are the main ICC communica-

548  22nd USENIX Security Symposium 

USENIX Association

the target class of intent

tion objects. They contain all the data that is used to
In method onClick() of Fig-
start other components.
is set using the re-
ure 7,
turn value of makeComponentName().
Its extra data
is set to the return value of makeBundle(). Finally,
a new Activity is started using the newly created In-
tent. We need to determine the value of intent at the
startActivity(intent) instruction.

Fourth,

IntentFilter objects are used for dynamic
Broadcast Receivers.
In registerMyReceiver() on Fig-
ure 7, an action and a category are added to IntentFil-
ter f . Then a Broadcast Receiver of type MyReceiver
(which we assume to be deﬁned) is registered us-
ing method registerReceiver().
It receives Intents that
have action a.b.ACTION and category a.b.CATEGORY
and that originate from applications with permission
a.b.PERMISSION. We want to determine the arguments
to the registerReceiver() call. That is, we want to
know that f contains action a.b.ACTION and category
a.b.CATEGORY. We also want to know that the type of
the Broadcast Receiver is MyReceiver.

In this section, we use the notations from Sagiv et
al. [32] summarized in Section 4. We assume that string
method arguments are available. We describe the string
analysis used in our implementation in Section 6.

5.1 ComponentName Model
In this section, we introduce the model we use for Com-
ponentName objects. We introduce the notion of a
branch ComponentName value. It represents the value
that a ComponentName object can take on a single
branch, given a single possible string argument value for
each method setting the ComponentName’s package and
class names, and in the absence of aliasing.
Deﬁnition 1. A branch ComponentName value is a tuple
c = (p,k), where p is a package name and k is a class
name.

In method makeComponentName() of Figure 7, two

branch ComponentName values are constructed:

(c.d, a.b.MyClass)

(1)

and

(c.d, a.b.MySecondClass)

(2)
The next deﬁnition introduces ComponentName val-
ues, which represent the possibly multiple values that a
ComponentName can have at a program point. A Com-
ponentName can take several values in different cases:
• After traversing different branches, as in method
• When a string argument can have several values at a
• When an object reference is a possible alias of an-

makeComponentName() of Figure 7.

other local reference or an object ﬁeld.

method call.

• When an object reference is a possible array element.
In the last two cases, in order to account for the possi-
bility of a false positive in the alias analysis, we keep
track of two branch ComponentName values. One con-
siders the inﬂuence of the call on the possible alias and
the other one does not.
Deﬁnition 2. A ComponentName value C is a set of
branch ComponentName values: C = {c1,c2,··· ,cm}.
The set of ComponentName values is denoted as Vc. We
deﬁne ⊥ = ∅ and (cid:26) as the ComponentName value that
is the set of all possible branch ComponentName val-
ues in the program. The operators ∪ and ⊆ are deﬁned
as traditional set union and comparison operators: for
C1,C2 ∈ Vc, C1 ⊆ C2 iff C1 ∪C2 = C2. Lc = (Vc,∪) is a
join semilattice.

Note that given the deﬁnitions of ⊥ and (cid:26) as speciﬁc
sets, ∪ and ⊆ naturally apply to them. For example, for
all C ∈ Vc, (cid:26)∪C = (cid:26).
In method makeComponentName() from Figure 7, the
value of c at the return statement is

{(c.d, a.b.MyClass) ,

(3)
It simply combines the values of c created in the two
branches, given by Equations (1) and (2).

(c.d, a.b.MySecondClass)} .

We deﬁne transformers from Vc to Vc that represent
the inﬂuence of a statement or a sequence of statements
on a ComponentName value. A pointwise branch Com-
ponentName transformer represents the inﬂuence of a
single branch, whereas a pointwise ComponentName
transformer represents the inﬂuence of possibly multiple
branches.
Deﬁnition 3. A pointwise branch ComponentName
transformer is a function δ c
(π,χ) : Vc → Vc, where π is a
package name and χ is a class name. It is such that, for
each C ∈ Vc,

δ c
(π,χ)(C) ={(π , χ)}

(4)

Note that δ c

(π,χ)(C) is independent of C, because API
methods for ComponentName objects systematically re-
place existing values for package and class names. In the
example from Figure 7, the pointwise branch Compo-
nentName transformer corresponding to the ﬁrst branch
is

δ c
(c.d,a.b.MyClass),
and the one for the second branch is

δ c
(c.d,a.b.MySecondClass).

(5)
Deﬁnition 4. A pointwise ComponentName transformer
is a function δ c
: Vc → Vc such that, for
each C ∈ Vc,

δ c
{(π1,χ1),··· ,(πn,χn)}(C) ={(π 1, χ1),··· , (πn, χn)}

{(π1,χ1),··· ,(πn,χn)}

A pointwise ComponentName transformer summa-

USENIX Association  

22nd USENIX Security Symposium  549

rizes the effect of multiple branches (or a single branch
with multiple possible string arguments, or with possi-
ble aliasing) on a ComponentName value. That is, given
the value C of a ComponentName right after statement
si and given transformer δ c
that sum-
marizes the inﬂuence of statements si+1,··· ,sk on C,
δ c
(C) represents all the possible values
{(π1,χ1),··· ,(πn,χn)}
of C right after sk. In method makeComponentName()
of Figure 7, the pointwise ComponentName transformer
that models the two branches is

{(π1,χ1),··· ,(πn,χn)}

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}.

(6)
It combines the transformers given by Equations (4)
and (5). In order to understand how this transformer is
applied in practice, we should mention that the algorithm
to solve IDE problems initially sets values to ⊥ [32].
Therefore, in method makeComponentName(), the value
associated with c is initially ⊥ = ∅. Using Deﬁnition 4,
we can easily see that if we apply the transformer given
by Equation (6), we get the value given by Equation (3).
This conﬁrms that the transformer models the inﬂuence
of the two branches:

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}(⊥)

= {(c.d, a.b.MyClass) ,

(c.d, a.b.MySecondClass)}

5.2 Bundle Model

The model of Bundle objects is deﬁned similarly to the
model of ComponentName objects. An additional difﬁ-
culty is introduced. The data in a Bundle can be modiﬁed
by adding the data in another Bundle to it, as shown in
method makeBundle() of Figure 7. In this example, the
data in Bundle b is added to the data in Bundle bundle.
Bundle bundle is later modiﬁed by removing the key-
value pair with key Surname. The issue is that when
the data ﬂow problem is being tackled, the value of b
is not known. Therefore, the inﬂuence of the call to
remove("Surname") is not known: if a key-value pair
with key Surname is part of b, then the call removes it
from bundle. Otherwise, it has no inﬂuence.

Our approach to deal with this object composition
problem is to perform two successive analyses. In Anal-
ysis I, we use placeholders for Bundles such as b in in-
struction bundle.putAll(b). We also record all subse-
quent method calls affecting bundle. After the problem
is solved, b’s key-value pairs at the putAll(b) method
call are known, as well as the subsequent method calls.
We then perform Analysis II, in which b’s key-value
pairs are added to bundle’s. The inﬂuence of the sub-
sequent method call is precisely evaluated and ﬁnally the
value of bundle at the return statement can be known.

b to V i

b, where V i

5.2.1 Analysis I
In the ﬁrst analysis, we consider intermediate values that
contain “placeholders” for Bundle values that are not
known when the problem is being solved.
Deﬁnition 5. An intermediate branch Bundle value is a
tuple bi = (E,O), where:
• E is a set of keys describing extra data.
• O is a tuple of two types of elements. O contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. O also contains functions
from V i
b is the set of intermediate Bun-
dle values deﬁned below. These functions represent a
sequence of method calls affecting a Bundle.
The difference with previous deﬁnitions is the intro-
duction of O, which models calls to putAll() as well as
subsequent calls affecting the same Bundle. In method
makeBundle() of Figure 7, at the return statement, the in-
termediate branch Bundle value associated with bundle
is (E,O), where
E ={FirstName}
O =((b, bundle.putAll(b)),β b

(7)
(8)
In O, (b, bundle.putAll(b)) is a reference to variable
b at instruction bundle.putAll(b). β b
(∅,Surname,0,())
models the remove() method call. It is deﬁned below.

(∅,{Surname},0,()))

b = (V i

b, Bi1 ⊆ Bi2 iff Bi1 ∪ Bi2 = Bi2. Li

We just deﬁned intermediate branch Bundle values.
As we did before, we need to consider multiple branches
and related issues (e.g., several possible string values):
Deﬁnition 6. An intermediate Bundle value Bi is a set of
intermediate branch Bundle values: Bi = {bi1,··· ,bim}.
The set of intermediate Bundle values is V i
b. We deﬁne
⊥ = ∅ and (cid:26) as the intermediate Bundle value that is
the set of all possible intermediate branch Bundle val-
ues in the program. We deﬁne ⊆ and ∪ as natural set
comparison and union operators. They are such that, for
Bi1,Bi2 ∈ V i
b,∪) is
a join semilattice.
In method makeBundle() from Figure 7, since there is
only a single branch, the intermediate Bundle value as-
sociated with bundle at the return statement is {(E,O)},
where E and O are given by Equations (7) and (8).
b to V i
b.
Similarly to the ComponentName model, we ﬁrst in-
troduce pointwise branch Bundle transformers before
deﬁning pointwise Bundle transformers.
In the def-
initions below, we use the \ notation for set differ-
ence, and ∪ is naturally extended to tuples such that
(a1,··· ,ak)∪ (ak+1,··· ,al) = (a1,··· ,ak,ak+1,··· ,al).
Deﬁnition 7. A pointwise branch Bundle transformer is
a function β b
• η + is a set of string keys describing extra data. It

Pointwise transformers are deﬁned from V i

(η +,η−,cl,Θ) : V i

models calls to putExtra() methods.

b → V i

b, where:

550  22nd USENIX Security Symposium 

USENIX Association

• η− is a set of string keys describing removed ex-
It represents the inﬂuence of calls to the

tra data.
removeExtra() method.

with the clear() method and 0 otherwise.

• cl takes value 1 if the Bundle data has been cleared
• Θ is a tuple of two types of elements. It contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. It also contains functions
from V i
b. These functions represent a sequence
of method calls affecting a Bundle.

b to V i

It is such that
β b
(η +,η−,cl,Θ)(⊥) =(cid:31)(cid:30)η +\η−,Θ(cid:29)(cid:28)
and, for Bi = {(E1,O1),··· , (Em,Om)} (Bi (cid:24)= ⊥),
β b
(η +,η−,cl,Θ)(Bi) ={(E (cid:23)1,O(cid:23)1),··· , (E(cid:23)m,O(cid:23)m)}
where, for each j from 1 to m:
E(cid:23)j =

O(cid:23)j =


η +\η−
(E j ∪ η +)\η−
E j
Θ
O j ∪(cid:23)β b

if cl = 1
if cl = 0 and O j = ∅
otherwise

(η +,η−,0,Θ)(cid:22)

if cl = 1 or O j = ∅
otherwise

The deﬁnition of E(cid:23)j accounts for several possible

cases:
• If the Bundle data has been cleared (i.e., cl = 1), then
we discard any data contained in E j. This leads to
value η +\η− for E(cid:23)j: we only keep the values η +
that were added to the Bundle data and remove the
values η− that were removed from it.

• If the Bundle has not been cleared, then there are two
possible cases: either no reference to another Bun-
dle has been previously recorded (i.e., O j = ∅), or
such a reference has been recorded to model a call to
putAll(). In the ﬁrst case, we simply take the union
of the original set E j and the set η + of added values,
and subtract the set η− of removed values. This ex-
plain the (E j ∪ η +)\η− value. In the second case, a
call to putAll() has been detected, which means that
any further method call adding or removing data has
to be added to set O j instead of E j. Therefore in this
case E(cid:23)j = E j.
The deﬁnition of O(cid:23)j considers several cases:
• If the Bundle data has been cleared, then the previous
value of O j is irrelevant and we set O(cid:23)j = Θ. Also, if
O j is empty, then we can also just set O(cid:23)j to Θ (which
may or may not be empty).

• Otherwise,

the Bundle data has not been cleared
(cl = 0) and a call to putAll() has been detected
(O j (cid:24)= ∅). Then it means that the current function
models method calls that happened after a call to
putAll(). Therefore we need to record β b
(η +,η−,0,Θ)
in O(cid:23)j, which explains the deﬁnition O(cid:23)j = O j ∪
(β b
(η +,η−,0,Θ)).

For example, the pointwise branch Bundle transformer
that models the inﬂuence of the method makeBundle()
from Figure 7 is β b

(η +,∅,0,Θ), where

η + ={FirstName}
Θ =(cid:23)(b, bundle.putAll(b)),

(9)

(10)

(∅,{Surname},0,())(cid:22)
β b

Pointwise branch Bundle transformers model the in-
ﬂuence of a single branch. In order to account for mul-
tiple branches or issues such as possible aliasing false
positive, we deﬁne pointwise Bundle transformers.
Deﬁnition 8. A pointwise Bundle transformer is a func-
tion

: V i
b → V i

b

β b
{(η +

1 +,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

such that, for each Bi ∈ V i
b,
β b
{(η +

1 ,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

(Bi) =
1 ,η−1 ,cl1,Θ1)(Bi)∪···∪β b

β b
(η +

n ,η−n ,cln,Θn)(Bi)
(η +

For example, method makeBundle() from Figure 7
only has a single branch, thus the pointwise Bundle trans-
former that models it is simply β b
, where η +
and Θ are given in Equations (9) and (10). As we did for
the ComponentName value example, we can conﬁrm us-
ing Deﬁnitions 7 and 8 that β b
(⊥) ={(E ,O)},
where E and O are given by Equations (7) and (8).

{(η +,∅,0,Θ)}

{(η +,∅,0,Θ)}

5.2.2 Analysis II

After Analysis I has been performed, the values of the
Bundles used in placeholders in intermediate Bundle val-
ues are known. Ultimately, we want to obtain branch
Bundle values and ﬁnally Bundle values:
Deﬁnition 9. A branch Bundle value b is a set E of string
keys describing extra data.
Deﬁnition 10. A Bundle value B is a set of branch Bun-
dle values: B = {b1,··· ,bm}.

Since the values of the referenced Bundles are known,
we can integrate them into the Bundle values referring to
them. Then the inﬂuence of the subsequent method calls
that have been recorded can precisely be known.

Let us consider the example of makeBundle() from
Figure 7. After Analysis I has been performed, we know
that the intermediate value of bundle at the return state-
ment is {(E,O)}, where

E ={FirstName}
O =(cid:23)(b, bundle.putAll(b)),β b
We consider all elements of O in order. As the
ﬁrst element of O is (b, bundle.putAll(b)), we inte-
grate b’s value into bundle. From Analysis I, we know

(∅,{Surname},0,())(cid:22)

USENIX Association  

22nd USENIX Security Symposium  551

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Constructor

b = new Bundle()

e.e[b 7! ?]

⇤

b

B.B

B.?

⇤

b

d

d

Adding int key-value pair

b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb

⇤

b

B.B

B.B

λB.βb

({MyInt},?,0,())(B)

d

d

B.B

1 public C o m p o n e n t N a m e

m a k e C o m p o n e n t N a m e () {

C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {

c = new C o m p o n e n t N a m e ( " c . d " ,

2
3
4

" a . b . MyClass " ) ;

} else {

" a . b . M y S e c o n d C l a s s " ) ; }

c = new C o m p o n e n t N a m e ( " c . d " ,

5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12

Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,

return c ; }

Copy constructor

b = new Bundle(d)

e.e[b 7! e(d)]

⇤

b

Clearing extra data keys

d.clear()

λe.ehd 7! βb

(?,?,1,())(e(d))i

⇤

b

d

⇤

B.B

B.B

B.B

B.B

B.B

⇤

b

d

⇤

b

b

λB.βb

(?,?,1,())(B)

d

d

Figure 6: Pointwise environment transformers for com-
mon Bundle operations

transformer t

the environment

require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.

The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.

We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges

environment
i.e.

transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).

ing studied.

of G∗,

assigns

to

this . m F i r s t N a m e ) ;

bundle . putAll ( b ) ;
bundle . remove ( " Surname " ) ;
return bundle ; }

Intent intent = new Intent () ;
intent . s e t C o m p o n t e n t ( m a k e C o m p o n e n t N a m e () ) ;
Bundle b = new Bundle () ;
b . p u t S t r i n g ( " Surname " , this . m S u r n a m e ) ;
intent . p u t E x t r a s ( m a k e B u n d l e ( b ) ) ;
r e g i s t e r M y R e c e i v e r () ;
s t a r t A c t i v i t y ( intent ) ; }

13
14
15
16
17 public void onClick ( View v ) {
18
19
20
21
22
23
24
25
26 public void r e g i s t e r M y R e c e i v e r () {
27
28
29
30
31

I n t e n t F i l t e r f = new I n t e n t F i l t e r () ;
f . a d d A c t i o n ( " a . b . ACTION " ) ;
f . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
r e g i s t e r R e c e i v e r ( new M y R e c e i v e r () ,

f , " a . b . P E R M I S S I O N " , null ) ; }
Figure 7: ICC objects example

Under certain conditions on the representation of
micro-functions, an IDE problem can be solved in time
O(ED3) [32]. For example, micro-functions should be
applied in constant time. In the model we present in Sec-
tion 5, we relax some of these constraints but ﬁnd that
the problem can still be solved efﬁciently in the average
case. When the problem is solved, we know the value as-
sociated with each symbol at important program points.

5 Reducing Intent ICC to an IDE problem

To solve the Intent ICC problem, we need to model
four different kinds of objects. First, ComponentName
objects contain a package name and a class name.
They can be used by explicit Intents. For example, in
method makeComponentName() of Figure 7, a Com-
ponentName object can take two different values de-
pending on which branch is executed.
In the ﬁrst
branch, it refers to class a.b.MyClass from applica-
tion package c.d. In the second one, it refers to class
a.b.MySecondClass. We want to know the possible
return values of makeComponentName().

Second, Bundle objects store data as key-value map-
pings. Method makeBundle() of Figure 7 creates a Bun-
dle and modiﬁes its value. We need to ﬁnd the possible
return values of makeBundle().

Third, Intent objects are the main ICC communica-

548  22nd USENIX Security Symposium 

USENIX Association

the target class of intent

tion objects. They contain all the data that is used to
In method onClick() of Fig-
start other components.
is set using the re-
ure 7,
turn value of makeComponentName().
Its extra data
is set to the return value of makeBundle(). Finally,
a new Activity is started using the newly created In-
tent. We need to determine the value of intent at the
startActivity(intent) instruction.

Fourth,

IntentFilter objects are used for dynamic
Broadcast Receivers.
In registerMyReceiver() on Fig-
ure 7, an action and a category are added to IntentFil-
ter f . Then a Broadcast Receiver of type MyReceiver
(which we assume to be deﬁned) is registered us-
ing method registerReceiver().
It receives Intents that
have action a.b.ACTION and category a.b.CATEGORY
and that originate from applications with permission
a.b.PERMISSION. We want to determine the arguments
to the registerReceiver() call. That is, we want to
know that f contains action a.b.ACTION and category
a.b.CATEGORY. We also want to know that the type of
the Broadcast Receiver is MyReceiver.

In this section, we use the notations from Sagiv et
al. [32] summarized in Section 4. We assume that string
method arguments are available. We describe the string
analysis used in our implementation in Section 6.

5.1 ComponentName Model
In this section, we introduce the model we use for Com-
ponentName objects. We introduce the notion of a
branch ComponentName value. It represents the value
that a ComponentName object can take on a single
branch, given a single possible string argument value for
each method setting the ComponentName’s package and
class names, and in the absence of aliasing.
Deﬁnition 1. A branch ComponentName value is a tuple
c = (p,k), where p is a package name and k is a class
name.

In method makeComponentName() of Figure 7, two

branch ComponentName values are constructed:

(c.d, a.b.MyClass)

(1)

and

(c.d, a.b.MySecondClass)

(2)
The next deﬁnition introduces ComponentName val-
ues, which represent the possibly multiple values that a
ComponentName can have at a program point. A Com-
ponentName can take several values in different cases:
• After traversing different branches, as in method
• When a string argument can have several values at a
• When an object reference is a possible alias of an-

makeComponentName() of Figure 7.

other local reference or an object ﬁeld.

method call.

• When an object reference is a possible array element.
In the last two cases, in order to account for the possi-
bility of a false positive in the alias analysis, we keep
track of two branch ComponentName values. One con-
siders the inﬂuence of the call on the possible alias and
the other one does not.
Deﬁnition 2. A ComponentName value C is a set of
branch ComponentName values: C = {c1,c2,··· ,cm}.
The set of ComponentName values is denoted as Vc. We
deﬁne ⊥ = ∅ and (cid:26) as the ComponentName value that
is the set of all possible branch ComponentName val-
ues in the program. The operators ∪ and ⊆ are deﬁned
as traditional set union and comparison operators: for
C1,C2 ∈ Vc, C1 ⊆ C2 iff C1 ∪C2 = C2. Lc = (Vc,∪) is a
join semilattice.

Note that given the deﬁnitions of ⊥ and (cid:26) as speciﬁc
sets, ∪ and ⊆ naturally apply to them. For example, for
all C ∈ Vc, (cid:26)∪C = (cid:26).
In method makeComponentName() from Figure 7, the
value of c at the return statement is

{(c.d, a.b.MyClass) ,

(3)
It simply combines the values of c created in the two
branches, given by Equations (1) and (2).

(c.d, a.b.MySecondClass)} .

We deﬁne transformers from Vc to Vc that represent
the inﬂuence of a statement or a sequence of statements
on a ComponentName value. A pointwise branch Com-
ponentName transformer represents the inﬂuence of a
single branch, whereas a pointwise ComponentName
transformer represents the inﬂuence of possibly multiple
branches.
Deﬁnition 3. A pointwise branch ComponentName
transformer is a function δ c
(π,χ) : Vc → Vc, where π is a
package name and χ is a class name. It is such that, for
each C ∈ Vc,

δ c
(π,χ)(C) ={(π , χ)}

(4)

Note that δ c

(π,χ)(C) is independent of C, because API
methods for ComponentName objects systematically re-
place existing values for package and class names. In the
example from Figure 7, the pointwise branch Compo-
nentName transformer corresponding to the ﬁrst branch
is

δ c
(c.d,a.b.MyClass),
and the one for the second branch is

δ c
(c.d,a.b.MySecondClass).

(5)
Deﬁnition 4. A pointwise ComponentName transformer
is a function δ c
: Vc → Vc such that, for
each C ∈ Vc,

δ c
{(π1,χ1),··· ,(πn,χn)}(C) ={(π 1, χ1),··· , (πn, χn)}

{(π1,χ1),··· ,(πn,χn)}

A pointwise ComponentName transformer summa-

USENIX Association  

22nd USENIX Security Symposium  549

rizes the effect of multiple branches (or a single branch
with multiple possible string arguments, or with possi-
ble aliasing) on a ComponentName value. That is, given
the value C of a ComponentName right after statement
si and given transformer δ c
that sum-
marizes the inﬂuence of statements si+1,··· ,sk on C,
δ c
(C) represents all the possible values
{(π1,χ1),··· ,(πn,χn)}
of C right after sk. In method makeComponentName()
of Figure 7, the pointwise ComponentName transformer
that models the two branches is

{(π1,χ1),··· ,(πn,χn)}

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}.

(6)
It combines the transformers given by Equations (4)
and (5). In order to understand how this transformer is
applied in practice, we should mention that the algorithm
to solve IDE problems initially sets values to ⊥ [32].
Therefore, in method makeComponentName(), the value
associated with c is initially ⊥ = ∅. Using Deﬁnition 4,
we can easily see that if we apply the transformer given
by Equation (6), we get the value given by Equation (3).
This conﬁrms that the transformer models the inﬂuence
of the two branches:

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}(⊥)

= {(c.d, a.b.MyClass) ,

(c.d, a.b.MySecondClass)}

5.2 Bundle Model

The model of Bundle objects is deﬁned similarly to the
model of ComponentName objects. An additional difﬁ-
culty is introduced. The data in a Bundle can be modiﬁed
by adding the data in another Bundle to it, as shown in
method makeBundle() of Figure 7. In this example, the
data in Bundle b is added to the data in Bundle bundle.
Bundle bundle is later modiﬁed by removing the key-
value pair with key Surname. The issue is that when
the data ﬂow problem is being tackled, the value of b
is not known. Therefore, the inﬂuence of the call to
remove("Surname") is not known: if a key-value pair
with key Surname is part of b, then the call removes it
from bundle. Otherwise, it has no inﬂuence.

Our approach to deal with this object composition
problem is to perform two successive analyses. In Anal-
ysis I, we use placeholders for Bundles such as b in in-
struction bundle.putAll(b). We also record all subse-
quent method calls affecting bundle. After the problem
is solved, b’s key-value pairs at the putAll(b) method
call are known, as well as the subsequent method calls.
We then perform Analysis II, in which b’s key-value
pairs are added to bundle’s. The inﬂuence of the sub-
sequent method call is precisely evaluated and ﬁnally the
value of bundle at the return statement can be known.

b to V i

b, where V i

5.2.1 Analysis I
In the ﬁrst analysis, we consider intermediate values that
contain “placeholders” for Bundle values that are not
known when the problem is being solved.
Deﬁnition 5. An intermediate branch Bundle value is a
tuple bi = (E,O), where:
• E is a set of keys describing extra data.
• O is a tuple of two types of elements. O contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. O also contains functions
from V i
b is the set of intermediate Bun-
dle values deﬁned below. These functions represent a
sequence of method calls affecting a Bundle.
The difference with previous deﬁnitions is the intro-
duction of O, which models calls to putAll() as well as
subsequent calls affecting the same Bundle. In method
makeBundle() of Figure 7, at the return statement, the in-
termediate branch Bundle value associated with bundle
is (E,O), where
E ={FirstName}
O =((b, bundle.putAll(b)),β b

(7)
(8)
In O, (b, bundle.putAll(b)) is a reference to variable
b at instruction bundle.putAll(b). β b
(∅,Surname,0,())
models the remove() method call. It is deﬁned below.

(∅,{Surname},0,()))

b = (V i

b, Bi1 ⊆ Bi2 iff Bi1 ∪ Bi2 = Bi2. Li

We just deﬁned intermediate branch Bundle values.
As we did before, we need to consider multiple branches
and related issues (e.g., several possible string values):
Deﬁnition 6. An intermediate Bundle value Bi is a set of
intermediate branch Bundle values: Bi = {bi1,··· ,bim}.
The set of intermediate Bundle values is V i
b. We deﬁne
⊥ = ∅ and (cid:26) as the intermediate Bundle value that is
the set of all possible intermediate branch Bundle val-
ues in the program. We deﬁne ⊆ and ∪ as natural set
comparison and union operators. They are such that, for
Bi1,Bi2 ∈ V i
b,∪) is
a join semilattice.
In method makeBundle() from Figure 7, since there is
only a single branch, the intermediate Bundle value as-
sociated with bundle at the return statement is {(E,O)},
where E and O are given by Equations (7) and (8).
b to V i
b.
Similarly to the ComponentName model, we ﬁrst in-
troduce pointwise branch Bundle transformers before
deﬁning pointwise Bundle transformers.
In the def-
initions below, we use the \ notation for set differ-
ence, and ∪ is naturally extended to tuples such that
(a1,··· ,ak)∪ (ak+1,··· ,al) = (a1,··· ,ak,ak+1,··· ,al).
Deﬁnition 7. A pointwise branch Bundle transformer is
a function β b
• η + is a set of string keys describing extra data. It

Pointwise transformers are deﬁned from V i

(η +,η−,cl,Θ) : V i

models calls to putExtra() methods.

b → V i

b, where:

550  22nd USENIX Security Symposium 

USENIX Association

• η− is a set of string keys describing removed ex-
It represents the inﬂuence of calls to the

tra data.
removeExtra() method.

with the clear() method and 0 otherwise.

• cl takes value 1 if the Bundle data has been cleared
• Θ is a tuple of two types of elements. It contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. It also contains functions
from V i
b. These functions represent a sequence
of method calls affecting a Bundle.

b to V i

It is such that
β b
(η +,η−,cl,Θ)(⊥) =(cid:31)(cid:30)η +\η−,Θ(cid:29)(cid:28)
and, for Bi = {(E1,O1),··· , (Em,Om)} (Bi (cid:24)= ⊥),
β b
(η +,η−,cl,Θ)(Bi) ={(E (cid:23)1,O(cid:23)1),··· , (E(cid:23)m,O(cid:23)m)}
where, for each j from 1 to m:
E(cid:23)j =

O(cid:23)j =


η +\η−
(E j ∪ η +)\η−
E j
Θ
O j ∪(cid:23)β b

if cl = 1
if cl = 0 and O j = ∅
otherwise

(η +,η−,0,Θ)(cid:22)

if cl = 1 or O j = ∅
otherwise

The deﬁnition of E(cid:23)j accounts for several possible

cases:
• If the Bundle data has been cleared (i.e., cl = 1), then
we discard any data contained in E j. This leads to
value η +\η− for E(cid:23)j: we only keep the values η +
that were added to the Bundle data and remove the
values η− that were removed from it.

• If the Bundle has not been cleared, then there are two
possible cases: either no reference to another Bun-
dle has been previously recorded (i.e., O j = ∅), or
such a reference has been recorded to model a call to
putAll(). In the ﬁrst case, we simply take the union
of the original set E j and the set η + of added values,
and subtract the set η− of removed values. This ex-
plain the (E j ∪ η +)\η− value. In the second case, a
call to putAll() has been detected, which means that
any further method call adding or removing data has
to be added to set O j instead of E j. Therefore in this
case E(cid:23)j = E j.
The deﬁnition of O(cid:23)j considers several cases:
• If the Bundle data has been cleared, then the previous
value of O j is irrelevant and we set O(cid:23)j = Θ. Also, if
O j is empty, then we can also just set O(cid:23)j to Θ (which
may or may not be empty).

• Otherwise,

the Bundle data has not been cleared
(cl = 0) and a call to putAll() has been detected
(O j (cid:24)= ∅). Then it means that the current function
models method calls that happened after a call to
putAll(). Therefore we need to record β b
(η +,η−,0,Θ)
in O(cid:23)j, which explains the deﬁnition O(cid:23)j = O j ∪
(β b
(η +,η−,0,Θ)).

For example, the pointwise branch Bundle transformer
that models the inﬂuence of the method makeBundle()
from Figure 7 is β b

(η +,∅,0,Θ), where

η + ={FirstName}
Θ =(cid:23)(b, bundle.putAll(b)),

(9)

(10)

(∅,{Surname},0,())(cid:22)
β b

Pointwise branch Bundle transformers model the in-
ﬂuence of a single branch. In order to account for mul-
tiple branches or issues such as possible aliasing false
positive, we deﬁne pointwise Bundle transformers.
Deﬁnition 8. A pointwise Bundle transformer is a func-
tion

: V i
b → V i

b

β b
{(η +

1 +,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

such that, for each Bi ∈ V i
b,
β b
{(η +

1 ,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

(Bi) =
1 ,η−1 ,cl1,Θ1)(Bi)∪···∪β b

β b
(η +

n ,η−n ,cln,Θn)(Bi)
(η +

For example, method makeBundle() from Figure 7
only has a single branch, thus the pointwise Bundle trans-
former that models it is simply β b
, where η +
and Θ are given in Equations (9) and (10). As we did for
the ComponentName value example, we can conﬁrm us-
ing Deﬁnitions 7 and 8 that β b
(⊥) ={(E ,O)},
where E and O are given by Equations (7) and (8).

{(η +,∅,0,Θ)}

{(η +,∅,0,Θ)}

5.2.2 Analysis II

After Analysis I has been performed, the values of the
Bundles used in placeholders in intermediate Bundle val-
ues are known. Ultimately, we want to obtain branch
Bundle values and ﬁnally Bundle values:
Deﬁnition 9. A branch Bundle value b is a set E of string
keys describing extra data.
Deﬁnition 10. A Bundle value B is a set of branch Bun-
dle values: B = {b1,··· ,bm}.

Since the values of the referenced Bundles are known,
we can integrate them into the Bundle values referring to
them. Then the inﬂuence of the subsequent method calls
that have been recorded can precisely be known.

Let us consider the example of makeBundle() from
Figure 7. After Analysis I has been performed, we know
that the intermediate value of bundle at the return state-
ment is {(E,O)}, where

E ={FirstName}
O =(cid:23)(b, bundle.putAll(b)),β b
We consider all elements of O in order. As the
ﬁrst element of O is (b, bundle.putAll(b)), we inte-
grate b’s value into bundle. From Analysis I, we know

(∅,{Surname},0,())(cid:22)

USENIX Association  

22nd USENIX Security Symposium  551

that the value of b at instruction bundle.putAll(b)
is {{Surname} ,∅}. Thus, E becomes {FirstName,
Surname}. The next element of O is β b
(∅,{Surname},0,()).
This means that we have to remove key Surname from E.
The ﬁnal value of E is therefore {FirstName}. Thus, the
Bundle value associated with bundle at the return state-
ment is {{FirstName}}.
Note that the referenced Bundle can also make refer-
ences to other Bundles. In that case, we perform the res-
olution for the referenced Bundles ﬁrst. There can be an
arbitrary number of levels of indirection. Analysis II is
iterated until a ﬁx-point is reached.

Intent and IntentFilter Models

5.3
The Intent model is deﬁned similarly to the Bundle
model, which includes object composition.
In method
onClick() of Figure 7, the target of Intent intent is set
using a ComponentName object and its extra data is set
with a Bundle. Because of this object composition, ﬁnd-
ing the Intent value also involves two analyses similar to
the ones performed for Bundles. First, intermediate In-
tent values with placeholders for referenced Component-
Name and Bundle objects are found. Second, the refer-
enced objects’ values are integrated into intent’s value.

i = (V i

Similarly to the Bundle model, we deﬁne intermedi-
ate branch Intent values and intermediate Intent values.
The set of intermediate Intent values is V i
i and we de-
ﬁne a lattice Li
i ,∪) as we did for Li
b. We also de-
ﬁne pointwise branch Intent transformers and pointwise
Intent transformers. For example, in method onClick()
of Figure 7, the ﬁnal intermediate value for intent sim-
ply has placeholders for a ComponentName and a Bun-
dle value. Other ﬁelds, such as action and categories,
are empty. The ComponentName and Bundle values are
computed using the models presented in Sections 5.1
and 5.2. Finally, we deﬁne branch Intent values and
Intent values, which are output by the second analysis.
The ﬁnal value for intent after the second analysis pre-
cisely contains the two possible targets (a.b.MyClass
and a.b.MySecondClass in package c.d) and extra
data key FirstName. For conciseness, and given the
strong similarities with the Bundle model, we do not in-
clude a full description of the Intent model here.

In order to analyze dynamic Broadcast Receivers, we
model IntentFilter objects. Modeling IntentFilters is sim-
ilar to modeling Intents, except that IntentFilters do not
involve object composition. That is because IntentFilters
do not have methods taking other IntentFilters as argu-
ment, except for a copy constructor. Thus, their analysis
is simpler and involves a single step. Similarly to what
we did for other ICC models, we deﬁne branch Intent-
Filter values, IntentFilter values, pointwise branch In-
tentFilter transformers and pointwise IntentFilter trans-

formers.
In particular, we deﬁne lattice L f = (Vf ,∪),
In method
is the set of IntentFilter values.
where Vf
onClick() from Figure 7, the ﬁnal value of f contains ac-
tion a.b.ACTION and category a.b.CATEGORY. Given
the similarity of the IntentFilter model with previous
models, we do not include a complete description.

5.4 Casting as an IDE Problem
These deﬁnitions allow us to deﬁne environment trans-
formers for our problem. Given environment e ∈
Env(D,L), environment transformer λ e.e is the identity,
which does not change the value of e. Given Intent i and
Intent value I, λ e.e[i (cid:27)→ I] transforms e to an environment
where all values are the same as in e, except that Intent i
is associated with value I.

We deﬁne an environment transformer for each API
method call. Each of these environment transformers
uses the pointwise environment transformers deﬁned in
Sections 5.1, 5.2 and 5.3. It precisely describes the inﬂu-
ence of a method call on the value associated with each
of the symbols in D.

Figure 6 shows some environment transformers and
their pointwise representation. The ﬁrst one is a con-
structor invocation, which sets the value corresponding
to b to ⊥. The second one adds an integer to the key-
value pairs in Bundle b’s extra data, which is represented
by environment transformer

({MyInt},∅,0,()) (e(b))(cid:30) .

λ e.e(cid:31)b (cid:27)→ β b
It means that
the environment stays the same, ex-
cept
the value associated with b becomes
β b
({MyInt},∅,0,()) (e(b)), with e(b) being the value previ-
ously associated with b in environment e. The pointwise
transformer for b is

that

on Figure 6 for consistency with the other pointwise
transformers.
It simply adds key MyInt to the set of
data keys. The next transformer is for a copy construc-
tor, where the value associated with d is assigned to the
value associated with b. The last transformer clears the
data keys associated with d.

Trivially, these environment transformers are distribu-

tive. Therefore, the following proposition holds.
Proposition 1. Let G∗ be the supergraph of an An-
droid application. Let Dc, Db Di and D f be the sets
of ComponentName, Bundle and Intent variables, re-
to which we add the special symbol Λ5.
spectively,
Let Lc, Li
b, Li
i and L f be the lattices deﬁned above.

5Recall from Section 4.2 that Λ symbolizes the absence of a data

ﬂow fact.

which we denote by

β b
({MyInt},∅,0,()),
({MyInt},∅,0,())(B)

λ B.β b

552  22nd USENIX Security Symposium 

USENIX Association

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Constructor

b = new Bundle()

e.e[b 7! ?]

⇤

b

B.B

B.?

⇤

b

d

d

Adding int key-value pair

b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb

⇤

b

B.B

B.B

λB.βb

({MyInt},?,0,())(B)

d

d

B.B

1 public C o m p o n e n t N a m e

m a k e C o m p o n e n t N a m e () {

C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {

c = new C o m p o n e n t N a m e ( " c . d " ,

2
3
4

" a . b . MyClass " ) ;

} else {

" a . b . M y S e c o n d C l a s s " ) ; }

c = new C o m p o n e n t N a m e ( " c . d " ,

5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12

Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,

return c ; }

Copy constructor

b = new Bundle(d)

e.e[b 7! e(d)]

⇤

b

Clearing extra data keys

d.clear()

λe.ehd 7! βb

(?,?,1,())(e(d))i

⇤

b

d

⇤

B.B

B.B

B.B

B.B

B.B

⇤

b

d

⇤

b

b

λB.βb

(?,?,1,())(B)

d

d

Figure 6: Pointwise environment transformers for com-
mon Bundle operations

transformer t

the environment

require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.

The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.

We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges

environment
i.e.

transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).

ing studied.

of G∗,

assigns

to

this . m F i r s t N a m e ) ;

bundle . putAll ( b ) ;
bundle . remove ( " Surname " ) ;
return bundle ; }

Intent intent = new Intent () ;
intent . s e t C o m p o n t e n t ( m a k e C o m p o n e n t N a m e () ) ;
Bundle b = new Bundle () ;
b . p u t S t r i n g ( " Surname " , this . m S u r n a m e ) ;
intent . p u t E x t r a s ( m a k e B u n d l e ( b ) ) ;
r e g i s t e r M y R e c e i v e r () ;
s t a r t A c t i v i t y ( intent ) ; }

13
14
15
16
17 public void onClick ( View v ) {
18
19
20
21
22
23
24
25
26 public void r e g i s t e r M y R e c e i v e r () {
27
28
29
30
31

I n t e n t F i l t e r f = new I n t e n t F i l t e r () ;
f . a d d A c t i o n ( " a . b . ACTION " ) ;
f . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
r e g i s t e r R e c e i v e r ( new M y R e c e i v e r () ,

f , " a . b . P E R M I S S I O N " , null ) ; }
Figure 7: ICC objects example

Under certain conditions on the representation of
micro-functions, an IDE problem can be solved in time
O(ED3) [32]. For example, micro-functions should be
applied in constant time. In the model we present in Sec-
tion 5, we relax some of these constraints but ﬁnd that
the problem can still be solved efﬁciently in the average
case. When the problem is solved, we know the value as-
sociated with each symbol at important program points.

5 Reducing Intent ICC to an IDE problem

To solve the Intent ICC problem, we need to model
four different kinds of objects. First, ComponentName
objects contain a package name and a class name.
They can be used by explicit Intents. For example, in
method makeComponentName() of Figure 7, a Com-
ponentName object can take two different values de-
pending on which branch is executed.
In the ﬁrst
branch, it refers to class a.b.MyClass from applica-
tion package c.d. In the second one, it refers to class
a.b.MySecondClass. We want to know the possible
return values of makeComponentName().

Second, Bundle objects store data as key-value map-
pings. Method makeBundle() of Figure 7 creates a Bun-
dle and modiﬁes its value. We need to ﬁnd the possible
return values of makeBundle().

Third, Intent objects are the main ICC communica-

548  22nd USENIX Security Symposium 

USENIX Association

the target class of intent

tion objects. They contain all the data that is used to
In method onClick() of Fig-
start other components.
is set using the re-
ure 7,
turn value of makeComponentName().
Its extra data
is set to the return value of makeBundle(). Finally,
a new Activity is started using the newly created In-
tent. We need to determine the value of intent at the
startActivity(intent) instruction.

Fourth,

IntentFilter objects are used for dynamic
Broadcast Receivers.
In registerMyReceiver() on Fig-
ure 7, an action and a category are added to IntentFil-
ter f . Then a Broadcast Receiver of type MyReceiver
(which we assume to be deﬁned) is registered us-
ing method registerReceiver().
It receives Intents that
have action a.b.ACTION and category a.b.CATEGORY
and that originate from applications with permission
a.b.PERMISSION. We want to determine the arguments
to the registerReceiver() call. That is, we want to
know that f contains action a.b.ACTION and category
a.b.CATEGORY. We also want to know that the type of
the Broadcast Receiver is MyReceiver.

In this section, we use the notations from Sagiv et
al. [32] summarized in Section 4. We assume that string
method arguments are available. We describe the string
analysis used in our implementation in Section 6.

5.1 ComponentName Model
In this section, we introduce the model we use for Com-
ponentName objects. We introduce the notion of a
branch ComponentName value. It represents the value
that a ComponentName object can take on a single
branch, given a single possible string argument value for
each method setting the ComponentName’s package and
class names, and in the absence of aliasing.
Deﬁnition 1. A branch ComponentName value is a tuple
c = (p,k), where p is a package name and k is a class
name.

In method makeComponentName() of Figure 7, two

branch ComponentName values are constructed:

(c.d, a.b.MyClass)

(1)

and

(c.d, a.b.MySecondClass)

(2)
The next deﬁnition introduces ComponentName val-
ues, which represent the possibly multiple values that a
ComponentName can have at a program point. A Com-
ponentName can take several values in different cases:
• After traversing different branches, as in method
• When a string argument can have several values at a
• When an object reference is a possible alias of an-

makeComponentName() of Figure 7.

other local reference or an object ﬁeld.

method call.

• When an object reference is a possible array element.
In the last two cases, in order to account for the possi-
bility of a false positive in the alias analysis, we keep
track of two branch ComponentName values. One con-
siders the inﬂuence of the call on the possible alias and
the other one does not.
Deﬁnition 2. A ComponentName value C is a set of
branch ComponentName values: C = {c1,c2,··· ,cm}.
The set of ComponentName values is denoted as Vc. We
deﬁne ⊥ = ∅ and (cid:26) as the ComponentName value that
is the set of all possible branch ComponentName val-
ues in the program. The operators ∪ and ⊆ are deﬁned
as traditional set union and comparison operators: for
C1,C2 ∈ Vc, C1 ⊆ C2 iff C1 ∪C2 = C2. Lc = (Vc,∪) is a
join semilattice.

Note that given the deﬁnitions of ⊥ and (cid:26) as speciﬁc
sets, ∪ and ⊆ naturally apply to them. For example, for
all C ∈ Vc, (cid:26)∪C = (cid:26).
In method makeComponentName() from Figure 7, the
value of c at the return statement is

{(c.d, a.b.MyClass) ,

(3)
It simply combines the values of c created in the two
branches, given by Equations (1) and (2).

(c.d, a.b.MySecondClass)} .

We deﬁne transformers from Vc to Vc that represent
the inﬂuence of a statement or a sequence of statements
on a ComponentName value. A pointwise branch Com-
ponentName transformer represents the inﬂuence of a
single branch, whereas a pointwise ComponentName
transformer represents the inﬂuence of possibly multiple
branches.
Deﬁnition 3. A pointwise branch ComponentName
transformer is a function δ c
(π,χ) : Vc → Vc, where π is a
package name and χ is a class name. It is such that, for
each C ∈ Vc,

δ c
(π,χ)(C) ={(π , χ)}

(4)

Note that δ c

(π,χ)(C) is independent of C, because API
methods for ComponentName objects systematically re-
place existing values for package and class names. In the
example from Figure 7, the pointwise branch Compo-
nentName transformer corresponding to the ﬁrst branch
is

δ c
(c.d,a.b.MyClass),
and the one for the second branch is

δ c
(c.d,a.b.MySecondClass).

(5)
Deﬁnition 4. A pointwise ComponentName transformer
is a function δ c
: Vc → Vc such that, for
each C ∈ Vc,

δ c
{(π1,χ1),··· ,(πn,χn)}(C) ={(π 1, χ1),··· , (πn, χn)}

{(π1,χ1),··· ,(πn,χn)}

A pointwise ComponentName transformer summa-

USENIX Association  

22nd USENIX Security Symposium  549

rizes the effect of multiple branches (or a single branch
with multiple possible string arguments, or with possi-
ble aliasing) on a ComponentName value. That is, given
the value C of a ComponentName right after statement
si and given transformer δ c
that sum-
marizes the inﬂuence of statements si+1,··· ,sk on C,
δ c
(C) represents all the possible values
{(π1,χ1),··· ,(πn,χn)}
of C right after sk. In method makeComponentName()
of Figure 7, the pointwise ComponentName transformer
that models the two branches is

{(π1,χ1),··· ,(πn,χn)}

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}.

(6)
It combines the transformers given by Equations (4)
and (5). In order to understand how this transformer is
applied in practice, we should mention that the algorithm
to solve IDE problems initially sets values to ⊥ [32].
Therefore, in method makeComponentName(), the value
associated with c is initially ⊥ = ∅. Using Deﬁnition 4,
we can easily see that if we apply the transformer given
by Equation (6), we get the value given by Equation (3).
This conﬁrms that the transformer models the inﬂuence
of the two branches:

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}(⊥)

= {(c.d, a.b.MyClass) ,

(c.d, a.b.MySecondClass)}

5.2 Bundle Model

The model of Bundle objects is deﬁned similarly to the
model of ComponentName objects. An additional difﬁ-
culty is introduced. The data in a Bundle can be modiﬁed
by adding the data in another Bundle to it, as shown in
method makeBundle() of Figure 7. In this example, the
data in Bundle b is added to the data in Bundle bundle.
Bundle bundle is later modiﬁed by removing the key-
value pair with key Surname. The issue is that when
the data ﬂow problem is being tackled, the value of b
is not known. Therefore, the inﬂuence of the call to
remove("Surname") is not known: if a key-value pair
with key Surname is part of b, then the call removes it
from bundle. Otherwise, it has no inﬂuence.

Our approach to deal with this object composition
problem is to perform two successive analyses. In Anal-
ysis I, we use placeholders for Bundles such as b in in-
struction bundle.putAll(b). We also record all subse-
quent method calls affecting bundle. After the problem
is solved, b’s key-value pairs at the putAll(b) method
call are known, as well as the subsequent method calls.
We then perform Analysis II, in which b’s key-value
pairs are added to bundle’s. The inﬂuence of the sub-
sequent method call is precisely evaluated and ﬁnally the
value of bundle at the return statement can be known.

b to V i

b, where V i

5.2.1 Analysis I
In the ﬁrst analysis, we consider intermediate values that
contain “placeholders” for Bundle values that are not
known when the problem is being solved.
Deﬁnition 5. An intermediate branch Bundle value is a
tuple bi = (E,O), where:
• E is a set of keys describing extra data.
• O is a tuple of two types of elements. O contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. O also contains functions
from V i
b is the set of intermediate Bun-
dle values deﬁned below. These functions represent a
sequence of method calls affecting a Bundle.
The difference with previous deﬁnitions is the intro-
duction of O, which models calls to putAll() as well as
subsequent calls affecting the same Bundle. In method
makeBundle() of Figure 7, at the return statement, the in-
termediate branch Bundle value associated with bundle
is (E,O), where
E ={FirstName}
O =((b, bundle.putAll(b)),β b

(7)
(8)
In O, (b, bundle.putAll(b)) is a reference to variable
b at instruction bundle.putAll(b). β b
(∅,Surname,0,())
models the remove() method call. It is deﬁned below.

(∅,{Surname},0,()))

b = (V i

b, Bi1 ⊆ Bi2 iff Bi1 ∪ Bi2 = Bi2. Li

We just deﬁned intermediate branch Bundle values.
As we did before, we need to consider multiple branches
and related issues (e.g., several possible string values):
Deﬁnition 6. An intermediate Bundle value Bi is a set of
intermediate branch Bundle values: Bi = {bi1,··· ,bim}.
The set of intermediate Bundle values is V i
b. We deﬁne
⊥ = ∅ and (cid:26) as the intermediate Bundle value that is
the set of all possible intermediate branch Bundle val-
ues in the program. We deﬁne ⊆ and ∪ as natural set
comparison and union operators. They are such that, for
Bi1,Bi2 ∈ V i
b,∪) is
a join semilattice.
In method makeBundle() from Figure 7, since there is
only a single branch, the intermediate Bundle value as-
sociated with bundle at the return statement is {(E,O)},
where E and O are given by Equations (7) and (8).
b to V i
b.
Similarly to the ComponentName model, we ﬁrst in-
troduce pointwise branch Bundle transformers before
deﬁning pointwise Bundle transformers.
In the def-
initions below, we use the \ notation for set differ-
ence, and ∪ is naturally extended to tuples such that
(a1,··· ,ak)∪ (ak+1,··· ,al) = (a1,··· ,ak,ak+1,··· ,al).
Deﬁnition 7. A pointwise branch Bundle transformer is
a function β b
• η + is a set of string keys describing extra data. It

Pointwise transformers are deﬁned from V i

(η +,η−,cl,Θ) : V i

models calls to putExtra() methods.

b → V i

b, where:

550  22nd USENIX Security Symposium 

USENIX Association

• η− is a set of string keys describing removed ex-
It represents the inﬂuence of calls to the

tra data.
removeExtra() method.

with the clear() method and 0 otherwise.

• cl takes value 1 if the Bundle data has been cleared
• Θ is a tuple of two types of elements. It contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. It also contains functions
from V i
b. These functions represent a sequence
of method calls affecting a Bundle.

b to V i

It is such that
β b
(η +,η−,cl,Θ)(⊥) =(cid:31)(cid:30)η +\η−,Θ(cid:29)(cid:28)
and, for Bi = {(E1,O1),··· , (Em,Om)} (Bi (cid:24)= ⊥),
β b
(η +,η−,cl,Θ)(Bi) ={(E (cid:23)1,O(cid:23)1),··· , (E(cid:23)m,O(cid:23)m)}
where, for each j from 1 to m:
E(cid:23)j =

O(cid:23)j =


η +\η−
(E j ∪ η +)\η−
E j
Θ
O j ∪(cid:23)β b

if cl = 1
if cl = 0 and O j = ∅
otherwise

(η +,η−,0,Θ)(cid:22)

if cl = 1 or O j = ∅
otherwise

The deﬁnition of E(cid:23)j accounts for several possible

cases:
• If the Bundle data has been cleared (i.e., cl = 1), then
we discard any data contained in E j. This leads to
value η +\η− for E(cid:23)j: we only keep the values η +
that were added to the Bundle data and remove the
values η− that were removed from it.

• If the Bundle has not been cleared, then there are two
possible cases: either no reference to another Bun-
dle has been previously recorded (i.e., O j = ∅), or
such a reference has been recorded to model a call to
putAll(). In the ﬁrst case, we simply take the union
of the original set E j and the set η + of added values,
and subtract the set η− of removed values. This ex-
plain the (E j ∪ η +)\η− value. In the second case, a
call to putAll() has been detected, which means that
any further method call adding or removing data has
to be added to set O j instead of E j. Therefore in this
case E(cid:23)j = E j.
The deﬁnition of O(cid:23)j considers several cases:
• If the Bundle data has been cleared, then the previous
value of O j is irrelevant and we set O(cid:23)j = Θ. Also, if
O j is empty, then we can also just set O(cid:23)j to Θ (which
may or may not be empty).

• Otherwise,

the Bundle data has not been cleared
(cl = 0) and a call to putAll() has been detected
(O j (cid:24)= ∅). Then it means that the current function
models method calls that happened after a call to
putAll(). Therefore we need to record β b
(η +,η−,0,Θ)
in O(cid:23)j, which explains the deﬁnition O(cid:23)j = O j ∪
(β b
(η +,η−,0,Θ)).

For example, the pointwise branch Bundle transformer
that models the inﬂuence of the method makeBundle()
from Figure 7 is β b

(η +,∅,0,Θ), where

η + ={FirstName}
Θ =(cid:23)(b, bundle.putAll(b)),

(9)

(10)

(∅,{Surname},0,())(cid:22)
β b

Pointwise branch Bundle transformers model the in-
ﬂuence of a single branch. In order to account for mul-
tiple branches or issues such as possible aliasing false
positive, we deﬁne pointwise Bundle transformers.
Deﬁnition 8. A pointwise Bundle transformer is a func-
tion

: V i
b → V i

b

β b
{(η +

1 +,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

such that, for each Bi ∈ V i
b,
β b
{(η +

1 ,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

(Bi) =
1 ,η−1 ,cl1,Θ1)(Bi)∪···∪β b

β b
(η +

n ,η−n ,cln,Θn)(Bi)
(η +

For example, method makeBundle() from Figure 7
only has a single branch, thus the pointwise Bundle trans-
former that models it is simply β b
, where η +
and Θ are given in Equations (9) and (10). As we did for
the ComponentName value example, we can conﬁrm us-
ing Deﬁnitions 7 and 8 that β b
(⊥) ={(E ,O)},
where E and O are given by Equations (7) and (8).

{(η +,∅,0,Θ)}

{(η +,∅,0,Θ)}

5.2.2 Analysis II

After Analysis I has been performed, the values of the
Bundles used in placeholders in intermediate Bundle val-
ues are known. Ultimately, we want to obtain branch
Bundle values and ﬁnally Bundle values:
Deﬁnition 9. A branch Bundle value b is a set E of string
keys describing extra data.
Deﬁnition 10. A Bundle value B is a set of branch Bun-
dle values: B = {b1,··· ,bm}.

Since the values of the referenced Bundles are known,
we can integrate them into the Bundle values referring to
them. Then the inﬂuence of the subsequent method calls
that have been recorded can precisely be known.

Let us consider the example of makeBundle() from
Figure 7. After Analysis I has been performed, we know
that the intermediate value of bundle at the return state-
ment is {(E,O)}, where

E ={FirstName}
O =(cid:23)(b, bundle.putAll(b)),β b
We consider all elements of O in order. As the
ﬁrst element of O is (b, bundle.putAll(b)), we inte-
grate b’s value into bundle. From Analysis I, we know

(∅,{Surname},0,())(cid:22)

USENIX Association  

22nd USENIX Security Symposium  551

that the value of b at instruction bundle.putAll(b)
is {{Surname} ,∅}. Thus, E becomes {FirstName,
Surname}. The next element of O is β b
(∅,{Surname},0,()).
This means that we have to remove key Surname from E.
The ﬁnal value of E is therefore {FirstName}. Thus, the
Bundle value associated with bundle at the return state-
ment is {{FirstName}}.
Note that the referenced Bundle can also make refer-
ences to other Bundles. In that case, we perform the res-
olution for the referenced Bundles ﬁrst. There can be an
arbitrary number of levels of indirection. Analysis II is
iterated until a ﬁx-point is reached.

Intent and IntentFilter Models

5.3
The Intent model is deﬁned similarly to the Bundle
model, which includes object composition.
In method
onClick() of Figure 7, the target of Intent intent is set
using a ComponentName object and its extra data is set
with a Bundle. Because of this object composition, ﬁnd-
ing the Intent value also involves two analyses similar to
the ones performed for Bundles. First, intermediate In-
tent values with placeholders for referenced Component-
Name and Bundle objects are found. Second, the refer-
enced objects’ values are integrated into intent’s value.

i = (V i

Similarly to the Bundle model, we deﬁne intermedi-
ate branch Intent values and intermediate Intent values.
The set of intermediate Intent values is V i
i and we de-
ﬁne a lattice Li
i ,∪) as we did for Li
b. We also de-
ﬁne pointwise branch Intent transformers and pointwise
Intent transformers. For example, in method onClick()
of Figure 7, the ﬁnal intermediate value for intent sim-
ply has placeholders for a ComponentName and a Bun-
dle value. Other ﬁelds, such as action and categories,
are empty. The ComponentName and Bundle values are
computed using the models presented in Sections 5.1
and 5.2. Finally, we deﬁne branch Intent values and
Intent values, which are output by the second analysis.
The ﬁnal value for intent after the second analysis pre-
cisely contains the two possible targets (a.b.MyClass
and a.b.MySecondClass in package c.d) and extra
data key FirstName. For conciseness, and given the
strong similarities with the Bundle model, we do not in-
clude a full description of the Intent model here.

In order to analyze dynamic Broadcast Receivers, we
model IntentFilter objects. Modeling IntentFilters is sim-
ilar to modeling Intents, except that IntentFilters do not
involve object composition. That is because IntentFilters
do not have methods taking other IntentFilters as argu-
ment, except for a copy constructor. Thus, their analysis
is simpler and involves a single step. Similarly to what
we did for other ICC models, we deﬁne branch Intent-
Filter values, IntentFilter values, pointwise branch In-
tentFilter transformers and pointwise IntentFilter trans-

formers.
In particular, we deﬁne lattice L f = (Vf ,∪),
In method
is the set of IntentFilter values.
where Vf
onClick() from Figure 7, the ﬁnal value of f contains ac-
tion a.b.ACTION and category a.b.CATEGORY. Given
the similarity of the IntentFilter model with previous
models, we do not include a complete description.

5.4 Casting as an IDE Problem
These deﬁnitions allow us to deﬁne environment trans-
formers for our problem. Given environment e ∈
Env(D,L), environment transformer λ e.e is the identity,
which does not change the value of e. Given Intent i and
Intent value I, λ e.e[i (cid:27)→ I] transforms e to an environment
where all values are the same as in e, except that Intent i
is associated with value I.

We deﬁne an environment transformer for each API
method call. Each of these environment transformers
uses the pointwise environment transformers deﬁned in
Sections 5.1, 5.2 and 5.3. It precisely describes the inﬂu-
ence of a method call on the value associated with each
of the symbols in D.

Figure 6 shows some environment transformers and
their pointwise representation. The ﬁrst one is a con-
structor invocation, which sets the value corresponding
to b to ⊥. The second one adds an integer to the key-
value pairs in Bundle b’s extra data, which is represented
by environment transformer

({MyInt},∅,0,()) (e(b))(cid:30) .

λ e.e(cid:31)b (cid:27)→ β b
It means that
the environment stays the same, ex-
cept
the value associated with b becomes
β b
({MyInt},∅,0,()) (e(b)), with e(b) being the value previ-
ously associated with b in environment e. The pointwise
transformer for b is

that

on Figure 6 for consistency with the other pointwise
transformers.
It simply adds key MyInt to the set of
data keys. The next transformer is for a copy construc-
tor, where the value associated with d is assigned to the
value associated with b. The last transformer clears the
data keys associated with d.

Trivially, these environment transformers are distribu-

tive. Therefore, the following proposition holds.
Proposition 1. Let G∗ be the supergraph of an An-
droid application. Let Dc, Db Di and D f be the sets
of ComponentName, Bundle and Intent variables, re-
to which we add the special symbol Λ5.
spectively,
Let Lc, Li
b, Li
i and L f be the lattices deﬁned above.

5Recall from Section 4.2 that Λ symbolizes the absence of a data

ﬂow fact.

which we denote by

β b
({MyInt},∅,0,()),
({MyInt},∅,0,())(B)

λ B.β b

552  22nd USENIX Security Symposium 

USENIX Association

Let Mc, Mb, Mi and Mf be the corresponding assign-
ments of distributive environment transformers. Then
(G∗,Dc,Lc,Mc), (G∗,Db,Li
i ) and
(G∗,Di,L f ,Mf ) are IDE problems.

b), (G∗,Db,Li

b,Mi

i,Mi

It follows from this proposition that we can use the

algorithm from [32] to solve the Intent ICC problem.

The original IDE framework [32] requires that the
micro-function be represented efﬁciently in order to
achieve the time complexity of O(ED3). Our model does
not meet these requirements:
in particular, applying,
composing, joining micro-function or testing for equality
of micro-functions cannot be done in constant time. In-
deed, the size of micro-functions grows with the number
of branches, aliases and possible string arguments (see
Equation 6 for an example with two branches). However,
in practice we can ﬁnd solutions to our IDE problem in-
stances in reasonable time, as we show in Section 6.

6 Evaluation

This section describes an evaluation of the approach pre-
sented in the preceding sections, and brieﬂy character-
izes the use of ICC in Android applications. We also
present a study of potential ICC vulnerabilities. Our
implementation is called Epicc (Efﬁcient and Precise
ICC) and is available at http://siis.cse.psu.edu/
epicc/.
It is built on Heros [3], an IDE framework
within Soot [34]. We also provide the version of Soot
that we modiﬁed to handle pathological cases encoun-
tered with retargeted code.

In order to compute string arguments, we use a simple
analysis traversing the interprocedural control ﬂow graph
of the application. The traversal starts at the call site and
looks for constant assignments to the call arguments. If a
string argument cannot be determined, we conservatively
assume that the argument can be any string. As we show
in Section 6.1, in many cases we are able to ﬁnd precise
string arguments. More complex analyses can be used if
more precision is desired [7].

For points-to analysis and call graph construction, we
use Spark [24], which is part of Soot. It performs a ﬂow-
sensitive, context-insensitive analysis. We approximate
the call graph in components with multiple entry points.
In order to generate a call graph of an Android appli-
cation, we currently use a “wrapper” as an entry point.
This wrapper calls each class entry point once, which
may under-approximate what happens at runtime. This
impacts a speciﬁcation only if an ICC ﬁeld (e.g., Intent)
is modiﬁed in a way that depends on the runtime execu-
tion order of class entry points. Generally, if we assume
that our model of components’ life cycle is complete and
if the application does not use native calls or reﬂection,
then our results are sound.

The analysis presented in this section is performed on
two datasets. The ﬁrst random sample dataset contains
350 applications, 348 of which were successfully ana-
lyzed after retargeting. They were extracted from the
Google Play store6 between September 2012 and Jan-
uary 2013. The applications were selected at random
from over 200,000 applications in our corpus. The sec-
ond popular application dataset contains the top 25 most
popular free applications from each of the 34 applica-
tion categories in the Play store. The 850 selected appli-
cations were downloaded from that application store on
January 30, 2013. Of those 850 applications, 838 could
be retargeted and processed and were used in the exper-
iments below. The 14 applications which were not ana-
lyzed were pathological cases where retargeting yielded
code which could not be analyzed (e.g., in some cases
the Dare tool generated offsets with integer overﬂow er-
rors due to excessive method sizes), or where applica-
tions could not be processed by Soot (e.g., character en-
coding problems).

6.1 Precision of ICC Speciﬁcations
The ﬁrst set of tests evaluates the technique’s precision
with our datasets. We deﬁne the precision metric to be
the percentage of source and sink locations for which a
speciﬁcation is identiﬁed without ambiguity. Ambiguity
occurs when an ICC API method argument cannot be de-
termined. These arguments are mainly strings of charac-
ters, which may be generated at runtime. In some cases,
runtime context determines string values, which implies
that our analysis cannot statically ﬁnd them.

Recall the various forms of ICC. Explicit ICC iden-
tiﬁes the communication sink by specifying the target’s
package and class name. Conversely, implicit ICC iden-
tiﬁes the sink through action, category, and/or data ﬁelds.
Further, a mixed ICC occurs when a source or sink can
take on explicit or implicit ICC values depending on the
runtime context. Finally, the dynamic receiver ICC oc-
curs when a sink binds to an ICC type through runtime
context (e.g., Broadcast Receivers which identify the In-
tent Filter types when being registered). We seek to de-
termine precise ICC speciﬁcations, where all ﬁelds of In-
tents or Intent Filters are known without ambiguity.

As shown in Table 1, with respect to the random sam-
ple corpus, we were able to provide unambiguous speci-
ﬁcations for over 91% of the 7,835 ICC locations in the
348 applications. Explicit ICC was precisely analyzed
more frequently (≈98%) than implicit ICC (≈88%). The
remaining 7% of ICC containing mixed and dynamic re-
ceivers proved to be more difﬁcult, where the precision
rates are much lower than others. This is likely due to
the fact that dynamic receivers involve ﬁnding more data

6Available at https://play.google.com/store/apps.

USENIX Association  

22nd USENIX Security Symposium  553

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Constructor

b = new Bundle()

e.e[b 7! ?]

⇤

b

B.B

B.?

⇤

b

d

d

Adding int key-value pair

b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb

⇤

b

B.B

B.B

λB.βb

({MyInt},?,0,())(B)

d

d

B.B

1 public C o m p o n e n t N a m e

m a k e C o m p o n e n t N a m e () {

C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {

c = new C o m p o n e n t N a m e ( " c . d " ,

2
3
4

" a . b . MyClass " ) ;

} else {

" a . b . M y S e c o n d C l a s s " ) ; }

c = new C o m p o n e n t N a m e ( " c . d " ,

5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12

Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,

return c ; }

Copy constructor

b = new Bundle(d)

e.e[b 7! e(d)]

⇤

b

Clearing extra data keys

d.clear()

λe.ehd 7! βb

(?,?,1,())(e(d))i

⇤

b

d

⇤

B.B

B.B

B.B

B.B

B.B

⇤

b

d

⇤

b

b

λB.βb

(?,?,1,())(B)

d

d

Figure 6: Pointwise environment transformers for com-
mon Bundle operations

transformer t

the environment

require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.

The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.

We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges

environment
i.e.

transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).

ing studied.

of G∗,

assigns

to

this . m F i r s t N a m e ) ;

bundle . putAll ( b ) ;
bundle . remove ( " Surname " ) ;
return bundle ; }

Intent intent = new Intent () ;
intent . s e t C o m p o n t e n t ( m a k e C o m p o n e n t N a m e () ) ;
Bundle b = new Bundle () ;
b . p u t S t r i n g ( " Surname " , this . m S u r n a m e ) ;
intent . p u t E x t r a s ( m a k e B u n d l e ( b ) ) ;
r e g i s t e r M y R e c e i v e r () ;
s t a r t A c t i v i t y ( intent ) ; }

13
14
15
16
17 public void onClick ( View v ) {
18
19
20
21
22
23
24
25
26 public void r e g i s t e r M y R e c e i v e r () {
27
28
29
30
31

I n t e n t F i l t e r f = new I n t e n t F i l t e r () ;
f . a d d A c t i o n ( " a . b . ACTION " ) ;
f . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
r e g i s t e r R e c e i v e r ( new M y R e c e i v e r () ,

f , " a . b . P E R M I S S I O N " , null ) ; }
Figure 7: ICC objects example

Under certain conditions on the representation of
micro-functions, an IDE problem can be solved in time
O(ED3) [32]. For example, micro-functions should be
applied in constant time. In the model we present in Sec-
tion 5, we relax some of these constraints but ﬁnd that
the problem can still be solved efﬁciently in the average
case. When the problem is solved, we know the value as-
sociated with each symbol at important program points.

5 Reducing Intent ICC to an IDE problem

To solve the Intent ICC problem, we need to model
four different kinds of objects. First, ComponentName
objects contain a package name and a class name.
They can be used by explicit Intents. For example, in
method makeComponentName() of Figure 7, a Com-
ponentName object can take two different values de-
pending on which branch is executed.
In the ﬁrst
branch, it refers to class a.b.MyClass from applica-
tion package c.d. In the second one, it refers to class
a.b.MySecondClass. We want to know the possible
return values of makeComponentName().

Second, Bundle objects store data as key-value map-
pings. Method makeBundle() of Figure 7 creates a Bun-
dle and modiﬁes its value. We need to ﬁnd the possible
return values of makeBundle().

Third, Intent objects are the main ICC communica-

548  22nd USENIX Security Symposium 

USENIX Association

the target class of intent

tion objects. They contain all the data that is used to
In method onClick() of Fig-
start other components.
is set using the re-
ure 7,
turn value of makeComponentName().
Its extra data
is set to the return value of makeBundle(). Finally,
a new Activity is started using the newly created In-
tent. We need to determine the value of intent at the
startActivity(intent) instruction.

Fourth,

IntentFilter objects are used for dynamic
Broadcast Receivers.
In registerMyReceiver() on Fig-
ure 7, an action and a category are added to IntentFil-
ter f . Then a Broadcast Receiver of type MyReceiver
(which we assume to be deﬁned) is registered us-
ing method registerReceiver().
It receives Intents that
have action a.b.ACTION and category a.b.CATEGORY
and that originate from applications with permission
a.b.PERMISSION. We want to determine the arguments
to the registerReceiver() call. That is, we want to
know that f contains action a.b.ACTION and category
a.b.CATEGORY. We also want to know that the type of
the Broadcast Receiver is MyReceiver.

In this section, we use the notations from Sagiv et
al. [32] summarized in Section 4. We assume that string
method arguments are available. We describe the string
analysis used in our implementation in Section 6.

5.1 ComponentName Model
In this section, we introduce the model we use for Com-
ponentName objects. We introduce the notion of a
branch ComponentName value. It represents the value
that a ComponentName object can take on a single
branch, given a single possible string argument value for
each method setting the ComponentName’s package and
class names, and in the absence of aliasing.
Deﬁnition 1. A branch ComponentName value is a tuple
c = (p,k), where p is a package name and k is a class
name.

In method makeComponentName() of Figure 7, two

branch ComponentName values are constructed:

(c.d, a.b.MyClass)

(1)

and

(c.d, a.b.MySecondClass)

(2)
The next deﬁnition introduces ComponentName val-
ues, which represent the possibly multiple values that a
ComponentName can have at a program point. A Com-
ponentName can take several values in different cases:
• After traversing different branches, as in method
• When a string argument can have several values at a
• When an object reference is a possible alias of an-

makeComponentName() of Figure 7.

other local reference or an object ﬁeld.

method call.

• When an object reference is a possible array element.
In the last two cases, in order to account for the possi-
bility of a false positive in the alias analysis, we keep
track of two branch ComponentName values. One con-
siders the inﬂuence of the call on the possible alias and
the other one does not.
Deﬁnition 2. A ComponentName value C is a set of
branch ComponentName values: C = {c1,c2,··· ,cm}.
The set of ComponentName values is denoted as Vc. We
deﬁne ⊥ = ∅ and (cid:26) as the ComponentName value that
is the set of all possible branch ComponentName val-
ues in the program. The operators ∪ and ⊆ are deﬁned
as traditional set union and comparison operators: for
C1,C2 ∈ Vc, C1 ⊆ C2 iff C1 ∪C2 = C2. Lc = (Vc,∪) is a
join semilattice.

Note that given the deﬁnitions of ⊥ and (cid:26) as speciﬁc
sets, ∪ and ⊆ naturally apply to them. For example, for
all C ∈ Vc, (cid:26)∪C = (cid:26).
In method makeComponentName() from Figure 7, the
value of c at the return statement is

{(c.d, a.b.MyClass) ,

(3)
It simply combines the values of c created in the two
branches, given by Equations (1) and (2).

(c.d, a.b.MySecondClass)} .

We deﬁne transformers from Vc to Vc that represent
the inﬂuence of a statement or a sequence of statements
on a ComponentName value. A pointwise branch Com-
ponentName transformer represents the inﬂuence of a
single branch, whereas a pointwise ComponentName
transformer represents the inﬂuence of possibly multiple
branches.
Deﬁnition 3. A pointwise branch ComponentName
transformer is a function δ c
(π,χ) : Vc → Vc, where π is a
package name and χ is a class name. It is such that, for
each C ∈ Vc,

δ c
(π,χ)(C) ={(π , χ)}

(4)

Note that δ c

(π,χ)(C) is independent of C, because API
methods for ComponentName objects systematically re-
place existing values for package and class names. In the
example from Figure 7, the pointwise branch Compo-
nentName transformer corresponding to the ﬁrst branch
is

δ c
(c.d,a.b.MyClass),
and the one for the second branch is

δ c
(c.d,a.b.MySecondClass).

(5)
Deﬁnition 4. A pointwise ComponentName transformer
is a function δ c
: Vc → Vc such that, for
each C ∈ Vc,

δ c
{(π1,χ1),··· ,(πn,χn)}(C) ={(π 1, χ1),··· , (πn, χn)}

{(π1,χ1),··· ,(πn,χn)}

A pointwise ComponentName transformer summa-

USENIX Association  

22nd USENIX Security Symposium  549

rizes the effect of multiple branches (or a single branch
with multiple possible string arguments, or with possi-
ble aliasing) on a ComponentName value. That is, given
the value C of a ComponentName right after statement
si and given transformer δ c
that sum-
marizes the inﬂuence of statements si+1,··· ,sk on C,
δ c
(C) represents all the possible values
{(π1,χ1),··· ,(πn,χn)}
of C right after sk. In method makeComponentName()
of Figure 7, the pointwise ComponentName transformer
that models the two branches is

{(π1,χ1),··· ,(πn,χn)}

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}.

(6)
It combines the transformers given by Equations (4)
and (5). In order to understand how this transformer is
applied in practice, we should mention that the algorithm
to solve IDE problems initially sets values to ⊥ [32].
Therefore, in method makeComponentName(), the value
associated with c is initially ⊥ = ∅. Using Deﬁnition 4,
we can easily see that if we apply the transformer given
by Equation (6), we get the value given by Equation (3).
This conﬁrms that the transformer models the inﬂuence
of the two branches:

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}(⊥)

= {(c.d, a.b.MyClass) ,

(c.d, a.b.MySecondClass)}

5.2 Bundle Model

The model of Bundle objects is deﬁned similarly to the
model of ComponentName objects. An additional difﬁ-
culty is introduced. The data in a Bundle can be modiﬁed
by adding the data in another Bundle to it, as shown in
method makeBundle() of Figure 7. In this example, the
data in Bundle b is added to the data in Bundle bundle.
Bundle bundle is later modiﬁed by removing the key-
value pair with key Surname. The issue is that when
the data ﬂow problem is being tackled, the value of b
is not known. Therefore, the inﬂuence of the call to
remove("Surname") is not known: if a key-value pair
with key Surname is part of b, then the call removes it
from bundle. Otherwise, it has no inﬂuence.

Our approach to deal with this object composition
problem is to perform two successive analyses. In Anal-
ysis I, we use placeholders for Bundles such as b in in-
struction bundle.putAll(b). We also record all subse-
quent method calls affecting bundle. After the problem
is solved, b’s key-value pairs at the putAll(b) method
call are known, as well as the subsequent method calls.
We then perform Analysis II, in which b’s key-value
pairs are added to bundle’s. The inﬂuence of the sub-
sequent method call is precisely evaluated and ﬁnally the
value of bundle at the return statement can be known.

b to V i

b, where V i

5.2.1 Analysis I
In the ﬁrst analysis, we consider intermediate values that
contain “placeholders” for Bundle values that are not
known when the problem is being solved.
Deﬁnition 5. An intermediate branch Bundle value is a
tuple bi = (E,O), where:
• E is a set of keys describing extra data.
• O is a tuple of two types of elements. O contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. O also contains functions
from V i
b is the set of intermediate Bun-
dle values deﬁned below. These functions represent a
sequence of method calls affecting a Bundle.
The difference with previous deﬁnitions is the intro-
duction of O, which models calls to putAll() as well as
subsequent calls affecting the same Bundle. In method
makeBundle() of Figure 7, at the return statement, the in-
termediate branch Bundle value associated with bundle
is (E,O), where
E ={FirstName}
O =((b, bundle.putAll(b)),β b

(7)
(8)
In O, (b, bundle.putAll(b)) is a reference to variable
b at instruction bundle.putAll(b). β b
(∅,Surname,0,())
models the remove() method call. It is deﬁned below.

(∅,{Surname},0,()))

b = (V i

b, Bi1 ⊆ Bi2 iff Bi1 ∪ Bi2 = Bi2. Li

We just deﬁned intermediate branch Bundle values.
As we did before, we need to consider multiple branches
and related issues (e.g., several possible string values):
Deﬁnition 6. An intermediate Bundle value Bi is a set of
intermediate branch Bundle values: Bi = {bi1,··· ,bim}.
The set of intermediate Bundle values is V i
b. We deﬁne
⊥ = ∅ and (cid:26) as the intermediate Bundle value that is
the set of all possible intermediate branch Bundle val-
ues in the program. We deﬁne ⊆ and ∪ as natural set
comparison and union operators. They are such that, for
Bi1,Bi2 ∈ V i
b,∪) is
a join semilattice.
In method makeBundle() from Figure 7, since there is
only a single branch, the intermediate Bundle value as-
sociated with bundle at the return statement is {(E,O)},
where E and O are given by Equations (7) and (8).
b to V i
b.
Similarly to the ComponentName model, we ﬁrst in-
troduce pointwise branch Bundle transformers before
deﬁning pointwise Bundle transformers.
In the def-
initions below, we use the \ notation for set differ-
ence, and ∪ is naturally extended to tuples such that
(a1,··· ,ak)∪ (ak+1,··· ,al) = (a1,··· ,ak,ak+1,··· ,al).
Deﬁnition 7. A pointwise branch Bundle transformer is
a function β b
• η + is a set of string keys describing extra data. It

Pointwise transformers are deﬁned from V i

(η +,η−,cl,Θ) : V i

models calls to putExtra() methods.

b → V i

b, where:

550  22nd USENIX Security Symposium 

USENIX Association

• η− is a set of string keys describing removed ex-
It represents the inﬂuence of calls to the

tra data.
removeExtra() method.

with the clear() method and 0 otherwise.

• cl takes value 1 if the Bundle data has been cleared
• Θ is a tuple of two types of elements. It contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. It also contains functions
from V i
b. These functions represent a sequence
of method calls affecting a Bundle.

b to V i

It is such that
β b
(η +,η−,cl,Θ)(⊥) =(cid:31)(cid:30)η +\η−,Θ(cid:29)(cid:28)
and, for Bi = {(E1,O1),··· , (Em,Om)} (Bi (cid:24)= ⊥),
β b
(η +,η−,cl,Θ)(Bi) ={(E (cid:23)1,O(cid:23)1),··· , (E(cid:23)m,O(cid:23)m)}
where, for each j from 1 to m:
E(cid:23)j =

O(cid:23)j =


η +\η−
(E j ∪ η +)\η−
E j
Θ
O j ∪(cid:23)β b

if cl = 1
if cl = 0 and O j = ∅
otherwise

(η +,η−,0,Θ)(cid:22)

if cl = 1 or O j = ∅
otherwise

The deﬁnition of E(cid:23)j accounts for several possible

cases:
• If the Bundle data has been cleared (i.e., cl = 1), then
we discard any data contained in E j. This leads to
value η +\η− for E(cid:23)j: we only keep the values η +
that were added to the Bundle data and remove the
values η− that were removed from it.

• If the Bundle has not been cleared, then there are two
possible cases: either no reference to another Bun-
dle has been previously recorded (i.e., O j = ∅), or
such a reference has been recorded to model a call to
putAll(). In the ﬁrst case, we simply take the union
of the original set E j and the set η + of added values,
and subtract the set η− of removed values. This ex-
plain the (E j ∪ η +)\η− value. In the second case, a
call to putAll() has been detected, which means that
any further method call adding or removing data has
to be added to set O j instead of E j. Therefore in this
case E(cid:23)j = E j.
The deﬁnition of O(cid:23)j considers several cases:
• If the Bundle data has been cleared, then the previous
value of O j is irrelevant and we set O(cid:23)j = Θ. Also, if
O j is empty, then we can also just set O(cid:23)j to Θ (which
may or may not be empty).

• Otherwise,

the Bundle data has not been cleared
(cl = 0) and a call to putAll() has been detected
(O j (cid:24)= ∅). Then it means that the current function
models method calls that happened after a call to
putAll(). Therefore we need to record β b
(η +,η−,0,Θ)
in O(cid:23)j, which explains the deﬁnition O(cid:23)j = O j ∪
(β b
(η +,η−,0,Θ)).

For example, the pointwise branch Bundle transformer
that models the inﬂuence of the method makeBundle()
from Figure 7 is β b

(η +,∅,0,Θ), where

η + ={FirstName}
Θ =(cid:23)(b, bundle.putAll(b)),

(9)

(10)

(∅,{Surname},0,())(cid:22)
β b

Pointwise branch Bundle transformers model the in-
ﬂuence of a single branch. In order to account for mul-
tiple branches or issues such as possible aliasing false
positive, we deﬁne pointwise Bundle transformers.
Deﬁnition 8. A pointwise Bundle transformer is a func-
tion

: V i
b → V i

b

β b
{(η +

1 +,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

such that, for each Bi ∈ V i
b,
β b
{(η +

1 ,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

(Bi) =
1 ,η−1 ,cl1,Θ1)(Bi)∪···∪β b

β b
(η +

n ,η−n ,cln,Θn)(Bi)
(η +

For example, method makeBundle() from Figure 7
only has a single branch, thus the pointwise Bundle trans-
former that models it is simply β b
, where η +
and Θ are given in Equations (9) and (10). As we did for
the ComponentName value example, we can conﬁrm us-
ing Deﬁnitions 7 and 8 that β b
(⊥) ={(E ,O)},
where E and O are given by Equations (7) and (8).

{(η +,∅,0,Θ)}

{(η +,∅,0,Θ)}

5.2.2 Analysis II

After Analysis I has been performed, the values of the
Bundles used in placeholders in intermediate Bundle val-
ues are known. Ultimately, we want to obtain branch
Bundle values and ﬁnally Bundle values:
Deﬁnition 9. A branch Bundle value b is a set E of string
keys describing extra data.
Deﬁnition 10. A Bundle value B is a set of branch Bun-
dle values: B = {b1,··· ,bm}.

Since the values of the referenced Bundles are known,
we can integrate them into the Bundle values referring to
them. Then the inﬂuence of the subsequent method calls
that have been recorded can precisely be known.

Let us consider the example of makeBundle() from
Figure 7. After Analysis I has been performed, we know
that the intermediate value of bundle at the return state-
ment is {(E,O)}, where

E ={FirstName}
O =(cid:23)(b, bundle.putAll(b)),β b
We consider all elements of O in order. As the
ﬁrst element of O is (b, bundle.putAll(b)), we inte-
grate b’s value into bundle. From Analysis I, we know

(∅,{Surname},0,())(cid:22)

USENIX Association  

22nd USENIX Security Symposium  551

that the value of b at instruction bundle.putAll(b)
is {{Surname} ,∅}. Thus, E becomes {FirstName,
Surname}. The next element of O is β b
(∅,{Surname},0,()).
This means that we have to remove key Surname from E.
The ﬁnal value of E is therefore {FirstName}. Thus, the
Bundle value associated with bundle at the return state-
ment is {{FirstName}}.
Note that the referenced Bundle can also make refer-
ences to other Bundles. In that case, we perform the res-
olution for the referenced Bundles ﬁrst. There can be an
arbitrary number of levels of indirection. Analysis II is
iterated until a ﬁx-point is reached.

Intent and IntentFilter Models

5.3
The Intent model is deﬁned similarly to the Bundle
model, which includes object composition.
In method
onClick() of Figure 7, the target of Intent intent is set
using a ComponentName object and its extra data is set
with a Bundle. Because of this object composition, ﬁnd-
ing the Intent value also involves two analyses similar to
the ones performed for Bundles. First, intermediate In-
tent values with placeholders for referenced Component-
Name and Bundle objects are found. Second, the refer-
enced objects’ values are integrated into intent’s value.

i = (V i

Similarly to the Bundle model, we deﬁne intermedi-
ate branch Intent values and intermediate Intent values.
The set of intermediate Intent values is V i
i and we de-
ﬁne a lattice Li
i ,∪) as we did for Li
b. We also de-
ﬁne pointwise branch Intent transformers and pointwise
Intent transformers. For example, in method onClick()
of Figure 7, the ﬁnal intermediate value for intent sim-
ply has placeholders for a ComponentName and a Bun-
dle value. Other ﬁelds, such as action and categories,
are empty. The ComponentName and Bundle values are
computed using the models presented in Sections 5.1
and 5.2. Finally, we deﬁne branch Intent values and
Intent values, which are output by the second analysis.
The ﬁnal value for intent after the second analysis pre-
cisely contains the two possible targets (a.b.MyClass
and a.b.MySecondClass in package c.d) and extra
data key FirstName. For conciseness, and given the
strong similarities with the Bundle model, we do not in-
clude a full description of the Intent model here.

In order to analyze dynamic Broadcast Receivers, we
model IntentFilter objects. Modeling IntentFilters is sim-
ilar to modeling Intents, except that IntentFilters do not
involve object composition. That is because IntentFilters
do not have methods taking other IntentFilters as argu-
ment, except for a copy constructor. Thus, their analysis
is simpler and involves a single step. Similarly to what
we did for other ICC models, we deﬁne branch Intent-
Filter values, IntentFilter values, pointwise branch In-
tentFilter transformers and pointwise IntentFilter trans-

formers.
In particular, we deﬁne lattice L f = (Vf ,∪),
In method
is the set of IntentFilter values.
where Vf
onClick() from Figure 7, the ﬁnal value of f contains ac-
tion a.b.ACTION and category a.b.CATEGORY. Given
the similarity of the IntentFilter model with previous
models, we do not include a complete description.

5.4 Casting as an IDE Problem
These deﬁnitions allow us to deﬁne environment trans-
formers for our problem. Given environment e ∈
Env(D,L), environment transformer λ e.e is the identity,
which does not change the value of e. Given Intent i and
Intent value I, λ e.e[i (cid:27)→ I] transforms e to an environment
where all values are the same as in e, except that Intent i
is associated with value I.

We deﬁne an environment transformer for each API
method call. Each of these environment transformers
uses the pointwise environment transformers deﬁned in
Sections 5.1, 5.2 and 5.3. It precisely describes the inﬂu-
ence of a method call on the value associated with each
of the symbols in D.

Figure 6 shows some environment transformers and
their pointwise representation. The ﬁrst one is a con-
structor invocation, which sets the value corresponding
to b to ⊥. The second one adds an integer to the key-
value pairs in Bundle b’s extra data, which is represented
by environment transformer

({MyInt},∅,0,()) (e(b))(cid:30) .

λ e.e(cid:31)b (cid:27)→ β b
It means that
the environment stays the same, ex-
cept
the value associated with b becomes
β b
({MyInt},∅,0,()) (e(b)), with e(b) being the value previ-
ously associated with b in environment e. The pointwise
transformer for b is

that

on Figure 6 for consistency with the other pointwise
transformers.
It simply adds key MyInt to the set of
data keys. The next transformer is for a copy construc-
tor, where the value associated with d is assigned to the
value associated with b. The last transformer clears the
data keys associated with d.

Trivially, these environment transformers are distribu-

tive. Therefore, the following proposition holds.
Proposition 1. Let G∗ be the supergraph of an An-
droid application. Let Dc, Db Di and D f be the sets
of ComponentName, Bundle and Intent variables, re-
to which we add the special symbol Λ5.
spectively,
Let Lc, Li
b, Li
i and L f be the lattices deﬁned above.

5Recall from Section 4.2 that Λ symbolizes the absence of a data

ﬂow fact.

which we denote by

β b
({MyInt},∅,0,()),
({MyInt},∅,0,())(B)

λ B.β b

552  22nd USENIX Security Symposium 

USENIX Association

Let Mc, Mb, Mi and Mf be the corresponding assign-
ments of distributive environment transformers. Then
(G∗,Dc,Lc,Mc), (G∗,Db,Li
i ) and
(G∗,Di,L f ,Mf ) are IDE problems.

b), (G∗,Db,Li

b,Mi

i,Mi

It follows from this proposition that we can use the

algorithm from [32] to solve the Intent ICC problem.

The original IDE framework [32] requires that the
micro-function be represented efﬁciently in order to
achieve the time complexity of O(ED3). Our model does
not meet these requirements:
in particular, applying,
composing, joining micro-function or testing for equality
of micro-functions cannot be done in constant time. In-
deed, the size of micro-functions grows with the number
of branches, aliases and possible string arguments (see
Equation 6 for an example with two branches). However,
in practice we can ﬁnd solutions to our IDE problem in-
stances in reasonable time, as we show in Section 6.

6 Evaluation

This section describes an evaluation of the approach pre-
sented in the preceding sections, and brieﬂy character-
izes the use of ICC in Android applications. We also
present a study of potential ICC vulnerabilities. Our
implementation is called Epicc (Efﬁcient and Precise
ICC) and is available at http://siis.cse.psu.edu/
epicc/.
It is built on Heros [3], an IDE framework
within Soot [34]. We also provide the version of Soot
that we modiﬁed to handle pathological cases encoun-
tered with retargeted code.

In order to compute string arguments, we use a simple
analysis traversing the interprocedural control ﬂow graph
of the application. The traversal starts at the call site and
looks for constant assignments to the call arguments. If a
string argument cannot be determined, we conservatively
assume that the argument can be any string. As we show
in Section 6.1, in many cases we are able to ﬁnd precise
string arguments. More complex analyses can be used if
more precision is desired [7].

For points-to analysis and call graph construction, we
use Spark [24], which is part of Soot. It performs a ﬂow-
sensitive, context-insensitive analysis. We approximate
the call graph in components with multiple entry points.
In order to generate a call graph of an Android appli-
cation, we currently use a “wrapper” as an entry point.
This wrapper calls each class entry point once, which
may under-approximate what happens at runtime. This
impacts a speciﬁcation only if an ICC ﬁeld (e.g., Intent)
is modiﬁed in a way that depends on the runtime execu-
tion order of class entry points. Generally, if we assume
that our model of components’ life cycle is complete and
if the application does not use native calls or reﬂection,
then our results are sound.

The analysis presented in this section is performed on
two datasets. The ﬁrst random sample dataset contains
350 applications, 348 of which were successfully ana-
lyzed after retargeting. They were extracted from the
Google Play store6 between September 2012 and Jan-
uary 2013. The applications were selected at random
from over 200,000 applications in our corpus. The sec-
ond popular application dataset contains the top 25 most
popular free applications from each of the 34 applica-
tion categories in the Play store. The 850 selected appli-
cations were downloaded from that application store on
January 30, 2013. Of those 850 applications, 838 could
be retargeted and processed and were used in the exper-
iments below. The 14 applications which were not ana-
lyzed were pathological cases where retargeting yielded
code which could not be analyzed (e.g., in some cases
the Dare tool generated offsets with integer overﬂow er-
rors due to excessive method sizes), or where applica-
tions could not be processed by Soot (e.g., character en-
coding problems).

6.1 Precision of ICC Speciﬁcations
The ﬁrst set of tests evaluates the technique’s precision
with our datasets. We deﬁne the precision metric to be
the percentage of source and sink locations for which a
speciﬁcation is identiﬁed without ambiguity. Ambiguity
occurs when an ICC API method argument cannot be de-
termined. These arguments are mainly strings of charac-
ters, which may be generated at runtime. In some cases,
runtime context determines string values, which implies
that our analysis cannot statically ﬁnd them.

Recall the various forms of ICC. Explicit ICC iden-
tiﬁes the communication sink by specifying the target’s
package and class name. Conversely, implicit ICC iden-
tiﬁes the sink through action, category, and/or data ﬁelds.
Further, a mixed ICC occurs when a source or sink can
take on explicit or implicit ICC values depending on the
runtime context. Finally, the dynamic receiver ICC oc-
curs when a sink binds to an ICC type through runtime
context (e.g., Broadcast Receivers which identify the In-
tent Filter types when being registered). We seek to de-
termine precise ICC speciﬁcations, where all ﬁelds of In-
tents or Intent Filters are known without ambiguity.

As shown in Table 1, with respect to the random sam-
ple corpus, we were able to provide unambiguous speci-
ﬁcations for over 91% of the 7,835 ICC locations in the
348 applications. Explicit ICC was precisely analyzed
more frequently (≈98%) than implicit ICC (≈88%). The
remaining 7% of ICC containing mixed and dynamic re-
ceivers proved to be more difﬁcult, where the precision
rates are much lower than others. This is likely due to
the fact that dynamic receivers involve ﬁnding more data

6Available at https://play.google.com/store/apps.

USENIX Association  

22nd USENIX Security Symposium  553

Explicit
Implicit
Mixed
Dyn. Rec.
Total

Explicit
Implicit
Mixed
Dyn. Rec.
Total

Random Sample

Precise

3,571 97.65%
3,225 88.45%
28 59.57%
357 73.61%
7,181 91.65%

% Total
% Imprecise
86
2.35% 3,657
421 11.55% 3,646
19 40.43%
47
128 26.39% 485
8.35% 7,835
654

Popular
% Imprecise
1,637
1,525

Precise
27,753 94.43%
23,133 93.82%
509 85.12%
4,161 95.81%
55,556 94.18%
Table 1: Precision metrics

89 14.88%
182
3,433

% Total
5.57% 29,390
6.18% 24,658
598
4.19% 4,343
5.82% 58,989

than Intents: Intent Filters limiting access to dynamic re-
ceivers can deﬁne several actions, and receivers can be
protected by a permission (which we attempt to recover).
In the popular applications, we obtain a precise spec-
iﬁcation in over 94% of the 58,989 ICC locations in the
838 apps. Explicit ICC was slightly more precisely an-
alyzed than implicit ICC. Mixed ICC is again hard to
recover. This is not surprising, as mixed ICC involves
different Intent values on two or more branches, which is
indicative of a method more complex than most others.
A facet of the analysis not shown in the table is the
number of applications for which we could identify un-
ambiguous speciﬁcations for all ICC – called 100% pre-
cision. In the random sample, 56% of the applications
could be analyzed with 100% precision, 80% of the ap-
plications with 90% precision, and 91% of the applica-
tions with 80% precision.
In the popular applications,
23% could be analyzed with 100% precision, 82% could
be analyzed with 90% precision and 94% with 80% pre-
cision. Note that a less-than-100% precision does not
mean that the analysis failed. Rather, these are cases
where runtime context determines string arguments, and
thus any static analysis technique would fail.

6.2 Computation Costs
A second set of tests sought to ascertain the computa-
tional costs of performing the IDE analysis using Epicc.
For this task we collected measurements at each stage of
the analysis and computed simple statistics characteriz-
ing the costs of each task on the random sample and the
popular applications.

Experiment results show that ICC analysis in this
model is feasible for applications in the Google Play
store. We were able to perform analysis of all 348 ap-
plications in the random sample in about 3.69 hours of
compute time. On average, it took just over 38 seconds
to perform analysis for a single application, with a stan-
dard deviation of 99 seconds. There was high variance in
the analysis run times. A CDF (cumulative distribution

i

)
e
m
T
 
n
o
i
t
a
t
u
p
m
o
C

(
 
F
D
C

i

)
e
m
T
 
n
o
i
t
a
t
u
p
m
o
C

(
 
F
D
C

 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0

 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0

 1

 10

 100

Applications (logscale)
(a) Random sample

 1

 10
Applications (logscale)
(b) Popular applications

 100

Figure 8: CDF of computation time

function) of the analysis computation time for all 348 ap-
plications is presented in Figure 8(a). It is clear from the
ﬁgure that costs were dominated by a handful of appli-
cations; the top application consumed over 11% of the
time, the top 5 consumed over 25% of the total time, and
the top 29 consumed over 50% of the total time. These
applications are large with a high number of entry points.
Analyzing the 838 popular applications took 33.58
hours, that is, 144 seconds per application. The standard
deviation was 277 seconds. The average processing time
is signiﬁcantly higher than for the random sample. How-
ever, this is expected, as the average application size is
almost 1,500 classes, which is signiﬁcantly higher than
the random sample (less than 400 classes per applica-
tion). This is likely related to the popularity bias: one can
expect frequently downloaded applications to have fully
developed features as well as more complex/numerous
features, which implies a larger code base. A CDF of the
computation time for all 838 applications is presented in
Figure 8(b). Once again, analysis time is dominated by
a few applications. The top 5 consumed over 11% of the
analysis time and the top 83 (less than 10% of the sam-
ple) consumed over 50% of the analysis time.

Processing was dominated by the standard Soot pro-
cessing (e.g., translating classes to an intermediate repre-
sentation, performing type inference and points-to anal-
ysis, building a call graph). It consumed 75% of the pro-
cessing time in the random sample and 86% in the pop-
ular applications. It was itself dominated by the trans-
lation to Soot’s internal representation and by the call
graph construction. The second most time-consuming
task was the IDE analysis (which also includes the string
analysis in our implementation). It took 15% of the pro-

554  22nd USENIX Security Symposium 

USENIX Association

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Constructor

b = new Bundle()

e.e[b 7! ?]

⇤

b

B.B

B.?

⇤

b

d

d

Adding int key-value pair

b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb

⇤

b

B.B

B.B

λB.βb

({MyInt},?,0,())(B)

d

d

B.B

1 public C o m p o n e n t N a m e

m a k e C o m p o n e n t N a m e () {

C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {

c = new C o m p o n e n t N a m e ( " c . d " ,

2
3
4

" a . b . MyClass " ) ;

} else {

" a . b . M y S e c o n d C l a s s " ) ; }

c = new C o m p o n e n t N a m e ( " c . d " ,

5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12

Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,

return c ; }

Copy constructor

b = new Bundle(d)

e.e[b 7! e(d)]

⇤

b

Clearing extra data keys

d.clear()

λe.ehd 7! βb

(?,?,1,())(e(d))i

⇤

b

d

⇤

B.B

B.B

B.B

B.B

B.B

⇤

b

d

⇤

b

b

λB.βb

(?,?,1,())(B)

d

d

Figure 6: Pointwise environment transformers for com-
mon Bundle operations

transformer t

the environment

require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.

The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.

We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges

environment
i.e.

transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).

ing studied.

of G∗,

assigns

to

this . m F i r s t N a m e ) ;

bundle . putAll ( b ) ;
bundle . remove ( " Surname " ) ;
return bundle ; }

Intent intent = new Intent () ;
intent . s e t C o m p o n t e n t ( m a k e C o m p o n e n t N a m e () ) ;
Bundle b = new Bundle () ;
b . p u t S t r i n g ( " Surname " , this . m S u r n a m e ) ;
intent . p u t E x t r a s ( m a k e B u n d l e ( b ) ) ;
r e g i s t e r M y R e c e i v e r () ;
s t a r t A c t i v i t y ( intent ) ; }

13
14
15
16
17 public void onClick ( View v ) {
18
19
20
21
22
23
24
25
26 public void r e g i s t e r M y R e c e i v e r () {
27
28
29
30
31

I n t e n t F i l t e r f = new I n t e n t F i l t e r () ;
f . a d d A c t i o n ( " a . b . ACTION " ) ;
f . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
r e g i s t e r R e c e i v e r ( new M y R e c e i v e r () ,

f , " a . b . P E R M I S S I O N " , null ) ; }
Figure 7: ICC objects example

Under certain conditions on the representation of
micro-functions, an IDE problem can be solved in time
O(ED3) [32]. For example, micro-functions should be
applied in constant time. In the model we present in Sec-
tion 5, we relax some of these constraints but ﬁnd that
the problem can still be solved efﬁciently in the average
case. When the problem is solved, we know the value as-
sociated with each symbol at important program points.

5 Reducing Intent ICC to an IDE problem

To solve the Intent ICC problem, we need to model
four different kinds of objects. First, ComponentName
objects contain a package name and a class name.
They can be used by explicit Intents. For example, in
method makeComponentName() of Figure 7, a Com-
ponentName object can take two different values de-
pending on which branch is executed.
In the ﬁrst
branch, it refers to class a.b.MyClass from applica-
tion package c.d. In the second one, it refers to class
a.b.MySecondClass. We want to know the possible
return values of makeComponentName().

Second, Bundle objects store data as key-value map-
pings. Method makeBundle() of Figure 7 creates a Bun-
dle and modiﬁes its value. We need to ﬁnd the possible
return values of makeBundle().

Third, Intent objects are the main ICC communica-

548  22nd USENIX Security Symposium 

USENIX Association

the target class of intent

tion objects. They contain all the data that is used to
In method onClick() of Fig-
start other components.
is set using the re-
ure 7,
turn value of makeComponentName().
Its extra data
is set to the return value of makeBundle(). Finally,
a new Activity is started using the newly created In-
tent. We need to determine the value of intent at the
startActivity(intent) instruction.

Fourth,

IntentFilter objects are used for dynamic
Broadcast Receivers.
In registerMyReceiver() on Fig-
ure 7, an action and a category are added to IntentFil-
ter f . Then a Broadcast Receiver of type MyReceiver
(which we assume to be deﬁned) is registered us-
ing method registerReceiver().
It receives Intents that
have action a.b.ACTION and category a.b.CATEGORY
and that originate from applications with permission
a.b.PERMISSION. We want to determine the arguments
to the registerReceiver() call. That is, we want to
know that f contains action a.b.ACTION and category
a.b.CATEGORY. We also want to know that the type of
the Broadcast Receiver is MyReceiver.

In this section, we use the notations from Sagiv et
al. [32] summarized in Section 4. We assume that string
method arguments are available. We describe the string
analysis used in our implementation in Section 6.

5.1 ComponentName Model
In this section, we introduce the model we use for Com-
ponentName objects. We introduce the notion of a
branch ComponentName value. It represents the value
that a ComponentName object can take on a single
branch, given a single possible string argument value for
each method setting the ComponentName’s package and
class names, and in the absence of aliasing.
Deﬁnition 1. A branch ComponentName value is a tuple
c = (p,k), where p is a package name and k is a class
name.

In method makeComponentName() of Figure 7, two

branch ComponentName values are constructed:

(c.d, a.b.MyClass)

(1)

and

(c.d, a.b.MySecondClass)

(2)
The next deﬁnition introduces ComponentName val-
ues, which represent the possibly multiple values that a
ComponentName can have at a program point. A Com-
ponentName can take several values in different cases:
• After traversing different branches, as in method
• When a string argument can have several values at a
• When an object reference is a possible alias of an-

makeComponentName() of Figure 7.

other local reference or an object ﬁeld.

method call.

• When an object reference is a possible array element.
In the last two cases, in order to account for the possi-
bility of a false positive in the alias analysis, we keep
track of two branch ComponentName values. One con-
siders the inﬂuence of the call on the possible alias and
the other one does not.
Deﬁnition 2. A ComponentName value C is a set of
branch ComponentName values: C = {c1,c2,··· ,cm}.
The set of ComponentName values is denoted as Vc. We
deﬁne ⊥ = ∅ and (cid:26) as the ComponentName value that
is the set of all possible branch ComponentName val-
ues in the program. The operators ∪ and ⊆ are deﬁned
as traditional set union and comparison operators: for
C1,C2 ∈ Vc, C1 ⊆ C2 iff C1 ∪C2 = C2. Lc = (Vc,∪) is a
join semilattice.

Note that given the deﬁnitions of ⊥ and (cid:26) as speciﬁc
sets, ∪ and ⊆ naturally apply to them. For example, for
all C ∈ Vc, (cid:26)∪C = (cid:26).
In method makeComponentName() from Figure 7, the
value of c at the return statement is

{(c.d, a.b.MyClass) ,

(3)
It simply combines the values of c created in the two
branches, given by Equations (1) and (2).

(c.d, a.b.MySecondClass)} .

We deﬁne transformers from Vc to Vc that represent
the inﬂuence of a statement or a sequence of statements
on a ComponentName value. A pointwise branch Com-
ponentName transformer represents the inﬂuence of a
single branch, whereas a pointwise ComponentName
transformer represents the inﬂuence of possibly multiple
branches.
Deﬁnition 3. A pointwise branch ComponentName
transformer is a function δ c
(π,χ) : Vc → Vc, where π is a
package name and χ is a class name. It is such that, for
each C ∈ Vc,

δ c
(π,χ)(C) ={(π , χ)}

(4)

Note that δ c

(π,χ)(C) is independent of C, because API
methods for ComponentName objects systematically re-
place existing values for package and class names. In the
example from Figure 7, the pointwise branch Compo-
nentName transformer corresponding to the ﬁrst branch
is

δ c
(c.d,a.b.MyClass),
and the one for the second branch is

δ c
(c.d,a.b.MySecondClass).

(5)
Deﬁnition 4. A pointwise ComponentName transformer
is a function δ c
: Vc → Vc such that, for
each C ∈ Vc,

δ c
{(π1,χ1),··· ,(πn,χn)}(C) ={(π 1, χ1),··· , (πn, χn)}

{(π1,χ1),··· ,(πn,χn)}

A pointwise ComponentName transformer summa-

USENIX Association  

22nd USENIX Security Symposium  549

rizes the effect of multiple branches (or a single branch
with multiple possible string arguments, or with possi-
ble aliasing) on a ComponentName value. That is, given
the value C of a ComponentName right after statement
si and given transformer δ c
that sum-
marizes the inﬂuence of statements si+1,··· ,sk on C,
δ c
(C) represents all the possible values
{(π1,χ1),··· ,(πn,χn)}
of C right after sk. In method makeComponentName()
of Figure 7, the pointwise ComponentName transformer
that models the two branches is

{(π1,χ1),··· ,(πn,χn)}

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}.

(6)
It combines the transformers given by Equations (4)
and (5). In order to understand how this transformer is
applied in practice, we should mention that the algorithm
to solve IDE problems initially sets values to ⊥ [32].
Therefore, in method makeComponentName(), the value
associated with c is initially ⊥ = ∅. Using Deﬁnition 4,
we can easily see that if we apply the transformer given
by Equation (6), we get the value given by Equation (3).
This conﬁrms that the transformer models the inﬂuence
of the two branches:

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}(⊥)

= {(c.d, a.b.MyClass) ,

(c.d, a.b.MySecondClass)}

5.2 Bundle Model

The model of Bundle objects is deﬁned similarly to the
model of ComponentName objects. An additional difﬁ-
culty is introduced. The data in a Bundle can be modiﬁed
by adding the data in another Bundle to it, as shown in
method makeBundle() of Figure 7. In this example, the
data in Bundle b is added to the data in Bundle bundle.
Bundle bundle is later modiﬁed by removing the key-
value pair with key Surname. The issue is that when
the data ﬂow problem is being tackled, the value of b
is not known. Therefore, the inﬂuence of the call to
remove("Surname") is not known: if a key-value pair
with key Surname is part of b, then the call removes it
from bundle. Otherwise, it has no inﬂuence.

Our approach to deal with this object composition
problem is to perform two successive analyses. In Anal-
ysis I, we use placeholders for Bundles such as b in in-
struction bundle.putAll(b). We also record all subse-
quent method calls affecting bundle. After the problem
is solved, b’s key-value pairs at the putAll(b) method
call are known, as well as the subsequent method calls.
We then perform Analysis II, in which b’s key-value
pairs are added to bundle’s. The inﬂuence of the sub-
sequent method call is precisely evaluated and ﬁnally the
value of bundle at the return statement can be known.

b to V i

b, where V i

5.2.1 Analysis I
In the ﬁrst analysis, we consider intermediate values that
contain “placeholders” for Bundle values that are not
known when the problem is being solved.
Deﬁnition 5. An intermediate branch Bundle value is a
tuple bi = (E,O), where:
• E is a set of keys describing extra data.
• O is a tuple of two types of elements. O contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. O also contains functions
from V i
b is the set of intermediate Bun-
dle values deﬁned below. These functions represent a
sequence of method calls affecting a Bundle.
The difference with previous deﬁnitions is the intro-
duction of O, which models calls to putAll() as well as
subsequent calls affecting the same Bundle. In method
makeBundle() of Figure 7, at the return statement, the in-
termediate branch Bundle value associated with bundle
is (E,O), where
E ={FirstName}
O =((b, bundle.putAll(b)),β b

(7)
(8)
In O, (b, bundle.putAll(b)) is a reference to variable
b at instruction bundle.putAll(b). β b
(∅,Surname,0,())
models the remove() method call. It is deﬁned below.

(∅,{Surname},0,()))

b = (V i

b, Bi1 ⊆ Bi2 iff Bi1 ∪ Bi2 = Bi2. Li

We just deﬁned intermediate branch Bundle values.
As we did before, we need to consider multiple branches
and related issues (e.g., several possible string values):
Deﬁnition 6. An intermediate Bundle value Bi is a set of
intermediate branch Bundle values: Bi = {bi1,··· ,bim}.
The set of intermediate Bundle values is V i
b. We deﬁne
⊥ = ∅ and (cid:26) as the intermediate Bundle value that is
the set of all possible intermediate branch Bundle val-
ues in the program. We deﬁne ⊆ and ∪ as natural set
comparison and union operators. They are such that, for
Bi1,Bi2 ∈ V i
b,∪) is
a join semilattice.
In method makeBundle() from Figure 7, since there is
only a single branch, the intermediate Bundle value as-
sociated with bundle at the return statement is {(E,O)},
where E and O are given by Equations (7) and (8).
b to V i
b.
Similarly to the ComponentName model, we ﬁrst in-
troduce pointwise branch Bundle transformers before
deﬁning pointwise Bundle transformers.
In the def-
initions below, we use the \ notation for set differ-
ence, and ∪ is naturally extended to tuples such that
(a1,··· ,ak)∪ (ak+1,··· ,al) = (a1,··· ,ak,ak+1,··· ,al).
Deﬁnition 7. A pointwise branch Bundle transformer is
a function β b
• η + is a set of string keys describing extra data. It

Pointwise transformers are deﬁned from V i

(η +,η−,cl,Θ) : V i

models calls to putExtra() methods.

b → V i

b, where:

550  22nd USENIX Security Symposium 

USENIX Association

• η− is a set of string keys describing removed ex-
It represents the inﬂuence of calls to the

tra data.
removeExtra() method.

with the clear() method and 0 otherwise.

• cl takes value 1 if the Bundle data has been cleared
• Θ is a tuple of two types of elements. It contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. It also contains functions
from V i
b. These functions represent a sequence
of method calls affecting a Bundle.

b to V i

It is such that
β b
(η +,η−,cl,Θ)(⊥) =(cid:31)(cid:30)η +\η−,Θ(cid:29)(cid:28)
and, for Bi = {(E1,O1),··· , (Em,Om)} (Bi (cid:24)= ⊥),
β b
(η +,η−,cl,Θ)(Bi) ={(E (cid:23)1,O(cid:23)1),··· , (E(cid:23)m,O(cid:23)m)}
where, for each j from 1 to m:
E(cid:23)j =

O(cid:23)j =


η +\η−
(E j ∪ η +)\η−
E j
Θ
O j ∪(cid:23)β b

if cl = 1
if cl = 0 and O j = ∅
otherwise

(η +,η−,0,Θ)(cid:22)

if cl = 1 or O j = ∅
otherwise

The deﬁnition of E(cid:23)j accounts for several possible

cases:
• If the Bundle data has been cleared (i.e., cl = 1), then
we discard any data contained in E j. This leads to
value η +\η− for E(cid:23)j: we only keep the values η +
that were added to the Bundle data and remove the
values η− that were removed from it.

• If the Bundle has not been cleared, then there are two
possible cases: either no reference to another Bun-
dle has been previously recorded (i.e., O j = ∅), or
such a reference has been recorded to model a call to
putAll(). In the ﬁrst case, we simply take the union
of the original set E j and the set η + of added values,
and subtract the set η− of removed values. This ex-
plain the (E j ∪ η +)\η− value. In the second case, a
call to putAll() has been detected, which means that
any further method call adding or removing data has
to be added to set O j instead of E j. Therefore in this
case E(cid:23)j = E j.
The deﬁnition of O(cid:23)j considers several cases:
• If the Bundle data has been cleared, then the previous
value of O j is irrelevant and we set O(cid:23)j = Θ. Also, if
O j is empty, then we can also just set O(cid:23)j to Θ (which
may or may not be empty).

• Otherwise,

the Bundle data has not been cleared
(cl = 0) and a call to putAll() has been detected
(O j (cid:24)= ∅). Then it means that the current function
models method calls that happened after a call to
putAll(). Therefore we need to record β b
(η +,η−,0,Θ)
in O(cid:23)j, which explains the deﬁnition O(cid:23)j = O j ∪
(β b
(η +,η−,0,Θ)).

For example, the pointwise branch Bundle transformer
that models the inﬂuence of the method makeBundle()
from Figure 7 is β b

(η +,∅,0,Θ), where

η + ={FirstName}
Θ =(cid:23)(b, bundle.putAll(b)),

(9)

(10)

(∅,{Surname},0,())(cid:22)
β b

Pointwise branch Bundle transformers model the in-
ﬂuence of a single branch. In order to account for mul-
tiple branches or issues such as possible aliasing false
positive, we deﬁne pointwise Bundle transformers.
Deﬁnition 8. A pointwise Bundle transformer is a func-
tion

: V i
b → V i

b

β b
{(η +

1 +,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

such that, for each Bi ∈ V i
b,
β b
{(η +

1 ,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

(Bi) =
1 ,η−1 ,cl1,Θ1)(Bi)∪···∪β b

β b
(η +

n ,η−n ,cln,Θn)(Bi)
(η +

For example, method makeBundle() from Figure 7
only has a single branch, thus the pointwise Bundle trans-
former that models it is simply β b
, where η +
and Θ are given in Equations (9) and (10). As we did for
the ComponentName value example, we can conﬁrm us-
ing Deﬁnitions 7 and 8 that β b
(⊥) ={(E ,O)},
where E and O are given by Equations (7) and (8).

{(η +,∅,0,Θ)}

{(η +,∅,0,Θ)}

5.2.2 Analysis II

After Analysis I has been performed, the values of the
Bundles used in placeholders in intermediate Bundle val-
ues are known. Ultimately, we want to obtain branch
Bundle values and ﬁnally Bundle values:
Deﬁnition 9. A branch Bundle value b is a set E of string
keys describing extra data.
Deﬁnition 10. A Bundle value B is a set of branch Bun-
dle values: B = {b1,··· ,bm}.

Since the values of the referenced Bundles are known,
we can integrate them into the Bundle values referring to
them. Then the inﬂuence of the subsequent method calls
that have been recorded can precisely be known.

Let us consider the example of makeBundle() from
Figure 7. After Analysis I has been performed, we know
that the intermediate value of bundle at the return state-
ment is {(E,O)}, where

E ={FirstName}
O =(cid:23)(b, bundle.putAll(b)),β b
We consider all elements of O in order. As the
ﬁrst element of O is (b, bundle.putAll(b)), we inte-
grate b’s value into bundle. From Analysis I, we know

(∅,{Surname},0,())(cid:22)

USENIX Association  

22nd USENIX Security Symposium  551

that the value of b at instruction bundle.putAll(b)
is {{Surname} ,∅}. Thus, E becomes {FirstName,
Surname}. The next element of O is β b
(∅,{Surname},0,()).
This means that we have to remove key Surname from E.
The ﬁnal value of E is therefore {FirstName}. Thus, the
Bundle value associated with bundle at the return state-
ment is {{FirstName}}.
Note that the referenced Bundle can also make refer-
ences to other Bundles. In that case, we perform the res-
olution for the referenced Bundles ﬁrst. There can be an
arbitrary number of levels of indirection. Analysis II is
iterated until a ﬁx-point is reached.

Intent and IntentFilter Models

5.3
The Intent model is deﬁned similarly to the Bundle
model, which includes object composition.
In method
onClick() of Figure 7, the target of Intent intent is set
using a ComponentName object and its extra data is set
with a Bundle. Because of this object composition, ﬁnd-
ing the Intent value also involves two analyses similar to
the ones performed for Bundles. First, intermediate In-
tent values with placeholders for referenced Component-
Name and Bundle objects are found. Second, the refer-
enced objects’ values are integrated into intent’s value.

i = (V i

Similarly to the Bundle model, we deﬁne intermedi-
ate branch Intent values and intermediate Intent values.
The set of intermediate Intent values is V i
i and we de-
ﬁne a lattice Li
i ,∪) as we did for Li
b. We also de-
ﬁne pointwise branch Intent transformers and pointwise
Intent transformers. For example, in method onClick()
of Figure 7, the ﬁnal intermediate value for intent sim-
ply has placeholders for a ComponentName and a Bun-
dle value. Other ﬁelds, such as action and categories,
are empty. The ComponentName and Bundle values are
computed using the models presented in Sections 5.1
and 5.2. Finally, we deﬁne branch Intent values and
Intent values, which are output by the second analysis.
The ﬁnal value for intent after the second analysis pre-
cisely contains the two possible targets (a.b.MyClass
and a.b.MySecondClass in package c.d) and extra
data key FirstName. For conciseness, and given the
strong similarities with the Bundle model, we do not in-
clude a full description of the Intent model here.

In order to analyze dynamic Broadcast Receivers, we
model IntentFilter objects. Modeling IntentFilters is sim-
ilar to modeling Intents, except that IntentFilters do not
involve object composition. That is because IntentFilters
do not have methods taking other IntentFilters as argu-
ment, except for a copy constructor. Thus, their analysis
is simpler and involves a single step. Similarly to what
we did for other ICC models, we deﬁne branch Intent-
Filter values, IntentFilter values, pointwise branch In-
tentFilter transformers and pointwise IntentFilter trans-

formers.
In particular, we deﬁne lattice L f = (Vf ,∪),
In method
is the set of IntentFilter values.
where Vf
onClick() from Figure 7, the ﬁnal value of f contains ac-
tion a.b.ACTION and category a.b.CATEGORY. Given
the similarity of the IntentFilter model with previous
models, we do not include a complete description.

5.4 Casting as an IDE Problem
These deﬁnitions allow us to deﬁne environment trans-
formers for our problem. Given environment e ∈
Env(D,L), environment transformer λ e.e is the identity,
which does not change the value of e. Given Intent i and
Intent value I, λ e.e[i (cid:27)→ I] transforms e to an environment
where all values are the same as in e, except that Intent i
is associated with value I.

We deﬁne an environment transformer for each API
method call. Each of these environment transformers
uses the pointwise environment transformers deﬁned in
Sections 5.1, 5.2 and 5.3. It precisely describes the inﬂu-
ence of a method call on the value associated with each
of the symbols in D.

Figure 6 shows some environment transformers and
their pointwise representation. The ﬁrst one is a con-
structor invocation, which sets the value corresponding
to b to ⊥. The second one adds an integer to the key-
value pairs in Bundle b’s extra data, which is represented
by environment transformer

({MyInt},∅,0,()) (e(b))(cid:30) .

λ e.e(cid:31)b (cid:27)→ β b
It means that
the environment stays the same, ex-
cept
the value associated with b becomes
β b
({MyInt},∅,0,()) (e(b)), with e(b) being the value previ-
ously associated with b in environment e. The pointwise
transformer for b is

that

on Figure 6 for consistency with the other pointwise
transformers.
It simply adds key MyInt to the set of
data keys. The next transformer is for a copy construc-
tor, where the value associated with d is assigned to the
value associated with b. The last transformer clears the
data keys associated with d.

Trivially, these environment transformers are distribu-

tive. Therefore, the following proposition holds.
Proposition 1. Let G∗ be the supergraph of an An-
droid application. Let Dc, Db Di and D f be the sets
of ComponentName, Bundle and Intent variables, re-
to which we add the special symbol Λ5.
spectively,
Let Lc, Li
b, Li
i and L f be the lattices deﬁned above.

5Recall from Section 4.2 that Λ symbolizes the absence of a data

ﬂow fact.

which we denote by

β b
({MyInt},∅,0,()),
({MyInt},∅,0,())(B)

λ B.β b

552  22nd USENIX Security Symposium 

USENIX Association

Let Mc, Mb, Mi and Mf be the corresponding assign-
ments of distributive environment transformers. Then
(G∗,Dc,Lc,Mc), (G∗,Db,Li
i ) and
(G∗,Di,L f ,Mf ) are IDE problems.

b), (G∗,Db,Li

b,Mi

i,Mi

It follows from this proposition that we can use the

algorithm from [32] to solve the Intent ICC problem.

The original IDE framework [32] requires that the
micro-function be represented efﬁciently in order to
achieve the time complexity of O(ED3). Our model does
not meet these requirements:
in particular, applying,
composing, joining micro-function or testing for equality
of micro-functions cannot be done in constant time. In-
deed, the size of micro-functions grows with the number
of branches, aliases and possible string arguments (see
Equation 6 for an example with two branches). However,
in practice we can ﬁnd solutions to our IDE problem in-
stances in reasonable time, as we show in Section 6.

6 Evaluation

This section describes an evaluation of the approach pre-
sented in the preceding sections, and brieﬂy character-
izes the use of ICC in Android applications. We also
present a study of potential ICC vulnerabilities. Our
implementation is called Epicc (Efﬁcient and Precise
ICC) and is available at http://siis.cse.psu.edu/
epicc/.
It is built on Heros [3], an IDE framework
within Soot [34]. We also provide the version of Soot
that we modiﬁed to handle pathological cases encoun-
tered with retargeted code.

In order to compute string arguments, we use a simple
analysis traversing the interprocedural control ﬂow graph
of the application. The traversal starts at the call site and
looks for constant assignments to the call arguments. If a
string argument cannot be determined, we conservatively
assume that the argument can be any string. As we show
in Section 6.1, in many cases we are able to ﬁnd precise
string arguments. More complex analyses can be used if
more precision is desired [7].

For points-to analysis and call graph construction, we
use Spark [24], which is part of Soot. It performs a ﬂow-
sensitive, context-insensitive analysis. We approximate
the call graph in components with multiple entry points.
In order to generate a call graph of an Android appli-
cation, we currently use a “wrapper” as an entry point.
This wrapper calls each class entry point once, which
may under-approximate what happens at runtime. This
impacts a speciﬁcation only if an ICC ﬁeld (e.g., Intent)
is modiﬁed in a way that depends on the runtime execu-
tion order of class entry points. Generally, if we assume
that our model of components’ life cycle is complete and
if the application does not use native calls or reﬂection,
then our results are sound.

The analysis presented in this section is performed on
two datasets. The ﬁrst random sample dataset contains
350 applications, 348 of which were successfully ana-
lyzed after retargeting. They were extracted from the
Google Play store6 between September 2012 and Jan-
uary 2013. The applications were selected at random
from over 200,000 applications in our corpus. The sec-
ond popular application dataset contains the top 25 most
popular free applications from each of the 34 applica-
tion categories in the Play store. The 850 selected appli-
cations were downloaded from that application store on
January 30, 2013. Of those 850 applications, 838 could
be retargeted and processed and were used in the exper-
iments below. The 14 applications which were not ana-
lyzed were pathological cases where retargeting yielded
code which could not be analyzed (e.g., in some cases
the Dare tool generated offsets with integer overﬂow er-
rors due to excessive method sizes), or where applica-
tions could not be processed by Soot (e.g., character en-
coding problems).

6.1 Precision of ICC Speciﬁcations
The ﬁrst set of tests evaluates the technique’s precision
with our datasets. We deﬁne the precision metric to be
the percentage of source and sink locations for which a
speciﬁcation is identiﬁed without ambiguity. Ambiguity
occurs when an ICC API method argument cannot be de-
termined. These arguments are mainly strings of charac-
ters, which may be generated at runtime. In some cases,
runtime context determines string values, which implies
that our analysis cannot statically ﬁnd them.

Recall the various forms of ICC. Explicit ICC iden-
tiﬁes the communication sink by specifying the target’s
package and class name. Conversely, implicit ICC iden-
tiﬁes the sink through action, category, and/or data ﬁelds.
Further, a mixed ICC occurs when a source or sink can
take on explicit or implicit ICC values depending on the
runtime context. Finally, the dynamic receiver ICC oc-
curs when a sink binds to an ICC type through runtime
context (e.g., Broadcast Receivers which identify the In-
tent Filter types when being registered). We seek to de-
termine precise ICC speciﬁcations, where all ﬁelds of In-
tents or Intent Filters are known without ambiguity.

As shown in Table 1, with respect to the random sam-
ple corpus, we were able to provide unambiguous speci-
ﬁcations for over 91% of the 7,835 ICC locations in the
348 applications. Explicit ICC was precisely analyzed
more frequently (≈98%) than implicit ICC (≈88%). The
remaining 7% of ICC containing mixed and dynamic re-
ceivers proved to be more difﬁcult, where the precision
rates are much lower than others. This is likely due to
the fact that dynamic receivers involve ﬁnding more data

6Available at https://play.google.com/store/apps.

USENIX Association  

22nd USENIX Security Symposium  553

Explicit
Implicit
Mixed
Dyn. Rec.
Total

Explicit
Implicit
Mixed
Dyn. Rec.
Total

Random Sample

Precise

3,571 97.65%
3,225 88.45%
28 59.57%
357 73.61%
7,181 91.65%

% Total
% Imprecise
86
2.35% 3,657
421 11.55% 3,646
19 40.43%
47
128 26.39% 485
8.35% 7,835
654

Popular
% Imprecise
1,637
1,525

Precise
27,753 94.43%
23,133 93.82%
509 85.12%
4,161 95.81%
55,556 94.18%
Table 1: Precision metrics

89 14.88%
182
3,433

% Total
5.57% 29,390
6.18% 24,658
598
4.19% 4,343
5.82% 58,989

than Intents: Intent Filters limiting access to dynamic re-
ceivers can deﬁne several actions, and receivers can be
protected by a permission (which we attempt to recover).
In the popular applications, we obtain a precise spec-
iﬁcation in over 94% of the 58,989 ICC locations in the
838 apps. Explicit ICC was slightly more precisely an-
alyzed than implicit ICC. Mixed ICC is again hard to
recover. This is not surprising, as mixed ICC involves
different Intent values on two or more branches, which is
indicative of a method more complex than most others.
A facet of the analysis not shown in the table is the
number of applications for which we could identify un-
ambiguous speciﬁcations for all ICC – called 100% pre-
cision. In the random sample, 56% of the applications
could be analyzed with 100% precision, 80% of the ap-
plications with 90% precision, and 91% of the applica-
tions with 80% precision.
In the popular applications,
23% could be analyzed with 100% precision, 82% could
be analyzed with 90% precision and 94% with 80% pre-
cision. Note that a less-than-100% precision does not
mean that the analysis failed. Rather, these are cases
where runtime context determines string arguments, and
thus any static analysis technique would fail.

6.2 Computation Costs
A second set of tests sought to ascertain the computa-
tional costs of performing the IDE analysis using Epicc.
For this task we collected measurements at each stage of
the analysis and computed simple statistics characteriz-
ing the costs of each task on the random sample and the
popular applications.

Experiment results show that ICC analysis in this
model is feasible for applications in the Google Play
store. We were able to perform analysis of all 348 ap-
plications in the random sample in about 3.69 hours of
compute time. On average, it took just over 38 seconds
to perform analysis for a single application, with a stan-
dard deviation of 99 seconds. There was high variance in
the analysis run times. A CDF (cumulative distribution

i

)
e
m
T
 
n
o
i
t
a
t
u
p
m
o
C

(
 
F
D
C

i

)
e
m
T
 
n
o
i
t
a
t
u
p
m
o
C

(
 
F
D
C

 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0

 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0

 1

 10

 100

Applications (logscale)
(a) Random sample

 1

 10
Applications (logscale)
(b) Popular applications

 100

Figure 8: CDF of computation time

function) of the analysis computation time for all 348 ap-
plications is presented in Figure 8(a). It is clear from the
ﬁgure that costs were dominated by a handful of appli-
cations; the top application consumed over 11% of the
time, the top 5 consumed over 25% of the total time, and
the top 29 consumed over 50% of the total time. These
applications are large with a high number of entry points.
Analyzing the 838 popular applications took 33.58
hours, that is, 144 seconds per application. The standard
deviation was 277 seconds. The average processing time
is signiﬁcantly higher than for the random sample. How-
ever, this is expected, as the average application size is
almost 1,500 classes, which is signiﬁcantly higher than
the random sample (less than 400 classes per applica-
tion). This is likely related to the popularity bias: one can
expect frequently downloaded applications to have fully
developed features as well as more complex/numerous
features, which implies a larger code base. A CDF of the
computation time for all 838 applications is presented in
Figure 8(b). Once again, analysis time is dominated by
a few applications. The top 5 consumed over 11% of the
analysis time and the top 83 (less than 10% of the sam-
ple) consumed over 50% of the analysis time.

Processing was dominated by the standard Soot pro-
cessing (e.g., translating classes to an intermediate repre-
sentation, performing type inference and points-to anal-
ysis, building a call graph). It consumed 75% of the pro-
cessing time in the random sample and 86% in the pop-
ular applications. It was itself dominated by the trans-
lation to Soot’s internal representation and by the call
graph construction. The second most time-consuming
task was the IDE analysis (which also includes the string
analysis in our implementation). It took 15% of the pro-

554  22nd USENIX Security Symposium 

USENIX Association

cessing time with the random sample and 7% with the
popular one. Finally, I/O operations accounted for most
of the remainder of the processing time. Loading classes
took 7% of the time in the random sample and 3% in the
popular one. Database operations accounted for 2% of
processing for the random sample and 3% for the popu-
lar applications. Other operations (e.g., parsing manifest
ﬁles) took less than 1% of processing time.

implicit Intents to address components within an appli-
cation, which is a potential security concern, since these
Intents may also be intercepted by other components.
Lastly, application entry points were relatively narrow
(with respect to intent types). Over 97% of the entry
points received one Intent type in the random sample.
Single Intent Filters were found in 94% of components
protected by Intent Filters in the popular applications.

6.3 Entry/Exit Point Analysis
This section brieﬂy characterizes the exit (source) and
entry (sink) points of Android applications in our data
sets. Note that this analysis is preliminary and will be
extended in future work.

An exit point is a location that serves as a source for
ICC; i.e., the sending of an Intent. In the random sample,
our analysis found 7,350 exit points which can transmit
10,035 unique Intent values. About 92% of these exit
points had a single Intent speciﬁcation, with the remain-
ing exit points being able to take on 2 or more values.
In two pathological cases, we noted an exit point that
could have 640 different Intent values (most likely the re-
sult of contrived control ﬂow or multiple aliasing for an
Intent value). The popular applications had 48,756 exit
points, associated with 316,419 Intent values. Single In-
tent speciﬁcations were found in 90% of exit points. We
found 10 pathological cases where an exit point was as-
sociated with 512 Intent values or more. The use of key
value data was more prevalent than we initially expected,
in about 36% of exit points in the random sample. Key-
value data was present in Intents in 46% of exit points in
the popular applications.

Our study of entry points focused on the sinks of
ICC that were either dynamically registered broadcast re-
ceivers or component interfaces (exported or not) identi-
ﬁed in the application manifest. In the random sample,
we were able to identify 3,863 such entry points associ-
ated with 1,222 unique intent ﬁlters. The popular appli-
cations comprised 25,291 entry points with 11,375 Intent
Filters. 1,174 components were exported (and thus avail-
able to other applications) in the random sample, 7,392
in the popular applications. Of those, only 6% (67) of
the exported components were protected by a permission
in the random sample and 5% (382) were protected in
the popular applications. This is concerning, since the
presence of unprotected components in privileged appli-
cations can lead to confused deputy [21] attacks [17].

Oddly, we also found 23 components that were ex-
ported without any Intent Filter in the random sample
and 220 in the popular sample. Conversely, we found 32
cases where a component had an Intent Filter but was not
exported in the random sample and 412 in the popular
one. The latter indicates that developers sometimes use

ICC Vulnerability Study

6.4
In this section, we perform a study of ICC vulnerabilities
in our samples using Epicc and compare our results with
ComDroid [6]. We look for the same seven vulnerabil-
ities as in [6]. Activity and Service hijacking can occur
when an Intent is sent to start an Activity or a Service
without a speciﬁc target. Broadcast thefts can happen
when an Intent is Broadcast without being protected by a
signature or signatureOrSystem permission7. In all three
cases, the Intent may be received by a malicious compo-
nent, along with its potentially sensitive data.

Malicious Activity or Service launch and Broadcast
injection are Intent spooﬁng vulnerabilities. They in-
dicate that a public component is not protected with a
signature or signatureOrSystem permission. It may be
started by malicious components. These vulnerabilities
can lead to permission leakage [17, 19, 25].

Finally, some Intent Broadcasts can only be sent by
the operating system, as indicated by their action ﬁeld.
Broadcast Receivers can register to receive them by spec-
ifying Intent Filters with the appropriate action. How-
ever, these public components can still be addressed di-
rectly by explicit Intents. That is why the target Re-
ceivers should check the action ﬁeld of the received In-
tent to make sure that it was sent by the system.

Table 2 shows the results of the study for the ran-
dom and the popular samples. The ﬁrst line shows the
number of vulnerabilities identically detected by both
analyses, the second line shows vulnerabilities detected
by ComDroid only and the third line shows vulner-
abilities detected by Epicc only. The last two lines
show the total number of vulnerabilities found by each
tool.
For the three unauthorized Intent receipt vul-
nerabilities (ﬁrst three columns), both ComDroid and
Epicc indicate whether the sent Intent has extra data
in the form of key-value pairs, and whether the In-
tent has the FLAG GRANT READ URI PERMISSION or the
FLAG GRANT WRITE URI PERMISSION. These ﬂags are
used in Intents which refer to Content Provider data and
may allow the recipient to read or write the data [6].

7The signature permission protection level only allows access to a
component from an application signed by the same developer. The
signatureOrSystem protection level additionally allows the operating
system to start the component.

USENIX Association  

22nd USENIX Security Symposium  555

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Constructor

b = new Bundle()

e.e[b 7! ?]

⇤

b

B.B

B.?

⇤

b

d

d

Adding int key-value pair

b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb

⇤

b

B.B

B.B

λB.βb

({MyInt},?,0,())(B)

d

d

B.B

1 public C o m p o n e n t N a m e

m a k e C o m p o n e n t N a m e () {

C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {

c = new C o m p o n e n t N a m e ( " c . d " ,

2
3
4

" a . b . MyClass " ) ;

} else {

" a . b . M y S e c o n d C l a s s " ) ; }

c = new C o m p o n e n t N a m e ( " c . d " ,

5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12

Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,

return c ; }

Copy constructor

b = new Bundle(d)

e.e[b 7! e(d)]

⇤

b

Clearing extra data keys

d.clear()

λe.ehd 7! βb

(?,?,1,())(e(d))i

⇤

b

d

⇤

B.B

B.B

B.B

B.B

B.B

⇤

b

d

⇤

b

b

λB.βb

(?,?,1,())(B)

d

d

Figure 6: Pointwise environment transformers for com-
mon Bundle operations

transformer t

the environment

require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.

The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.

We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges

environment
i.e.

transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).

ing studied.

of G∗,

assigns

to

this . m F i r s t N a m e ) ;

bundle . putAll ( b ) ;
bundle . remove ( " Surname " ) ;
return bundle ; }

Intent intent = new Intent () ;
intent . s e t C o m p o n t e n t ( m a k e C o m p o n e n t N a m e () ) ;
Bundle b = new Bundle () ;
b . p u t S t r i n g ( " Surname " , this . m S u r n a m e ) ;
intent . p u t E x t r a s ( m a k e B u n d l e ( b ) ) ;
r e g i s t e r M y R e c e i v e r () ;
s t a r t A c t i v i t y ( intent ) ; }

13
14
15
16
17 public void onClick ( View v ) {
18
19
20
21
22
23
24
25
26 public void r e g i s t e r M y R e c e i v e r () {
27
28
29
30
31

I n t e n t F i l t e r f = new I n t e n t F i l t e r () ;
f . a d d A c t i o n ( " a . b . ACTION " ) ;
f . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
r e g i s t e r R e c e i v e r ( new M y R e c e i v e r () ,

f , " a . b . P E R M I S S I O N " , null ) ; }
Figure 7: ICC objects example

Under certain conditions on the representation of
micro-functions, an IDE problem can be solved in time
O(ED3) [32]. For example, micro-functions should be
applied in constant time. In the model we present in Sec-
tion 5, we relax some of these constraints but ﬁnd that
the problem can still be solved efﬁciently in the average
case. When the problem is solved, we know the value as-
sociated with each symbol at important program points.

5 Reducing Intent ICC to an IDE problem

To solve the Intent ICC problem, we need to model
four different kinds of objects. First, ComponentName
objects contain a package name and a class name.
They can be used by explicit Intents. For example, in
method makeComponentName() of Figure 7, a Com-
ponentName object can take two different values de-
pending on which branch is executed.
In the ﬁrst
branch, it refers to class a.b.MyClass from applica-
tion package c.d. In the second one, it refers to class
a.b.MySecondClass. We want to know the possible
return values of makeComponentName().

Second, Bundle objects store data as key-value map-
pings. Method makeBundle() of Figure 7 creates a Bun-
dle and modiﬁes its value. We need to ﬁnd the possible
return values of makeBundle().

Third, Intent objects are the main ICC communica-

548  22nd USENIX Security Symposium 

USENIX Association

the target class of intent

tion objects. They contain all the data that is used to
In method onClick() of Fig-
start other components.
is set using the re-
ure 7,
turn value of makeComponentName().
Its extra data
is set to the return value of makeBundle(). Finally,
a new Activity is started using the newly created In-
tent. We need to determine the value of intent at the
startActivity(intent) instruction.

Fourth,

IntentFilter objects are used for dynamic
Broadcast Receivers.
In registerMyReceiver() on Fig-
ure 7, an action and a category are added to IntentFil-
ter f . Then a Broadcast Receiver of type MyReceiver
(which we assume to be deﬁned) is registered us-
ing method registerReceiver().
It receives Intents that
have action a.b.ACTION and category a.b.CATEGORY
and that originate from applications with permission
a.b.PERMISSION. We want to determine the arguments
to the registerReceiver() call. That is, we want to
know that f contains action a.b.ACTION and category
a.b.CATEGORY. We also want to know that the type of
the Broadcast Receiver is MyReceiver.

In this section, we use the notations from Sagiv et
al. [32] summarized in Section 4. We assume that string
method arguments are available. We describe the string
analysis used in our implementation in Section 6.

5.1 ComponentName Model
In this section, we introduce the model we use for Com-
ponentName objects. We introduce the notion of a
branch ComponentName value. It represents the value
that a ComponentName object can take on a single
branch, given a single possible string argument value for
each method setting the ComponentName’s package and
class names, and in the absence of aliasing.
Deﬁnition 1. A branch ComponentName value is a tuple
c = (p,k), where p is a package name and k is a class
name.

In method makeComponentName() of Figure 7, two

branch ComponentName values are constructed:

(c.d, a.b.MyClass)

(1)

and

(c.d, a.b.MySecondClass)

(2)
The next deﬁnition introduces ComponentName val-
ues, which represent the possibly multiple values that a
ComponentName can have at a program point. A Com-
ponentName can take several values in different cases:
• After traversing different branches, as in method
• When a string argument can have several values at a
• When an object reference is a possible alias of an-

makeComponentName() of Figure 7.

other local reference or an object ﬁeld.

method call.

• When an object reference is a possible array element.
In the last two cases, in order to account for the possi-
bility of a false positive in the alias analysis, we keep
track of two branch ComponentName values. One con-
siders the inﬂuence of the call on the possible alias and
the other one does not.
Deﬁnition 2. A ComponentName value C is a set of
branch ComponentName values: C = {c1,c2,··· ,cm}.
The set of ComponentName values is denoted as Vc. We
deﬁne ⊥ = ∅ and (cid:26) as the ComponentName value that
is the set of all possible branch ComponentName val-
ues in the program. The operators ∪ and ⊆ are deﬁned
as traditional set union and comparison operators: for
C1,C2 ∈ Vc, C1 ⊆ C2 iff C1 ∪C2 = C2. Lc = (Vc,∪) is a
join semilattice.

Note that given the deﬁnitions of ⊥ and (cid:26) as speciﬁc
sets, ∪ and ⊆ naturally apply to them. For example, for
all C ∈ Vc, (cid:26)∪C = (cid:26).
In method makeComponentName() from Figure 7, the
value of c at the return statement is

{(c.d, a.b.MyClass) ,

(3)
It simply combines the values of c created in the two
branches, given by Equations (1) and (2).

(c.d, a.b.MySecondClass)} .

We deﬁne transformers from Vc to Vc that represent
the inﬂuence of a statement or a sequence of statements
on a ComponentName value. A pointwise branch Com-
ponentName transformer represents the inﬂuence of a
single branch, whereas a pointwise ComponentName
transformer represents the inﬂuence of possibly multiple
branches.
Deﬁnition 3. A pointwise branch ComponentName
transformer is a function δ c
(π,χ) : Vc → Vc, where π is a
package name and χ is a class name. It is such that, for
each C ∈ Vc,

δ c
(π,χ)(C) ={(π , χ)}

(4)

Note that δ c

(π,χ)(C) is independent of C, because API
methods for ComponentName objects systematically re-
place existing values for package and class names. In the
example from Figure 7, the pointwise branch Compo-
nentName transformer corresponding to the ﬁrst branch
is

δ c
(c.d,a.b.MyClass),
and the one for the second branch is

δ c
(c.d,a.b.MySecondClass).

(5)
Deﬁnition 4. A pointwise ComponentName transformer
is a function δ c
: Vc → Vc such that, for
each C ∈ Vc,

δ c
{(π1,χ1),··· ,(πn,χn)}(C) ={(π 1, χ1),··· , (πn, χn)}

{(π1,χ1),··· ,(πn,χn)}

A pointwise ComponentName transformer summa-

USENIX Association  

22nd USENIX Security Symposium  549

rizes the effect of multiple branches (or a single branch
with multiple possible string arguments, or with possi-
ble aliasing) on a ComponentName value. That is, given
the value C of a ComponentName right after statement
si and given transformer δ c
that sum-
marizes the inﬂuence of statements si+1,··· ,sk on C,
δ c
(C) represents all the possible values
{(π1,χ1),··· ,(πn,χn)}
of C right after sk. In method makeComponentName()
of Figure 7, the pointwise ComponentName transformer
that models the two branches is

{(π1,χ1),··· ,(πn,χn)}

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}.

(6)
It combines the transformers given by Equations (4)
and (5). In order to understand how this transformer is
applied in practice, we should mention that the algorithm
to solve IDE problems initially sets values to ⊥ [32].
Therefore, in method makeComponentName(), the value
associated with c is initially ⊥ = ∅. Using Deﬁnition 4,
we can easily see that if we apply the transformer given
by Equation (6), we get the value given by Equation (3).
This conﬁrms that the transformer models the inﬂuence
of the two branches:

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}(⊥)

= {(c.d, a.b.MyClass) ,

(c.d, a.b.MySecondClass)}

5.2 Bundle Model

The model of Bundle objects is deﬁned similarly to the
model of ComponentName objects. An additional difﬁ-
culty is introduced. The data in a Bundle can be modiﬁed
by adding the data in another Bundle to it, as shown in
method makeBundle() of Figure 7. In this example, the
data in Bundle b is added to the data in Bundle bundle.
Bundle bundle is later modiﬁed by removing the key-
value pair with key Surname. The issue is that when
the data ﬂow problem is being tackled, the value of b
is not known. Therefore, the inﬂuence of the call to
remove("Surname") is not known: if a key-value pair
with key Surname is part of b, then the call removes it
from bundle. Otherwise, it has no inﬂuence.

Our approach to deal with this object composition
problem is to perform two successive analyses. In Anal-
ysis I, we use placeholders for Bundles such as b in in-
struction bundle.putAll(b). We also record all subse-
quent method calls affecting bundle. After the problem
is solved, b’s key-value pairs at the putAll(b) method
call are known, as well as the subsequent method calls.
We then perform Analysis II, in which b’s key-value
pairs are added to bundle’s. The inﬂuence of the sub-
sequent method call is precisely evaluated and ﬁnally the
value of bundle at the return statement can be known.

b to V i

b, where V i

5.2.1 Analysis I
In the ﬁrst analysis, we consider intermediate values that
contain “placeholders” for Bundle values that are not
known when the problem is being solved.
Deﬁnition 5. An intermediate branch Bundle value is a
tuple bi = (E,O), where:
• E is a set of keys describing extra data.
• O is a tuple of two types of elements. O contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. O also contains functions
from V i
b is the set of intermediate Bun-
dle values deﬁned below. These functions represent a
sequence of method calls affecting a Bundle.
The difference with previous deﬁnitions is the intro-
duction of O, which models calls to putAll() as well as
subsequent calls affecting the same Bundle. In method
makeBundle() of Figure 7, at the return statement, the in-
termediate branch Bundle value associated with bundle
is (E,O), where
E ={FirstName}
O =((b, bundle.putAll(b)),β b

(7)
(8)
In O, (b, bundle.putAll(b)) is a reference to variable
b at instruction bundle.putAll(b). β b
(∅,Surname,0,())
models the remove() method call. It is deﬁned below.

(∅,{Surname},0,()))

b = (V i

b, Bi1 ⊆ Bi2 iff Bi1 ∪ Bi2 = Bi2. Li

We just deﬁned intermediate branch Bundle values.
As we did before, we need to consider multiple branches
and related issues (e.g., several possible string values):
Deﬁnition 6. An intermediate Bundle value Bi is a set of
intermediate branch Bundle values: Bi = {bi1,··· ,bim}.
The set of intermediate Bundle values is V i
b. We deﬁne
⊥ = ∅ and (cid:26) as the intermediate Bundle value that is
the set of all possible intermediate branch Bundle val-
ues in the program. We deﬁne ⊆ and ∪ as natural set
comparison and union operators. They are such that, for
Bi1,Bi2 ∈ V i
b,∪) is
a join semilattice.
In method makeBundle() from Figure 7, since there is
only a single branch, the intermediate Bundle value as-
sociated with bundle at the return statement is {(E,O)},
where E and O are given by Equations (7) and (8).
b to V i
b.
Similarly to the ComponentName model, we ﬁrst in-
troduce pointwise branch Bundle transformers before
deﬁning pointwise Bundle transformers.
In the def-
initions below, we use the \ notation for set differ-
ence, and ∪ is naturally extended to tuples such that
(a1,··· ,ak)∪ (ak+1,··· ,al) = (a1,··· ,ak,ak+1,··· ,al).
Deﬁnition 7. A pointwise branch Bundle transformer is
a function β b
• η + is a set of string keys describing extra data. It

Pointwise transformers are deﬁned from V i

(η +,η−,cl,Θ) : V i

models calls to putExtra() methods.

b → V i

b, where:

550  22nd USENIX Security Symposium 

USENIX Association

• η− is a set of string keys describing removed ex-
It represents the inﬂuence of calls to the

tra data.
removeExtra() method.

with the clear() method and 0 otherwise.

• cl takes value 1 if the Bundle data has been cleared
• Θ is a tuple of two types of elements. It contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. It also contains functions
from V i
b. These functions represent a sequence
of method calls affecting a Bundle.

b to V i

It is such that
β b
(η +,η−,cl,Θ)(⊥) =(cid:31)(cid:30)η +\η−,Θ(cid:29)(cid:28)
and, for Bi = {(E1,O1),··· , (Em,Om)} (Bi (cid:24)= ⊥),
β b
(η +,η−,cl,Θ)(Bi) ={(E (cid:23)1,O(cid:23)1),··· , (E(cid:23)m,O(cid:23)m)}
where, for each j from 1 to m:
E(cid:23)j =

O(cid:23)j =


η +\η−
(E j ∪ η +)\η−
E j
Θ
O j ∪(cid:23)β b

if cl = 1
if cl = 0 and O j = ∅
otherwise

(η +,η−,0,Θ)(cid:22)

if cl = 1 or O j = ∅
otherwise

The deﬁnition of E(cid:23)j accounts for several possible

cases:
• If the Bundle data has been cleared (i.e., cl = 1), then
we discard any data contained in E j. This leads to
value η +\η− for E(cid:23)j: we only keep the values η +
that were added to the Bundle data and remove the
values η− that were removed from it.

• If the Bundle has not been cleared, then there are two
possible cases: either no reference to another Bun-
dle has been previously recorded (i.e., O j = ∅), or
such a reference has been recorded to model a call to
putAll(). In the ﬁrst case, we simply take the union
of the original set E j and the set η + of added values,
and subtract the set η− of removed values. This ex-
plain the (E j ∪ η +)\η− value. In the second case, a
call to putAll() has been detected, which means that
any further method call adding or removing data has
to be added to set O j instead of E j. Therefore in this
case E(cid:23)j = E j.
The deﬁnition of O(cid:23)j considers several cases:
• If the Bundle data has been cleared, then the previous
value of O j is irrelevant and we set O(cid:23)j = Θ. Also, if
O j is empty, then we can also just set O(cid:23)j to Θ (which
may or may not be empty).

• Otherwise,

the Bundle data has not been cleared
(cl = 0) and a call to putAll() has been detected
(O j (cid:24)= ∅). Then it means that the current function
models method calls that happened after a call to
putAll(). Therefore we need to record β b
(η +,η−,0,Θ)
in O(cid:23)j, which explains the deﬁnition O(cid:23)j = O j ∪
(β b
(η +,η−,0,Θ)).

For example, the pointwise branch Bundle transformer
that models the inﬂuence of the method makeBundle()
from Figure 7 is β b

(η +,∅,0,Θ), where

η + ={FirstName}
Θ =(cid:23)(b, bundle.putAll(b)),

(9)

(10)

(∅,{Surname},0,())(cid:22)
β b

Pointwise branch Bundle transformers model the in-
ﬂuence of a single branch. In order to account for mul-
tiple branches or issues such as possible aliasing false
positive, we deﬁne pointwise Bundle transformers.
Deﬁnition 8. A pointwise Bundle transformer is a func-
tion

: V i
b → V i

b

β b
{(η +

1 +,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

such that, for each Bi ∈ V i
b,
β b
{(η +

1 ,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

(Bi) =
1 ,η−1 ,cl1,Θ1)(Bi)∪···∪β b

β b
(η +

n ,η−n ,cln,Θn)(Bi)
(η +

For example, method makeBundle() from Figure 7
only has a single branch, thus the pointwise Bundle trans-
former that models it is simply β b
, where η +
and Θ are given in Equations (9) and (10). As we did for
the ComponentName value example, we can conﬁrm us-
ing Deﬁnitions 7 and 8 that β b
(⊥) ={(E ,O)},
where E and O are given by Equations (7) and (8).

{(η +,∅,0,Θ)}

{(η +,∅,0,Θ)}

5.2.2 Analysis II

After Analysis I has been performed, the values of the
Bundles used in placeholders in intermediate Bundle val-
ues are known. Ultimately, we want to obtain branch
Bundle values and ﬁnally Bundle values:
Deﬁnition 9. A branch Bundle value b is a set E of string
keys describing extra data.
Deﬁnition 10. A Bundle value B is a set of branch Bun-
dle values: B = {b1,··· ,bm}.

Since the values of the referenced Bundles are known,
we can integrate them into the Bundle values referring to
them. Then the inﬂuence of the subsequent method calls
that have been recorded can precisely be known.

Let us consider the example of makeBundle() from
Figure 7. After Analysis I has been performed, we know
that the intermediate value of bundle at the return state-
ment is {(E,O)}, where

E ={FirstName}
O =(cid:23)(b, bundle.putAll(b)),β b
We consider all elements of O in order. As the
ﬁrst element of O is (b, bundle.putAll(b)), we inte-
grate b’s value into bundle. From Analysis I, we know

(∅,{Surname},0,())(cid:22)

USENIX Association  

22nd USENIX Security Symposium  551

that the value of b at instruction bundle.putAll(b)
is {{Surname} ,∅}. Thus, E becomes {FirstName,
Surname}. The next element of O is β b
(∅,{Surname},0,()).
This means that we have to remove key Surname from E.
The ﬁnal value of E is therefore {FirstName}. Thus, the
Bundle value associated with bundle at the return state-
ment is {{FirstName}}.
Note that the referenced Bundle can also make refer-
ences to other Bundles. In that case, we perform the res-
olution for the referenced Bundles ﬁrst. There can be an
arbitrary number of levels of indirection. Analysis II is
iterated until a ﬁx-point is reached.

Intent and IntentFilter Models

5.3
The Intent model is deﬁned similarly to the Bundle
model, which includes object composition.
In method
onClick() of Figure 7, the target of Intent intent is set
using a ComponentName object and its extra data is set
with a Bundle. Because of this object composition, ﬁnd-
ing the Intent value also involves two analyses similar to
the ones performed for Bundles. First, intermediate In-
tent values with placeholders for referenced Component-
Name and Bundle objects are found. Second, the refer-
enced objects’ values are integrated into intent’s value.

i = (V i

Similarly to the Bundle model, we deﬁne intermedi-
ate branch Intent values and intermediate Intent values.
The set of intermediate Intent values is V i
i and we de-
ﬁne a lattice Li
i ,∪) as we did for Li
b. We also de-
ﬁne pointwise branch Intent transformers and pointwise
Intent transformers. For example, in method onClick()
of Figure 7, the ﬁnal intermediate value for intent sim-
ply has placeholders for a ComponentName and a Bun-
dle value. Other ﬁelds, such as action and categories,
are empty. The ComponentName and Bundle values are
computed using the models presented in Sections 5.1
and 5.2. Finally, we deﬁne branch Intent values and
Intent values, which are output by the second analysis.
The ﬁnal value for intent after the second analysis pre-
cisely contains the two possible targets (a.b.MyClass
and a.b.MySecondClass in package c.d) and extra
data key FirstName. For conciseness, and given the
strong similarities with the Bundle model, we do not in-
clude a full description of the Intent model here.

In order to analyze dynamic Broadcast Receivers, we
model IntentFilter objects. Modeling IntentFilters is sim-
ilar to modeling Intents, except that IntentFilters do not
involve object composition. That is because IntentFilters
do not have methods taking other IntentFilters as argu-
ment, except for a copy constructor. Thus, their analysis
is simpler and involves a single step. Similarly to what
we did for other ICC models, we deﬁne branch Intent-
Filter values, IntentFilter values, pointwise branch In-
tentFilter transformers and pointwise IntentFilter trans-

formers.
In particular, we deﬁne lattice L f = (Vf ,∪),
In method
is the set of IntentFilter values.
where Vf
onClick() from Figure 7, the ﬁnal value of f contains ac-
tion a.b.ACTION and category a.b.CATEGORY. Given
the similarity of the IntentFilter model with previous
models, we do not include a complete description.

5.4 Casting as an IDE Problem
These deﬁnitions allow us to deﬁne environment trans-
formers for our problem. Given environment e ∈
Env(D,L), environment transformer λ e.e is the identity,
which does not change the value of e. Given Intent i and
Intent value I, λ e.e[i (cid:27)→ I] transforms e to an environment
where all values are the same as in e, except that Intent i
is associated with value I.

We deﬁne an environment transformer for each API
method call. Each of these environment transformers
uses the pointwise environment transformers deﬁned in
Sections 5.1, 5.2 and 5.3. It precisely describes the inﬂu-
ence of a method call on the value associated with each
of the symbols in D.

Figure 6 shows some environment transformers and
their pointwise representation. The ﬁrst one is a con-
structor invocation, which sets the value corresponding
to b to ⊥. The second one adds an integer to the key-
value pairs in Bundle b’s extra data, which is represented
by environment transformer

({MyInt},∅,0,()) (e(b))(cid:30) .

λ e.e(cid:31)b (cid:27)→ β b
It means that
the environment stays the same, ex-
cept
the value associated with b becomes
β b
({MyInt},∅,0,()) (e(b)), with e(b) being the value previ-
ously associated with b in environment e. The pointwise
transformer for b is

that

on Figure 6 for consistency with the other pointwise
transformers.
It simply adds key MyInt to the set of
data keys. The next transformer is for a copy construc-
tor, where the value associated with d is assigned to the
value associated with b. The last transformer clears the
data keys associated with d.

Trivially, these environment transformers are distribu-

tive. Therefore, the following proposition holds.
Proposition 1. Let G∗ be the supergraph of an An-
droid application. Let Dc, Db Di and D f be the sets
of ComponentName, Bundle and Intent variables, re-
to which we add the special symbol Λ5.
spectively,
Let Lc, Li
b, Li
i and L f be the lattices deﬁned above.

5Recall from Section 4.2 that Λ symbolizes the absence of a data

ﬂow fact.

which we denote by

β b
({MyInt},∅,0,()),
({MyInt},∅,0,())(B)

λ B.β b

552  22nd USENIX Security Symposium 

USENIX Association

Let Mc, Mb, Mi and Mf be the corresponding assign-
ments of distributive environment transformers. Then
(G∗,Dc,Lc,Mc), (G∗,Db,Li
i ) and
(G∗,Di,L f ,Mf ) are IDE problems.

b), (G∗,Db,Li

b,Mi

i,Mi

It follows from this proposition that we can use the

algorithm from [32] to solve the Intent ICC problem.

The original IDE framework [32] requires that the
micro-function be represented efﬁciently in order to
achieve the time complexity of O(ED3). Our model does
not meet these requirements:
in particular, applying,
composing, joining micro-function or testing for equality
of micro-functions cannot be done in constant time. In-
deed, the size of micro-functions grows with the number
of branches, aliases and possible string arguments (see
Equation 6 for an example with two branches). However,
in practice we can ﬁnd solutions to our IDE problem in-
stances in reasonable time, as we show in Section 6.

6 Evaluation

This section describes an evaluation of the approach pre-
sented in the preceding sections, and brieﬂy character-
izes the use of ICC in Android applications. We also
present a study of potential ICC vulnerabilities. Our
implementation is called Epicc (Efﬁcient and Precise
ICC) and is available at http://siis.cse.psu.edu/
epicc/.
It is built on Heros [3], an IDE framework
within Soot [34]. We also provide the version of Soot
that we modiﬁed to handle pathological cases encoun-
tered with retargeted code.

In order to compute string arguments, we use a simple
analysis traversing the interprocedural control ﬂow graph
of the application. The traversal starts at the call site and
looks for constant assignments to the call arguments. If a
string argument cannot be determined, we conservatively
assume that the argument can be any string. As we show
in Section 6.1, in many cases we are able to ﬁnd precise
string arguments. More complex analyses can be used if
more precision is desired [7].

For points-to analysis and call graph construction, we
use Spark [24], which is part of Soot. It performs a ﬂow-
sensitive, context-insensitive analysis. We approximate
the call graph in components with multiple entry points.
In order to generate a call graph of an Android appli-
cation, we currently use a “wrapper” as an entry point.
This wrapper calls each class entry point once, which
may under-approximate what happens at runtime. This
impacts a speciﬁcation only if an ICC ﬁeld (e.g., Intent)
is modiﬁed in a way that depends on the runtime execu-
tion order of class entry points. Generally, if we assume
that our model of components’ life cycle is complete and
if the application does not use native calls or reﬂection,
then our results are sound.

The analysis presented in this section is performed on
two datasets. The ﬁrst random sample dataset contains
350 applications, 348 of which were successfully ana-
lyzed after retargeting. They were extracted from the
Google Play store6 between September 2012 and Jan-
uary 2013. The applications were selected at random
from over 200,000 applications in our corpus. The sec-
ond popular application dataset contains the top 25 most
popular free applications from each of the 34 applica-
tion categories in the Play store. The 850 selected appli-
cations were downloaded from that application store on
January 30, 2013. Of those 850 applications, 838 could
be retargeted and processed and were used in the exper-
iments below. The 14 applications which were not ana-
lyzed were pathological cases where retargeting yielded
code which could not be analyzed (e.g., in some cases
the Dare tool generated offsets with integer overﬂow er-
rors due to excessive method sizes), or where applica-
tions could not be processed by Soot (e.g., character en-
coding problems).

6.1 Precision of ICC Speciﬁcations
The ﬁrst set of tests evaluates the technique’s precision
with our datasets. We deﬁne the precision metric to be
the percentage of source and sink locations for which a
speciﬁcation is identiﬁed without ambiguity. Ambiguity
occurs when an ICC API method argument cannot be de-
termined. These arguments are mainly strings of charac-
ters, which may be generated at runtime. In some cases,
runtime context determines string values, which implies
that our analysis cannot statically ﬁnd them.

Recall the various forms of ICC. Explicit ICC iden-
tiﬁes the communication sink by specifying the target’s
package and class name. Conversely, implicit ICC iden-
tiﬁes the sink through action, category, and/or data ﬁelds.
Further, a mixed ICC occurs when a source or sink can
take on explicit or implicit ICC values depending on the
runtime context. Finally, the dynamic receiver ICC oc-
curs when a sink binds to an ICC type through runtime
context (e.g., Broadcast Receivers which identify the In-
tent Filter types when being registered). We seek to de-
termine precise ICC speciﬁcations, where all ﬁelds of In-
tents or Intent Filters are known without ambiguity.

As shown in Table 1, with respect to the random sam-
ple corpus, we were able to provide unambiguous speci-
ﬁcations for over 91% of the 7,835 ICC locations in the
348 applications. Explicit ICC was precisely analyzed
more frequently (≈98%) than implicit ICC (≈88%). The
remaining 7% of ICC containing mixed and dynamic re-
ceivers proved to be more difﬁcult, where the precision
rates are much lower than others. This is likely due to
the fact that dynamic receivers involve ﬁnding more data

6Available at https://play.google.com/store/apps.

USENIX Association  

22nd USENIX Security Symposium  553

Explicit
Implicit
Mixed
Dyn. Rec.
Total

Explicit
Implicit
Mixed
Dyn. Rec.
Total

Random Sample

Precise

3,571 97.65%
3,225 88.45%
28 59.57%
357 73.61%
7,181 91.65%

% Total
% Imprecise
86
2.35% 3,657
421 11.55% 3,646
19 40.43%
47
128 26.39% 485
8.35% 7,835
654

Popular
% Imprecise
1,637
1,525

Precise
27,753 94.43%
23,133 93.82%
509 85.12%
4,161 95.81%
55,556 94.18%
Table 1: Precision metrics

89 14.88%
182
3,433

% Total
5.57% 29,390
6.18% 24,658
598
4.19% 4,343
5.82% 58,989

than Intents: Intent Filters limiting access to dynamic re-
ceivers can deﬁne several actions, and receivers can be
protected by a permission (which we attempt to recover).
In the popular applications, we obtain a precise spec-
iﬁcation in over 94% of the 58,989 ICC locations in the
838 apps. Explicit ICC was slightly more precisely an-
alyzed than implicit ICC. Mixed ICC is again hard to
recover. This is not surprising, as mixed ICC involves
different Intent values on two or more branches, which is
indicative of a method more complex than most others.
A facet of the analysis not shown in the table is the
number of applications for which we could identify un-
ambiguous speciﬁcations for all ICC – called 100% pre-
cision. In the random sample, 56% of the applications
could be analyzed with 100% precision, 80% of the ap-
plications with 90% precision, and 91% of the applica-
tions with 80% precision.
In the popular applications,
23% could be analyzed with 100% precision, 82% could
be analyzed with 90% precision and 94% with 80% pre-
cision. Note that a less-than-100% precision does not
mean that the analysis failed. Rather, these are cases
where runtime context determines string arguments, and
thus any static analysis technique would fail.

6.2 Computation Costs
A second set of tests sought to ascertain the computa-
tional costs of performing the IDE analysis using Epicc.
For this task we collected measurements at each stage of
the analysis and computed simple statistics characteriz-
ing the costs of each task on the random sample and the
popular applications.

Experiment results show that ICC analysis in this
model is feasible for applications in the Google Play
store. We were able to perform analysis of all 348 ap-
plications in the random sample in about 3.69 hours of
compute time. On average, it took just over 38 seconds
to perform analysis for a single application, with a stan-
dard deviation of 99 seconds. There was high variance in
the analysis run times. A CDF (cumulative distribution

i

)
e
m
T
 
n
o
i
t
a
t
u
p
m
o
C

(
 
F
D
C

i

)
e
m
T
 
n
o
i
t
a
t
u
p
m
o
C

(
 
F
D
C

 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0

 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0

 1

 10

 100

Applications (logscale)
(a) Random sample

 1

 10
Applications (logscale)
(b) Popular applications

 100

Figure 8: CDF of computation time

function) of the analysis computation time for all 348 ap-
plications is presented in Figure 8(a). It is clear from the
ﬁgure that costs were dominated by a handful of appli-
cations; the top application consumed over 11% of the
time, the top 5 consumed over 25% of the total time, and
the top 29 consumed over 50% of the total time. These
applications are large with a high number of entry points.
Analyzing the 838 popular applications took 33.58
hours, that is, 144 seconds per application. The standard
deviation was 277 seconds. The average processing time
is signiﬁcantly higher than for the random sample. How-
ever, this is expected, as the average application size is
almost 1,500 classes, which is signiﬁcantly higher than
the random sample (less than 400 classes per applica-
tion). This is likely related to the popularity bias: one can
expect frequently downloaded applications to have fully
developed features as well as more complex/numerous
features, which implies a larger code base. A CDF of the
computation time for all 838 applications is presented in
Figure 8(b). Once again, analysis time is dominated by
a few applications. The top 5 consumed over 11% of the
analysis time and the top 83 (less than 10% of the sam-
ple) consumed over 50% of the analysis time.

Processing was dominated by the standard Soot pro-
cessing (e.g., translating classes to an intermediate repre-
sentation, performing type inference and points-to anal-
ysis, building a call graph). It consumed 75% of the pro-
cessing time in the random sample and 86% in the pop-
ular applications. It was itself dominated by the trans-
lation to Soot’s internal representation and by the call
graph construction. The second most time-consuming
task was the IDE analysis (which also includes the string
analysis in our implementation). It took 15% of the pro-

554  22nd USENIX Security Symposium 

USENIX Association

cessing time with the random sample and 7% with the
popular one. Finally, I/O operations accounted for most
of the remainder of the processing time. Loading classes
took 7% of the time in the random sample and 3% in the
popular one. Database operations accounted for 2% of
processing for the random sample and 3% for the popu-
lar applications. Other operations (e.g., parsing manifest
ﬁles) took less than 1% of processing time.

implicit Intents to address components within an appli-
cation, which is a potential security concern, since these
Intents may also be intercepted by other components.
Lastly, application entry points were relatively narrow
(with respect to intent types). Over 97% of the entry
points received one Intent type in the random sample.
Single Intent Filters were found in 94% of components
protected by Intent Filters in the popular applications.

6.3 Entry/Exit Point Analysis
This section brieﬂy characterizes the exit (source) and
entry (sink) points of Android applications in our data
sets. Note that this analysis is preliminary and will be
extended in future work.

An exit point is a location that serves as a source for
ICC; i.e., the sending of an Intent. In the random sample,
our analysis found 7,350 exit points which can transmit
10,035 unique Intent values. About 92% of these exit
points had a single Intent speciﬁcation, with the remain-
ing exit points being able to take on 2 or more values.
In two pathological cases, we noted an exit point that
could have 640 different Intent values (most likely the re-
sult of contrived control ﬂow or multiple aliasing for an
Intent value). The popular applications had 48,756 exit
points, associated with 316,419 Intent values. Single In-
tent speciﬁcations were found in 90% of exit points. We
found 10 pathological cases where an exit point was as-
sociated with 512 Intent values or more. The use of key
value data was more prevalent than we initially expected,
in about 36% of exit points in the random sample. Key-
value data was present in Intents in 46% of exit points in
the popular applications.

Our study of entry points focused on the sinks of
ICC that were either dynamically registered broadcast re-
ceivers or component interfaces (exported or not) identi-
ﬁed in the application manifest. In the random sample,
we were able to identify 3,863 such entry points associ-
ated with 1,222 unique intent ﬁlters. The popular appli-
cations comprised 25,291 entry points with 11,375 Intent
Filters. 1,174 components were exported (and thus avail-
able to other applications) in the random sample, 7,392
in the popular applications. Of those, only 6% (67) of
the exported components were protected by a permission
in the random sample and 5% (382) were protected in
the popular applications. This is concerning, since the
presence of unprotected components in privileged appli-
cations can lead to confused deputy [21] attacks [17].

Oddly, we also found 23 components that were ex-
ported without any Intent Filter in the random sample
and 220 in the popular sample. Conversely, we found 32
cases where a component had an Intent Filter but was not
exported in the random sample and 412 in the popular
one. The latter indicates that developers sometimes use

ICC Vulnerability Study

6.4
In this section, we perform a study of ICC vulnerabilities
in our samples using Epicc and compare our results with
ComDroid [6]. We look for the same seven vulnerabil-
ities as in [6]. Activity and Service hijacking can occur
when an Intent is sent to start an Activity or a Service
without a speciﬁc target. Broadcast thefts can happen
when an Intent is Broadcast without being protected by a
signature or signatureOrSystem permission7. In all three
cases, the Intent may be received by a malicious compo-
nent, along with its potentially sensitive data.

Malicious Activity or Service launch and Broadcast
injection are Intent spooﬁng vulnerabilities. They in-
dicate that a public component is not protected with a
signature or signatureOrSystem permission. It may be
started by malicious components. These vulnerabilities
can lead to permission leakage [17, 19, 25].

Finally, some Intent Broadcasts can only be sent by
the operating system, as indicated by their action ﬁeld.
Broadcast Receivers can register to receive them by spec-
ifying Intent Filters with the appropriate action. How-
ever, these public components can still be addressed di-
rectly by explicit Intents. That is why the target Re-
ceivers should check the action ﬁeld of the received In-
tent to make sure that it was sent by the system.

Table 2 shows the results of the study for the ran-
dom and the popular samples. The ﬁrst line shows the
number of vulnerabilities identically detected by both
analyses, the second line shows vulnerabilities detected
by ComDroid only and the third line shows vulner-
abilities detected by Epicc only. The last two lines
show the total number of vulnerabilities found by each
tool.
For the three unauthorized Intent receipt vul-
nerabilities (ﬁrst three columns), both ComDroid and
Epicc indicate whether the sent Intent has extra data
in the form of key-value pairs, and whether the In-
tent has the FLAG GRANT READ URI PERMISSION or the
FLAG GRANT WRITE URI PERMISSION. These ﬂags are
used in Intents which refer to Content Provider data and
may allow the recipient to read or write the data [6].

7The signature permission protection level only allows access to a
component from an application signed by the same developer. The
signatureOrSystem protection level additionally allows the operating
system to start the component.

USENIX Association  

22nd USENIX Security Symposium  555

Vulnerability

Activity
Hijacking

Sample
Identical

Broadcast

Theft
R

P

Service
Hijacking
R
P
P
78 1,200 503 4,825 179 1,731 23 263 273 3,503
18 104 1,684
78
3
1
43
Total ComDroid 3,507 22,931 156 1,735 721 7,679 191 1,900 25 281 377 5,187

R
30
3
77
33
81 1,351 526 5,122 183 1,751 23 264 277 3,546 107

Injection w/o action check vulnerabilities
P
R
126 3,677 26,862
20 1,333 12,997
580
3,171
146 5,010 39,859
706 3,969 30,033

Service Broadcast System Broadcast
Launch
P

Total Epicc
Table 2: ICC vulnerability study results for the random sample (R) and the popular applications (P)

2,772 17,293

535 218 2,854
151
297

23

R

P
2,591 15,214
7,717
2,079

916
181

Activity
Launch
R

ComDroid only

Epicc only

12
4

169
20

2
0

4

P R

Total

P

R

292

For the presence of ﬂags and the detection of extra
data, Epicc can precisely indicate when the value of an
Intent depends on the execution path. On the other hand,
a ComDroid speciﬁcation does not make this distinction.
When Epicc and ComDroid differ for a code location, we
include ﬂags in both the “ComDroid only” and “Epicc
only” rows of Table 2.

The Activity hijacking vulnerabilities found by both
ComDroid and Epicc are unsurprisingly common: they
represent all cases where implicit Intents are used to
start Activities. Service hijacking vulnerabilities are
much less prevalent, which is correlated with the fact
that Services are used less often than Activities. Broad-
cast theft vulnerabilities are quite common as well. As
previously described in Section 6.3, few exported com-
ponents are protected by permissions. Therefore, the
high number of malicious Activity or Service launch
as well as Broadcast injection vulnerabilities is not sur-
prising. Note the discrepancy between the number
of components without permissions and the total num-
ber of these vulnerabilities. A large portion of the
components not protected by permissions are Activities
with the android.intent.action.MAIN action and
the android.intent.category.LAUNCHER category,
which indicate that these components cannot be started
without direct user intervention. They are therefore not
counted as potential vulnerabilities.

If we consider the ﬁrst three vulnerabilities (unautho-
rized Intent receipt), we can see that ComDroid ﬂags a
high number of locations where Epicc differs. A manual
examination of a random subset of applications shows
that these differences are either false positives detected
by ComDroid or cases where Epicc gives a more precise
vulnerability speciﬁcation. We observed that a number of
code locations are detected as vulnerable by ComDroid,
whereas Soot does not ﬁnd them to be reachable. Epicc
takes advantage from the sound and precise Soot call
graph construction to output fewer false positives. Ad-
ditionally, the IDE model used by Epicc can accurately
keep track of differences between branches (e.g., explic-
it/implicit Intent or URI ﬂags), whereas ComDroid can-
not. Note that when an Intent is implicit on one branch
and explicit on another, ComDroid detects it as explicit,
which is a false negative. On the other hand, the IDE
model correctly keeps track of the possibilities.

With a few exceptions, the ComDroid and Epicc anal-
yses detect the same possible malicious Activity and Ser-
vice launches. That is expected, since both are detected
by simply parsing the manifest ﬁle. The few differences
can be explained by minor implementation differences
or bugs in pathological cases. The Broadcast injection
vulnerability shows stronger differences, with ComDroid
detecting 377 cases for the random sample and 5,187
for the popular one, whereas Epicc only ﬁnds 277 and
3,546, respectively. Some of the Broadcast injections
detected by ComDroid involved dynamically registered
Broadcast Receivers found in unreachable code. Once
again, the call graph used by Epicc proves to be an ad-
vantage. Many other cases involve Receivers listening
to protected system Broadcasts (i.e., they are protected
by Intent Filters that only receive Intents sent by the sys-
tem). The list of protected Broadcasts used by ComDroid
is outdated, hence the false positives.

Finally, there is a signiﬁcant difference in the de-
tection of the system Broadcasts without action check,
with Epicc detecting 107 vulnerabilities in the random
sample and 706 in the popular one, whereas ComDroid
only detects 33 and 146, respectively. The ﬁrst rea-
son for that difference is that the ComDroid list of pro-
tected Broadcasts is outdated. Another reason is an
edge case, where the Soot type inference determines Re-
ceivers registered using a registerReceiver() method as
having type android.content.BroadcastReceiver
(i.e., the abstract superclass of all Receivers). It occurs
when several types of Receivers can reach the call to
registerReceiver(). Since no Receiver code can be in-
spected, even though there may be a vulnerability, our
analysis conservatively ﬂags it as a vulnerability.

Overall, Epicc detects 34,002 potential vulnerabilities.
On the other hand, ComDroid detects 44,869 potential
security issues, that is, 32% more than Epicc. As de-
tailed above, the extra ﬂags found by ComDroid that
we checked were all false positives. Further, the poten-
tial causes of unsoundness in Epicc (i.e., JNI, reﬂection
and entry point handling) are also handled unsoundly in
ComDroid. Thus, we do not expect the locations ﬂagged
by ComDroid but not by Epicc to be false negatives. The
precision gain over ComDroid is signiﬁcant and will help
further analyses. Note that it is possible that both tools
have false negatives in the presence of JNI, reﬂection,

556  22nd USENIX Security Symposium 

USENIX Association

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Constructor

b = new Bundle()

e.e[b 7! ?]

⇤

b

B.B

B.?

⇤

b

d

d

Adding int key-value pair

b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb

⇤

b

B.B

B.B

λB.βb

({MyInt},?,0,())(B)

d

d

B.B

1 public C o m p o n e n t N a m e

m a k e C o m p o n e n t N a m e () {

C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {

c = new C o m p o n e n t N a m e ( " c . d " ,

2
3
4

" a . b . MyClass " ) ;

} else {

" a . b . M y S e c o n d C l a s s " ) ; }

c = new C o m p o n e n t N a m e ( " c . d " ,

5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12

Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,

return c ; }

Copy constructor

b = new Bundle(d)

e.e[b 7! e(d)]

⇤

b

Clearing extra data keys

d.clear()

λe.ehd 7! βb

(?,?,1,())(e(d))i

⇤

b

d

⇤

B.B

B.B

B.B

B.B

B.B

⇤

b

d

⇤

b

b

λB.βb

(?,?,1,())(B)

d

d

Figure 6: Pointwise environment transformers for com-
mon Bundle operations

transformer t

the environment

require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.

The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.

We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges

environment
i.e.

transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).

ing studied.

of G∗,

assigns

to

this . m F i r s t N a m e ) ;

bundle . putAll ( b ) ;
bundle . remove ( " Surname " ) ;
return bundle ; }

Intent intent = new Intent () ;
intent . s e t C o m p o n t e n t ( m a k e C o m p o n e n t N a m e () ) ;
Bundle b = new Bundle () ;
b . p u t S t r i n g ( " Surname " , this . m S u r n a m e ) ;
intent . p u t E x t r a s ( m a k e B u n d l e ( b ) ) ;
r e g i s t e r M y R e c e i v e r () ;
s t a r t A c t i v i t y ( intent ) ; }

13
14
15
16
17 public void onClick ( View v ) {
18
19
20
21
22
23
24
25
26 public void r e g i s t e r M y R e c e i v e r () {
27
28
29
30
31

I n t e n t F i l t e r f = new I n t e n t F i l t e r () ;
f . a d d A c t i o n ( " a . b . ACTION " ) ;
f . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
r e g i s t e r R e c e i v e r ( new M y R e c e i v e r () ,

f , " a . b . P E R M I S S I O N " , null ) ; }
Figure 7: ICC objects example

Under certain conditions on the representation of
micro-functions, an IDE problem can be solved in time
O(ED3) [32]. For example, micro-functions should be
applied in constant time. In the model we present in Sec-
tion 5, we relax some of these constraints but ﬁnd that
the problem can still be solved efﬁciently in the average
case. When the problem is solved, we know the value as-
sociated with each symbol at important program points.

5 Reducing Intent ICC to an IDE problem

To solve the Intent ICC problem, we need to model
four different kinds of objects. First, ComponentName
objects contain a package name and a class name.
They can be used by explicit Intents. For example, in
method makeComponentName() of Figure 7, a Com-
ponentName object can take two different values de-
pending on which branch is executed.
In the ﬁrst
branch, it refers to class a.b.MyClass from applica-
tion package c.d. In the second one, it refers to class
a.b.MySecondClass. We want to know the possible
return values of makeComponentName().

Second, Bundle objects store data as key-value map-
pings. Method makeBundle() of Figure 7 creates a Bun-
dle and modiﬁes its value. We need to ﬁnd the possible
return values of makeBundle().

Third, Intent objects are the main ICC communica-

548  22nd USENIX Security Symposium 

USENIX Association

the target class of intent

tion objects. They contain all the data that is used to
In method onClick() of Fig-
start other components.
is set using the re-
ure 7,
turn value of makeComponentName().
Its extra data
is set to the return value of makeBundle(). Finally,
a new Activity is started using the newly created In-
tent. We need to determine the value of intent at the
startActivity(intent) instruction.

Fourth,

IntentFilter objects are used for dynamic
Broadcast Receivers.
In registerMyReceiver() on Fig-
ure 7, an action and a category are added to IntentFil-
ter f . Then a Broadcast Receiver of type MyReceiver
(which we assume to be deﬁned) is registered us-
ing method registerReceiver().
It receives Intents that
have action a.b.ACTION and category a.b.CATEGORY
and that originate from applications with permission
a.b.PERMISSION. We want to determine the arguments
to the registerReceiver() call. That is, we want to
know that f contains action a.b.ACTION and category
a.b.CATEGORY. We also want to know that the type of
the Broadcast Receiver is MyReceiver.

In this section, we use the notations from Sagiv et
al. [32] summarized in Section 4. We assume that string
method arguments are available. We describe the string
analysis used in our implementation in Section 6.

5.1 ComponentName Model
In this section, we introduce the model we use for Com-
ponentName objects. We introduce the notion of a
branch ComponentName value. It represents the value
that a ComponentName object can take on a single
branch, given a single possible string argument value for
each method setting the ComponentName’s package and
class names, and in the absence of aliasing.
Deﬁnition 1. A branch ComponentName value is a tuple
c = (p,k), where p is a package name and k is a class
name.

In method makeComponentName() of Figure 7, two

branch ComponentName values are constructed:

(c.d, a.b.MyClass)

(1)

and

(c.d, a.b.MySecondClass)

(2)
The next deﬁnition introduces ComponentName val-
ues, which represent the possibly multiple values that a
ComponentName can have at a program point. A Com-
ponentName can take several values in different cases:
• After traversing different branches, as in method
• When a string argument can have several values at a
• When an object reference is a possible alias of an-

makeComponentName() of Figure 7.

other local reference or an object ﬁeld.

method call.

• When an object reference is a possible array element.
In the last two cases, in order to account for the possi-
bility of a false positive in the alias analysis, we keep
track of two branch ComponentName values. One con-
siders the inﬂuence of the call on the possible alias and
the other one does not.
Deﬁnition 2. A ComponentName value C is a set of
branch ComponentName values: C = {c1,c2,··· ,cm}.
The set of ComponentName values is denoted as Vc. We
deﬁne ⊥ = ∅ and (cid:26) as the ComponentName value that
is the set of all possible branch ComponentName val-
ues in the program. The operators ∪ and ⊆ are deﬁned
as traditional set union and comparison operators: for
C1,C2 ∈ Vc, C1 ⊆ C2 iff C1 ∪C2 = C2. Lc = (Vc,∪) is a
join semilattice.

Note that given the deﬁnitions of ⊥ and (cid:26) as speciﬁc
sets, ∪ and ⊆ naturally apply to them. For example, for
all C ∈ Vc, (cid:26)∪C = (cid:26).
In method makeComponentName() from Figure 7, the
value of c at the return statement is

{(c.d, a.b.MyClass) ,

(3)
It simply combines the values of c created in the two
branches, given by Equations (1) and (2).

(c.d, a.b.MySecondClass)} .

We deﬁne transformers from Vc to Vc that represent
the inﬂuence of a statement or a sequence of statements
on a ComponentName value. A pointwise branch Com-
ponentName transformer represents the inﬂuence of a
single branch, whereas a pointwise ComponentName
transformer represents the inﬂuence of possibly multiple
branches.
Deﬁnition 3. A pointwise branch ComponentName
transformer is a function δ c
(π,χ) : Vc → Vc, where π is a
package name and χ is a class name. It is such that, for
each C ∈ Vc,

δ c
(π,χ)(C) ={(π , χ)}

(4)

Note that δ c

(π,χ)(C) is independent of C, because API
methods for ComponentName objects systematically re-
place existing values for package and class names. In the
example from Figure 7, the pointwise branch Compo-
nentName transformer corresponding to the ﬁrst branch
is

δ c
(c.d,a.b.MyClass),
and the one for the second branch is

δ c
(c.d,a.b.MySecondClass).

(5)
Deﬁnition 4. A pointwise ComponentName transformer
is a function δ c
: Vc → Vc such that, for
each C ∈ Vc,

δ c
{(π1,χ1),··· ,(πn,χn)}(C) ={(π 1, χ1),··· , (πn, χn)}

{(π1,χ1),··· ,(πn,χn)}

A pointwise ComponentName transformer summa-

USENIX Association  

22nd USENIX Security Symposium  549

rizes the effect of multiple branches (or a single branch
with multiple possible string arguments, or with possi-
ble aliasing) on a ComponentName value. That is, given
the value C of a ComponentName right after statement
si and given transformer δ c
that sum-
marizes the inﬂuence of statements si+1,··· ,sk on C,
δ c
(C) represents all the possible values
{(π1,χ1),··· ,(πn,χn)}
of C right after sk. In method makeComponentName()
of Figure 7, the pointwise ComponentName transformer
that models the two branches is

{(π1,χ1),··· ,(πn,χn)}

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}.

(6)
It combines the transformers given by Equations (4)
and (5). In order to understand how this transformer is
applied in practice, we should mention that the algorithm
to solve IDE problems initially sets values to ⊥ [32].
Therefore, in method makeComponentName(), the value
associated with c is initially ⊥ = ∅. Using Deﬁnition 4,
we can easily see that if we apply the transformer given
by Equation (6), we get the value given by Equation (3).
This conﬁrms that the transformer models the inﬂuence
of the two branches:

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}(⊥)

= {(c.d, a.b.MyClass) ,

(c.d, a.b.MySecondClass)}

5.2 Bundle Model

The model of Bundle objects is deﬁned similarly to the
model of ComponentName objects. An additional difﬁ-
culty is introduced. The data in a Bundle can be modiﬁed
by adding the data in another Bundle to it, as shown in
method makeBundle() of Figure 7. In this example, the
data in Bundle b is added to the data in Bundle bundle.
Bundle bundle is later modiﬁed by removing the key-
value pair with key Surname. The issue is that when
the data ﬂow problem is being tackled, the value of b
is not known. Therefore, the inﬂuence of the call to
remove("Surname") is not known: if a key-value pair
with key Surname is part of b, then the call removes it
from bundle. Otherwise, it has no inﬂuence.

Our approach to deal with this object composition
problem is to perform two successive analyses. In Anal-
ysis I, we use placeholders for Bundles such as b in in-
struction bundle.putAll(b). We also record all subse-
quent method calls affecting bundle. After the problem
is solved, b’s key-value pairs at the putAll(b) method
call are known, as well as the subsequent method calls.
We then perform Analysis II, in which b’s key-value
pairs are added to bundle’s. The inﬂuence of the sub-
sequent method call is precisely evaluated and ﬁnally the
value of bundle at the return statement can be known.

b to V i

b, where V i

5.2.1 Analysis I
In the ﬁrst analysis, we consider intermediate values that
contain “placeholders” for Bundle values that are not
known when the problem is being solved.
Deﬁnition 5. An intermediate branch Bundle value is a
tuple bi = (E,O), where:
• E is a set of keys describing extra data.
• O is a tuple of two types of elements. O contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. O also contains functions
from V i
b is the set of intermediate Bun-
dle values deﬁned below. These functions represent a
sequence of method calls affecting a Bundle.
The difference with previous deﬁnitions is the intro-
duction of O, which models calls to putAll() as well as
subsequent calls affecting the same Bundle. In method
makeBundle() of Figure 7, at the return statement, the in-
termediate branch Bundle value associated with bundle
is (E,O), where
E ={FirstName}
O =((b, bundle.putAll(b)),β b

(7)
(8)
In O, (b, bundle.putAll(b)) is a reference to variable
b at instruction bundle.putAll(b). β b
(∅,Surname,0,())
models the remove() method call. It is deﬁned below.

(∅,{Surname},0,()))

b = (V i

b, Bi1 ⊆ Bi2 iff Bi1 ∪ Bi2 = Bi2. Li

We just deﬁned intermediate branch Bundle values.
As we did before, we need to consider multiple branches
and related issues (e.g., several possible string values):
Deﬁnition 6. An intermediate Bundle value Bi is a set of
intermediate branch Bundle values: Bi = {bi1,··· ,bim}.
The set of intermediate Bundle values is V i
b. We deﬁne
⊥ = ∅ and (cid:26) as the intermediate Bundle value that is
the set of all possible intermediate branch Bundle val-
ues in the program. We deﬁne ⊆ and ∪ as natural set
comparison and union operators. They are such that, for
Bi1,Bi2 ∈ V i
b,∪) is
a join semilattice.
In method makeBundle() from Figure 7, since there is
only a single branch, the intermediate Bundle value as-
sociated with bundle at the return statement is {(E,O)},
where E and O are given by Equations (7) and (8).
b to V i
b.
Similarly to the ComponentName model, we ﬁrst in-
troduce pointwise branch Bundle transformers before
deﬁning pointwise Bundle transformers.
In the def-
initions below, we use the \ notation for set differ-
ence, and ∪ is naturally extended to tuples such that
(a1,··· ,ak)∪ (ak+1,··· ,al) = (a1,··· ,ak,ak+1,··· ,al).
Deﬁnition 7. A pointwise branch Bundle transformer is
a function β b
• η + is a set of string keys describing extra data. It

Pointwise transformers are deﬁned from V i

(η +,η−,cl,Θ) : V i

models calls to putExtra() methods.

b → V i

b, where:

550  22nd USENIX Security Symposium 

USENIX Association

• η− is a set of string keys describing removed ex-
It represents the inﬂuence of calls to the

tra data.
removeExtra() method.

with the clear() method and 0 otherwise.

• cl takes value 1 if the Bundle data has been cleared
• Θ is a tuple of two types of elements. It contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. It also contains functions
from V i
b. These functions represent a sequence
of method calls affecting a Bundle.

b to V i

It is such that
β b
(η +,η−,cl,Θ)(⊥) =(cid:31)(cid:30)η +\η−,Θ(cid:29)(cid:28)
and, for Bi = {(E1,O1),··· , (Em,Om)} (Bi (cid:24)= ⊥),
β b
(η +,η−,cl,Θ)(Bi) ={(E (cid:23)1,O(cid:23)1),··· , (E(cid:23)m,O(cid:23)m)}
where, for each j from 1 to m:
E(cid:23)j =

O(cid:23)j =


η +\η−
(E j ∪ η +)\η−
E j
Θ
O j ∪(cid:23)β b

if cl = 1
if cl = 0 and O j = ∅
otherwise

(η +,η−,0,Θ)(cid:22)

if cl = 1 or O j = ∅
otherwise

The deﬁnition of E(cid:23)j accounts for several possible

cases:
• If the Bundle data has been cleared (i.e., cl = 1), then
we discard any data contained in E j. This leads to
value η +\η− for E(cid:23)j: we only keep the values η +
that were added to the Bundle data and remove the
values η− that were removed from it.

• If the Bundle has not been cleared, then there are two
possible cases: either no reference to another Bun-
dle has been previously recorded (i.e., O j = ∅), or
such a reference has been recorded to model a call to
putAll(). In the ﬁrst case, we simply take the union
of the original set E j and the set η + of added values,
and subtract the set η− of removed values. This ex-
plain the (E j ∪ η +)\η− value. In the second case, a
call to putAll() has been detected, which means that
any further method call adding or removing data has
to be added to set O j instead of E j. Therefore in this
case E(cid:23)j = E j.
The deﬁnition of O(cid:23)j considers several cases:
• If the Bundle data has been cleared, then the previous
value of O j is irrelevant and we set O(cid:23)j = Θ. Also, if
O j is empty, then we can also just set O(cid:23)j to Θ (which
may or may not be empty).

• Otherwise,

the Bundle data has not been cleared
(cl = 0) and a call to putAll() has been detected
(O j (cid:24)= ∅). Then it means that the current function
models method calls that happened after a call to
putAll(). Therefore we need to record β b
(η +,η−,0,Θ)
in O(cid:23)j, which explains the deﬁnition O(cid:23)j = O j ∪
(β b
(η +,η−,0,Θ)).

For example, the pointwise branch Bundle transformer
that models the inﬂuence of the method makeBundle()
from Figure 7 is β b

(η +,∅,0,Θ), where

η + ={FirstName}
Θ =(cid:23)(b, bundle.putAll(b)),

(9)

(10)

(∅,{Surname},0,())(cid:22)
β b

Pointwise branch Bundle transformers model the in-
ﬂuence of a single branch. In order to account for mul-
tiple branches or issues such as possible aliasing false
positive, we deﬁne pointwise Bundle transformers.
Deﬁnition 8. A pointwise Bundle transformer is a func-
tion

: V i
b → V i

b

β b
{(η +

1 +,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

such that, for each Bi ∈ V i
b,
β b
{(η +

1 ,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

(Bi) =
1 ,η−1 ,cl1,Θ1)(Bi)∪···∪β b

β b
(η +

n ,η−n ,cln,Θn)(Bi)
(η +

For example, method makeBundle() from Figure 7
only has a single branch, thus the pointwise Bundle trans-
former that models it is simply β b
, where η +
and Θ are given in Equations (9) and (10). As we did for
the ComponentName value example, we can conﬁrm us-
ing Deﬁnitions 7 and 8 that β b
(⊥) ={(E ,O)},
where E and O are given by Equations (7) and (8).

{(η +,∅,0,Θ)}

{(η +,∅,0,Θ)}

5.2.2 Analysis II

After Analysis I has been performed, the values of the
Bundles used in placeholders in intermediate Bundle val-
ues are known. Ultimately, we want to obtain branch
Bundle values and ﬁnally Bundle values:
Deﬁnition 9. A branch Bundle value b is a set E of string
keys describing extra data.
Deﬁnition 10. A Bundle value B is a set of branch Bun-
dle values: B = {b1,··· ,bm}.

Since the values of the referenced Bundles are known,
we can integrate them into the Bundle values referring to
them. Then the inﬂuence of the subsequent method calls
that have been recorded can precisely be known.

Let us consider the example of makeBundle() from
Figure 7. After Analysis I has been performed, we know
that the intermediate value of bundle at the return state-
ment is {(E,O)}, where

E ={FirstName}
O =(cid:23)(b, bundle.putAll(b)),β b
We consider all elements of O in order. As the
ﬁrst element of O is (b, bundle.putAll(b)), we inte-
grate b’s value into bundle. From Analysis I, we know

(∅,{Surname},0,())(cid:22)

USENIX Association  

22nd USENIX Security Symposium  551

that the value of b at instruction bundle.putAll(b)
is {{Surname} ,∅}. Thus, E becomes {FirstName,
Surname}. The next element of O is β b
(∅,{Surname},0,()).
This means that we have to remove key Surname from E.
The ﬁnal value of E is therefore {FirstName}. Thus, the
Bundle value associated with bundle at the return state-
ment is {{FirstName}}.
Note that the referenced Bundle can also make refer-
ences to other Bundles. In that case, we perform the res-
olution for the referenced Bundles ﬁrst. There can be an
arbitrary number of levels of indirection. Analysis II is
iterated until a ﬁx-point is reached.

Intent and IntentFilter Models

5.3
The Intent model is deﬁned similarly to the Bundle
model, which includes object composition.
In method
onClick() of Figure 7, the target of Intent intent is set
using a ComponentName object and its extra data is set
with a Bundle. Because of this object composition, ﬁnd-
ing the Intent value also involves two analyses similar to
the ones performed for Bundles. First, intermediate In-
tent values with placeholders for referenced Component-
Name and Bundle objects are found. Second, the refer-
enced objects’ values are integrated into intent’s value.

i = (V i

Similarly to the Bundle model, we deﬁne intermedi-
ate branch Intent values and intermediate Intent values.
The set of intermediate Intent values is V i
i and we de-
ﬁne a lattice Li
i ,∪) as we did for Li
b. We also de-
ﬁne pointwise branch Intent transformers and pointwise
Intent transformers. For example, in method onClick()
of Figure 7, the ﬁnal intermediate value for intent sim-
ply has placeholders for a ComponentName and a Bun-
dle value. Other ﬁelds, such as action and categories,
are empty. The ComponentName and Bundle values are
computed using the models presented in Sections 5.1
and 5.2. Finally, we deﬁne branch Intent values and
Intent values, which are output by the second analysis.
The ﬁnal value for intent after the second analysis pre-
cisely contains the two possible targets (a.b.MyClass
and a.b.MySecondClass in package c.d) and extra
data key FirstName. For conciseness, and given the
strong similarities with the Bundle model, we do not in-
clude a full description of the Intent model here.

In order to analyze dynamic Broadcast Receivers, we
model IntentFilter objects. Modeling IntentFilters is sim-
ilar to modeling Intents, except that IntentFilters do not
involve object composition. That is because IntentFilters
do not have methods taking other IntentFilters as argu-
ment, except for a copy constructor. Thus, their analysis
is simpler and involves a single step. Similarly to what
we did for other ICC models, we deﬁne branch Intent-
Filter values, IntentFilter values, pointwise branch In-
tentFilter transformers and pointwise IntentFilter trans-

formers.
In particular, we deﬁne lattice L f = (Vf ,∪),
In method
is the set of IntentFilter values.
where Vf
onClick() from Figure 7, the ﬁnal value of f contains ac-
tion a.b.ACTION and category a.b.CATEGORY. Given
the similarity of the IntentFilter model with previous
models, we do not include a complete description.

5.4 Casting as an IDE Problem
These deﬁnitions allow us to deﬁne environment trans-
formers for our problem. Given environment e ∈
Env(D,L), environment transformer λ e.e is the identity,
which does not change the value of e. Given Intent i and
Intent value I, λ e.e[i (cid:27)→ I] transforms e to an environment
where all values are the same as in e, except that Intent i
is associated with value I.

We deﬁne an environment transformer for each API
method call. Each of these environment transformers
uses the pointwise environment transformers deﬁned in
Sections 5.1, 5.2 and 5.3. It precisely describes the inﬂu-
ence of a method call on the value associated with each
of the symbols in D.

Figure 6 shows some environment transformers and
their pointwise representation. The ﬁrst one is a con-
structor invocation, which sets the value corresponding
to b to ⊥. The second one adds an integer to the key-
value pairs in Bundle b’s extra data, which is represented
by environment transformer

({MyInt},∅,0,()) (e(b))(cid:30) .

λ e.e(cid:31)b (cid:27)→ β b
It means that
the environment stays the same, ex-
cept
the value associated with b becomes
β b
({MyInt},∅,0,()) (e(b)), with e(b) being the value previ-
ously associated with b in environment e. The pointwise
transformer for b is

that

on Figure 6 for consistency with the other pointwise
transformers.
It simply adds key MyInt to the set of
data keys. The next transformer is for a copy construc-
tor, where the value associated with d is assigned to the
value associated with b. The last transformer clears the
data keys associated with d.

Trivially, these environment transformers are distribu-

tive. Therefore, the following proposition holds.
Proposition 1. Let G∗ be the supergraph of an An-
droid application. Let Dc, Db Di and D f be the sets
of ComponentName, Bundle and Intent variables, re-
to which we add the special symbol Λ5.
spectively,
Let Lc, Li
b, Li
i and L f be the lattices deﬁned above.

5Recall from Section 4.2 that Λ symbolizes the absence of a data

ﬂow fact.

which we denote by

β b
({MyInt},∅,0,()),
({MyInt},∅,0,())(B)

λ B.β b

552  22nd USENIX Security Symposium 

USENIX Association

Let Mc, Mb, Mi and Mf be the corresponding assign-
ments of distributive environment transformers. Then
(G∗,Dc,Lc,Mc), (G∗,Db,Li
i ) and
(G∗,Di,L f ,Mf ) are IDE problems.

b), (G∗,Db,Li

b,Mi

i,Mi

It follows from this proposition that we can use the

algorithm from [32] to solve the Intent ICC problem.

The original IDE framework [32] requires that the
micro-function be represented efﬁciently in order to
achieve the time complexity of O(ED3). Our model does
not meet these requirements:
in particular, applying,
composing, joining micro-function or testing for equality
of micro-functions cannot be done in constant time. In-
deed, the size of micro-functions grows with the number
of branches, aliases and possible string arguments (see
Equation 6 for an example with two branches). However,
in practice we can ﬁnd solutions to our IDE problem in-
stances in reasonable time, as we show in Section 6.

6 Evaluation

This section describes an evaluation of the approach pre-
sented in the preceding sections, and brieﬂy character-
izes the use of ICC in Android applications. We also
present a study of potential ICC vulnerabilities. Our
implementation is called Epicc (Efﬁcient and Precise
ICC) and is available at http://siis.cse.psu.edu/
epicc/.
It is built on Heros [3], an IDE framework
within Soot [34]. We also provide the version of Soot
that we modiﬁed to handle pathological cases encoun-
tered with retargeted code.

In order to compute string arguments, we use a simple
analysis traversing the interprocedural control ﬂow graph
of the application. The traversal starts at the call site and
looks for constant assignments to the call arguments. If a
string argument cannot be determined, we conservatively
assume that the argument can be any string. As we show
in Section 6.1, in many cases we are able to ﬁnd precise
string arguments. More complex analyses can be used if
more precision is desired [7].

For points-to analysis and call graph construction, we
use Spark [24], which is part of Soot. It performs a ﬂow-
sensitive, context-insensitive analysis. We approximate
the call graph in components with multiple entry points.
In order to generate a call graph of an Android appli-
cation, we currently use a “wrapper” as an entry point.
This wrapper calls each class entry point once, which
may under-approximate what happens at runtime. This
impacts a speciﬁcation only if an ICC ﬁeld (e.g., Intent)
is modiﬁed in a way that depends on the runtime execu-
tion order of class entry points. Generally, if we assume
that our model of components’ life cycle is complete and
if the application does not use native calls or reﬂection,
then our results are sound.

The analysis presented in this section is performed on
two datasets. The ﬁrst random sample dataset contains
350 applications, 348 of which were successfully ana-
lyzed after retargeting. They were extracted from the
Google Play store6 between September 2012 and Jan-
uary 2013. The applications were selected at random
from over 200,000 applications in our corpus. The sec-
ond popular application dataset contains the top 25 most
popular free applications from each of the 34 applica-
tion categories in the Play store. The 850 selected appli-
cations were downloaded from that application store on
January 30, 2013. Of those 850 applications, 838 could
be retargeted and processed and were used in the exper-
iments below. The 14 applications which were not ana-
lyzed were pathological cases where retargeting yielded
code which could not be analyzed (e.g., in some cases
the Dare tool generated offsets with integer overﬂow er-
rors due to excessive method sizes), or where applica-
tions could not be processed by Soot (e.g., character en-
coding problems).

6.1 Precision of ICC Speciﬁcations
The ﬁrst set of tests evaluates the technique’s precision
with our datasets. We deﬁne the precision metric to be
the percentage of source and sink locations for which a
speciﬁcation is identiﬁed without ambiguity. Ambiguity
occurs when an ICC API method argument cannot be de-
termined. These arguments are mainly strings of charac-
ters, which may be generated at runtime. In some cases,
runtime context determines string values, which implies
that our analysis cannot statically ﬁnd them.

Recall the various forms of ICC. Explicit ICC iden-
tiﬁes the communication sink by specifying the target’s
package and class name. Conversely, implicit ICC iden-
tiﬁes the sink through action, category, and/or data ﬁelds.
Further, a mixed ICC occurs when a source or sink can
take on explicit or implicit ICC values depending on the
runtime context. Finally, the dynamic receiver ICC oc-
curs when a sink binds to an ICC type through runtime
context (e.g., Broadcast Receivers which identify the In-
tent Filter types when being registered). We seek to de-
termine precise ICC speciﬁcations, where all ﬁelds of In-
tents or Intent Filters are known without ambiguity.

As shown in Table 1, with respect to the random sam-
ple corpus, we were able to provide unambiguous speci-
ﬁcations for over 91% of the 7,835 ICC locations in the
348 applications. Explicit ICC was precisely analyzed
more frequently (≈98%) than implicit ICC (≈88%). The
remaining 7% of ICC containing mixed and dynamic re-
ceivers proved to be more difﬁcult, where the precision
rates are much lower than others. This is likely due to
the fact that dynamic receivers involve ﬁnding more data

6Available at https://play.google.com/store/apps.

USENIX Association  

22nd USENIX Security Symposium  553

Explicit
Implicit
Mixed
Dyn. Rec.
Total

Explicit
Implicit
Mixed
Dyn. Rec.
Total

Random Sample

Precise

3,571 97.65%
3,225 88.45%
28 59.57%
357 73.61%
7,181 91.65%

% Total
% Imprecise
86
2.35% 3,657
421 11.55% 3,646
19 40.43%
47
128 26.39% 485
8.35% 7,835
654

Popular
% Imprecise
1,637
1,525

Precise
27,753 94.43%
23,133 93.82%
509 85.12%
4,161 95.81%
55,556 94.18%
Table 1: Precision metrics

89 14.88%
182
3,433

% Total
5.57% 29,390
6.18% 24,658
598
4.19% 4,343
5.82% 58,989

than Intents: Intent Filters limiting access to dynamic re-
ceivers can deﬁne several actions, and receivers can be
protected by a permission (which we attempt to recover).
In the popular applications, we obtain a precise spec-
iﬁcation in over 94% of the 58,989 ICC locations in the
838 apps. Explicit ICC was slightly more precisely an-
alyzed than implicit ICC. Mixed ICC is again hard to
recover. This is not surprising, as mixed ICC involves
different Intent values on two or more branches, which is
indicative of a method more complex than most others.
A facet of the analysis not shown in the table is the
number of applications for which we could identify un-
ambiguous speciﬁcations for all ICC – called 100% pre-
cision. In the random sample, 56% of the applications
could be analyzed with 100% precision, 80% of the ap-
plications with 90% precision, and 91% of the applica-
tions with 80% precision.
In the popular applications,
23% could be analyzed with 100% precision, 82% could
be analyzed with 90% precision and 94% with 80% pre-
cision. Note that a less-than-100% precision does not
mean that the analysis failed. Rather, these are cases
where runtime context determines string arguments, and
thus any static analysis technique would fail.

6.2 Computation Costs
A second set of tests sought to ascertain the computa-
tional costs of performing the IDE analysis using Epicc.
For this task we collected measurements at each stage of
the analysis and computed simple statistics characteriz-
ing the costs of each task on the random sample and the
popular applications.

Experiment results show that ICC analysis in this
model is feasible for applications in the Google Play
store. We were able to perform analysis of all 348 ap-
plications in the random sample in about 3.69 hours of
compute time. On average, it took just over 38 seconds
to perform analysis for a single application, with a stan-
dard deviation of 99 seconds. There was high variance in
the analysis run times. A CDF (cumulative distribution

i

)
e
m
T
 
n
o
i
t
a
t
u
p
m
o
C

(
 
F
D
C

i

)
e
m
T
 
n
o
i
t
a
t
u
p
m
o
C

(
 
F
D
C

 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0

 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0

 1

 10

 100

Applications (logscale)
(a) Random sample

 1

 10
Applications (logscale)
(b) Popular applications

 100

Figure 8: CDF of computation time

function) of the analysis computation time for all 348 ap-
plications is presented in Figure 8(a). It is clear from the
ﬁgure that costs were dominated by a handful of appli-
cations; the top application consumed over 11% of the
time, the top 5 consumed over 25% of the total time, and
the top 29 consumed over 50% of the total time. These
applications are large with a high number of entry points.
Analyzing the 838 popular applications took 33.58
hours, that is, 144 seconds per application. The standard
deviation was 277 seconds. The average processing time
is signiﬁcantly higher than for the random sample. How-
ever, this is expected, as the average application size is
almost 1,500 classes, which is signiﬁcantly higher than
the random sample (less than 400 classes per applica-
tion). This is likely related to the popularity bias: one can
expect frequently downloaded applications to have fully
developed features as well as more complex/numerous
features, which implies a larger code base. A CDF of the
computation time for all 838 applications is presented in
Figure 8(b). Once again, analysis time is dominated by
a few applications. The top 5 consumed over 11% of the
analysis time and the top 83 (less than 10% of the sam-
ple) consumed over 50% of the analysis time.

Processing was dominated by the standard Soot pro-
cessing (e.g., translating classes to an intermediate repre-
sentation, performing type inference and points-to anal-
ysis, building a call graph). It consumed 75% of the pro-
cessing time in the random sample and 86% in the pop-
ular applications. It was itself dominated by the trans-
lation to Soot’s internal representation and by the call
graph construction. The second most time-consuming
task was the IDE analysis (which also includes the string
analysis in our implementation). It took 15% of the pro-

554  22nd USENIX Security Symposium 

USENIX Association

cessing time with the random sample and 7% with the
popular one. Finally, I/O operations accounted for most
of the remainder of the processing time. Loading classes
took 7% of the time in the random sample and 3% in the
popular one. Database operations accounted for 2% of
processing for the random sample and 3% for the popu-
lar applications. Other operations (e.g., parsing manifest
ﬁles) took less than 1% of processing time.

implicit Intents to address components within an appli-
cation, which is a potential security concern, since these
Intents may also be intercepted by other components.
Lastly, application entry points were relatively narrow
(with respect to intent types). Over 97% of the entry
points received one Intent type in the random sample.
Single Intent Filters were found in 94% of components
protected by Intent Filters in the popular applications.

6.3 Entry/Exit Point Analysis
This section brieﬂy characterizes the exit (source) and
entry (sink) points of Android applications in our data
sets. Note that this analysis is preliminary and will be
extended in future work.

An exit point is a location that serves as a source for
ICC; i.e., the sending of an Intent. In the random sample,
our analysis found 7,350 exit points which can transmit
10,035 unique Intent values. About 92% of these exit
points had a single Intent speciﬁcation, with the remain-
ing exit points being able to take on 2 or more values.
In two pathological cases, we noted an exit point that
could have 640 different Intent values (most likely the re-
sult of contrived control ﬂow or multiple aliasing for an
Intent value). The popular applications had 48,756 exit
points, associated with 316,419 Intent values. Single In-
tent speciﬁcations were found in 90% of exit points. We
found 10 pathological cases where an exit point was as-
sociated with 512 Intent values or more. The use of key
value data was more prevalent than we initially expected,
in about 36% of exit points in the random sample. Key-
value data was present in Intents in 46% of exit points in
the popular applications.

Our study of entry points focused on the sinks of
ICC that were either dynamically registered broadcast re-
ceivers or component interfaces (exported or not) identi-
ﬁed in the application manifest. In the random sample,
we were able to identify 3,863 such entry points associ-
ated with 1,222 unique intent ﬁlters. The popular appli-
cations comprised 25,291 entry points with 11,375 Intent
Filters. 1,174 components were exported (and thus avail-
able to other applications) in the random sample, 7,392
in the popular applications. Of those, only 6% (67) of
the exported components were protected by a permission
in the random sample and 5% (382) were protected in
the popular applications. This is concerning, since the
presence of unprotected components in privileged appli-
cations can lead to confused deputy [21] attacks [17].

Oddly, we also found 23 components that were ex-
ported without any Intent Filter in the random sample
and 220 in the popular sample. Conversely, we found 32
cases where a component had an Intent Filter but was not
exported in the random sample and 412 in the popular
one. The latter indicates that developers sometimes use

ICC Vulnerability Study

6.4
In this section, we perform a study of ICC vulnerabilities
in our samples using Epicc and compare our results with
ComDroid [6]. We look for the same seven vulnerabil-
ities as in [6]. Activity and Service hijacking can occur
when an Intent is sent to start an Activity or a Service
without a speciﬁc target. Broadcast thefts can happen
when an Intent is Broadcast without being protected by a
signature or signatureOrSystem permission7. In all three
cases, the Intent may be received by a malicious compo-
nent, along with its potentially sensitive data.

Malicious Activity or Service launch and Broadcast
injection are Intent spooﬁng vulnerabilities. They in-
dicate that a public component is not protected with a
signature or signatureOrSystem permission. It may be
started by malicious components. These vulnerabilities
can lead to permission leakage [17, 19, 25].

Finally, some Intent Broadcasts can only be sent by
the operating system, as indicated by their action ﬁeld.
Broadcast Receivers can register to receive them by spec-
ifying Intent Filters with the appropriate action. How-
ever, these public components can still be addressed di-
rectly by explicit Intents. That is why the target Re-
ceivers should check the action ﬁeld of the received In-
tent to make sure that it was sent by the system.

Table 2 shows the results of the study for the ran-
dom and the popular samples. The ﬁrst line shows the
number of vulnerabilities identically detected by both
analyses, the second line shows vulnerabilities detected
by ComDroid only and the third line shows vulner-
abilities detected by Epicc only. The last two lines
show the total number of vulnerabilities found by each
tool.
For the three unauthorized Intent receipt vul-
nerabilities (ﬁrst three columns), both ComDroid and
Epicc indicate whether the sent Intent has extra data
in the form of key-value pairs, and whether the In-
tent has the FLAG GRANT READ URI PERMISSION or the
FLAG GRANT WRITE URI PERMISSION. These ﬂags are
used in Intents which refer to Content Provider data and
may allow the recipient to read or write the data [6].

7The signature permission protection level only allows access to a
component from an application signed by the same developer. The
signatureOrSystem protection level additionally allows the operating
system to start the component.

USENIX Association  

22nd USENIX Security Symposium  555

Vulnerability

Activity
Hijacking

Sample
Identical

Broadcast

Theft
R

P

Service
Hijacking
R
P
P
78 1,200 503 4,825 179 1,731 23 263 273 3,503
18 104 1,684
78
3
1
43
Total ComDroid 3,507 22,931 156 1,735 721 7,679 191 1,900 25 281 377 5,187

R
30
3
77
33
81 1,351 526 5,122 183 1,751 23 264 277 3,546 107

Injection w/o action check vulnerabilities
P
R
126 3,677 26,862
20 1,333 12,997
580
3,171
146 5,010 39,859
706 3,969 30,033

Service Broadcast System Broadcast
Launch
P

Total Epicc
Table 2: ICC vulnerability study results for the random sample (R) and the popular applications (P)

2,772 17,293

535 218 2,854
151
297

23

R

P
2,591 15,214
7,717
2,079

916
181

Activity
Launch
R

ComDroid only

Epicc only

12
4

169
20

2
0

4

P R

Total

P

R

292

For the presence of ﬂags and the detection of extra
data, Epicc can precisely indicate when the value of an
Intent depends on the execution path. On the other hand,
a ComDroid speciﬁcation does not make this distinction.
When Epicc and ComDroid differ for a code location, we
include ﬂags in both the “ComDroid only” and “Epicc
only” rows of Table 2.

The Activity hijacking vulnerabilities found by both
ComDroid and Epicc are unsurprisingly common: they
represent all cases where implicit Intents are used to
start Activities. Service hijacking vulnerabilities are
much less prevalent, which is correlated with the fact
that Services are used less often than Activities. Broad-
cast theft vulnerabilities are quite common as well. As
previously described in Section 6.3, few exported com-
ponents are protected by permissions. Therefore, the
high number of malicious Activity or Service launch
as well as Broadcast injection vulnerabilities is not sur-
prising. Note the discrepancy between the number
of components without permissions and the total num-
ber of these vulnerabilities. A large portion of the
components not protected by permissions are Activities
with the android.intent.action.MAIN action and
the android.intent.category.LAUNCHER category,
which indicate that these components cannot be started
without direct user intervention. They are therefore not
counted as potential vulnerabilities.

If we consider the ﬁrst three vulnerabilities (unautho-
rized Intent receipt), we can see that ComDroid ﬂags a
high number of locations where Epicc differs. A manual
examination of a random subset of applications shows
that these differences are either false positives detected
by ComDroid or cases where Epicc gives a more precise
vulnerability speciﬁcation. We observed that a number of
code locations are detected as vulnerable by ComDroid,
whereas Soot does not ﬁnd them to be reachable. Epicc
takes advantage from the sound and precise Soot call
graph construction to output fewer false positives. Ad-
ditionally, the IDE model used by Epicc can accurately
keep track of differences between branches (e.g., explic-
it/implicit Intent or URI ﬂags), whereas ComDroid can-
not. Note that when an Intent is implicit on one branch
and explicit on another, ComDroid detects it as explicit,
which is a false negative. On the other hand, the IDE
model correctly keeps track of the possibilities.

With a few exceptions, the ComDroid and Epicc anal-
yses detect the same possible malicious Activity and Ser-
vice launches. That is expected, since both are detected
by simply parsing the manifest ﬁle. The few differences
can be explained by minor implementation differences
or bugs in pathological cases. The Broadcast injection
vulnerability shows stronger differences, with ComDroid
detecting 377 cases for the random sample and 5,187
for the popular one, whereas Epicc only ﬁnds 277 and
3,546, respectively. Some of the Broadcast injections
detected by ComDroid involved dynamically registered
Broadcast Receivers found in unreachable code. Once
again, the call graph used by Epicc proves to be an ad-
vantage. Many other cases involve Receivers listening
to protected system Broadcasts (i.e., they are protected
by Intent Filters that only receive Intents sent by the sys-
tem). The list of protected Broadcasts used by ComDroid
is outdated, hence the false positives.

Finally, there is a signiﬁcant difference in the de-
tection of the system Broadcasts without action check,
with Epicc detecting 107 vulnerabilities in the random
sample and 706 in the popular one, whereas ComDroid
only detects 33 and 146, respectively. The ﬁrst rea-
son for that difference is that the ComDroid list of pro-
tected Broadcasts is outdated. Another reason is an
edge case, where the Soot type inference determines Re-
ceivers registered using a registerReceiver() method as
having type android.content.BroadcastReceiver
(i.e., the abstract superclass of all Receivers). It occurs
when several types of Receivers can reach the call to
registerReceiver(). Since no Receiver code can be in-
spected, even though there may be a vulnerability, our
analysis conservatively ﬂags it as a vulnerability.

Overall, Epicc detects 34,002 potential vulnerabilities.
On the other hand, ComDroid detects 44,869 potential
security issues, that is, 32% more than Epicc. As de-
tailed above, the extra ﬂags found by ComDroid that
we checked were all false positives. Further, the poten-
tial causes of unsoundness in Epicc (i.e., JNI, reﬂection
and entry point handling) are also handled unsoundly in
ComDroid. Thus, we do not expect the locations ﬂagged
by ComDroid but not by Epicc to be false negatives. The
precision gain over ComDroid is signiﬁcant and will help
further analyses. Note that it is possible that both tools
have false negatives in the presence of JNI, reﬂection,

556  22nd USENIX Security Symposium 

USENIX Association

or when the life cycle is not properly approximated. In
particular, we found that 776 out of the 838 popular ap-
plications and 237 out of 348 applications in the random
sample make reﬂective calls. Future work will seek to
quantify how often these cause false negatives in prac-
tice. We will also attempt to determine if the locations
ﬂagged by Epicc are true positives.

7 Related Work

ComDroid [6] is the work most closely related to ours.
Our work aims to formalize the notions it ﬁrst captured.
It is different in many aspects. First, ComDroid di-
rectly analyses Dalvik bytecode, whereas we use retar-
geted Java bytecode. This allows us to leverage anal-
yses integrated with Soot (e.g., call graph). Also, un-
like ComDroid, our analysis is fully interprocedural and
context-sensitive. Second, our ICC model is sound and
more detailed, taking multiple branches and aliasing into
account. Thus, as shown in Section 6.4, our ICC vulnera-
bility study produces fewer false positives. Finally, Com-
Droid seeks to ﬁnd potential vulnerabilities, whereas our
approach enables ﬁnding attacks for vulnerabilities in ex-
isting applications. This is done by keeping a database
of analysis results and matching newly analyzed applica-
tions with applications in our database. This will allow
us to identify problematic application combinations.

Several kinds of application analysis have been per-
formed for the Android platform [10]. Permission anal-
ysis infers applications properties based on the permis-
sions requested at install time. Kirin [13] uses permis-
sions to ﬂag applications with potential dangerous func-
tionality. Other methods for permission analysis have
been proposed [2, 15, 16], including analyses to detect
over-privileged applications [15] or malware [36].

Dynamic analysis consists in analyzing applications
while they are running. TaintDroid [11] performs dy-
namic taint tracking on Android. It exposes widespread
leakage of personal data to third parties. An extension to
TaintDroid handles implicit ﬂows [18] by monitoring and
recording control ﬂow information. TaintDroid is also
used in the AppFence system [22], which actively pre-
vents sensitive data exﬁltration from mobile devices. Al-
ternative approaches dynamically prevent some classes
of privilege escalation attack through ICC [4, 9]. Dy-
namic analyses such as TaintDroid are limited by the
way they interact with the User Interface (UI). Smart-
Droid [35] tackles this issue by combining static and dy-
namic analyses. It is able to simulate the UI to expose
hidden behavior for seven malwares. As we use static
analysis we do not interact with the UI: the call graph is
complete and does not depend on any runtime condition.
Static analysis consists in analyzing application code
to infer useful properties without running the applica-

tion. Several approaches for static analysis have already
been proposed for Android applications. Enck et al.
use decompilation [28] followed by source code analysis
to characterize security properties of applications [12].
Grace et al. perform a study of the dangers caused by
100 ad libraries found in a sample of 100,000 applica-
tions [20] through a reachability analysis on disassem-
bled bytecode. Several analyses have statically found
permission leaks [17, 19, 25], which happen when a priv-
ileged application leaks its capabilities to unprivileged
ones. These analyses focus on ﬁnding paths between ex-
posed entry points and sensitive API calls, whereas we
focus on connecting exit points to entry points. Thus,
these analyses could beneﬁt from our ICC analysis.

ScanDal [23] attempts to soundly analyze information
ﬂow. It convert Dalvik bytecode to a formally deﬁned
intermediate language. Dangerous ﬂows are detected us-
ing abstract interpretation. Its analysis is path-insensitive
and has limited context-sensitivity. It ﬁnds some actual
privacy leaks, but is limited by a high number of false
positives and ﬂows that are impossible to conﬁrm.

Saint [30] modiﬁes the Android framework to control
application interaction. Every application comes with
a policy describing how it uses permissions it declares.
Policy compliance veriﬁcation is a possible application
of our tool but is out of the scope of this paper.

8 Conclusion

In this paper we have introduced an efﬁcient and sound
technique for inferring ICC speciﬁcations, and demon-
strated its feasibility on a large collection of market ap-
plications. Future work will study a range of applications
and analyses that exploit the database of ICC speciﬁca-
tions. We will also explore a range of extensions that can
use this information at runtime to identify potentially ma-
licious communication between applications. Through
these activities, we aim to aid the community’s efforts to
gauge the security of market applications.

Acknowledgements

We thank Matthew Dering for providing our application
samples. We also thank Atul Prakash, Patrick Traynor
and our shepherd Ben Livshits for editorial comments
during the writing of this paper. This material is based
upon work supported by the National Science Founda-
tion Grants No. CNS-1228700, CNS-0905447, CNS-
1064944 and CNS-0643907. Any opinions, ﬁndings, and
conclusions or recommendations expressed in this mate-
rial are those of the authors and do not necessarily reﬂect
the views of the National Science Foundation. This re-
search is also supported by a Google Faculty Award.

USENIX Association  

22nd USENIX Security Symposium  557

Effective Inter-Component Communication 

Mapping in Android with Epicc: An Essential Step 

Towards Holistic Security Analysis

Damien Octeau and Patrick McDaniel, Pennsylvania State University;  

Somesh Jha, University of Wisconsin; Alexandre Bartel, University of Luxembourg;  

Eric Bodden, Technische Universität Darmstadt;  

Jacques Klein and Yves Le Traon, University of Luxembourg

Open access to the Proceedings of the 22nd USENIX Security Symposium is sponsored by USENIXThis paper is included in the Proceedings of the 22nd USENIX Security Symposium.August 14–16, 2013 • Washington, D.C., USAISBN 978-1-931971-03-4Effective Inter-Component Communication Mapping in Android with Epicc:

An Essential Step Towards Holistic Security Analysis

Damien Octeau1, Patrick McDaniel1, Somesh Jha2, Alexandre Bartel3, Eric Bodden4, Jacques

Klein3, and Yves Le Traon3

1Department of Computer Science and Engineering, Pennsylvania State University

2Computer Sciences Department, University of Wisconsin,

3Interdisciplinary Centre for Security, Reliability and Trust, University of Luxembourg

4EC SPRIDE, Technische Universit¨at Darmstadt

{octeau,mcdaniel}@cse.psu.edu, jha@cs.wisc.edu, {alexandre.bartel,jacques.klein,yves.letraon}@uni.lu, eric.bodden@ec-spride.de

Abstract

Many threats present in smartphones are the result of in-
teractions between application components, not just ar-
tifacts of single components. However, current tech-
niques for identifying inter-application communication
are ad hoc and do not scale to large numbers of ap-
plications.
In this paper, we reduce the discovery of
inter-component communication (ICC) in smartphones
to an instance of the Interprocedural Distributive Envi-
ronment (IDE) problem, and develop a sound static anal-
ysis technique targeted to the Android platform. We ap-
ply this analysis to 1,200 applications selected from the
Play store and characterize the locations and substance
of their ICC. Experiments show that full speciﬁcations
for ICC can be identiﬁed for over 93% of ICC locations
for the applications studied. Further the analysis scales
well; analysis of each application took on average 113
seconds to complete. Epicc, the resulting tool, ﬁnds ICC
vulnerabilities with far fewer false positives than the next
best tool. In this way, we develop a scalable vehicle to
extend current security analysis to entire collections of
applications as well as the interfaces they export.

1

Introduction

The rapid rise of smartphone has led to new applications
and modes of communication [1]. The scale of the new
software markets is breathtaking; Google’s Play Store
has served billions of application downloads [31] within
a few years. Such advances have also come with a dark
side. Users are subjected to privacy violations [11, 12]
and malicious behaviors [33] from the very applications
they have come to depend on. Unfortunately, for many
reasons, application markets cannot provide security as-
surances on the applications they serve [26], and previ-
ous attempts at doing so have had limited success [27].

Past analyses of Android applications [12, 14, 15, 17,
19, 36] have largely focused on analyzing application

components in isolation. Recent works have attempted
to expose and analyze the interfaces provided by com-
ponents to interact [6, 12], but have done so in ad hoc
and imprecise ways. Conversely, this paper attempts to
formally recast Inter-Component Communication (ICC)
analysis to infer the locations and substance of all inter-
and intra-application communication available for a tar-
get environment. This approach provides a high-ﬁdelity
means to study how components interact, which is a nec-
essary step for a comprehensive security analysis. For
example, our analysis can also be used to perform in-
formation ﬂow analysis between application components
and to identify new types of attacks, such as application
collusion [5, 8], where two applications work together
to compromise the privacy of the user. In general, most
vulnerability analysis techniques for Android need to an-
alyze ICC, and thus can beneﬁt from our analysis.

Android application components interact through ICC
objects – mainly Intents. Components can also commu-
nicate across applications, allowing developers to reuse
functionality. The proposed approach identiﬁes a spec-
iﬁcation for every ICC source and sink. This includes
the location of the ICC entry point or exit point, the ICC
Intent action, data type and category, as well as the ICC
Intent key/value types and the target component name.
Note that where ICC values are not ﬁxed we infer all
possible ICC values, thereby building a complete speci-
ﬁcation of the possible ways ICC can be used. The spec-
iﬁcations are recorded in a database in ﬂows detected by
matching compatible speciﬁcations. The structure of the
speciﬁcations ensures that ICC matching is efﬁcient.
We make the following contributions in this work:
• We show how to reduce the analysis of Intent ICC
to an Interprocedural Distributive Environment (IDE)
problem. Such a problem can be solved efﬁciently
using existing algorithms [32].

• We develop Epicc, a working analysis tool built
on top of an existing IDE framework [3] within
the Soot [34] suite, which we have made available

USENIX Association  

22nd USENIX Security Symposium  543

Component A

Intent
  - Action
  - Categories
  - Data

Component B

Intent Filter
  - Actions
  - Categories
  - Data

Figure 1: Implicit Intent ICC

at http://siis.cse.psu.edu/epicc/.

• We perform a study of ICC vulnerabilities and com-
pare it to ComDroid [6], the current state-of-the-art.
Our ICC vulnerability detection shows signiﬁcantly
increased precision, with ComDroid ﬂagging 32%
more code locations. While we use our tool to per-
form a study of some ICC vulnerabilities, our anal-
ysis can be used to address a wider variety of ICC-
related vulnerabilities.

• We perform a study of ICC in 1,200 representative
applications from the free section of the Google Play
Store. We found that the majority of speciﬁcations
were relatively narrow, most ICC objects having a
single possible type. Also, key/value pairs are widely
used to communicate data over ICC. Lastly, our anal-
ysis scales well, with an average analysis time of 113
seconds per application.

face is deﬁned through Activities.

within and across applications.

that should take place in the background.

1.1 Android ICC
Android applications are developed in Java and compiled
to a platform-speciﬁc Dalvik bytecode, and are com-
posed of four types of components:
• An Activity represents a user screen. The user inter-
• A Service allows developers to specify processing
• A Content Provider allows sharing of structured data
• A Broadcast Receiver is a component that receives
Intents are the primary vehicle for ICC. For example, a
developer might want to start a component to display the
user’s current location on a map. She can create an Intent
containing the user’s location and send it to a component
that renders the map. Developers can specify an Intent’s
target component (or target components) in two ways, (a)
explicitly, by specifying the target’s application package
and class name, and (b) implicitly by setting the Intent’s
action, category or data ﬁelds.

broadcast communication objects, called Intents.

In order for a component to be able to receive implicit
Intents, Intent Filters have to be speciﬁed for it in the
application’s manifest ﬁle. Illustrated in Figure 1, Intent
Filters describe the action, category or data ﬁelds of the
Intents that should be delivered by the operating system
to a given application component.

ICC can occur both within a single application and be-
tween different applications. In order for a component to

be accessible to other applications, its exported attribute
has to be set to true in the manifest ﬁle. If the exported
attribute of a component is not deﬁned, the OS makes
the component available to other applications if an Intent
Filter has been declared for it.

Intents can carry extra data in the form of key-value
mappings. This data is contained in a Bundle object as-
sociated with the Intent. Intents can also carry data in the
form of URIs with context-speciﬁc references to external
resources or data.

Developers can restrict access to components using
permissions. Permissions are generally declared in the
manifest ﬁle. A component protected by a permission
can only be addressed by applications that have obtained
that permission. Permission requests by applications are
granted by users at install time and enforced by the OS
at runtime.

2 Android ICC Analysis

As highlighted above, the goal of the analysis presented
in this paper is to infer speciﬁcations for each ICC source
and sink in the targeted applications. These speciﬁca-
tions detail the type, form, and data associated with the
communication. We consider communication with Con-
tent Providers to be out of scope. Our analysis has the
following goals:
Soundness - The analysis should generate all speciﬁca-
tions for ICC that may appear at runtime. Informally, we
want to guarantee that no ICC will go undetected. Our
analysis was designed to be sound under the assumption
that the applications use no reﬂection or native calls, and
that the components’ life cycle is modeled completely.
Precision - The previous goal implies that some gen-
erated ICC speciﬁcations may not happen at runtime
(“false positives”). Precision means that we want to
limit the number of cases where two components are de-
tected as connected, even though they are not in practice.
Our analysis currently does not handle URIs1. Since the
data contained in Intents in the form of URIs is used to
match Intents to target components, not using URIs as
a matching criterion potentially implies more false posi-
tives. Other possible sources of imprecision include the
points-to and string analyses. We empirically demon-
strate analysis precision in Section 6.1.

Note that, since we do not handle URIs yet, this im-
plies that Content Providers are out of the scope of this
paper and will be handled in future work.

1Extending the analysis to include URIs is a straightforward exer-
cise using the same approaches deﬁned in the following sections. We
have a working prototype and defer reporting on it to future work.

544  22nd USENIX Security Symposium 

USENIX Association

new O n C l i c k L i s t e n e r () {

public void onClick ( View v ) {

1 private O n C l i c k L i s t e n e r m M y L i s t e n e r =
2
3
4
5
6
7
Figure 2: Example of implicit Intent communication

Intent intent = new Intent () ;
intent . s e t A c t i o n ( " a . b . ACTION " ) ;
intent . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
s t a r t A c t i v i t y ( intent ) ; } };

2.1 Applications
Although Android applications are developed in Java,
existing Java analyses cannot handle the Android-
speciﬁc ICC mechanisms. The analysis presented in this
paper deals with ICC and can be used as the basis for
numerous important analyses, for example:
Finding ICC vulnerabilities - Android ICC APIs are
complex to use, which causes developers to commonly
leave their applications vulnerable [6, 12]. Examples of
ICC vulnerabilities include sending an Intent that may be
intercepted by a malicious component, or exposing com-
ponents to be launched by a malicious Intent. The ﬁrst
application of our work is in ﬁnding these vulnerabilities.
We present a study of ICC vulnerabilities in Section 6.4.
Finding attacks on ICC vulnerabilities - Our analy-
sis can go beyond ICC vulnerability detection and can be
used for a holistic attack detection process. For each app.
we compute entry points and exit points and systemati-
cally match them with entry and exit points of previously
processed applications. Therefore, our analysis can de-
tect applications that may exploit a given vulnerability.
Inter-component information ﬂow analysis - We com-
pute which data sent at an exit point can potentially be
used at a receiving entry point. An information ﬂow anal-
ysis using our ICC analysis ﬁnd ﬂows between a source
in a component and a sink in a different component (pos-
sibly in a different application).

In the case where the source and sink components
belong to different applications, we can detect cases of
application collusion [5, 8]. The unique communica-
tion primitives in Android allow for a new attack model
for malicious or privacy-violating application develop-
ers. Two or more applications can work together to leak
private information and go undetected. For example, ap-
plication A can request access to GPS location informa-
tion, while application B requests access to the network.
Permissions requested by each application do not seem
suspicious, therefore a user might download both appli-
cations. However, in practice it is possible for A and B to
work together to leak GPS location data to the network.
It is almost impossible for users to anticipate this kind of
breach of privacy. However, statically detecting this at-
tack is a simple application of our ICC analysis, whereas
the current state-of-the-art requires dynamic analysis and
modiﬁcation of the Android platform [5].

1 public void onClick ( View v ) {
2
3
4
5

Intent i = new Intent () ;
i . p u t E x t r a ( " Balance " , this . m B a l a n c e ) ;
if ( this . m C o n d i t i o n ) {

i . s e t C l a s s N a m e ( " a . b " ,

" a . b . MyClass " ) ;

} else {

}
s t a r t A c t i v i t y ( i ) ; }

i . s e t A c t i o n ( " a . b . ACTION " ) ;
i . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
i = m o d i f y I n t e n t ( i ) ;

6
7
8
9
10
11
12
13 public Intent m o d i f y I n t e n t ( Intent in ) {
14
15
16
17

Intent intent = new Intent ( in ) ;
intent . s e t A c t i o n ( " a . b . N E W _ A C T I O N " ) ;
intent . a d d C a t e g o r y ( " a . b . N E W _ C A T E G O R Y " ) ;
return intent ; }

Figure 3: Intent communication: running example

2.2 Examples
Figure 2 shows a representative example of ICC pro-
gramming.
It deﬁnes a ﬁeld that is a click listener.
When activated by a click on an element, it creates In-
tent intent and sets its action and category. Finally, the
startActivity() call takes intent as an argument. It causes
the OS to ﬁnd an activity that accepts Intents with the
given action and category. When such an activity is
found, it is started by the OS. If several activities meeting
the action and category requirements are found, the user
is asked which activity should be started.

This ﬁrst example is trivial. Let us now consider the
more complex example from Figure 3, which will be
used throughout this paper. Let us assume that this piece
of code is in a banking application. First, Intent intent
containing private data is created. Then, if condition
this.mCondition is true, intent is made explicit by tar-
geting a speciﬁc class. Otherwise, it is made implicit.
Next, an activity is started using startActivity(). Note
that we have made the implicit Intent branch contrived to
demonstrate how function calls are handled. In this ex-
ample, the safe branch is the one in which intent targets a
speciﬁc component. The other one may leak data, since it
might be intercepted by an malicious Activity. We want
to be able to detect that possible information leak.
In
other words, we want to infer the two possible Intent val-
ues at startActivity(). In particular, knowing the implicit
value would allow us to ﬁnd which applications can in-
tercept it and to detect possible eavesdropping.

3 Connecting Application Components:

Overview

Our analysis aims at connecting components, both within
single applications and between different applications.
For each input application A, it outputs the following:
1. A list of entry points for A that may be called by com-

USENIX Association  

22nd USENIX Security Symposium  545

ponents in A or in other applications.

2. A list of exit points for A where A may send an Intent
to another component. That component can be in A
or in a different application. The value of Intents at
each exit point is precisely determined, which allows
us to accurately determine possible targets.

3. A list of links between A’s own components and be-
tween A’s components and other applications’ com-
ponents. These links are computed using 1. and 2. as
well as all the previously analyzed applications.
Let us consider the example in Figure 3, which
is part of our example banking application.
The
startActivity(i) instruction is an exit point for the
application. Our analysis outputs the value of i at this in-
struction as well as all the possible targets. These targets
can be components of our banking application itself or
components of previously analyzed applications.

Figure 4 shows an overview of our component match-
ing process. It can be divided into three main functions:
• Finding target components that can be started by
other components (i.e. “entry points”) and identify-
ing criteria for a target to be activated.

of targets can be activated at these program points.

• Finding characteristics of exit points, i.e. what kind
• Matching exit points with possible targets.
Given an application, we start by parsing its manifest
ﬁle to extract package information, permissions used and
a list of components2 and associated intent ﬁlters (1).
These components are the potential targets of ICC. We
match these possible entry points with the pool of already
computed exit points (2). We then add the newly com-
puted entry points to our database of entry points (3).
This database and the exit points database grow as we
analyze more applications. Then we proceed with the
string analysis, which identiﬁes key API method argu-
ments such as action strings or component names (4).
Next, the main Interprocedural Distributive Environment
(IDE) analysis precisely computes the values of Intent
used at ICC API calls (5).
It also compute the values
of Intent Filters that select Intents received by dynami-
cally registered Broadcast Receivers. These exit points
are matched with entry points from the existing pool of
entry points (6). The newly computed exit points are
stored in the exit point database to allow for later match-
ing (7). The values associated with dynamically reg-
istered Broadcast Receivers are used for matching with
exit points in the database (8). Finally, these values are
stored in the entry point database (9).

One of the inputs to our analysis is a set of class ﬁles.
These classes are in Java bytecode format, since our anal-
ysis is built on top of Soot [34], an existing Java analysis
framework. Android application code is distributed in

a platform-speciﬁc Dalvik bytecode format that is opti-
mized for resource-constrained devices, such as smart-
phones and tablets. Therefore, we use Dare [29], an ex-
isting tool that efﬁciently and accurately retarget Dalvik
bytecode to Java bytecode. While other tools such as
dex2jar3 and ded [28] are available, Dare is currently
the only formally deﬁned one and other tools’ output is
sometimes not reliable.

The manifest parsing step is trivial and we use a sim-
ple string analysis (see Section 6). Also, the matching
process matches exit points with entry points. It can be
made efﬁcient if properly organized in a database. Thus,
we focus our description on the main IDE analysis.

It is important to distinguish between what is com-
puted by the string analysis and by the IDE analysis. In
the example from Figure 2, the string analysis computes
the values of the arguments to the API calls setAction()
and addCategory(). The IDE analysis, on the other
hand, uses the results from the string analysis along with
a model of the Android ICC API to determine the value
of the Intent.
In particular, in Figure 2, it determines
that, at the call to startActivity(), Intent intent has action
a.b.ACTION and category a.b.CATEGORY. In Figure 3,
the IDE analysis tells us that i has two possibles values
at the call to startActivity() and determines exactly what
the two possible values are.

Reducing the Intent ICC problem to an IDE prob-
lem [32] has important advantages. Our analysis is scal-
able (see Section 6). Further, it is a precise analysis, in
the sense that it generates few false positives (links be-
tween two components which may not communicate in
reality). Thus, security analyses using our ICC analysis
will not be plagued by ICC-related false positives. This
precision is due to the fact that the IDE framework is
ﬂow-sensitive, inter-procedural and context-sensitive.

The ﬂow-sensitivity means that we can distinguish In-
tent values between different program points.
In the
example from Figure 3, if Intent i was used for ICC
right before the call to modi f yIntent(), we would accu-
rately capture that this value is different from the one at
startActivity(). The context-sensitivity means that the
analysis of the call to modi f yIntent() is sensitive to the
method’s calling context. If modi f yIntent() is called at
another location with a different argument i2, the analy-
sis will precisely distinguish between the values returned
by the two calls. Otherwise, in a context-insensitive anal-
ysis, the return value would summarize all possible val-
ues given all contexts in which modi f yIntent() is called
in the program. The value of i computed by a context-
insensitive analysis would be inﬂuenced by the value of
i2, which is not the case in reality. That would be signif-
icantly less precise, resulting in more false positives.

2Broadcast Receivers can be registered either statically in the man-

ifest ﬁle or dynamically using the registerReceiver() methods.

3Available at http://code.google.com/p/dex2jar/.

546  22nd USENIX Security Symposium 

USENIX Association

Manifest

(1) Parsing

Components, Intent 
Filters & permissions

(6) Matching

ICC 
links

Intent 
values

(7) Populating 

database

Exit 
points

(8) Matching

(3) Populating 

database

(2) Matching

Entry 
points

ICC 
links

ICC 
links

(4) String 
analysis

Key string 
values

Class 
ﬁles

(5) IDE 
analysis

Dynamic receivers (Intent 

Filters & permissions)

(9) Populating 

database

Figure 4: Connecting Application Components

onClick(View v)

START

i = new Intent();

i.putExtra("Balance", 

this.mBalance);

if 

(this.mCondition)

(p)

modifyIntent(Intent in)

intent = new Intent(in);

i.setClassName("a.
b", "a.b.MyClass");

i.setAction("a.b.

ACTION");

intent.setAction("a.b.
NEW_ACTION");

i.addCategory("a.
b.CATEGORY");

intent.addCategory("a.
b.NEW_CATEGORY");

(c)

(r)

i = modifyIntent(i); 

(CALL)

i = modifyIntent(i); 

(RETURN)

return intent;

startActivity(i);

END

Normal ﬂow edge
Call edge
Return edge
Call-to-return edge

Figure 5: Supergraph G∗ for the program from Figure 3

4 The IDE Framework: Background

The main part of our analysis is based on the IDE frame-
work [32]. In this section, we summarize the main ideas
and notations of the IDE framework. A complete de-
scription is available in [32]. The IDE framework solves
a class of interprocedural data ﬂow analysis problems. In
these problems, an environment contains information at
each program point. For each program idiom, environ-
ment transformers are deﬁned and modify the environ-
ment according to semantics. The solution to this class
of problems can be found efﬁciently.

4.1 Supergraphs
A program is represented using a supergraph G∗. G∗ is
composed of the control ﬂow graphs of the procedures
in the program. Each procedure call site is represented
by two nodes, one call node representing control right
before the callee is entered and one return-site node to
which control ﬂows right after exiting the callee. Fig-
ure 5 shows the supergraph of the program in Figure 3.

(r).

The nodes of a supergraph are program statements.
There are four kinds of edges between these nodes.
Given a call to procedure (p) with call node (c) and
return-site (r), three kinds of edges are used to model
the effects of the procedure call on the environment:
• A call edge between (c) and the ﬁrst statement of (p).
• A return edge between the last statement of (p) and
• A call-to-return edge between (c) and (r).
All other edges in the supergraph are normal intrapro-
cedural ﬂow edges. Informally, the call edge transfers
symbols and associated values from the calling method
to the callee when a symbol of interest is a procedure ar-
gument. The return edge transfers information from the
return value of the callee to the environment in the call-
ing procedure. Finally, the call-to-return edge propagates
data ﬂow information that is not affected by the callee,
“in parallel” to the procedure call (e.g., local variables).

4.2 Environment transformers
Let D be a ﬁnite set of symbols (e.g., program variables).
D contains at least a symbol Λ that represents the absence
of a data ﬂow fact. Let L = (V,(cid:29)) be a join semilattice
with bottom element ⊥, where V is a set of values4. An
environment e is a function from D to L. The set of envi-
ronments from D to L is denoted by Env(D,L).

Operator (cid:29) is deﬁned over Env(D,L) as a natural ex-
tension of (cid:29) in semilattice L: for e1,e2 ∈ Env(D,L), e1 (cid:29)
e2 is such that, for all d ∈ D, (e1(cid:29)e2)(d) =e 1(d)(cid:29)e2(d).
transformer is a function from
The algorithms from [32]
Env(D,L) to Env(D,L).
4A join semilattice is a partially ordered set in which any two ele-

An environment

ments have a least upper bound.

USENIX Association  

22nd USENIX Security Symposium  547

Constructor

b = new Bundle()

e.e[b 7! ?]

⇤

b

B.B

B.?

⇤

b

d

d

Adding int key-value pair

b.putInt("MyInt", mInt)
({MyInt},?,0,())(e(b))i
λe.ehb 7! βb

⇤

b

B.B

B.B

λB.βb

({MyInt},?,0,())(B)

d

d

B.B

1 public C o m p o n e n t N a m e

m a k e C o m p o n e n t N a m e () {

C o m p o n e n t N a m e c ;
if ( this . m C o n d i t i o n ) {

c = new C o m p o n e n t N a m e ( " c . d " ,

2
3
4

" a . b . MyClass " ) ;

} else {

" a . b . M y S e c o n d C l a s s " ) ; }

c = new C o m p o n e n t N a m e ( " c . d " ,

5
6
7
8
9
10 public Bundle m a k e B u n d l e ( Bundle b ) {
11
12

Bundle bundle = new Bundle () ;
bundle . p u t S t r i n g ( " F i r s t N a m e " ,

return c ; }

Copy constructor

b = new Bundle(d)

e.e[b 7! e(d)]

⇤

b

Clearing extra data keys

d.clear()

λe.ehd 7! βb

(?,?,1,())(e(d))i

⇤

b

d

⇤

B.B

B.B

B.B

B.B

B.B

⇤

b

d

⇤

b

b

λB.βb

(?,?,1,())(B)

d

d

Figure 6: Pointwise environment transformers for com-
mon Bundle operations

transformer t

the environment

require that
transformers be dis-
tributive. An environment
is said to
be distributive if for all e1,e2, . . . ∈ Env(D,L), and
d ∈ D, (t((cid:30)iei))(d) = ((cid:30)it(ei))(d).
It is denoted by
t : Env(D,L) −→d Env(D,L). Environment transform-
ers have a pointwise representation. We show an exam-
ple on Figure 6. Given environment e ∈ Env(D,L), trans-
former λ e.e is the identity, which preserves the value of
e. Given symbol b ∈ D and value B ∈ L, λ e.e[b (cid:27)→ B]
transforms e to an environment where all values are the
same as in e, except that symbol b is associated with
value B. The functions from L to L (represented next
to each arrow in Figure 6) are called micro-functions.

The environment transformer for the copy constructor
call b = new Bundle(d) is λ e.e[b (cid:27)→ e(d)]. It means
that the value associated with b after the instruction is the
same as d’s value before the instruction. In the pointwise
representation, this is symbolized by an arrow between d
and b with an identity function next to it.

We are trying to determine the value associated with
each symbol at program points of interest, which is done
by solving an Interprocedural Distributive Environment
(IDE) problem. An instance IDE problem is deﬁned as a
tuple (G∗,D,L,M), where:
• G∗ = (N∗,E∗) is the supergraph of the application be-
• D is the set of symbols of interest.
• L is a join semilattice (V,(cid:30)) with least element ⊥.
distributive
• M
the
edges

environment
i.e.

transformers
M : E∗ −→ (Env(D,L) −→d Env(D,L)).

ing studied.

of G∗,

assigns

to

this . m F i r s t N a m e ) ;

bundle . putAll ( b ) ;
bundle . remove ( " Surname " ) ;
return bundle ; }

Intent intent = new Intent () ;
intent . s e t C o m p o n t e n t ( m a k e C o m p o n e n t N a m e () ) ;
Bundle b = new Bundle () ;
b . p u t S t r i n g ( " Surname " , this . m S u r n a m e ) ;
intent . p u t E x t r a s ( m a k e B u n d l e ( b ) ) ;
r e g i s t e r M y R e c e i v e r () ;
s t a r t A c t i v i t y ( intent ) ; }

13
14
15
16
17 public void onClick ( View v ) {
18
19
20
21
22
23
24
25
26 public void r e g i s t e r M y R e c e i v e r () {
27
28
29
30
31

I n t e n t F i l t e r f = new I n t e n t F i l t e r () ;
f . a d d A c t i o n ( " a . b . ACTION " ) ;
f . a d d C a t e g o r y ( " a . b . C A T E G O R Y " ) ;
r e g i s t e r R e c e i v e r ( new M y R e c e i v e r () ,

f , " a . b . P E R M I S S I O N " , null ) ; }
Figure 7: ICC objects example

Under certain conditions on the representation of
micro-functions, an IDE problem can be solved in time
O(ED3) [32]. For example, micro-functions should be
applied in constant time. In the model we present in Sec-
tion 5, we relax some of these constraints but ﬁnd that
the problem can still be solved efﬁciently in the average
case. When the problem is solved, we know the value as-
sociated with each symbol at important program points.

5 Reducing Intent ICC to an IDE problem

To solve the Intent ICC problem, we need to model
four different kinds of objects. First, ComponentName
objects contain a package name and a class name.
They can be used by explicit Intents. For example, in
method makeComponentName() of Figure 7, a Com-
ponentName object can take two different values de-
pending on which branch is executed.
In the ﬁrst
branch, it refers to class a.b.MyClass from applica-
tion package c.d. In the second one, it refers to class
a.b.MySecondClass. We want to know the possible
return values of makeComponentName().

Second, Bundle objects store data as key-value map-
pings. Method makeBundle() of Figure 7 creates a Bun-
dle and modiﬁes its value. We need to ﬁnd the possible
return values of makeBundle().

Third, Intent objects are the main ICC communica-

548  22nd USENIX Security Symposium 

USENIX Association

the target class of intent

tion objects. They contain all the data that is used to
In method onClick() of Fig-
start other components.
is set using the re-
ure 7,
turn value of makeComponentName().
Its extra data
is set to the return value of makeBundle(). Finally,
a new Activity is started using the newly created In-
tent. We need to determine the value of intent at the
startActivity(intent) instruction.

Fourth,

IntentFilter objects are used for dynamic
Broadcast Receivers.
In registerMyReceiver() on Fig-
ure 7, an action and a category are added to IntentFil-
ter f . Then a Broadcast Receiver of type MyReceiver
(which we assume to be deﬁned) is registered us-
ing method registerReceiver().
It receives Intents that
have action a.b.ACTION and category a.b.CATEGORY
and that originate from applications with permission
a.b.PERMISSION. We want to determine the arguments
to the registerReceiver() call. That is, we want to
know that f contains action a.b.ACTION and category
a.b.CATEGORY. We also want to know that the type of
the Broadcast Receiver is MyReceiver.

In this section, we use the notations from Sagiv et
al. [32] summarized in Section 4. We assume that string
method arguments are available. We describe the string
analysis used in our implementation in Section 6.

5.1 ComponentName Model
In this section, we introduce the model we use for Com-
ponentName objects. We introduce the notion of a
branch ComponentName value. It represents the value
that a ComponentName object can take on a single
branch, given a single possible string argument value for
each method setting the ComponentName’s package and
class names, and in the absence of aliasing.
Deﬁnition 1. A branch ComponentName value is a tuple
c = (p,k), where p is a package name and k is a class
name.

In method makeComponentName() of Figure 7, two

branch ComponentName values are constructed:

(c.d, a.b.MyClass)

(1)

and

(c.d, a.b.MySecondClass)

(2)
The next deﬁnition introduces ComponentName val-
ues, which represent the possibly multiple values that a
ComponentName can have at a program point. A Com-
ponentName can take several values in different cases:
• After traversing different branches, as in method
• When a string argument can have several values at a
• When an object reference is a possible alias of an-

makeComponentName() of Figure 7.

other local reference or an object ﬁeld.

method call.

• When an object reference is a possible array element.
In the last two cases, in order to account for the possi-
bility of a false positive in the alias analysis, we keep
track of two branch ComponentName values. One con-
siders the inﬂuence of the call on the possible alias and
the other one does not.
Deﬁnition 2. A ComponentName value C is a set of
branch ComponentName values: C = {c1,c2,··· ,cm}.
The set of ComponentName values is denoted as Vc. We
deﬁne ⊥ = ∅ and (cid:26) as the ComponentName value that
is the set of all possible branch ComponentName val-
ues in the program. The operators ∪ and ⊆ are deﬁned
as traditional set union and comparison operators: for
C1,C2 ∈ Vc, C1 ⊆ C2 iff C1 ∪C2 = C2. Lc = (Vc,∪) is a
join semilattice.

Note that given the deﬁnitions of ⊥ and (cid:26) as speciﬁc
sets, ∪ and ⊆ naturally apply to them. For example, for
all C ∈ Vc, (cid:26)∪C = (cid:26).
In method makeComponentName() from Figure 7, the
value of c at the return statement is

{(c.d, a.b.MyClass) ,

(3)
It simply combines the values of c created in the two
branches, given by Equations (1) and (2).

(c.d, a.b.MySecondClass)} .

We deﬁne transformers from Vc to Vc that represent
the inﬂuence of a statement or a sequence of statements
on a ComponentName value. A pointwise branch Com-
ponentName transformer represents the inﬂuence of a
single branch, whereas a pointwise ComponentName
transformer represents the inﬂuence of possibly multiple
branches.
Deﬁnition 3. A pointwise branch ComponentName
transformer is a function δ c
(π,χ) : Vc → Vc, where π is a
package name and χ is a class name. It is such that, for
each C ∈ Vc,

δ c
(π,χ)(C) ={(π , χ)}

(4)

Note that δ c

(π,χ)(C) is independent of C, because API
methods for ComponentName objects systematically re-
place existing values for package and class names. In the
example from Figure 7, the pointwise branch Compo-
nentName transformer corresponding to the ﬁrst branch
is

δ c
(c.d,a.b.MyClass),
and the one for the second branch is

δ c
(c.d,a.b.MySecondClass).

(5)
Deﬁnition 4. A pointwise ComponentName transformer
is a function δ c
: Vc → Vc such that, for
each C ∈ Vc,

δ c
{(π1,χ1),··· ,(πn,χn)}(C) ={(π 1, χ1),··· , (πn, χn)}

{(π1,χ1),··· ,(πn,χn)}

A pointwise ComponentName transformer summa-

USENIX Association  

22nd USENIX Security Symposium  549

rizes the effect of multiple branches (or a single branch
with multiple possible string arguments, or with possi-
ble aliasing) on a ComponentName value. That is, given
the value C of a ComponentName right after statement
si and given transformer δ c
that sum-
marizes the inﬂuence of statements si+1,··· ,sk on C,
δ c
(C) represents all the possible values
{(π1,χ1),··· ,(πn,χn)}
of C right after sk. In method makeComponentName()
of Figure 7, the pointwise ComponentName transformer
that models the two branches is

{(π1,χ1),··· ,(πn,χn)}

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}.

(6)
It combines the transformers given by Equations (4)
and (5). In order to understand how this transformer is
applied in practice, we should mention that the algorithm
to solve IDE problems initially sets values to ⊥ [32].
Therefore, in method makeComponentName(), the value
associated with c is initially ⊥ = ∅. Using Deﬁnition 4,
we can easily see that if we apply the transformer given
by Equation (6), we get the value given by Equation (3).
This conﬁrms that the transformer models the inﬂuence
of the two branches:

δ c
{(c.d,a.b.MyClass),(c.d,a.b.MySecondClass)}(⊥)

= {(c.d, a.b.MyClass) ,

(c.d, a.b.MySecondClass)}

5.2 Bundle Model

The model of Bundle objects is deﬁned similarly to the
model of ComponentName objects. An additional difﬁ-
culty is introduced. The data in a Bundle can be modiﬁed
by adding the data in another Bundle to it, as shown in
method makeBundle() of Figure 7. In this example, the
data in Bundle b is added to the data in Bundle bundle.
Bundle bundle is later modiﬁed by removing the key-
value pair with key Surname. The issue is that when
the data ﬂow problem is being tackled, the value of b
is not known. Therefore, the inﬂuence of the call to
remove("Surname") is not known: if a key-value pair
with key Surname is part of b, then the call removes it
from bundle. Otherwise, it has no inﬂuence.

Our approach to deal with this object composition
problem is to perform two successive analyses. In Anal-
ysis I, we use placeholders for Bundles such as b in in-
struction bundle.putAll(b). We also record all subse-
quent method calls affecting bundle. After the problem
is solved, b’s key-value pairs at the putAll(b) method
call are known, as well as the subsequent method calls.
We then perform Analysis II, in which b’s key-value
pairs are added to bundle’s. The inﬂuence of the sub-
sequent method call is precisely evaluated and ﬁnally the
value of bundle at the return statement can be known.

b to V i

b, where V i

5.2.1 Analysis I
In the ﬁrst analysis, we consider intermediate values that
contain “placeholders” for Bundle values that are not
known when the problem is being solved.
Deﬁnition 5. An intermediate branch Bundle value is a
tuple bi = (E,O), where:
• E is a set of keys describing extra data.
• O is a tuple of two types of elements. O contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. O also contains functions
from V i
b is the set of intermediate Bun-
dle values deﬁned below. These functions represent a
sequence of method calls affecting a Bundle.
The difference with previous deﬁnitions is the intro-
duction of O, which models calls to putAll() as well as
subsequent calls affecting the same Bundle. In method
makeBundle() of Figure 7, at the return statement, the in-
termediate branch Bundle value associated with bundle
is (E,O), where
E ={FirstName}
O =((b, bundle.putAll(b)),β b

(7)
(8)
In O, (b, bundle.putAll(b)) is a reference to variable
b at instruction bundle.putAll(b). β b
(∅,Surname,0,())
models the remove() method call. It is deﬁned below.

(∅,{Surname},0,()))

b = (V i

b, Bi1 ⊆ Bi2 iff Bi1 ∪ Bi2 = Bi2. Li

We just deﬁned intermediate branch Bundle values.
As we did before, we need to consider multiple branches
and related issues (e.g., several possible string values):
Deﬁnition 6. An intermediate Bundle value Bi is a set of
intermediate branch Bundle values: Bi = {bi1,··· ,bim}.
The set of intermediate Bundle values is V i
b. We deﬁne
⊥ = ∅ and (cid:26) as the intermediate Bundle value that is
the set of all possible intermediate branch Bundle val-
ues in the program. We deﬁne ⊆ and ∪ as natural set
comparison and union operators. They are such that, for
Bi1,Bi2 ∈ V i
b,∪) is
a join semilattice.
In method makeBundle() from Figure 7, since there is
only a single branch, the intermediate Bundle value as-
sociated with bundle at the return statement is {(E,O)},
where E and O are given by Equations (7) and (8).
b to V i
b.
Similarly to the ComponentName model, we ﬁrst in-
troduce pointwise branch Bundle transformers before
deﬁning pointwise Bundle transformers.
In the def-
initions below, we use the \ notation for set differ-
ence, and ∪ is naturally extended to tuples such that
(a1,··· ,ak)∪ (ak+1,··· ,al) = (a1,··· ,ak,ak+1,··· ,al).
Deﬁnition 7. A pointwise branch Bundle transformer is
a function β b
• η + is a set of string keys describing extra data. It

Pointwise transformers are deﬁned from V i

(η +,η−,cl,Θ) : V i

models calls to putExtra() methods.

b → V i

b, where:

550  22nd USENIX Security Symposium 

USENIX Association

• η− is a set of string keys describing removed ex-
It represents the inﬂuence of calls to the

tra data.
removeExtra() method.

with the clear() method and 0 otherwise.

• cl takes value 1 if the Bundle data has been cleared
• Θ is a tuple of two types of elements. It contains ref-
erences to particular Bundle symbols at instructions
where putAll() calls occur. It also contains functions
from V i
b. These functions represent a sequence
of method calls affecting a Bundle.

b to V i

It is such that
β b
(η +,η−,cl,Θ)(⊥) =(cid:31)(cid:30)η +\η−,Θ(cid:29)(cid:28)
and, for Bi = {(E1,O1),··· , (Em,Om)} (Bi (cid:24)= ⊥),
β b
(η +,η−,cl,Θ)(Bi) ={(E (cid:23)1,O(cid:23)1),··· , (E(cid:23)m,O(cid:23)m)}
where, for each j from 1 to m:
E(cid:23)j =

O(cid:23)j =


η +\η−
(E j ∪ η +)\η−
E j
Θ
O j ∪(cid:23)β b

if cl = 1
if cl = 0 and O j = ∅
otherwise

(η +,η−,0,Θ)(cid:22)

if cl = 1 or O j = ∅
otherwise

The deﬁnition of E(cid:23)j accounts for several possible

cases:
• If the Bundle data has been cleared (i.e., cl = 1), then
we discard any data contained in E j. This leads to
value η +\η− for E(cid:23)j: we only keep the values η +
that were added to the Bundle data and remove the
values η− that were removed from it.

• If the Bundle has not been cleared, then there are two
possible cases: either no reference to another Bun-
dle has been previously recorded (i.e., O j = ∅), or
such a reference has been recorded to model a call to
putAll(). In the ﬁrst case, we simply take the union
of the original set E j and the set η + of added values,
and subtract the set η− of removed values. This ex-
plain the (E j ∪ η +)\η− value. In the second case, a
call to putAll() has been detected, which means that
any further method call adding or removing data has
to be added to set O j instead of E j. Therefore in this
case E(cid:23)j = E j.
The deﬁnition of O(cid:23)j considers several cases:
• If the Bundle data has been cleared, then the previous
value of O j is irrelevant and we set O(cid:23)j = Θ. Also, if
O j is empty, then we can also just set O(cid:23)j to Θ (which
may or may not be empty).

• Otherwise,

the Bundle data has not been cleared
(cl = 0) and a call to putAll() has been detected
(O j (cid:24)= ∅). Then it means that the current function
models method calls that happened after a call to
putAll(). Therefore we need to record β b
(η +,η−,0,Θ)
in O(cid:23)j, which explains the deﬁnition O(cid:23)j = O j ∪
(β b
(η +,η−,0,Θ)).

For example, the pointwise branch Bundle transformer
that models the inﬂuence of the method makeBundle()
from Figure 7 is β b

(η +,∅,0,Θ), where

η + ={FirstName}
Θ =(cid:23)(b, bundle.putAll(b)),

(9)

(10)

(∅,{Surname},0,())(cid:22)
β b

Pointwise branch Bundle transformers model the in-
ﬂuence of a single branch. In order to account for mul-
tiple branches or issues such as possible aliasing false
positive, we deﬁne pointwise Bundle transformers.
Deﬁnition 8. A pointwise Bundle transformer is a func-
tion

: V i
b → V i

b

β b
{(η +

1 +,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

such that, for each Bi ∈ V i
b,
β b
{(η +

1 ,η−1 ,cl1,Θ1),··· ,(η +

n ,η−n ,cln,Θn)}

(Bi) =
1 ,η−1 ,cl1,Θ1)(Bi)∪···∪β b

β b
(η +

n ,η−n ,cln,Θn)(Bi)
(η +

For example, method makeBundle() from Figure 7
only has a single branch, thus the pointwise Bundle trans-
former that models it is simply β b
, where η +
and Θ are given in Equations (9) and (10). As we did for
the ComponentName value example, we can conﬁrm us-
ing Deﬁnitions 7 and 8 that β b
(⊥) ={(E ,O)},
where E and O are given by Equations (7) and (8).

{(η +,∅,0,Θ)}

{(η +,∅,0,Θ)}

5.2.2 Analysis II

After Analysis I has been performed, the values of the
Bundles used in placeholders in intermediate Bundle val-
ues are known. Ultimately, we want to obtain branch
Bundle values and ﬁnally Bundle values:
Deﬁnition 9. A branch Bundle value b is a set E of string
keys describing extra data.
Deﬁnition 10. A Bundle value B is a set of branch Bun-
dle values: B = {b1,··· ,bm}.

Since the values of the referenced Bundles are known,
we can integrate them into the Bundle values referring to
them. Then the inﬂuence of the subsequent method calls
that have been recorded can precisely be known.

Let us consider the example of makeBundle() from
Figure 7. After Analysis I has been performed, we know
that the intermediate value of bundle at the return state-
ment is {(E,O)}, where

E ={FirstName}
O =(cid:23)(b, bundle.putAll(b)),β b
We consider all elements of O in order. As the
ﬁrst element of O is (b, bundle.putAll(b)), we inte-
grate b’s value into bundle. From Analysis I, we know

(∅,{Surname},0,())(cid:22)

USENIX Association  

22nd USENIX Security Symposium  551

that the value of b at instruction bundle.putAll(b)
is {{Surname} ,∅}. Thus, E becomes {FirstName,
Surname}. The next element of O is β b
(∅,{Surname},0,()).
This means that we have to remove key Surname from E.
The ﬁnal value of E is therefore {FirstName}. Thus, the
Bundle value associated with bundle at the return state-
ment is {{FirstName}}.
Note that the referenced Bundle can also make refer-
ences to other Bundles. In that case, we perform the res-
olution for the referenced Bundles ﬁrst. There can be an
arbitrary number of levels of indirection. Analysis II is
iterated until a ﬁx-point is reached.

Intent and IntentFilter Models

5.3
The Intent model is deﬁned similarly to the Bundle
model, which includes object composition.
In method
onClick() of Figure 7, the target of Intent intent is set
using a ComponentName object and its extra data is set
with a Bundle. Because of this object composition, ﬁnd-
ing the Intent value also involves two analyses similar to
the ones performed for Bundles. First, intermediate In-
tent values with placeholders for referenced Component-
Name and Bundle objects are found. Second, the refer-
enced objects’ values are integrated into intent’s value.

i = (V i

Similarly to the Bundle model, we deﬁne intermedi-
ate branch Intent values and intermediate Intent values.
The set of intermediate Intent values is V i
i and we de-
ﬁne a lattice Li
i ,∪) as we did for Li
b. We also de-
ﬁne pointwise branch Intent transformers and pointwise
Intent transformers. For example, in method onClick()
of Figure 7, the ﬁnal intermediate value for intent sim-
ply has placeholders for a ComponentName and a Bun-
dle value. Other ﬁelds, such as action and categories,
are empty. The ComponentName and Bundle values are
computed using the models presented in Sections 5.1
and 5.2. Finally, we deﬁne branch Intent values and
Intent values, which are output by the second analysis.
The ﬁnal value for intent after the second analysis pre-
cisely contains the two possible targets (a.b.MyClass
and a.b.MySecondClass in package c.d) and extra
data key FirstName. For conciseness, and given the
strong similarities with the Bundle model, we do not in-
clude a full description of the Intent model here.

In order to analyze dynamic Broadcast Receivers, we
model IntentFilter objects. Modeling IntentFilters is sim-
ilar to modeling Intents, except that IntentFilters do not
involve object composition. That is because IntentFilters
do not have methods taking other IntentFilters as argu-
ment, except for a copy constructor. Thus, their analysis
is simpler and involves a single step. Similarly to what
we did for other ICC models, we deﬁne branch Intent-
Filter values, IntentFilter values, pointwise branch In-
tentFilter transformers and pointwise IntentFilter trans-

formers.
In particular, we deﬁne lattice L f = (Vf ,∪),
In method
is the set of IntentFilter values.
where Vf
onClick() from Figure 7, the ﬁnal value of f contains ac-
tion a.b.ACTION and category a.b.CATEGORY. Given
the similarity of the IntentFilter model with previous
models, we do not include a complete description.

5.4 Casting as an IDE Problem
These deﬁnitions allow us to deﬁne environment trans-
formers for our problem. Given environment e ∈
Env(D,L), environment transformer λ e.e is the identity,
which does not change the value of e. Given Intent i and
Intent value I, λ e.e[i (cid:27)→ I] transforms e to an environment
where all values are the same as in e, except that Intent i
is associated with value I.

We deﬁne an environment transformer for each API
method call. Each of these environment transformers
uses the pointwise environment transformers deﬁned in
Sections 5.1, 5.2 and 5.3. It precisely describes the inﬂu-
ence of a method call on the value associated with each
of the symbols in D.

Figure 6 shows some environment transformers and
their pointwise representation. The ﬁrst one is a con-
structor invocation, which sets the value corresponding
to b to ⊥. The second one adds an integer to the key-
value pairs in Bundle b’s extra data, which is represented
by environment transformer

({MyInt},∅,0,()) (e(b))(cid:30) .

λ e.e(cid:31)b (cid:27)→ β b
It means that
the environment stays the same, ex-
cept
the value associated with b becomes
β b
({MyInt},∅,0,()) (e(b)), with e(b) being the value previ-
ously associated with b in environment e. The pointwise
transformer for b is

that

on Figure 6 for consistency with the other pointwise
transformers.
It simply adds key MyInt to the set of
data keys. The next transformer is for a copy construc-
tor, where the value associated with d is assigned to the
value associated with b. The last transformer clears the
data keys associated with d.

Trivially, these environment transformers are distribu-

tive. Therefore, the following proposition holds.
Proposition 1. Let G∗ be the supergraph of an An-
droid application. Let Dc, Db Di and D f be the sets
of ComponentName, Bundle and Intent variables, re-
to which we add the special symbol Λ5.
spectively,
Let Lc, Li
b, Li
i and L f be the lattices deﬁned above.

5Recall from Section 4.2 that Λ symbolizes the absence of a data

ﬂow fact.

which we denote by

β b
({MyInt},∅,0,()),
({MyInt},∅,0,())(B)

λ B.β b

552  22nd USENIX Security Symposium 

USENIX Association

Let Mc, Mb, Mi and Mf be the corresponding assign-
ments of distributive environment transformers. Then
(G∗,Dc,Lc,Mc), (G∗,Db,Li
i ) and
(G∗,Di,L f ,Mf ) are IDE problems.

b), (G∗,Db,Li

b,Mi

i,Mi

It follows from this proposition that we can use the

algorithm from [32] to solve the Intent ICC problem.

The original IDE framework [32] requires that the
micro-function be represented efﬁciently in order to
achieve the time complexity of O(ED3). Our model does
not meet these requirements:
in particular, applying,
composing, joining micro-function or testing for equality
of micro-functions cannot be done in constant time. In-
deed, the size of micro-functions grows with the number
of branches, aliases and possible string arguments (see
Equation 6 for an example with two branches). However,
in practice we can ﬁnd solutions to our IDE problem in-
stances in reasonable time, as we show in Section 6.

6 Evaluation

This section describes an evaluation of the approach pre-
sented in the preceding sections, and brieﬂy character-
izes the use of ICC in Android applications. We also
present a study of potential ICC vulnerabilities. Our
implementation is called Epicc (Efﬁcient and Precise
ICC) and is available at http://siis.cse.psu.edu/
epicc/.
It is built on Heros [3], an IDE framework
within Soot [34]. We also provide the version of Soot
that we modiﬁed to handle pathological cases encoun-
tered with retargeted code.

In order to compute string arguments, we use a simple
analysis traversing the interprocedural control ﬂow graph
of the application. The traversal starts at the call site and
looks for constant assignments to the call arguments. If a
string argument cannot be determined, we conservatively
assume that the argument can be any string. As we show
in Section 6.1, in many cases we are able to ﬁnd precise
string arguments. More complex analyses can be used if
more precision is desired [7].

For points-to analysis and call graph construction, we
use Spark [24], which is part of Soot. It performs a ﬂow-
sensitive, context-insensitive analysis. We approximate
the call graph in components with multiple entry points.
In order to generate a call graph of an Android appli-
cation, we currently use a “wrapper” as an entry point.
This wrapper calls each class entry point once, which
may under-approximate what happens at runtime. This
impacts a speciﬁcation only if an ICC ﬁeld (e.g., Intent)
is modiﬁed in a way that depends on the runtime execu-
tion order of class entry points. Generally, if we assume
that our model of components’ life cycle is complete and
if the application does not use native calls or reﬂection,
then our results are sound.

The analysis presented in this section is performed on
two datasets. The ﬁrst random sample dataset contains
350 applications, 348 of which were successfully ana-
lyzed after retargeting. They were extracted from the
Google Play store6 between September 2012 and Jan-
uary 2013. The applications were selected at random
from over 200,000 applications in our corpus. The sec-
ond popular application dataset contains the top 25 most
popular free applications from each of the 34 applica-
tion categories in the Play store. The 850 selected appli-
cations were downloaded from that application store on
January 30, 2013. Of those 850 applications, 838 could
be retargeted and processed and were used in the exper-
iments below. The 14 applications which were not ana-
lyzed were pathological cases where retargeting yielded
code which could not be analyzed (e.g., in some cases
the Dare tool generated offsets with integer overﬂow er-
rors due to excessive method sizes), or where applica-
tions could not be processed by Soot (e.g., character en-
coding problems).

6.1 Precision of ICC Speciﬁcations
The ﬁrst set of tests evaluates the technique’s precision
with our datasets. We deﬁne the precision metric to be
the percentage of source and sink locations for which a
speciﬁcation is identiﬁed without ambiguity. Ambiguity
occurs when an ICC API method argument cannot be de-
termined. These arguments are mainly strings of charac-
ters, which may be generated at runtime. In some cases,
runtime context determines string values, which implies
that our analysis cannot statically ﬁnd them.

Recall the various forms of ICC. Explicit ICC iden-
tiﬁes the communication sink by specifying the target’s
package and class name. Conversely, implicit ICC iden-
tiﬁes the sink through action, category, and/or data ﬁelds.
Further, a mixed ICC occurs when a source or sink can
take on explicit or implicit ICC values depending on the
runtime context. Finally, the dynamic receiver ICC oc-
curs when a sink binds to an ICC type through runtime
context (e.g., Broadcast Receivers which identify the In-
tent Filter types when being registered). We seek to de-
termine precise ICC speciﬁcations, where all ﬁelds of In-
tents or Intent Filters are known without ambiguity.

As shown in Table 1, with respect to the random sam-
ple corpus, we were able to provide unambiguous speci-
ﬁcations for over 91% of the 7,835 ICC locations in the
348 applications. Explicit ICC was precisely analyzed
more frequently (≈98%) than implicit ICC (≈88%). The
remaining 7% of ICC containing mixed and dynamic re-
ceivers proved to be more difﬁcult, where the precision
rates are much lower than others. This is likely due to
the fact that dynamic receivers involve ﬁnding more data

6Available at https://play.google.com/store/apps.

USENIX Association  

22nd USENIX Security Symposium  553

Explicit
Implicit
Mixed
Dyn. Rec.
Total

Explicit
Implicit
Mixed
Dyn. Rec.
Total

Random Sample

Precise

3,571 97.65%
3,225 88.45%
28 59.57%
357 73.61%
7,181 91.65%

% Total
% Imprecise
86
2.35% 3,657
421 11.55% 3,646
19 40.43%
47
128 26.39% 485
8.35% 7,835
654

Popular
% Imprecise
1,637
1,525

Precise
27,753 94.43%
23,133 93.82%
509 85.12%
4,161 95.81%
55,556 94.18%
Table 1: Precision metrics

89 14.88%
182
3,433

% Total
5.57% 29,390
6.18% 24,658
598
4.19% 4,343
5.82% 58,989

than Intents: Intent Filters limiting access to dynamic re-
ceivers can deﬁne several actions, and receivers can be
protected by a permission (which we attempt to recover).
In the popular applications, we obtain a precise spec-
iﬁcation in over 94% of the 58,989 ICC locations in the
838 apps. Explicit ICC was slightly more precisely an-
alyzed than implicit ICC. Mixed ICC is again hard to
recover. This is not surprising, as mixed ICC involves
different Intent values on two or more branches, which is
indicative of a method more complex than most others.
A facet of the analysis not shown in the table is the
number of applications for which we could identify un-
ambiguous speciﬁcations for all ICC – called 100% pre-
cision. In the random sample, 56% of the applications
could be analyzed with 100% precision, 80% of the ap-
plications with 90% precision, and 91% of the applica-
tions with 80% precision.
In the popular applications,
23% could be analyzed with 100% precision, 82% could
be analyzed with 90% precision and 94% with 80% pre-
cision. Note that a less-than-100% precision does not
mean that the analysis failed. Rather, these are cases
where runtime context determines string arguments, and
thus any static analysis technique would fail.

6.2 Computation Costs
A second set of tests sought to ascertain the computa-
tional costs of performing the IDE analysis using Epicc.
For this task we collected measurements at each stage of
the analysis and computed simple statistics characteriz-
ing the costs of each task on the random sample and the
popular applications.

Experiment results show that ICC analysis in this
model is feasible for applications in the Google Play
store. We were able to perform analysis of all 348 ap-
plications in the random sample in about 3.69 hours of
compute time. On average, it took just over 38 seconds
to perform analysis for a single application, with a stan-
dard deviation of 99 seconds. There was high variance in
the analysis run times. A CDF (cumulative distribution

i

)
e
m
T
 
n
o
i
t
a
t
u
p
m
o
C

(
 
F
D
C

i

)
e
m
T
 
n
o
i
t
a
t
u
p
m
o
C

(
 
F
D
C

 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0

 1
 0.9
 0.8
 0.7
 0.6
 0.5
 0.4
 0.3
 0.2
 0.1
 0

 1

 10

 100

Applications (logscale)
(a) Random sample

 1

 10
Applications (logscale)
(b) Popular applications

 100

Figure 8: CDF of computation time

function) of the analysis computation time for all 348 ap-
plications is presented in Figure 8(a). It is clear from the
ﬁgure that costs were dominated by a handful of appli-
cations; the top application consumed over 11% of the
time, the top 5 consumed over 25% of the total time, and
the top 29 consumed over 50% of the total time. These
applications are large with a high number of entry points.
Analyzing the 838 popular applications took 33.58
hours, that is, 144 seconds per application. The standard
deviation was 277 seconds. The average processing time
is signiﬁcantly higher than for the random sample. How-
ever, this is expected, as the average application size is
almost 1,500 classes, which is signiﬁcantly higher than
the random sample (less than 400 classes per applica-
tion). This is likely related to the popularity bias: one can
expect frequently downloaded applications to have fully
developed features as well as more complex/numerous
features, which implies a larger code base. A CDF of the
computation time for all 838 applications is presented in
Figure 8(b). Once again, analysis time is dominated by
a few applications. The top 5 consumed over 11% of the
analysis time and the top 83 (less than 10% of the sam-
ple) consumed over 50% of the analysis time.

Processing was dominated by the standard Soot pro-
cessing (e.g., translating classes to an intermediate repre-
sentation, performing type inference and points-to anal-
ysis, building a call graph). It consumed 75% of the pro-
cessing time in the random sample and 86% in the pop-
ular applications. It was itself dominated by the trans-
lation to Soot’s internal representation and by the call
graph construction. The second most time-consuming
task was the IDE analysis (which also includes the string
analysis in our implementation). It took 15% of the pro-

554  22nd USENIX Security Symposium 

USENIX Association

cessing time with the random sample and 7% with the
popular one. Finally, I/O operations accounted for most
of the remainder of the processing time. Loading classes
took 7% of the time in the random sample and 3% in the
popular one. Database operations accounted for 2% of
processing for the random sample and 3% for the popu-
lar applications. Other operations (e.g., parsing manifest
ﬁles) took less than 1% of processing time.

implicit Intents to address components within an appli-
cation, which is a potential security concern, since these
Intents may also be intercepted by other components.
Lastly, application entry points were relatively narrow
(with respect to intent types). Over 97% of the entry
points received one Intent type in the random sample.
Single Intent Filters were found in 94% of components
protected by Intent Filters in the popular applications.

6.3 Entry/Exit Point Analysis
This section brieﬂy characterizes the exit (source) and
entry (sink) points of Android applications in our data
sets. Note that this analysis is preliminary and will be
extended in future work.

An exit point is a location that serves as a source for
ICC; i.e., the sending of an Intent. In the random sample,
our analysis found 7,350 exit points which can transmit
10,035 unique Intent values. About 92% of these exit
points had a single Intent speciﬁcation, with the remain-
ing exit points being able to take on 2 or more values.
In two pathological cases, we noted an exit point that
could have 640 different Intent values (most likely the re-
sult of contrived control ﬂow or multiple aliasing for an
Intent value). The popular applications had 48,756 exit
points, associated with 316,419 Intent values. Single In-
tent speciﬁcations were found in 90% of exit points. We
found 10 pathological cases where an exit point was as-
sociated with 512 Intent values or more. The use of key
value data was more prevalent than we initially expected,
in about 36% of exit points in the random sample. Key-
value data was present in Intents in 46% of exit points in
the popular applications.

Our study of entry points focused on the sinks of
ICC that were either dynamically registered broadcast re-
ceivers or component interfaces (exported or not) identi-
ﬁed in the application manifest. In the random sample,
we were able to identify 3,863 such entry points associ-
ated with 1,222 unique intent ﬁlters. The popular appli-
cations comprised 25,291 entry points with 11,375 Intent
Filters. 1,174 components were exported (and thus avail-
able to other applications) in the random sample, 7,392
in the popular applications. Of those, only 6% (67) of
the exported components were protected by a permission
in the random sample and 5% (382) were protected in
the popular applications. This is concerning, since the
presence of unprotected components in privileged appli-
cations can lead to confused deputy [21] attacks [17].

Oddly, we also found 23 components that were ex-
ported without any Intent Filter in the random sample
and 220 in the popular sample. Conversely, we found 32
cases where a component had an Intent Filter but was not
exported in the random sample and 412 in the popular
one. The latter indicates that developers sometimes use

ICC Vulnerability Study

6.4
In this section, we perform a study of ICC vulnerabilities
in our samples using Epicc and compare our results with
ComDroid [6]. We look for the same seven vulnerabil-
ities as in [6]. Activity and Service hijacking can occur
when an Intent is sent to start an Activity or a Service
without a speciﬁc target. Broadcast thefts can happen
when an Intent is Broadcast without being protected by a
signature or signatureOrSystem permission7. In all three
cases, the Intent may be received by a malicious compo-
nent, along with its potentially sensitive data.

Malicious Activity or Service launch and Broadcast
injection are Intent spooﬁng vulnerabilities. They in-
dicate that a public component is not protected with a
signature or signatureOrSystem permission. It may be
started by malicious components. These vulnerabilities
can lead to permission leakage [17, 19, 25].

Finally, some Intent Broadcasts can only be sent by
the operating system, as indicated by their action ﬁeld.
Broadcast Receivers can register to receive them by spec-
ifying Intent Filters with the appropriate action. How-
ever, these public components can still be addressed di-
rectly by explicit Intents. That is why the target Re-
ceivers should check the action ﬁeld of the received In-
tent to make sure that it was sent by the system.

Table 2 shows the results of the study for the ran-
dom and the popular samples. The ﬁrst line shows the
number of vulnerabilities identically detected by both
analyses, the second line shows vulnerabilities detected
by ComDroid only and the third line shows vulner-
abilities detected by Epicc only. The last two lines
show the total number of vulnerabilities found by each
tool.
For the three unauthorized Intent receipt vul-
nerabilities (ﬁrst three columns), both ComDroid and
Epicc indicate whether the sent Intent has extra data
in the form of key-value pairs, and whether the In-
tent has the FLAG GRANT READ URI PERMISSION or the
FLAG GRANT WRITE URI PERMISSION. These ﬂags are
used in Intents which refer to Content Provider data and
may allow the recipient to read or write the data [6].

7The signature permission protection level only allows access to a
component from an application signed by the same developer. The
signatureOrSystem protection level additionally allows the operating
system to start the component.

USENIX Association  

22nd USENIX Security Symposium  555

Vulnerability

Activity
Hijacking

Sample
Identical

Broadcast

Theft
R

P

Service
Hijacking
R
P
P
78 1,200 503 4,825 179 1,731 23 263 273 3,503
18 104 1,684
78
3
1
43
Total ComDroid 3,507 22,931 156 1,735 721 7,679 191 1,900 25 281 377 5,187

R
30
3
77
33
81 1,351 526 5,122 183 1,751 23 264 277 3,546 107

Injection w/o action check vulnerabilities
P
R
126 3,677 26,862
20 1,333 12,997
580
3,171
146 5,010 39,859
706 3,969 30,033

Service Broadcast System Broadcast
Launch
P

Total Epicc
Table 2: ICC vulnerability study results for the random sample (R) and the popular applications (P)

2,772 17,293

535 218 2,854
151
297

23

R

P
2,591 15,214
7,717
2,079

916
181

Activity
Launch
R

ComDroid only

Epicc only

12
4

169
20

2
0

4

P R

Total

P

R

292

For the presence of ﬂags and the detection of extra
data, Epicc can precisely indicate when the value of an
Intent depends on the execution path. On the other hand,
a ComDroid speciﬁcation does not make this distinction.
When Epicc and ComDroid differ for a code location, we
include ﬂags in both the “ComDroid only” and “Epicc
only” rows of Table 2.

The Activity hijacking vulnerabilities found by both
ComDroid and Epicc are unsurprisingly common: they
represent all cases where implicit Intents are used to
start Activities. Service hijacking vulnerabilities are
much less prevalent, which is correlated with the fact
that Services are used less often than Activities. Broad-
cast theft vulnerabilities are quite common as well. As
previously described in Section 6.3, few exported com-
ponents are protected by permissions. Therefore, the
high number of malicious Activity or Service launch
as well as Broadcast injection vulnerabilities is not sur-
prising. Note the discrepancy between the number
of components without permissions and the total num-
ber of these vulnerabilities. A large portion of the
components not protected by permissions are Activities
with the android.intent.action.MAIN action and
the android.intent.category.LAUNCHER category,
which indicate that these components cannot be started
without direct user intervention. They are therefore not
counted as potential vulnerabilities.

If we consider the ﬁrst three vulnerabilities (unautho-
rized Intent receipt), we can see that ComDroid ﬂags a
high number of locations where Epicc differs. A manual
examination of a random subset of applications shows
that these differences are either false positives detected
by ComDroid or cases where Epicc gives a more precise
vulnerability speciﬁcation. We observed that a number of
code locations are detected as vulnerable by ComDroid,
whereas Soot does not ﬁnd them to be reachable. Epicc
takes advantage from the sound and precise Soot call
graph construction to output fewer false positives. Ad-
ditionally, the IDE model used by Epicc can accurately
keep track of differences between branches (e.g., explic-
it/implicit Intent or URI ﬂags), whereas ComDroid can-
not. Note that when an Intent is implicit on one branch
and explicit on another, ComDroid detects it as explicit,
which is a false negative. On the other hand, the IDE
model correctly keeps track of the possibilities.

With a few exceptions, the ComDroid and Epicc anal-
yses detect the same possible malicious Activity and Ser-
vice launches. That is expected, since both are detected
by simply parsing the manifest ﬁle. The few differences
can be explained by minor implementation differences
or bugs in pathological cases. The Broadcast injection
vulnerability shows stronger differences, with ComDroid
detecting 377 cases for the random sample and 5,187
for the popular one, whereas Epicc only ﬁnds 277 and
3,546, respectively. Some of the Broadcast injections
detected by ComDroid involved dynamically registered
Broadcast Receivers found in unreachable code. Once
again, the call graph used by Epicc proves to be an ad-
vantage. Many other cases involve Receivers listening
to protected system Broadcasts (i.e., they are protected
by Intent Filters that only receive Intents sent by the sys-
tem). The list of protected Broadcasts used by ComDroid
is outdated, hence the false positives.

Finally, there is a signiﬁcant difference in the de-
tection of the system Broadcasts without action check,
with Epicc detecting 107 vulnerabilities in the random
sample and 706 in the popular one, whereas ComDroid
only detects 33 and 146, respectively. The ﬁrst rea-
son for that difference is that the ComDroid list of pro-
tected Broadcasts is outdated. Another reason is an
edge case, where the Soot type inference determines Re-
ceivers registered using a registerReceiver() method as
having type android.content.BroadcastReceiver
(i.e., the abstract superclass of all Receivers). It occurs
when several types of Receivers can reach the call to
registerReceiver(). Since no Receiver code can be in-
spected, even though there may be a vulnerability, our
analysis conservatively ﬂags it as a vulnerability.

Overall, Epicc detects 34,002 potential vulnerabilities.
On the other hand, ComDroid detects 44,869 potential
security issues, that is, 32% more than Epicc. As de-
tailed above, the extra ﬂags found by ComDroid that
we checked were all false positives. Further, the poten-
tial causes of unsoundness in Epicc (i.e., JNI, reﬂection
and entry point handling) are also handled unsoundly in
ComDroid. Thus, we do not expect the locations ﬂagged
by ComDroid but not by Epicc to be false negatives. The
precision gain over ComDroid is signiﬁcant and will help
further analyses. Note that it is possible that both tools
have false negatives in the presence of JNI, reﬂection,

556  22nd USENIX Security Symposium 

USENIX Association

or when the life cycle is not properly approximated. In
particular, we found that 776 out of the 838 popular ap-
plications and 237 out of 348 applications in the random
sample make reﬂective calls. Future work will seek to
quantify how often these cause false negatives in prac-
tice. We will also attempt to determine if the locations
ﬂagged by Epicc are true positives.

7 Related Work

ComDroid [6] is the work most closely related to ours.
Our work aims to formalize the notions it ﬁrst captured.
It is different in many aspects. First, ComDroid di-
rectly analyses Dalvik bytecode, whereas we use retar-
geted Java bytecode. This allows us to leverage anal-
yses integrated with Soot (e.g., call graph). Also, un-
like ComDroid, our analysis is fully interprocedural and
context-sensitive. Second, our ICC model is sound and
more detailed, taking multiple branches and aliasing into
account. Thus, as shown in Section 6.4, our ICC vulnera-
bility study produces fewer false positives. Finally, Com-
Droid seeks to ﬁnd potential vulnerabilities, whereas our
approach enables ﬁnding attacks for vulnerabilities in ex-
isting applications. This is done by keeping a database
of analysis results and matching newly analyzed applica-
tions with applications in our database. This will allow
us to identify problematic application combinations.

Several kinds of application analysis have been per-
formed for the Android platform [10]. Permission anal-
ysis infers applications properties based on the permis-
sions requested at install time. Kirin [13] uses permis-
sions to ﬂag applications with potential dangerous func-
tionality. Other methods for permission analysis have
been proposed [2, 15, 16], including analyses to detect
over-privileged applications [15] or malware [36].

Dynamic analysis consists in analyzing applications
while they are running. TaintDroid [11] performs dy-
namic taint tracking on Android. It exposes widespread
leakage of personal data to third parties. An extension to
TaintDroid handles implicit ﬂows [18] by monitoring and
recording control ﬂow information. TaintDroid is also
used in the AppFence system [22], which actively pre-
vents sensitive data exﬁltration from mobile devices. Al-
ternative approaches dynamically prevent some classes
of privilege escalation attack through ICC [4, 9]. Dy-
namic analyses such as TaintDroid are limited by the
way they interact with the User Interface (UI). Smart-
Droid [35] tackles this issue by combining static and dy-
namic analyses. It is able to simulate the UI to expose
hidden behavior for seven malwares. As we use static
analysis we do not interact with the UI: the call graph is
complete and does not depend on any runtime condition.
Static analysis consists in analyzing application code
to infer useful properties without running the applica-

tion. Several approaches for static analysis have already
been proposed for Android applications. Enck et al.
use decompilation [28] followed by source code analysis
to characterize security properties of applications [12].
Grace et al. perform a study of the dangers caused by
100 ad libraries found in a sample of 100,000 applica-
tions [20] through a reachability analysis on disassem-
bled bytecode. Several analyses have statically found
permission leaks [17, 19, 25], which happen when a priv-
ileged application leaks its capabilities to unprivileged
ones. These analyses focus on ﬁnding paths between ex-
posed entry points and sensitive API calls, whereas we
focus on connecting exit points to entry points. Thus,
these analyses could beneﬁt from our ICC analysis.

ScanDal [23] attempts to soundly analyze information
ﬂow. It convert Dalvik bytecode to a formally deﬁned
intermediate language. Dangerous ﬂows are detected us-
ing abstract interpretation. Its analysis is path-insensitive
and has limited context-sensitivity. It ﬁnds some actual
privacy leaks, but is limited by a high number of false
positives and ﬂows that are impossible to conﬁrm.

Saint [30] modiﬁes the Android framework to control
application interaction. Every application comes with
a policy describing how it uses permissions it declares.
Policy compliance veriﬁcation is a possible application
of our tool but is out of the scope of this paper.

8 Conclusion

In this paper we have introduced an efﬁcient and sound
technique for inferring ICC speciﬁcations, and demon-
strated its feasibility on a large collection of market ap-
plications. Future work will study a range of applications
and analyses that exploit the database of ICC speciﬁca-
tions. We will also explore a range of extensions that can
use this information at runtime to identify potentially ma-
licious communication between applications. Through
these activities, we aim to aid the community’s efforts to
gauge the security of market applications.

Acknowledgements

We thank Matthew Dering for providing our application
samples. We also thank Atul Prakash, Patrick Traynor
and our shepherd Ben Livshits for editorial comments
during the writing of this paper. This material is based
upon work supported by the National Science Founda-
tion Grants No. CNS-1228700, CNS-0905447, CNS-
1064944 and CNS-0643907. Any opinions, ﬁndings, and
conclusions or recommendations expressed in this mate-
rial are those of the authors and do not necessarily reﬂect
the views of the National Science Foundation. This re-
search is also supported by a Google Faculty Award.

USENIX Association  

22nd USENIX Security Symposium  557

References

[1] ARTHUR, C.

Feature phones dwindle as android powers
ahead in third quarter. The Guardian, Nov. 2012. Available
at http://www.guardian.co.uk/technology/2012/nov/
15/smartphones-market-android-feature-phones.

[2] BARRERA, D., KAYACIK, H. G., VAN OORSHOT, P. C., AND
SOMAYAJI, A. A Methodology for Empirical Analysis of
Permission-Based Security Models and its Application to An-
droid. In Proceedings of the ACM Conference on Computer and
Communications Security (Oct. 2010).

[3] BODDEN, E.

Inter-procedural data-ﬂow analysis with ifds/ide
and soot.
In Proceedings of the ACM SIGPLAN International
Workshop on State of the Art in Java Program analysis (2012).
Available from http://sable.github.com/heros/.

[4] BUGIEL, S., DAVI, L., DMITRIENKO, A., FISCHER, T., AND
SADEGHI, A.-R. XManDroid: A New Android Evolution to
Mitigate Privilege Escalation Attacks. Tech. Rep. TR-2011-04,
Technische Universitat Darmstadt, Germany, Apr. 2011.

[5] BUGIEL, S., DAVI, L., DMITRIENKO, A., FISCHER, T.,
SADEGHI, A.-R., AND SHASTRY, B. Towards taming privilege-
escalation attacks on Android. In Proceedings of the 19th Annual
Network & Distributed System Security Symposium (Feb. 2012).
[6] CHIN, E., FELT, A. P., GREENWOOD, K., AND WAGNER, D.
Analyzing Inter-Application Communication in Android. In Pro-
ceedings of the 9th Annual International Conference on Mobile
Systems, Applications, and Services (MobiSys) (2011).

[7] CHRISTENSEN, A. S., MØLLER, A., AND SCHWARTZBACH,
M. I. Precise analysis of string expressions.
In Proc. 10th
International Static Analysis Symposium (SAS) (June 2003),
vol. 2694 of LNCS, Springer-Verlag, pp. 1–18. Available from
http://www.brics.dk/JSA/.

[8] DAVI, L., DMITRIENKO, A., SADEGHI, A.-R., AND
WINANDY, M. Privilege Escalation Attacks on Android. In Proc.
of the 13th Information Security Conference (ISC) (Oct. 2010).

[9] DIETZ, M., SHEKHAR, S., PISETSKY, Y., SHU, A., AND WAL-
LACH, D. S. Quire: Lightweight Provenance for Smart Phone
Operating Systems. In 20th USENIX Security Symposium (2011).
[10] ENCK, W. Defending users against smartphone apps: Techniques

and future directions. In ICISS (2011), pp. 49–70.

[11] ENCK, W., GILBERT, P., CHUN, B.-G., COX, L. P., JUNG,
J., MCDANIEL, P., AND SHETH, A. N.
TaintDroid: An
Information-Flow Tracking System for Realtime Privacy Moni-
toring on Smartphones.
In Proc. of the 9th USENIX Symp. on
Operating Systems Design and Implementation (OSDI) (2010).

[12] ENCK, W., OCTEAU, D., MCDANIEL, P., AND CHAUDHURI,
S. A Study of Android Application Security. In Proceedings of
the 20th USENIX Security Symposium (August 2011).

[13] ENCK, W., ONGTANG, M., AND MCDANIEL, P.

On
Lightweight Mobile Phone Application Certiﬁcation. In Proceed-
ings of the 16th ACM Conference on Computer and Communica-
tions Security (CCS) (Nov. 2009).

[14] ENCK, W., ONGTANG, M., AND MCDANIEL, P. Understand-
ing Android Security. IEEE Security & Privacy Magazine 7, 1
(January/February 2009), 50–57.

[15] FELT, A. P., CHIN, E., HANNA, S., SONG, D., AND WAGNER,
D. Android Permissions Demystiﬁed. In Proc. of the ACM Conf.
on Computer and Communications Security (CCS) (2011).

[16] FELT, A. P., GREENWOOD, K., AND WAGNER, D. The Ef-
fectiveness of Application Permissions. In Proc. of the USENIX
Conference on Web Application Development (WebApps) (2011).
[17] FELT, A. P., WANG, H. J., MOSHCHUK, A., HANNA, S., AND
CHIN, E. Permission Re-Delegation: Attacks and Defenses. In
Proc. of the 20th USENIX Security Symp. (August 2011).

[18] GILBERT, P., CHUN, B.-G., COX, L. P., AND JUNG, J. Vision:
Automated Security Validation of Mobile Apps at App Markets.
In Proceedings of the International Workshop on Mobile Cloud
Computing and Services (MCS) (2011).

[19] GRACE, M., ZHOU, Y., WANG, Z., AND JIANG, X. Systematic
Detection of Capability Leaks in Stock Android Smartphones. In
NDSS ’12 (2012).

[20] GRACE, M. C., ZHOU, W., JIANG, X., AND SADEGHI, A.-R.
Unsafe exposure analysis of mobile in-app advertisements.
In
Proceedings of the ﬁfth ACM conference on Security and Privacy
in Wireless and Mobile Networks (2012), WISEC ’12, ACM.

[21] HARDY, N. The confused deputy: (or why capabilities might
have been invented). SIGOPS Oper. Syst. Rev. 22, 4 (Oct. 1988).
[22] HORNYACK, P., HAN, S., JUNG, J., SCHECHTER, S., AND
WETHERALL, D. These Aren’t the Droids You’re Looking For:
Retroﬁtting Android to Protect Data from Imperious Applica-
tions. In Proceedings of the ACM Conference on Computer and
Communications Security (CCS) (2011).

[23] KIM, J., YOON, Y., AND YI, K. Scandal: Static analyzer for
detecting privacy leaks in android applications. In MoST 2012:
Workshop on Mobile Security Technologies 2012 (2012).

[24] LHOT ´AK, O., AND HENDREN, L. Scaling java points-to analysis
using spark. In Proceedings of the 12th international conference
on Compiler construction (2003), CC’03, Springer-Verlag.

[25] LU, L., LI, Z., WU, Z., LEE, W., AND JIANG, G. Chex: stat-
ically vetting android apps for component hijacking vulnerabil-
ities.
In Proc. of the 2012 ACM conference on Computer and
communications security (2012), CCS ’12, ACM, pp. 229–240.
[26] MCDANIEL, P., AND ENCK, W. Not So Great Expectations:
Why Application Markets Haven’t Failed Security. IEEE Secu-
rity & Privacy Magazine 8, 5 (September/October 2010), 76–78.
[27] MLOT, S. Google’s bouncer malware tool hacked. PC Mag-
azine, June 2012. Available from http://www.pcmag.com/
article2/0,2817,2405358,00.asp.

[28] OCTEAU, D., ENCK, W., AND MCDANIEL, P. The ded Decom-
piler. Tech. Rep. NAS-TR-0140-2010, Network and Security Re-
search Center, Pennsylvania State University, USA, Sept. 2010.
Available from http://siis.cse.psu.edu/ded/.

[29] OCTEAU, D., JHA, S., AND MCDANIEL, P.

Retarget-
ing android applications to java bytecode.
In Proceed-
ings of the 20th International Symposium on the Foundations
of Software Engineering (November 2012). Available from
http://siis.cse.psu.edu/dare/.

[30] ONGTANG, M., MCLAUGHLIN, S., ENCK, W., AND MC-
DANIEL, P. Semantically Rich Application-Centric Security in
Android. In Proceedings of the 25th Annual Computer Security
Applications Conference (ACSAC) (Dec. 2009), pp. 340–349.

[31] ROSENBERG,

J.

Google play hits 25 billion down-
loads.
Avail-
able at http://officialandroid.blogspot.com/2012/
09/google-play-hits-25-billion-downloads.html.

Android - Ofﬁcial blog, Sept. 2012.

[32] SAGIV, M., REPS, T., AND HORWITZ, S. Precise interprocedu-
ral dataﬂow analysis with applications to constant propagation.
Theor. Comput. Sci. 167, 1-2 (Oct. 1996), 131–170.

[33] SECURITY, N. Malware controls 620,000 phones, sends
costly messages. Help Net Security, January 2013. Avail-
able from http://www.net-security.org/malware_news.
php?id=2391.

[34] VALL ´EE-RAI, R., GAGNON, E., HENDREN, L. J., LAM, P.,
POMINVILLE, P., AND SUNDARESAN, V. Optimizing java byte-
code using the soot framework: Is it feasible? In Proc. of the 9th
International Conf. on Compiler Construction (2000), CC ’00.

[35] ZHENG, C., ZHU, S., DAI, S., GU, G., GONG, X., HAN, X.,
AND ZOU, W. Smartdroid: an automatic system for revealing ui-
based trigger conditions in android applications. In Proceedings
of the second ACM workshop on Security and privacy in smart-
phones and mobile devices (2012), ACM, pp. 93–104.

[36] ZHOU, Y., WANG, Z., ZHOU, W., AND JIANG, X. Hey, You,
Get off of My Market: Detecting Malicious Apps in Ofﬁcial and
Alternative Android Markets. In Proceedings of the Network and
Distributed System Security Symposium (Feb. 2012).

558  22nd USENIX Security Symposium 

USENIX Association

