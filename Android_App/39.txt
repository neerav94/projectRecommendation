 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

The IFDS framework
Our inter-procedural dataﬂow analysis problem is formulated
in terms of the IFDS framework by Reps et al. [25] and can
therefore be reduced to a graph-reachability problem. IFDS
solves inter-procedural, ﬁnite, distributive subset problems
and works by creating a so-called exploded supergraph based
on ﬂow functions associated with the program statements.
A ﬂow function deﬁnes the impact of a statement on a set
of ﬂow facts. For example, the statement x = y would be
associated with a ﬂow function that maps a fact set {y} (i.e.
y is tainted) to a fact set {x, y} (x and y are both tainted).
Function calls are modeled using summary functions, which
makes the approach precise, yet very e cient: at di↵erent
call sites to the same method m, the summary function for
m is just reused (gaining e ciency) but it is applied to the
taint information at that very call site (thus yielding full
context sensitivity). Section 4 gives more details about how
FlowDroid constructs the supergraph.

Once the supergraph is constructed, the algorithm decides
whether a variable x at a statement s is tainted simply by
computing whether the node representing (s, x) is reachable
within this graph. Because all method calls have been ab-
stracted through summary functions, those queries are fully
intra-procedural and therefore highly e cient.
Attacker model
We assume an attacker that can supply an app with arbi-
trary malicious bytecode, obfuscated or not. In the scenario
treated in this paper, the attacker’s goal is to leak private
data through a dangerously broad set of permissions granted
by the user [4]. Our analysis makes sound assumptions on the
installation environment and app inputs, meaning that the
attacker is free to tamper with those as well. FlowDroid
does assume, however, that the attacker has no way of cir-
cumventing the security measures of the Android platform.
Also, right now no static analysis for Android, including
FlowDroid has a way of dealing with dynamic loading and
reﬂection. Bodden et al. showed how those features can be
handled in general [9], however their approach requires access
to a load-time instrumentation API, which is something that
Android does not currently support. We are in contact with
Google to see if such an API can be supported in the future.

3. PRECISE MODELLING OF LIFECYCLE

Multiple entry points. Unlike Java programs, Android ap-
plications do not have a main method. Apps instead comprise
many entry points, i.e., methods that are implicitly called
by the Android framework. The Android operating system
deﬁnes a complete lifecycle for all components in an applica-
tion. There are four di↵erent components an app developer
can deﬁne: activities are single focused user actions, ser-
vices perform background tasks, content providers deﬁne a
database-like storage, and broadcast receivers listen for global
events. All these components are implemented by deriving
a custom class from a predeﬁned operating system class,
registering it in the AndroidManifest.xml ﬁle and overwrit-
ing the lifecycle methods. The Android system calls these
methods at runtime to start or stop the component, or pause
or resume it, depending on environment needs. It can, e.g.,
stop an application because of low memory, and later restart
it when the user returns to it. Figure 1 shows the lifecycle

Activity
launched

onCreate()

User navigates
to the activity

onStart()

onRestart()

User

returns
to the
activity

User navigates
to the activity

App process

killed

Apps with

higher priority
needs memory

onResume()

Activity
running

Another

activity comes

into the foreground

onPause()

The activity is
no longer visible

onStop()

The activity is ﬁnishing or

being destroyed by the system

onDestroy()

Activity
shut down

Figure 1: Android Activity Lifecycle

for an activity. In result, when constructing a call graph,
Android analyses cannot simply start by inspecting a pre-
deﬁned “main” method. Instead, all possible transitions in
the Android lifecycle must be modeled precisely. To cope
with this problem, FlowDroid constructs a custom dummy
main method emulating the lifecycle. However, the lifecycle
is more complex than depicted and explicitly documented.
There are additional methods for saving and restoring state,
as well as callbacks that notify the app about additional state
changes. If not taken into account, a malicious application
could exploit these methods and send out secret information
without being noticed.

Asynchronously executing components. An application
can contain multiple components, e.g., three activities and
one service. The activities run sequentially, however, one can-
not pre-estimate their order. One activity could, for instance,
be the main one initially visible to the user and then launch
either one of the others depending on user input. Services run
in parallel. FlowDroid thus conservatively assumes that all
components (activities, services, etc.) inside an application
to run in an arbitrary sequential order. Within a component,
the analysis is fully ﬂow-sensitive, though. Additionally, the
Android operating system allows applications to register call-
backs for various types of information, e.g., location updates
or UI interactions. Callbacks implement predeﬁned interfaces
declaring methods that are then called asynchronously by
the operating system. FlowDroid models these callbacks
in its dummy main method, for instance to recognize cases
where an application stores to the heap the location data
that is passed into the callback as a parameter, and later
sends this data to the internet when the activity is stopped.
The order in which callbacks are invoked cannot generally
be predicted, which is why FlowDroid conservatively as-

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

The IFDS framework
Our inter-procedural dataﬂow analysis problem is formulated
in terms of the IFDS framework by Reps et al. [25] and can
therefore be reduced to a graph-reachability problem. IFDS
solves inter-procedural, ﬁnite, distributive subset problems
and works by creating a so-called exploded supergraph based
on ﬂow functions associated with the program statements.
A ﬂow function deﬁnes the impact of a statement on a set
of ﬂow facts. For example, the statement x = y would be
associated with a ﬂow function that maps a fact set {y} (i.e.
y is tainted) to a fact set {x, y} (x and y are both tainted).
Function calls are modeled using summary functions, which
makes the approach precise, yet very e cient: at di↵erent
call sites to the same method m, the summary function for
m is just reused (gaining e ciency) but it is applied to the
taint information at that very call site (thus yielding full
context sensitivity). Section 4 gives more details about how
FlowDroid constructs the supergraph.

Once the supergraph is constructed, the algorithm decides
whether a variable x at a statement s is tainted simply by
computing whether the node representing (s, x) is reachable
within this graph. Because all method calls have been ab-
stracted through summary functions, those queries are fully
intra-procedural and therefore highly e cient.
Attacker model
We assume an attacker that can supply an app with arbi-
trary malicious bytecode, obfuscated or not. In the scenario
treated in this paper, the attacker’s goal is to leak private
data through a dangerously broad set of permissions granted
by the user [4]. Our analysis makes sound assumptions on the
installation environment and app inputs, meaning that the
attacker is free to tamper with those as well. FlowDroid
does assume, however, that the attacker has no way of cir-
cumventing the security measures of the Android platform.
Also, right now no static analysis for Android, including
FlowDroid has a way of dealing with dynamic loading and
reﬂection. Bodden et al. showed how those features can be
handled in general [9], however their approach requires access
to a load-time instrumentation API, which is something that
Android does not currently support. We are in contact with
Google to see if such an API can be supported in the future.

3. PRECISE MODELLING OF LIFECYCLE

Multiple entry points. Unlike Java programs, Android ap-
plications do not have a main method. Apps instead comprise
many entry points, i.e., methods that are implicitly called
by the Android framework. The Android operating system
deﬁnes a complete lifecycle for all components in an applica-
tion. There are four di↵erent components an app developer
can deﬁne: activities are single focused user actions, ser-
vices perform background tasks, content providers deﬁne a
database-like storage, and broadcast receivers listen for global
events. All these components are implemented by deriving
a custom class from a predeﬁned operating system class,
registering it in the AndroidManifest.xml ﬁle and overwrit-
ing the lifecycle methods. The Android system calls these
methods at runtime to start or stop the component, or pause
or resume it, depending on environment needs. It can, e.g.,
stop an application because of low memory, and later restart
it when the user returns to it. Figure 1 shows the lifecycle

Activity
launched

onCreate()

User navigates
to the activity

onStart()

onRestart()

User

returns
to the
activity

User navigates
to the activity

App process

killed

Apps with

higher priority
needs memory

onResume()

Activity
running

Another

activity comes

into the foreground

onPause()

The activity is
no longer visible

onStop()

The activity is ﬁnishing or

being destroyed by the system

onDestroy()

Activity
shut down

Figure 1: Android Activity Lifecycle

for an activity. In result, when constructing a call graph,
Android analyses cannot simply start by inspecting a pre-
deﬁned “main” method. Instead, all possible transitions in
the Android lifecycle must be modeled precisely. To cope
with this problem, FlowDroid constructs a custom dummy
main method emulating the lifecycle. However, the lifecycle
is more complex than depicted and explicitly documented.
There are additional methods for saving and restoring state,
as well as callbacks that notify the app about additional state
changes. If not taken into account, a malicious application
could exploit these methods and send out secret information
without being noticed.

Asynchronously executing components. An application
can contain multiple components, e.g., three activities and
one service. The activities run sequentially, however, one can-
not pre-estimate their order. One activity could, for instance,
be the main one initially visible to the user and then launch
either one of the others depending on user input. Services run
in parallel. FlowDroid thus conservatively assumes that all
components (activities, services, etc.) inside an application
to run in an arbitrary sequential order. Within a component,
the analysis is fully ﬂow-sensitive, though. Additionally, the
Android operating system allows applications to register call-
backs for various types of information, e.g., location updates
or UI interactions. Callbacks implement predeﬁned interfaces
declaring methods that are then called asynchronously by
the operating system. FlowDroid models these callbacks
in its dummy main method, for instance to recognize cases
where an application stores to the heap the location data
that is passed into the callback as a parameter, and later
sends this data to the internet when the activity is stopped.
The order in which callbacks are invoked cannot generally
be predicted, which is why FlowDroid conservatively as-

LeakageApp la = new LeakageApp();

la.onCreate();

la.onStart();

la.onResume();

p

p

la.onPause();

p

la.onStop();

p

p

la.onDestroy();

la.sendMessage();

la.onRestart();

5

4

void foo( z ) {

x = z.g;
w = source(); 
x.f = w;

a.g.f

6

void main() { 
7
b.f

a = new A();
b = a.g;
foo(a);
sink(b.f);

}

x.f
} 

3

x.f
2

z.g.f

w

1

Figure 3: Taint analysis under realistic aliasing

Name
V arId
F ieldId
Stmt
Loc
V al = Loc [ {null}
Env : V arId ! V al
Heap : Loc ⇥ F ieldId ! V al Heap
States = Env ⇥ Heap

Description
Program variables
Field identiﬁers
Statements2
Memory locations
Values
Environment

Program States

Figure 2: CFG for dummy main method

Table 1: Formalization Domains

sumes that all callbacks can be invoked in any possible order.
Some static analysis are path-sensitive, i.e., consider each
possible program paths separately. In such cases, considering
all possible orderings would be very expensive. Fortunately,
FlowDroid bases its analysis on IFDS, which is not path-
sensitive and instead joins analysis results immediately at
any control-ﬂow merge point. For FlowDroid can thus
generate a main method in which every order of individual
component lifecycles and callbacks is possible, it does not
need to simulate all possible paths.

Example. In Figure 2 we show the control-ﬂow graph of the
dummy main method for our example. In this ﬁgure, p repre-
sents an opaque predicate of which we know that FlowDroid
won’t be able to evaluate it statically (for instance, a check
involving an environment variable). In result, the analysis
will automatically consider on equal terms both branches for
conditions involving p. Note that, to gain maximal precision,
we generate an individual dummy main method for each app
analyzed. Each main method will only involve the fraction of
the lifecycle that, according to the app’s XML conﬁguration
ﬁles, can actually occur. Disabled activities are automati-
cally ﬁltered and callback methods are only invoked in the
contexts of the components to which they actually belong.
A button click handler is for instance only analyzed in the
context of its respective activity.

4. CONTEXT, OBJECT, FIELD AND FLOW-

SENSITIVE ANALYSIS

One major di culty in the analysis is how to handle alias-
ing with high object sensitivity. Figure 3 shows how Flow-
Droid combines a forward-taint analysis and an on-demand
backward-alias analysis to decide that b.f is tainted at the
3 , where the forward analysis
sink. The important step is
assigns a taint to x.f. On such assignments to the heap, the
backward analysis searches upwards for aliases of x.f, an

idea borrowed from Andromeda [27]. At
is found and then propagated forward.

7 , the alias b.f

To increase the reproducibility of our approach, in this
section we give important details about the di↵erent transfer
functions our analysis associates with program statements.
In the following, ﬁrst we deﬁne an abstract heap model. Sec-
tion 4.1 explains our general taint analysis, while Section 4.2
explains our on-demand alias analysis.

FlowDroid leverages IFDS to propagate each tainted
value individually, using a multi-threaded implementation.
When processing any given statement, the set T of incoming
taints are transformed into a set of outgoing taints. We deﬁne
the abstract analysis semantics with the standard notation
used similarly by Tripp et al. [27]. Table 1 shows our abstract
domain. For representing the e↵ects of program statements,
FlowDroid uses the semantics deﬁned in Table 2. H 2
Heap deﬁnes the current heap, and E 2 Env the current
environment. A program state is deﬁned as   = hE, Hi 2
States.
To be able to explain our taint propagation algorithm in

detail we declare the following helper functions:

arrayElem(x) : V arId ! Boolean returns true i↵ x refer-

ences an array element

static(x) : F ieldId ! Boolean returns true i↵ x is a static

ﬁeld

2FlowDroid operates on an intermediate representation
that represents compound statements through individual
atomic statements.

Statement
x = new Object()
x = y
x.f = y
x = y.f

Semantics
  =  [x ! o 2 Loc. o is fresh]
  =  [E(x) ! E(y)]
  =  [H((E(x), f )) ! E(y)]
  =  [E(x) ! H((E(y), f ))]

Table 2: Program Semantics

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

The IFDS framework
Our inter-procedural dataﬂow analysis problem is formulated
in terms of the IFDS framework by Reps et al. [25] and can
therefore be reduced to a graph-reachability problem. IFDS
solves inter-procedural, ﬁnite, distributive subset problems
and works by creating a so-called exploded supergraph based
on ﬂow functions associated with the program statements.
A ﬂow function deﬁnes the impact of a statement on a set
of ﬂow facts. For example, the statement x = y would be
associated with a ﬂow function that maps a fact set {y} (i.e.
y is tainted) to a fact set {x, y} (x and y are both tainted).
Function calls are modeled using summary functions, which
makes the approach precise, yet very e cient: at di↵erent
call sites to the same method m, the summary function for
m is just reused (gaining e ciency) but it is applied to the
taint information at that very call site (thus yielding full
context sensitivity). Section 4 gives more details about how
FlowDroid constructs the supergraph.

Once the supergraph is constructed, the algorithm decides
whether a variable x at a statement s is tainted simply by
computing whether the node representing (s, x) is reachable
within this graph. Because all method calls have been ab-
stracted through summary functions, those queries are fully
intra-procedural and therefore highly e cient.
Attacker model
We assume an attacker that can supply an app with arbi-
trary malicious bytecode, obfuscated or not. In the scenario
treated in this paper, the attacker’s goal is to leak private
data through a dangerously broad set of permissions granted
by the user [4]. Our analysis makes sound assumptions on the
installation environment and app inputs, meaning that the
attacker is free to tamper with those as well. FlowDroid
does assume, however, that the attacker has no way of cir-
cumventing the security measures of the Android platform.
Also, right now no static analysis for Android, including
FlowDroid has a way of dealing with dynamic loading and
reﬂection. Bodden et al. showed how those features can be
handled in general [9], however their approach requires access
to a load-time instrumentation API, which is something that
Android does not currently support. We are in contact with
Google to see if such an API can be supported in the future.

3. PRECISE MODELLING OF LIFECYCLE

Multiple entry points. Unlike Java programs, Android ap-
plications do not have a main method. Apps instead comprise
many entry points, i.e., methods that are implicitly called
by the Android framework. The Android operating system
deﬁnes a complete lifecycle for all components in an applica-
tion. There are four di↵erent components an app developer
can deﬁne: activities are single focused user actions, ser-
vices perform background tasks, content providers deﬁne a
database-like storage, and broadcast receivers listen for global
events. All these components are implemented by deriving
a custom class from a predeﬁned operating system class,
registering it in the AndroidManifest.xml ﬁle and overwrit-
ing the lifecycle methods. The Android system calls these
methods at runtime to start or stop the component, or pause
or resume it, depending on environment needs. It can, e.g.,
stop an application because of low memory, and later restart
it when the user returns to it. Figure 1 shows the lifecycle

Activity
launched

onCreate()

User navigates
to the activity

onStart()

onRestart()

User

returns
to the
activity

User navigates
to the activity

App process

killed

Apps with

higher priority
needs memory

onResume()

Activity
running

Another

activity comes

into the foreground

onPause()

The activity is
no longer visible

onStop()

The activity is ﬁnishing or

being destroyed by the system

onDestroy()

Activity
shut down

Figure 1: Android Activity Lifecycle

for an activity. In result, when constructing a call graph,
Android analyses cannot simply start by inspecting a pre-
deﬁned “main” method. Instead, all possible transitions in
the Android lifecycle must be modeled precisely. To cope
with this problem, FlowDroid constructs a custom dummy
main method emulating the lifecycle. However, the lifecycle
is more complex than depicted and explicitly documented.
There are additional methods for saving and restoring state,
as well as callbacks that notify the app about additional state
changes. If not taken into account, a malicious application
could exploit these methods and send out secret information
without being noticed.

Asynchronously executing components. An application
can contain multiple components, e.g., three activities and
one service. The activities run sequentially, however, one can-
not pre-estimate their order. One activity could, for instance,
be the main one initially visible to the user and then launch
either one of the others depending on user input. Services run
in parallel. FlowDroid thus conservatively assumes that all
components (activities, services, etc.) inside an application
to run in an arbitrary sequential order. Within a component,
the analysis is fully ﬂow-sensitive, though. Additionally, the
Android operating system allows applications to register call-
backs for various types of information, e.g., location updates
or UI interactions. Callbacks implement predeﬁned interfaces
declaring methods that are then called asynchronously by
the operating system. FlowDroid models these callbacks
in its dummy main method, for instance to recognize cases
where an application stores to the heap the location data
that is passed into the callback as a parameter, and later
sends this data to the internet when the activity is stopped.
The order in which callbacks are invoked cannot generally
be predicted, which is why FlowDroid conservatively as-

LeakageApp la = new LeakageApp();

la.onCreate();

la.onStart();

la.onResume();

p

p

la.onPause();

p

la.onStop();

p

p

la.onDestroy();

la.sendMessage();

la.onRestart();

5

4

void foo( z ) {

x = z.g;
w = source(); 
x.f = w;

a.g.f

6

void main() { 
7
b.f

a = new A();
b = a.g;
foo(a);
sink(b.f);

}

x.f
} 

3

x.f
2

z.g.f

w

1

Figure 3: Taint analysis under realistic aliasing

Name
V arId
F ieldId
Stmt
Loc
V al = Loc [ {null}
Env : V arId ! V al
Heap : Loc ⇥ F ieldId ! V al Heap
States = Env ⇥ Heap

Description
Program variables
Field identiﬁers
Statements2
Memory locations
Values
Environment

Program States

Figure 2: CFG for dummy main method

Table 1: Formalization Domains

sumes that all callbacks can be invoked in any possible order.
Some static analysis are path-sensitive, i.e., consider each
possible program paths separately. In such cases, considering
all possible orderings would be very expensive. Fortunately,
FlowDroid bases its analysis on IFDS, which is not path-
sensitive and instead joins analysis results immediately at
any control-ﬂow merge point. For FlowDroid can thus
generate a main method in which every order of individual
component lifecycles and callbacks is possible, it does not
need to simulate all possible paths.

Example. In Figure 2 we show the control-ﬂow graph of the
dummy main method for our example. In this ﬁgure, p repre-
sents an opaque predicate of which we know that FlowDroid
won’t be able to evaluate it statically (for instance, a check
involving an environment variable). In result, the analysis
will automatically consider on equal terms both branches for
conditions involving p. Note that, to gain maximal precision,
we generate an individual dummy main method for each app
analyzed. Each main method will only involve the fraction of
the lifecycle that, according to the app’s XML conﬁguration
ﬁles, can actually occur. Disabled activities are automati-
cally ﬁltered and callback methods are only invoked in the
contexts of the components to which they actually belong.
A button click handler is for instance only analyzed in the
context of its respective activity.

4. CONTEXT, OBJECT, FIELD AND FLOW-

SENSITIVE ANALYSIS

One major di culty in the analysis is how to handle alias-
ing with high object sensitivity. Figure 3 shows how Flow-
Droid combines a forward-taint analysis and an on-demand
backward-alias analysis to decide that b.f is tainted at the
3 , where the forward analysis
sink. The important step is
assigns a taint to x.f. On such assignments to the heap, the
backward analysis searches upwards for aliases of x.f, an

idea borrowed from Andromeda [27]. At
is found and then propagated forward.

7 , the alias b.f

To increase the reproducibility of our approach, in this
section we give important details about the di↵erent transfer
functions our analysis associates with program statements.
In the following, ﬁrst we deﬁne an abstract heap model. Sec-
tion 4.1 explains our general taint analysis, while Section 4.2
explains our on-demand alias analysis.

FlowDroid leverages IFDS to propagate each tainted
value individually, using a multi-threaded implementation.
When processing any given statement, the set T of incoming
taints are transformed into a set of outgoing taints. We deﬁne
the abstract analysis semantics with the standard notation
used similarly by Tripp et al. [27]. Table 1 shows our abstract
domain. For representing the e↵ects of program statements,
FlowDroid uses the semantics deﬁned in Table 2. H 2
Heap deﬁnes the current heap, and E 2 Env the current
environment. A program state is deﬁned as   = hE, Hi 2
States.
To be able to explain our taint propagation algorithm in

detail we declare the following helper functions:

arrayElem(x) : V arId ! Boolean returns true i↵ x refer-

ences an array element

static(x) : F ieldId ! Boolean returns true i↵ x is a static

ﬁeld

2FlowDroid operates on an intermediate representation
that represents compound statements through individual
atomic statements.

Statement
x = new Object()
x = y
x.f = y
x = y.f

Semantics
  =  [x ! o 2 Loc. o is fresh]
  =  [E(x) ! E(y)]
  =  [H((E(x), f )) ! E(y)]
  =  [E(x) ! H((E(y), f ))]

Table 2: Program Semantics

immut(x) : V arId ! Boolean returns true i↵ x is a primi-

tive or immutable data type (int, String, etc.)

source(s) : Stmt ! P (V arId) returns a set of variable names
tainted by the source statement s or ; if s is no source
native(s) : Stmt ! Boolean returns true i↵ s contains a call

to a native method

nativeT aint(s) : Stmt ! P (V arId) returns values which are
tainted after the native call s 2 Stmt. Such values can
include the base object on which the method was in-
voked, the return value, or one or more of the input
parameters.

nativeAlias(s) : Stmt ! P (V arId) returns possible aliases
of tainted values before the native call s 2 Stmt (back-
wards analysis)

To model deep object sensitivity, FlowDroid does not
simply propagate simple ﬁelds like x.f but instead so-called
access paths [27] up to a ﬁxed length. x.f.g.h for instance
models an access path of length 3. We use the notation
x.f n to describe an arbitrary but ﬁxed access path of length
n, rooted at x. For example x.f 3 represents paths such as
x.f.g.h. Note that x.f 0 is equal to x. The notation allows
us to split ﬁeld accesses such that x.f p = x.f n.f m where
p = m + n. In result, T is actually a set of currently tainted
access paths.

A concrete state is a program state extended by the set
of tainted access paths T resulting in a triple   = hE, H, Ti.
At the beginning it holds that T = ;. Tainted access paths
are added to the set whenever the analysis reaches a call to
a source, or when processing a statement that propagates an
existing taint to a new memory location. We next explain
the di↵erent transfer functions that FlowDroid uses to
compute taints. Section 4.2 explains how we use access paths
to deal with aliasing.
4.1 Taint analysis

The taint analysis starts directly at each of the identiﬁed
and reachable sources. The IFDS framework distinguishes
four di↵erent kinds of ﬂow functions: normal, call, return
and call-to-return.

Normal ﬂow function. Normal ﬂow functions are applied
at all statements that are neither calls nor returns. In Flow-
Droid, only method calls can be the original source of a
taint. Thus, a normal ﬂow function can never generate new
taints, it can only transfer, preserve, or “kill” existing taints.
FlowDroid is insensitive to array indices, tainting the
entire set of array elements even if the program taints just
a single element. To be sound, FlowDroid thus needs to
assume that the entire contents remain tainted, even if the
single array element is overwritten by an untainted value
later-on. For an assignment statement s 2 Stmt with the
structure x.f n = y.f m with n, m 2 N0 the following rules
apply:

T [ {x.f n.f p} 8p : y.f m.f p 2 T
T\{x.f n}
T

y.f m.f⇤ /2 T ^ ¬arrayElem(x.f n)
otherwise

A special case is the new statement which creates a fresh

T s !8<:

object:
T x.f n=new...

        ! T\{x.f n.f⇤ 2 T|¬arrayElem(x.f n)}.

Assigning a fresh object erases the taints for the memory
location referred to by the left-hand side and all access paths
that could be reached through this reference.

Assignments of arithmetic operations such as x = a + b are
treated by tainting the left-hand side if any of the operands
are tainted. For now, FlowDroid uses a simple two-element
security lattice but it can easily be extended to track more
information about the kind of taint that is propagated.

Call ﬂow function. Call ﬂow functions handle ﬂows into
callees of calls such as c.m(a0, . . . , an), n 2 N0. To model
the context change from the body of the caller to the one of
the callee, FlowDroid builds taint set Tcallee based on the
caller’s set Tcaller, replacing references to actual parameters
ai by references to formal parameters pi. If a variable is
tainted in the caller’s context, FlowDroid converts it to
the callee context by replacing c with this.
{this.f m} c.f m 2 Tcaller
ai.f p 2 Tcaller
{pi.f p}
{y.f q}
x.f q 2 Tcaller ^ static(y.f q)

Tcallee

s ! [8<:

Return ﬂow function. At a return (both exceptional and
regular), the return ﬂow function maps taints from the callee’s
context back to the one of the caller. FlowDroid’s return
ﬂow functions specially treats immutable values. Such val-
ues, by their very nature, can never change their taint status.
Thus, if a parameter of an immutable type like String or int
was not tainted before the call it cannot be tainted by the
callee and is thus still guaranteed to be untainted on return.
In all other cases, the taint of all tainted access paths is
mapped back to the caller’s context. The following ﬂow func-
tion applies when the callee returns a variable r after being
called using a statement of the form b = c.m(a0, . . . , an):

Tcaller

s ! [8>><>>:

{c.f m}
this.f m 2 Tcallee
{ai.f p} pi.f p 2 Tcallee ^ ¬immut(ai)
x.f q 2 Tcallee ^ static(y.f q)
{y.f q}
{b.f v}
r.f v 2 Tcallee

Call-to-return ﬂow function. For every call there is also
intra-procedural edge propagating all taint values that are
independent of the callee.
In this function, we generate
taints at sources, through a simple pattern match against an
extensible list of method signatures. We also handle native
method calls here (for details, see Section 5). Again consider
a call b = c.m(a0, . . . , an):

T [ nativeT aint(s, T ) native(s) ^ ai.f m 2 T
T [ {x}
T

x 2 source(s)
otherwise

T s !8<:

4.2 On-demand alias analysis

During our research we experimented a lot with di↵er-
ent ways to resolve aliasing e↵ectively and e ciently. As it
turned out, using ahead-of-time analyses is usually too costly
(because the analysis computes alias information for all pro-
gram variables, not just those that carry taints) and too
imprecise (because the analysis would not support the same
level of context-sensitivity as our taint analysis). We hence
opted for a demand-driven approach by Tripp et al., which
executes within the same context-sensitive IFDS framework
as our taint analysis [27]. As Figure 3 shows, this on-demand
analysis is triggered at assignments to heap variables, i.e.,

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

The IFDS framework
Our inter-procedural dataﬂow analysis problem is formulated
in terms of the IFDS framework by Reps et al. [25] and can
therefore be reduced to a graph-reachability problem. IFDS
solves inter-procedural, ﬁnite, distributive subset problems
and works by creating a so-called exploded supergraph based
on ﬂow functions associated with the program statements.
A ﬂow function deﬁnes the impact of a statement on a set
of ﬂow facts. For example, the statement x = y would be
associated with a ﬂow function that maps a fact set {y} (i.e.
y is tainted) to a fact set {x, y} (x and y are both tainted).
Function calls are modeled using summary functions, which
makes the approach precise, yet very e cient: at di↵erent
call sites to the same method m, the summary function for
m is just reused (gaining e ciency) but it is applied to the
taint information at that very call site (thus yielding full
context sensitivity). Section 4 gives more details about how
FlowDroid constructs the supergraph.

Once the supergraph is constructed, the algorithm decides
whether a variable x at a statement s is tainted simply by
computing whether the node representing (s, x) is reachable
within this graph. Because all method calls have been ab-
stracted through summary functions, those queries are fully
intra-procedural and therefore highly e cient.
Attacker model
We assume an attacker that can supply an app with arbi-
trary malicious bytecode, obfuscated or not. In the scenario
treated in this paper, the attacker’s goal is to leak private
data through a dangerously broad set of permissions granted
by the user [4]. Our analysis makes sound assumptions on the
installation environment and app inputs, meaning that the
attacker is free to tamper with those as well. FlowDroid
does assume, however, that the attacker has no way of cir-
cumventing the security measures of the Android platform.
Also, right now no static analysis for Android, including
FlowDroid has a way of dealing with dynamic loading and
reﬂection. Bodden et al. showed how those features can be
handled in general [9], however their approach requires access
to a load-time instrumentation API, which is something that
Android does not currently support. We are in contact with
Google to see if such an API can be supported in the future.

3. PRECISE MODELLING OF LIFECYCLE

Multiple entry points. Unlike Java programs, Android ap-
plications do not have a main method. Apps instead comprise
many entry points, i.e., methods that are implicitly called
by the Android framework. The Android operating system
deﬁnes a complete lifecycle for all components in an applica-
tion. There are four di↵erent components an app developer
can deﬁne: activities are single focused user actions, ser-
vices perform background tasks, content providers deﬁne a
database-like storage, and broadcast receivers listen for global
events. All these components are implemented by deriving
a custom class from a predeﬁned operating system class,
registering it in the AndroidManifest.xml ﬁle and overwrit-
ing the lifecycle methods. The Android system calls these
methods at runtime to start or stop the component, or pause
or resume it, depending on environment needs. It can, e.g.,
stop an application because of low memory, and later restart
it when the user returns to it. Figure 1 shows the lifecycle

Activity
launched

onCreate()

User navigates
to the activity

onStart()

onRestart()

User

returns
to the
activity

User navigates
to the activity

App process

killed

Apps with

higher priority
needs memory

onResume()

Activity
running

Another

activity comes

into the foreground

onPause()

The activity is
no longer visible

onStop()

The activity is ﬁnishing or

being destroyed by the system

onDestroy()

Activity
shut down

Figure 1: Android Activity Lifecycle

for an activity. In result, when constructing a call graph,
Android analyses cannot simply start by inspecting a pre-
deﬁned “main” method. Instead, all possible transitions in
the Android lifecycle must be modeled precisely. To cope
with this problem, FlowDroid constructs a custom dummy
main method emulating the lifecycle. However, the lifecycle
is more complex than depicted and explicitly documented.
There are additional methods for saving and restoring state,
as well as callbacks that notify the app about additional state
changes. If not taken into account, a malicious application
could exploit these methods and send out secret information
without being noticed.

Asynchronously executing components. An application
can contain multiple components, e.g., three activities and
one service. The activities run sequentially, however, one can-
not pre-estimate their order. One activity could, for instance,
be the main one initially visible to the user and then launch
either one of the others depending on user input. Services run
in parallel. FlowDroid thus conservatively assumes that all
components (activities, services, etc.) inside an application
to run in an arbitrary sequential order. Within a component,
the analysis is fully ﬂow-sensitive, though. Additionally, the
Android operating system allows applications to register call-
backs for various types of information, e.g., location updates
or UI interactions. Callbacks implement predeﬁned interfaces
declaring methods that are then called asynchronously by
the operating system. FlowDroid models these callbacks
in its dummy main method, for instance to recognize cases
where an application stores to the heap the location data
that is passed into the callback as a parameter, and later
sends this data to the internet when the activity is stopped.
The order in which callbacks are invoked cannot generally
be predicted, which is why FlowDroid conservatively as-

LeakageApp la = new LeakageApp();

la.onCreate();

la.onStart();

la.onResume();

p

p

la.onPause();

p

la.onStop();

p

p

la.onDestroy();

la.sendMessage();

la.onRestart();

5

4

void foo( z ) {

x = z.g;
w = source(); 
x.f = w;

a.g.f

6

void main() { 
7
b.f

a = new A();
b = a.g;
foo(a);
sink(b.f);

}

x.f
} 

3

x.f
2

z.g.f

w

1

Figure 3: Taint analysis under realistic aliasing

Name
V arId
F ieldId
Stmt
Loc
V al = Loc [ {null}
Env : V arId ! V al
Heap : Loc ⇥ F ieldId ! V al Heap
States = Env ⇥ Heap

Description
Program variables
Field identiﬁers
Statements2
Memory locations
Values
Environment

Program States

Figure 2: CFG for dummy main method

Table 1: Formalization Domains

sumes that all callbacks can be invoked in any possible order.
Some static analysis are path-sensitive, i.e., consider each
possible program paths separately. In such cases, considering
all possible orderings would be very expensive. Fortunately,
FlowDroid bases its analysis on IFDS, which is not path-
sensitive and instead joins analysis results immediately at
any control-ﬂow merge point. For FlowDroid can thus
generate a main method in which every order of individual
component lifecycles and callbacks is possible, it does not
need to simulate all possible paths.

Example. In Figure 2 we show the control-ﬂow graph of the
dummy main method for our example. In this ﬁgure, p repre-
sents an opaque predicate of which we know that FlowDroid
won’t be able to evaluate it statically (for instance, a check
involving an environment variable). In result, the analysis
will automatically consider on equal terms both branches for
conditions involving p. Note that, to gain maximal precision,
we generate an individual dummy main method for each app
analyzed. Each main method will only involve the fraction of
the lifecycle that, according to the app’s XML conﬁguration
ﬁles, can actually occur. Disabled activities are automati-
cally ﬁltered and callback methods are only invoked in the
contexts of the components to which they actually belong.
A button click handler is for instance only analyzed in the
context of its respective activity.

4. CONTEXT, OBJECT, FIELD AND FLOW-

SENSITIVE ANALYSIS

One major di culty in the analysis is how to handle alias-
ing with high object sensitivity. Figure 3 shows how Flow-
Droid combines a forward-taint analysis and an on-demand
backward-alias analysis to decide that b.f is tainted at the
3 , where the forward analysis
sink. The important step is
assigns a taint to x.f. On such assignments to the heap, the
backward analysis searches upwards for aliases of x.f, an

idea borrowed from Andromeda [27]. At
is found and then propagated forward.

7 , the alias b.f

To increase the reproducibility of our approach, in this
section we give important details about the di↵erent transfer
functions our analysis associates with program statements.
In the following, ﬁrst we deﬁne an abstract heap model. Sec-
tion 4.1 explains our general taint analysis, while Section 4.2
explains our on-demand alias analysis.

FlowDroid leverages IFDS to propagate each tainted
value individually, using a multi-threaded implementation.
When processing any given statement, the set T of incoming
taints are transformed into a set of outgoing taints. We deﬁne
the abstract analysis semantics with the standard notation
used similarly by Tripp et al. [27]. Table 1 shows our abstract
domain. For representing the e↵ects of program statements,
FlowDroid uses the semantics deﬁned in Table 2. H 2
Heap deﬁnes the current heap, and E 2 Env the current
environment. A program state is deﬁned as   = hE, Hi 2
States.
To be able to explain our taint propagation algorithm in

detail we declare the following helper functions:

arrayElem(x) : V arId ! Boolean returns true i↵ x refer-

ences an array element

static(x) : F ieldId ! Boolean returns true i↵ x is a static

ﬁeld

2FlowDroid operates on an intermediate representation
that represents compound statements through individual
atomic statements.

Statement
x = new Object()
x = y
x.f = y
x = y.f

Semantics
  =  [x ! o 2 Loc. o is fresh]
  =  [E(x) ! E(y)]
  =  [H((E(x), f )) ! E(y)]
  =  [E(x) ! H((E(y), f ))]

Table 2: Program Semantics

immut(x) : V arId ! Boolean returns true i↵ x is a primi-

tive or immutable data type (int, String, etc.)

source(s) : Stmt ! P (V arId) returns a set of variable names
tainted by the source statement s or ; if s is no source
native(s) : Stmt ! Boolean returns true i↵ s contains a call

to a native method

nativeT aint(s) : Stmt ! P (V arId) returns values which are
tainted after the native call s 2 Stmt. Such values can
include the base object on which the method was in-
voked, the return value, or one or more of the input
parameters.

nativeAlias(s) : Stmt ! P (V arId) returns possible aliases
of tainted values before the native call s 2 Stmt (back-
wards analysis)

To model deep object sensitivity, FlowDroid does not
simply propagate simple ﬁelds like x.f but instead so-called
access paths [27] up to a ﬁxed length. x.f.g.h for instance
models an access path of length 3. We use the notation
x.f n to describe an arbitrary but ﬁxed access path of length
n, rooted at x. For example x.f 3 represents paths such as
x.f.g.h. Note that x.f 0 is equal to x. The notation allows
us to split ﬁeld accesses such that x.f p = x.f n.f m where
p = m + n. In result, T is actually a set of currently tainted
access paths.

A concrete state is a program state extended by the set
of tainted access paths T resulting in a triple   = hE, H, Ti.
At the beginning it holds that T = ;. Tainted access paths
are added to the set whenever the analysis reaches a call to
a source, or when processing a statement that propagates an
existing taint to a new memory location. We next explain
the di↵erent transfer functions that FlowDroid uses to
compute taints. Section 4.2 explains how we use access paths
to deal with aliasing.
4.1 Taint analysis

The taint analysis starts directly at each of the identiﬁed
and reachable sources. The IFDS framework distinguishes
four di↵erent kinds of ﬂow functions: normal, call, return
and call-to-return.

Normal ﬂow function. Normal ﬂow functions are applied
at all statements that are neither calls nor returns. In Flow-
Droid, only method calls can be the original source of a
taint. Thus, a normal ﬂow function can never generate new
taints, it can only transfer, preserve, or “kill” existing taints.
FlowDroid is insensitive to array indices, tainting the
entire set of array elements even if the program taints just
a single element. To be sound, FlowDroid thus needs to
assume that the entire contents remain tainted, even if the
single array element is overwritten by an untainted value
later-on. For an assignment statement s 2 Stmt with the
structure x.f n = y.f m with n, m 2 N0 the following rules
apply:

T [ {x.f n.f p} 8p : y.f m.f p 2 T
T\{x.f n}
T

y.f m.f⇤ /2 T ^ ¬arrayElem(x.f n)
otherwise

A special case is the new statement which creates a fresh

T s !8<:

object:
T x.f n=new...

        ! T\{x.f n.f⇤ 2 T|¬arrayElem(x.f n)}.

Assigning a fresh object erases the taints for the memory
location referred to by the left-hand side and all access paths
that could be reached through this reference.

Assignments of arithmetic operations such as x = a + b are
treated by tainting the left-hand side if any of the operands
are tainted. For now, FlowDroid uses a simple two-element
security lattice but it can easily be extended to track more
information about the kind of taint that is propagated.

Call ﬂow function. Call ﬂow functions handle ﬂows into
callees of calls such as c.m(a0, . . . , an), n 2 N0. To model
the context change from the body of the caller to the one of
the callee, FlowDroid builds taint set Tcallee based on the
caller’s set Tcaller, replacing references to actual parameters
ai by references to formal parameters pi. If a variable is
tainted in the caller’s context, FlowDroid converts it to
the callee context by replacing c with this.
{this.f m} c.f m 2 Tcaller
ai.f p 2 Tcaller
{pi.f p}
{y.f q}
x.f q 2 Tcaller ^ static(y.f q)

Tcallee

s ! [8<:

Return ﬂow function. At a return (both exceptional and
regular), the return ﬂow function maps taints from the callee’s
context back to the one of the caller. FlowDroid’s return
ﬂow functions specially treats immutable values. Such val-
ues, by their very nature, can never change their taint status.
Thus, if a parameter of an immutable type like String or int
was not tainted before the call it cannot be tainted by the
callee and is thus still guaranteed to be untainted on return.
In all other cases, the taint of all tainted access paths is
mapped back to the caller’s context. The following ﬂow func-
tion applies when the callee returns a variable r after being
called using a statement of the form b = c.m(a0, . . . , an):

Tcaller

s ! [8>><>>:

{c.f m}
this.f m 2 Tcallee
{ai.f p} pi.f p 2 Tcallee ^ ¬immut(ai)
x.f q 2 Tcallee ^ static(y.f q)
{y.f q}
{b.f v}
r.f v 2 Tcallee

Call-to-return ﬂow function. For every call there is also
intra-procedural edge propagating all taint values that are
independent of the callee.
In this function, we generate
taints at sources, through a simple pattern match against an
extensible list of method signatures. We also handle native
method calls here (for details, see Section 5). Again consider
a call b = c.m(a0, . . . , an):

T [ nativeT aint(s, T ) native(s) ^ ai.f m 2 T
T [ {x}
T

x 2 source(s)
otherwise

T s !8<:

4.2 On-demand alias analysis

During our research we experimented a lot with di↵er-
ent ways to resolve aliasing e↵ectively and e ciently. As it
turned out, using ahead-of-time analyses is usually too costly
(because the analysis computes alias information for all pro-
gram variables, not just those that carry taints) and too
imprecise (because the analysis would not support the same
level of context-sensitivity as our taint analysis). We hence
opted for a demand-driven approach by Tripp et al., which
executes within the same context-sensitive IFDS framework
as our taint analysis [27]. As Figure 3 shows, this on-demand
analysis is triggered at assignments to heap variables, i.e.,

statements of the form x.f = v. The alias analysis then walks
backward through the control-ﬂow graph. Whenever it ﬁnds
an alias, it triggers the forward analysis in turn, propagat-
ing an aliased taint from the location at which the alias
was found. Similar to the forward analysis, we deﬁne ﬂow
functions which compute the alias propagation information.
Let the set A deﬁne the alias information. The only ini-
tial element in A is the complete access path of the tainted
value which caused the alias lookup. The backward solver
terminates when A becomes empty.

source, sink and

entry-point detection

parse manifest ﬁle

generate

main method

parse .dex ﬁles

build call graph

parse layout xmls

perform taint

analysis

Normal ﬂow function. For a statement x.f = y.g the fol-
lowing rule applies:

A s ! [⇢ A\{x.f.f p} [ {y.g.f p} 8p : x.f.f p 2 A

otherwise

A

For new statements, FlowDroid erases all alias informa-
tion for the left-hand side, as fresh objects cannot be aliased:
A x.f =new...

       ! A\{8m : x.f.f⇤ 2 A}

Call ﬂow function. Since the backward analysis traverses
the control-ﬂow graph backwards, its call ﬂow function prop-
agates information from call sites to return sites in the callee.
Consider again a call b = c.m(a0, . . . , an) and a return site
returning a variable r:
b.f m 2 Acaller
{r.f m}
{this.f m} c.f m 2 Acaller
{y.f q}
y.f q 2 Acaller ^ static(y.f q)

Acallee

s ! [8<:

Return ﬂow function. In the backwards analysis, return
ﬂow functions propagate from the callee’s start point to just
before the call site. The return ﬂow function thus maps the
callee’s aliases at back to the caller while taking into account
renaming from formal parameters pi to actual parameters ai.
For a call site c.m(a0, . . . , an) we obtain:
this.f m 2 Acallee
y.f q 2 Acallee ^ static(y.f q)

{c.f m}
{ai.f p} pi.f p 2 Acallee
{y.f q}

Acaller

s ! [8<:
A s !8>><>>:

Call-to-return ﬂow function. For a call site b = c.m(a0, . . . , an),
the call-to-return ﬂow function handles aliases induced by
native calls and kills aliases of references obtained through b:

A [ nativeAlias(s) native(s)
^(ai.f m 2 A _ c.f n 2 A)
A\{b.f n}
b.f n 2 A
otherwise
A

5.

IMPLEMENTATION

FlowDroid extends the Soot framework [16] which pro-
vides important prerequisites for a precise analysis, in par-
ticular a very accurate call graph. Through a plugin called
Dexpler [5] Soot supports not only converting Java code but
also Android’s dex ﬁles into the Jimple intermediate repre-
sentation which allows us to implement our analysis for both
targets. FlowDroid further uses Heros [8] as an implemen-
tation of IFDS on top of Soot and Dexpler. We next explain
FlowDroid’s architecture, while the subsequent sections
explain interesting implementation details and FlowDroid’s
current limitations.

Figure 4: Overview of FlowDroid

Architecture. Figure 4 shows FlowDroid’s architecture.
Android applications are packaged in apk ﬁles (Android Pack-
ages), which are essentially zip-compressed archives. After
unzipping an archive, FlowDroid searches for lifecycle and
callback methods as well as calls to sources and sinks in the
application. This is done by parsing various Android-speciﬁc
ﬁles, including the layout XML ﬁles, the dex ﬁles contain-
ing the executable code and the manifest ﬁle deﬁning the
activities, services, broadcast receivers and content providers
in the application. We describe the detection of UI Inter-
actions in detail below. Next, FlowDroid generates the
main method from the list of lifecycle and callback methods
(see the Paragraphs Callbacks and Substitution Classes for
more information). This main method is then used to gener-
ate a call graph and an inter-procedural control-ﬂow graph
(ICFG). Starting at the detected sources, the taint analysis
then tracks taints by traversing the ICFG as explained in
Section 4. Native Calls require a special treatment which
is described below along with a performance optimization
called Taint Wrapping. At the end, FlowDroid reports all
discovered ﬂows from sources to sinks.

UI Interactions. UI elements can be taint sources, e.g., if
an application prompts the user for a password and then
sends it out to the Internet. FlowDroid thus scans the
layout XML ﬁles in the apk ﬁle for text inputs and links
them to the source-code statements where they are accessed.
This is non-trivial, as the Android operating system manages
access to such resources at runtime and a static analysis tool
must simulate these runtime APIs as precisely as possible.
Note that we need to over-approximate resource accesses in
the general case, though. In Android, resource mappings can
be conﬁguration-dependent, for instance to support di↵erent
layouts for smartphones and tablets. In this case, we can
only assume all cases as possible. Not all data in text ﬁelds
is sensitive, though. FlowDroid can be conﬁgured to either
consider all text ﬁelds or to restrict itself to special sensitive
ﬁelds like password input ﬁelds (the default).

Callbacks. To model the app lifecycle correctly (see Sec-
tion 3), FlowDroid contains a list of callback interfaces
extracted from the Android documentation. FlowDroid
ﬁrst computes a call graph ignoring callbacks, to determine
which activity will potentially register which kind of callback
at runtime. Next, FlowDroid generates a customized main
method for each activity, taking the respective discovered
callbacks into account.

Substitution Classes. J2EE and Android applications some-
times operate on interface types or abstract class types that
at runtime receive objects instantiated within the J2EE or

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

The IFDS framework
Our inter-procedural dataﬂow analysis problem is formulated
in terms of the IFDS framework by Reps et al. [25] and can
therefore be reduced to a graph-reachability problem. IFDS
solves inter-procedural, ﬁnite, distributive subset problems
and works by creating a so-called exploded supergraph based
on ﬂow functions associated with the program statements.
A ﬂow function deﬁnes the impact of a statement on a set
of ﬂow facts. For example, the statement x = y would be
associated with a ﬂow function that maps a fact set {y} (i.e.
y is tainted) to a fact set {x, y} (x and y are both tainted).
Function calls are modeled using summary functions, which
makes the approach precise, yet very e cient: at di↵erent
call sites to the same method m, the summary function for
m is just reused (gaining e ciency) but it is applied to the
taint information at that very call site (thus yielding full
context sensitivity). Section 4 gives more details about how
FlowDroid constructs the supergraph.

Once the supergraph is constructed, the algorithm decides
whether a variable x at a statement s is tainted simply by
computing whether the node representing (s, x) is reachable
within this graph. Because all method calls have been ab-
stracted through summary functions, those queries are fully
intra-procedural and therefore highly e cient.
Attacker model
We assume an attacker that can supply an app with arbi-
trary malicious bytecode, obfuscated or not. In the scenario
treated in this paper, the attacker’s goal is to leak private
data through a dangerously broad set of permissions granted
by the user [4]. Our analysis makes sound assumptions on the
installation environment and app inputs, meaning that the
attacker is free to tamper with those as well. FlowDroid
does assume, however, that the attacker has no way of cir-
cumventing the security measures of the Android platform.
Also, right now no static analysis for Android, including
FlowDroid has a way of dealing with dynamic loading and
reﬂection. Bodden et al. showed how those features can be
handled in general [9], however their approach requires access
to a load-time instrumentation API, which is something that
Android does not currently support. We are in contact with
Google to see if such an API can be supported in the future.

3. PRECISE MODELLING OF LIFECYCLE

Multiple entry points. Unlike Java programs, Android ap-
plications do not have a main method. Apps instead comprise
many entry points, i.e., methods that are implicitly called
by the Android framework. The Android operating system
deﬁnes a complete lifecycle for all components in an applica-
tion. There are four di↵erent components an app developer
can deﬁne: activities are single focused user actions, ser-
vices perform background tasks, content providers deﬁne a
database-like storage, and broadcast receivers listen for global
events. All these components are implemented by deriving
a custom class from a predeﬁned operating system class,
registering it in the AndroidManifest.xml ﬁle and overwrit-
ing the lifecycle methods. The Android system calls these
methods at runtime to start or stop the component, or pause
or resume it, depending on environment needs. It can, e.g.,
stop an application because of low memory, and later restart
it when the user returns to it. Figure 1 shows the lifecycle

Activity
launched

onCreate()

User navigates
to the activity

onStart()

onRestart()

User

returns
to the
activity

User navigates
to the activity

App process

killed

Apps with

higher priority
needs memory

onResume()

Activity
running

Another

activity comes

into the foreground

onPause()

The activity is
no longer visible

onStop()

The activity is ﬁnishing or

being destroyed by the system

onDestroy()

Activity
shut down

Figure 1: Android Activity Lifecycle

for an activity. In result, when constructing a call graph,
Android analyses cannot simply start by inspecting a pre-
deﬁned “main” method. Instead, all possible transitions in
the Android lifecycle must be modeled precisely. To cope
with this problem, FlowDroid constructs a custom dummy
main method emulating the lifecycle. However, the lifecycle
is more complex than depicted and explicitly documented.
There are additional methods for saving and restoring state,
as well as callbacks that notify the app about additional state
changes. If not taken into account, a malicious application
could exploit these methods and send out secret information
without being noticed.

Asynchronously executing components. An application
can contain multiple components, e.g., three activities and
one service. The activities run sequentially, however, one can-
not pre-estimate their order. One activity could, for instance,
be the main one initially visible to the user and then launch
either one of the others depending on user input. Services run
in parallel. FlowDroid thus conservatively assumes that all
components (activities, services, etc.) inside an application
to run in an arbitrary sequential order. Within a component,
the analysis is fully ﬂow-sensitive, though. Additionally, the
Android operating system allows applications to register call-
backs for various types of information, e.g., location updates
or UI interactions. Callbacks implement predeﬁned interfaces
declaring methods that are then called asynchronously by
the operating system. FlowDroid models these callbacks
in its dummy main method, for instance to recognize cases
where an application stores to the heap the location data
that is passed into the callback as a parameter, and later
sends this data to the internet when the activity is stopped.
The order in which callbacks are invoked cannot generally
be predicted, which is why FlowDroid conservatively as-

LeakageApp la = new LeakageApp();

la.onCreate();

la.onStart();

la.onResume();

p

p

la.onPause();

p

la.onStop();

p

p

la.onDestroy();

la.sendMessage();

la.onRestart();

5

4

void foo( z ) {

x = z.g;
w = source(); 
x.f = w;

a.g.f

6

void main() { 
7
b.f

a = new A();
b = a.g;
foo(a);
sink(b.f);

}

x.f
} 

3

x.f
2

z.g.f

w

1

Figure 3: Taint analysis under realistic aliasing

Name
V arId
F ieldId
Stmt
Loc
V al = Loc [ {null}
Env : V arId ! V al
Heap : Loc ⇥ F ieldId ! V al Heap
States = Env ⇥ Heap

Description
Program variables
Field identiﬁers
Statements2
Memory locations
Values
Environment

Program States

Figure 2: CFG for dummy main method

Table 1: Formalization Domains

sumes that all callbacks can be invoked in any possible order.
Some static analysis are path-sensitive, i.e., consider each
possible program paths separately. In such cases, considering
all possible orderings would be very expensive. Fortunately,
FlowDroid bases its analysis on IFDS, which is not path-
sensitive and instead joins analysis results immediately at
any control-ﬂow merge point. For FlowDroid can thus
generate a main method in which every order of individual
component lifecycles and callbacks is possible, it does not
need to simulate all possible paths.

Example. In Figure 2 we show the control-ﬂow graph of the
dummy main method for our example. In this ﬁgure, p repre-
sents an opaque predicate of which we know that FlowDroid
won’t be able to evaluate it statically (for instance, a check
involving an environment variable). In result, the analysis
will automatically consider on equal terms both branches for
conditions involving p. Note that, to gain maximal precision,
we generate an individual dummy main method for each app
analyzed. Each main method will only involve the fraction of
the lifecycle that, according to the app’s XML conﬁguration
ﬁles, can actually occur. Disabled activities are automati-
cally ﬁltered and callback methods are only invoked in the
contexts of the components to which they actually belong.
A button click handler is for instance only analyzed in the
context of its respective activity.

4. CONTEXT, OBJECT, FIELD AND FLOW-

SENSITIVE ANALYSIS

One major di culty in the analysis is how to handle alias-
ing with high object sensitivity. Figure 3 shows how Flow-
Droid combines a forward-taint analysis and an on-demand
backward-alias analysis to decide that b.f is tainted at the
3 , where the forward analysis
sink. The important step is
assigns a taint to x.f. On such assignments to the heap, the
backward analysis searches upwards for aliases of x.f, an

idea borrowed from Andromeda [27]. At
is found and then propagated forward.

7 , the alias b.f

To increase the reproducibility of our approach, in this
section we give important details about the di↵erent transfer
functions our analysis associates with program statements.
In the following, ﬁrst we deﬁne an abstract heap model. Sec-
tion 4.1 explains our general taint analysis, while Section 4.2
explains our on-demand alias analysis.

FlowDroid leverages IFDS to propagate each tainted
value individually, using a multi-threaded implementation.
When processing any given statement, the set T of incoming
taints are transformed into a set of outgoing taints. We deﬁne
the abstract analysis semantics with the standard notation
used similarly by Tripp et al. [27]. Table 1 shows our abstract
domain. For representing the e↵ects of program statements,
FlowDroid uses the semantics deﬁned in Table 2. H 2
Heap deﬁnes the current heap, and E 2 Env the current
environment. A program state is deﬁned as   = hE, Hi 2
States.
To be able to explain our taint propagation algorithm in

detail we declare the following helper functions:

arrayElem(x) : V arId ! Boolean returns true i↵ x refer-

ences an array element

static(x) : F ieldId ! Boolean returns true i↵ x is a static

ﬁeld

2FlowDroid operates on an intermediate representation
that represents compound statements through individual
atomic statements.

Statement
x = new Object()
x = y
x.f = y
x = y.f

Semantics
  =  [x ! o 2 Loc. o is fresh]
  =  [E(x) ! E(y)]
  =  [H((E(x), f )) ! E(y)]
  =  [E(x) ! H((E(y), f ))]

Table 2: Program Semantics

immut(x) : V arId ! Boolean returns true i↵ x is a primi-

tive or immutable data type (int, String, etc.)

source(s) : Stmt ! P (V arId) returns a set of variable names
tainted by the source statement s or ; if s is no source
native(s) : Stmt ! Boolean returns true i↵ s contains a call

to a native method

nativeT aint(s) : Stmt ! P (V arId) returns values which are
tainted after the native call s 2 Stmt. Such values can
include the base object on which the method was in-
voked, the return value, or one or more of the input
parameters.

nativeAlias(s) : Stmt ! P (V arId) returns possible aliases
of tainted values before the native call s 2 Stmt (back-
wards analysis)

To model deep object sensitivity, FlowDroid does not
simply propagate simple ﬁelds like x.f but instead so-called
access paths [27] up to a ﬁxed length. x.f.g.h for instance
models an access path of length 3. We use the notation
x.f n to describe an arbitrary but ﬁxed access path of length
n, rooted at x. For example x.f 3 represents paths such as
x.f.g.h. Note that x.f 0 is equal to x. The notation allows
us to split ﬁeld accesses such that x.f p = x.f n.f m where
p = m + n. In result, T is actually a set of currently tainted
access paths.

A concrete state is a program state extended by the set
of tainted access paths T resulting in a triple   = hE, H, Ti.
At the beginning it holds that T = ;. Tainted access paths
are added to the set whenever the analysis reaches a call to
a source, or when processing a statement that propagates an
existing taint to a new memory location. We next explain
the di↵erent transfer functions that FlowDroid uses to
compute taints. Section 4.2 explains how we use access paths
to deal with aliasing.
4.1 Taint analysis

The taint analysis starts directly at each of the identiﬁed
and reachable sources. The IFDS framework distinguishes
four di↵erent kinds of ﬂow functions: normal, call, return
and call-to-return.

Normal ﬂow function. Normal ﬂow functions are applied
at all statements that are neither calls nor returns. In Flow-
Droid, only method calls can be the original source of a
taint. Thus, a normal ﬂow function can never generate new
taints, it can only transfer, preserve, or “kill” existing taints.
FlowDroid is insensitive to array indices, tainting the
entire set of array elements even if the program taints just
a single element. To be sound, FlowDroid thus needs to
assume that the entire contents remain tainted, even if the
single array element is overwritten by an untainted value
later-on. For an assignment statement s 2 Stmt with the
structure x.f n = y.f m with n, m 2 N0 the following rules
apply:

T [ {x.f n.f p} 8p : y.f m.f p 2 T
T\{x.f n}
T

y.f m.f⇤ /2 T ^ ¬arrayElem(x.f n)
otherwise

A special case is the new statement which creates a fresh

T s !8<:

object:
T x.f n=new...

        ! T\{x.f n.f⇤ 2 T|¬arrayElem(x.f n)}.

Assigning a fresh object erases the taints for the memory
location referred to by the left-hand side and all access paths
that could be reached through this reference.

Assignments of arithmetic operations such as x = a + b are
treated by tainting the left-hand side if any of the operands
are tainted. For now, FlowDroid uses a simple two-element
security lattice but it can easily be extended to track more
information about the kind of taint that is propagated.

Call ﬂow function. Call ﬂow functions handle ﬂows into
callees of calls such as c.m(a0, . . . , an), n 2 N0. To model
the context change from the body of the caller to the one of
the callee, FlowDroid builds taint set Tcallee based on the
caller’s set Tcaller, replacing references to actual parameters
ai by references to formal parameters pi. If a variable is
tainted in the caller’s context, FlowDroid converts it to
the callee context by replacing c with this.
{this.f m} c.f m 2 Tcaller
ai.f p 2 Tcaller
{pi.f p}
{y.f q}
x.f q 2 Tcaller ^ static(y.f q)

Tcallee

s ! [8<:

Return ﬂow function. At a return (both exceptional and
regular), the return ﬂow function maps taints from the callee’s
context back to the one of the caller. FlowDroid’s return
ﬂow functions specially treats immutable values. Such val-
ues, by their very nature, can never change their taint status.
Thus, if a parameter of an immutable type like String or int
was not tainted before the call it cannot be tainted by the
callee and is thus still guaranteed to be untainted on return.
In all other cases, the taint of all tainted access paths is
mapped back to the caller’s context. The following ﬂow func-
tion applies when the callee returns a variable r after being
called using a statement of the form b = c.m(a0, . . . , an):

Tcaller

s ! [8>><>>:

{c.f m}
this.f m 2 Tcallee
{ai.f p} pi.f p 2 Tcallee ^ ¬immut(ai)
x.f q 2 Tcallee ^ static(y.f q)
{y.f q}
{b.f v}
r.f v 2 Tcallee

Call-to-return ﬂow function. For every call there is also
intra-procedural edge propagating all taint values that are
independent of the callee.
In this function, we generate
taints at sources, through a simple pattern match against an
extensible list of method signatures. We also handle native
method calls here (for details, see Section 5). Again consider
a call b = c.m(a0, . . . , an):

T [ nativeT aint(s, T ) native(s) ^ ai.f m 2 T
T [ {x}
T

x 2 source(s)
otherwise

T s !8<:

4.2 On-demand alias analysis

During our research we experimented a lot with di↵er-
ent ways to resolve aliasing e↵ectively and e ciently. As it
turned out, using ahead-of-time analyses is usually too costly
(because the analysis computes alias information for all pro-
gram variables, not just those that carry taints) and too
imprecise (because the analysis would not support the same
level of context-sensitivity as our taint analysis). We hence
opted for a demand-driven approach by Tripp et al., which
executes within the same context-sensitive IFDS framework
as our taint analysis [27]. As Figure 3 shows, this on-demand
analysis is triggered at assignments to heap variables, i.e.,

statements of the form x.f = v. The alias analysis then walks
backward through the control-ﬂow graph. Whenever it ﬁnds
an alias, it triggers the forward analysis in turn, propagat-
ing an aliased taint from the location at which the alias
was found. Similar to the forward analysis, we deﬁne ﬂow
functions which compute the alias propagation information.
Let the set A deﬁne the alias information. The only ini-
tial element in A is the complete access path of the tainted
value which caused the alias lookup. The backward solver
terminates when A becomes empty.

source, sink and

entry-point detection

parse manifest ﬁle

generate

main method

parse .dex ﬁles

build call graph

parse layout xmls

perform taint

analysis

Normal ﬂow function. For a statement x.f = y.g the fol-
lowing rule applies:

A s ! [⇢ A\{x.f.f p} [ {y.g.f p} 8p : x.f.f p 2 A

otherwise

A

For new statements, FlowDroid erases all alias informa-
tion for the left-hand side, as fresh objects cannot be aliased:
A x.f =new...

       ! A\{8m : x.f.f⇤ 2 A}

Call ﬂow function. Since the backward analysis traverses
the control-ﬂow graph backwards, its call ﬂow function prop-
agates information from call sites to return sites in the callee.
Consider again a call b = c.m(a0, . . . , an) and a return site
returning a variable r:
b.f m 2 Acaller
{r.f m}
{this.f m} c.f m 2 Acaller
{y.f q}
y.f q 2 Acaller ^ static(y.f q)

Acallee

s ! [8<:

Return ﬂow function. In the backwards analysis, return
ﬂow functions propagate from the callee’s start point to just
before the call site. The return ﬂow function thus maps the
callee’s aliases at back to the caller while taking into account
renaming from formal parameters pi to actual parameters ai.
For a call site c.m(a0, . . . , an) we obtain:
this.f m 2 Acallee
y.f q 2 Acallee ^ static(y.f q)

{c.f m}
{ai.f p} pi.f p 2 Acallee
{y.f q}

Acaller

s ! [8<:
A s !8>><>>:

Call-to-return ﬂow function. For a call site b = c.m(a0, . . . , an),
the call-to-return ﬂow function handles aliases induced by
native calls and kills aliases of references obtained through b:

A [ nativeAlias(s) native(s)
^(ai.f m 2 A _ c.f n 2 A)
A\{b.f n}
b.f n 2 A
otherwise
A

5.

IMPLEMENTATION

FlowDroid extends the Soot framework [16] which pro-
vides important prerequisites for a precise analysis, in par-
ticular a very accurate call graph. Through a plugin called
Dexpler [5] Soot supports not only converting Java code but
also Android’s dex ﬁles into the Jimple intermediate repre-
sentation which allows us to implement our analysis for both
targets. FlowDroid further uses Heros [8] as an implemen-
tation of IFDS on top of Soot and Dexpler. We next explain
FlowDroid’s architecture, while the subsequent sections
explain interesting implementation details and FlowDroid’s
current limitations.

Figure 4: Overview of FlowDroid

Architecture. Figure 4 shows FlowDroid’s architecture.
Android applications are packaged in apk ﬁles (Android Pack-
ages), which are essentially zip-compressed archives. After
unzipping an archive, FlowDroid searches for lifecycle and
callback methods as well as calls to sources and sinks in the
application. This is done by parsing various Android-speciﬁc
ﬁles, including the layout XML ﬁles, the dex ﬁles contain-
ing the executable code and the manifest ﬁle deﬁning the
activities, services, broadcast receivers and content providers
in the application. We describe the detection of UI Inter-
actions in detail below. Next, FlowDroid generates the
main method from the list of lifecycle and callback methods
(see the Paragraphs Callbacks and Substitution Classes for
more information). This main method is then used to gener-
ate a call graph and an inter-procedural control-ﬂow graph
(ICFG). Starting at the detected sources, the taint analysis
then tracks taints by traversing the ICFG as explained in
Section 4. Native Calls require a special treatment which
is described below along with a performance optimization
called Taint Wrapping. At the end, FlowDroid reports all
discovered ﬂows from sources to sinks.

UI Interactions. UI elements can be taint sources, e.g., if
an application prompts the user for a password and then
sends it out to the Internet. FlowDroid thus scans the
layout XML ﬁles in the apk ﬁle for text inputs and links
them to the source-code statements where they are accessed.
This is non-trivial, as the Android operating system manages
access to such resources at runtime and a static analysis tool
must simulate these runtime APIs as precisely as possible.
Note that we need to over-approximate resource accesses in
the general case, though. In Android, resource mappings can
be conﬁguration-dependent, for instance to support di↵erent
layouts for smartphones and tablets. In this case, we can
only assume all cases as possible. Not all data in text ﬁelds
is sensitive, though. FlowDroid can be conﬁgured to either
consider all text ﬁelds or to restrict itself to special sensitive
ﬁelds like password input ﬁelds (the default).

Callbacks. To model the app lifecycle correctly (see Sec-
tion 3), FlowDroid contains a list of callback interfaces
extracted from the Android documentation. FlowDroid
ﬁrst computes a call graph ignoring callbacks, to determine
which activity will potentially register which kind of callback
at runtime. Next, FlowDroid generates a customized main
method for each activity, taking the respective discovered
callbacks into account.

Substitution Classes. J2EE and Android applications some-
times operate on interface types or abstract class types that
at runtime receive objects instantiated within the J2EE or

Android framework. FlowDroid’s main-method generator
cannot easily be aware of those concrete subtypes. Flow-
Droid thus allows the analysis designer to provide a list of
so-called substitution classes. A substitution class provides
a concrete implementation for one or more of these inter-
faces, simply for the purpose of the analysis. The user can
choose whether to provide a stub or a real implementation,
depending on whether the designer aims for higher precision
or scalability. For Android, substitution classes are required,
for instance, for the abstract class android.context.Context.

Native Calls. Both Java and the Android platform support
invoking native methods written in C or other unmanaged
languages. For a Java-based analysis, such methods are black
boxes which cannot be resolved. We thus deﬁned explicit
taint propagation rules for the most common native methods,
such as arraycopy in java.lang.System. In this example, third
argument (the output array) will become tainted if the ﬁrst
argument (the input array) is tainted before the call. For
native methods without an explicit rule, we assume call
arguments and the return value to become tainted if at
least one parameter was tainted before. This is neither
entirely sound nor maximally precise but is probably the
only practical approximation in a black-box setting.

Taint Wrapping. Including the full JRE or Android plat-
form runtime in the analysis requires a lot of time and mem-
ory and can lead to unwanted imprecisions. Thus, while
explicit taint-propagation rules are required for native meth-
ods, they can be useful for regular Java methods as well:
their use can prevent the taint propagation from having
to analyze the library’s internals. FlowDroid supports a
simple textual ﬁle format for deﬁning such “shortcut rules”.
Predeﬁned rules handle collection classes, string bu↵ers and
similar commonly used data structures.

Limitations. At the moment FlowDroid ignores reﬂective
calls, which is unsound. While specialized static string anal-
yses can be used to simulate reﬂection to some extent, past
research has found such analyses to be incomplete [9], as
reﬂective call targets are often determined by external conﬁg-
uration ﬁles. On the Java platform, reﬂection-analysis tools
such as TamiFlex [9] can be used to make static analysis
tools aware of reﬂective calls. Such tool require load-time
instrumentation through java.lang.instrument, however, which
the Android platform does not currently support.

As described above, native code is approximated conser-
vatively using taint wrapping. Another limitation of Flow-
Droid is its current focus on explicit data ﬂows. Implicit
ﬂows caused by control-ﬂow dependencies are currently ig-
nored, but we plan to include them in the near future. Flow-
Droid also ignores probabilistic and possibilistic leaks caused
by multi-threading [13].

6. EXPERIMANTAL EVALUATION

Our evaluation addresses the following research questions:

RQ1 How does FlowDroid compare to commercial taint-
analysis tools for Android, both in terms of precision
and recall?

RQ2 Can FlowDroid ﬁnd all privacy leaks in Insecure-
Bank, an app speciﬁcally designed by others to chal-

lenge vulnerability-detection tools for Android [21], and
what is its performance?

RQ3 Can FlowDroid ﬁnd leaks in real-world applications

and how fast is it?

RQ4 How well does FlowDroid perform when being ap-
plied to taint-analysis problems related to Java, not
Android, both in terms of precision and recall?

The next sections address each research question in detail.
Section 6.5 explains why, unfortunately, we were unable to
directly compare FlowDroid to academic Android analysis
tools published elsewhere.
6.1 RQ1: Commercial taint-analysis tools

While there are benchmark suites for analyzing web appli-
cations or speciﬁcally for detecting di↵erent kinds of Java vul-
nerabilities [17], at the moment there is no Android-speciﬁc
analysis benchmark suite. This is problematic because the
generic Java test suites do not cover aspects like the An-
droid lifecycle, callbacks or interactions with UI elements
like password ﬁelds. Thus, they cannot be used for assessing
the practical e↵ectiveness of Android analysis tools.

DroidBench. Speciﬁcally for this work, we therefore de-
veloped an Android-speciﬁc test suite called DroidBench
containing 39 small Android apps. The suite can be used
to assess both static and dynamic taint analyses, but in
particular it contains test cases for interesting static-analysis
problems (ﬁeld sensitivity, object sensitivity, tradeo↵s in
access-path lengths etc.) as well as for Android-speciﬁc
challenges like correctly modeling an application’s lifecycle,
adequately handling asynchronous callbacks and interacting
with the UI. Table 3 contains a list of all apps in the suite
together with their respective names and short descriptions.
The table also indicates whether an analysis tool must model
the Android lifecycle or callback infrastructure to be able to
successfully analyze the app. We envision our test suite to
be extended by other researchers as well and then be used
to compare the completeness and correctness of the various
taint analysis approaches. DroidBench is available from
our project website.

Table 5 presents the analysis results for FlowDroid and
two commercial analysis tools explained in the following.
As the results show, FlowDroid generally performs quite
well. As explained before, for performance reasons, Flow-
Droid handles array indices imprecisely. The same limi-
tation applies to ListAccess1, causing false positives in the
ﬁrst category. Handling indices precisely and e ciently is an
interesting open research question. Button2 causes a false
positive because FlowDroid does not currently support
strong updates. In result, it cannot kill taints for certain
button combinations. Strong updates would require a must-
alias analysis which is hard to achieve inter-procedurally.
IntentSink1 is not detected because the test case contains no
actual sink. Instead, the tainted value is stored in an intent
which is then handed back to the activity by the framework.
Such cases are hard to handle without special treatment.
StaticInitialization1 fails because Soot currently assumes
all static initializers to execute at the beginning of the pro-
gram, which in this case is not correct. We plan to add
better support in the future. As most known taint-analysis
tools, FlowDroid currently disregards implicit ﬂows caused
through control-ﬂow dependencies.

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

The IFDS framework
Our inter-procedural dataﬂow analysis problem is formulated
in terms of the IFDS framework by Reps et al. [25] and can
therefore be reduced to a graph-reachability problem. IFDS
solves inter-procedural, ﬁnite, distributive subset problems
and works by creating a so-called exploded supergraph based
on ﬂow functions associated with the program statements.
A ﬂow function deﬁnes the impact of a statement on a set
of ﬂow facts. For example, the statement x = y would be
associated with a ﬂow function that maps a fact set {y} (i.e.
y is tainted) to a fact set {x, y} (x and y are both tainted).
Function calls are modeled using summary functions, which
makes the approach precise, yet very e cient: at di↵erent
call sites to the same method m, the summary function for
m is just reused (gaining e ciency) but it is applied to the
taint information at that very call site (thus yielding full
context sensitivity). Section 4 gives more details about how
FlowDroid constructs the supergraph.

Once the supergraph is constructed, the algorithm decides
whether a variable x at a statement s is tainted simply by
computing whether the node representing (s, x) is reachable
within this graph. Because all method calls have been ab-
stracted through summary functions, those queries are fully
intra-procedural and therefore highly e cient.
Attacker model
We assume an attacker that can supply an app with arbi-
trary malicious bytecode, obfuscated or not. In the scenario
treated in this paper, the attacker’s goal is to leak private
data through a dangerously broad set of permissions granted
by the user [4]. Our analysis makes sound assumptions on the
installation environment and app inputs, meaning that the
attacker is free to tamper with those as well. FlowDroid
does assume, however, that the attacker has no way of cir-
cumventing the security measures of the Android platform.
Also, right now no static analysis for Android, including
FlowDroid has a way of dealing with dynamic loading and
reﬂection. Bodden et al. showed how those features can be
handled in general [9], however their approach requires access
to a load-time instrumentation API, which is something that
Android does not currently support. We are in contact with
Google to see if such an API can be supported in the future.

3. PRECISE MODELLING OF LIFECYCLE

Multiple entry points. Unlike Java programs, Android ap-
plications do not have a main method. Apps instead comprise
many entry points, i.e., methods that are implicitly called
by the Android framework. The Android operating system
deﬁnes a complete lifecycle for all components in an applica-
tion. There are four di↵erent components an app developer
can deﬁne: activities are single focused user actions, ser-
vices perform background tasks, content providers deﬁne a
database-like storage, and broadcast receivers listen for global
events. All these components are implemented by deriving
a custom class from a predeﬁned operating system class,
registering it in the AndroidManifest.xml ﬁle and overwrit-
ing the lifecycle methods. The Android system calls these
methods at runtime to start or stop the component, or pause
or resume it, depending on environment needs. It can, e.g.,
stop an application because of low memory, and later restart
it when the user returns to it. Figure 1 shows the lifecycle

Activity
launched

onCreate()

User navigates
to the activity

onStart()

onRestart()

User

returns
to the
activity

User navigates
to the activity

App process

killed

Apps with

higher priority
needs memory

onResume()

Activity
running

Another

activity comes

into the foreground

onPause()

The activity is
no longer visible

onStop()

The activity is ﬁnishing or

being destroyed by the system

onDestroy()

Activity
shut down

Figure 1: Android Activity Lifecycle

for an activity. In result, when constructing a call graph,
Android analyses cannot simply start by inspecting a pre-
deﬁned “main” method. Instead, all possible transitions in
the Android lifecycle must be modeled precisely. To cope
with this problem, FlowDroid constructs a custom dummy
main method emulating the lifecycle. However, the lifecycle
is more complex than depicted and explicitly documented.
There are additional methods for saving and restoring state,
as well as callbacks that notify the app about additional state
changes. If not taken into account, a malicious application
could exploit these methods and send out secret information
without being noticed.

Asynchronously executing components. An application
can contain multiple components, e.g., three activities and
one service. The activities run sequentially, however, one can-
not pre-estimate their order. One activity could, for instance,
be the main one initially visible to the user and then launch
either one of the others depending on user input. Services run
in parallel. FlowDroid thus conservatively assumes that all
components (activities, services, etc.) inside an application
to run in an arbitrary sequential order. Within a component,
the analysis is fully ﬂow-sensitive, though. Additionally, the
Android operating system allows applications to register call-
backs for various types of information, e.g., location updates
or UI interactions. Callbacks implement predeﬁned interfaces
declaring methods that are then called asynchronously by
the operating system. FlowDroid models these callbacks
in its dummy main method, for instance to recognize cases
where an application stores to the heap the location data
that is passed into the callback as a parameter, and later
sends this data to the internet when the activity is stopped.
The order in which callbacks are invoked cannot generally
be predicted, which is why FlowDroid conservatively as-

LeakageApp la = new LeakageApp();

la.onCreate();

la.onStart();

la.onResume();

p

p

la.onPause();

p

la.onStop();

p

p

la.onDestroy();

la.sendMessage();

la.onRestart();

5

4

void foo( z ) {

x = z.g;
w = source(); 
x.f = w;

a.g.f

6

void main() { 
7
b.f

a = new A();
b = a.g;
foo(a);
sink(b.f);

}

x.f
} 

3

x.f
2

z.g.f

w

1

Figure 3: Taint analysis under realistic aliasing

Name
V arId
F ieldId
Stmt
Loc
V al = Loc [ {null}
Env : V arId ! V al
Heap : Loc ⇥ F ieldId ! V al Heap
States = Env ⇥ Heap

Description
Program variables
Field identiﬁers
Statements2
Memory locations
Values
Environment

Program States

Figure 2: CFG for dummy main method

Table 1: Formalization Domains

sumes that all callbacks can be invoked in any possible order.
Some static analysis are path-sensitive, i.e., consider each
possible program paths separately. In such cases, considering
all possible orderings would be very expensive. Fortunately,
FlowDroid bases its analysis on IFDS, which is not path-
sensitive and instead joins analysis results immediately at
any control-ﬂow merge point. For FlowDroid can thus
generate a main method in which every order of individual
component lifecycles and callbacks is possible, it does not
need to simulate all possible paths.

Example. In Figure 2 we show the control-ﬂow graph of the
dummy main method for our example. In this ﬁgure, p repre-
sents an opaque predicate of which we know that FlowDroid
won’t be able to evaluate it statically (for instance, a check
involving an environment variable). In result, the analysis
will automatically consider on equal terms both branches for
conditions involving p. Note that, to gain maximal precision,
we generate an individual dummy main method for each app
analyzed. Each main method will only involve the fraction of
the lifecycle that, according to the app’s XML conﬁguration
ﬁles, can actually occur. Disabled activities are automati-
cally ﬁltered and callback methods are only invoked in the
contexts of the components to which they actually belong.
A button click handler is for instance only analyzed in the
context of its respective activity.

4. CONTEXT, OBJECT, FIELD AND FLOW-

SENSITIVE ANALYSIS

One major di culty in the analysis is how to handle alias-
ing with high object sensitivity. Figure 3 shows how Flow-
Droid combines a forward-taint analysis and an on-demand
backward-alias analysis to decide that b.f is tainted at the
3 , where the forward analysis
sink. The important step is
assigns a taint to x.f. On such assignments to the heap, the
backward analysis searches upwards for aliases of x.f, an

idea borrowed from Andromeda [27]. At
is found and then propagated forward.

7 , the alias b.f

To increase the reproducibility of our approach, in this
section we give important details about the di↵erent transfer
functions our analysis associates with program statements.
In the following, ﬁrst we deﬁne an abstract heap model. Sec-
tion 4.1 explains our general taint analysis, while Section 4.2
explains our on-demand alias analysis.

FlowDroid leverages IFDS to propagate each tainted
value individually, using a multi-threaded implementation.
When processing any given statement, the set T of incoming
taints are transformed into a set of outgoing taints. We deﬁne
the abstract analysis semantics with the standard notation
used similarly by Tripp et al. [27]. Table 1 shows our abstract
domain. For representing the e↵ects of program statements,
FlowDroid uses the semantics deﬁned in Table 2. H 2
Heap deﬁnes the current heap, and E 2 Env the current
environment. A program state is deﬁned as   = hE, Hi 2
States.
To be able to explain our taint propagation algorithm in

detail we declare the following helper functions:

arrayElem(x) : V arId ! Boolean returns true i↵ x refer-

ences an array element

static(x) : F ieldId ! Boolean returns true i↵ x is a static

ﬁeld

2FlowDroid operates on an intermediate representation
that represents compound statements through individual
atomic statements.

Statement
x = new Object()
x = y
x.f = y
x = y.f

Semantics
  =  [x ! o 2 Loc. o is fresh]
  =  [E(x) ! E(y)]
  =  [H((E(x), f )) ! E(y)]
  =  [E(x) ! H((E(y), f ))]

Table 2: Program Semantics

immut(x) : V arId ! Boolean returns true i↵ x is a primi-

tive or immutable data type (int, String, etc.)

source(s) : Stmt ! P (V arId) returns a set of variable names
tainted by the source statement s or ; if s is no source
native(s) : Stmt ! Boolean returns true i↵ s contains a call

to a native method

nativeT aint(s) : Stmt ! P (V arId) returns values which are
tainted after the native call s 2 Stmt. Such values can
include the base object on which the method was in-
voked, the return value, or one or more of the input
parameters.

nativeAlias(s) : Stmt ! P (V arId) returns possible aliases
of tainted values before the native call s 2 Stmt (back-
wards analysis)

To model deep object sensitivity, FlowDroid does not
simply propagate simple ﬁelds like x.f but instead so-called
access paths [27] up to a ﬁxed length. x.f.g.h for instance
models an access path of length 3. We use the notation
x.f n to describe an arbitrary but ﬁxed access path of length
n, rooted at x. For example x.f 3 represents paths such as
x.f.g.h. Note that x.f 0 is equal to x. The notation allows
us to split ﬁeld accesses such that x.f p = x.f n.f m where
p = m + n. In result, T is actually a set of currently tainted
access paths.

A concrete state is a program state extended by the set
of tainted access paths T resulting in a triple   = hE, H, Ti.
At the beginning it holds that T = ;. Tainted access paths
are added to the set whenever the analysis reaches a call to
a source, or when processing a statement that propagates an
existing taint to a new memory location. We next explain
the di↵erent transfer functions that FlowDroid uses to
compute taints. Section 4.2 explains how we use access paths
to deal with aliasing.
4.1 Taint analysis

The taint analysis starts directly at each of the identiﬁed
and reachable sources. The IFDS framework distinguishes
four di↵erent kinds of ﬂow functions: normal, call, return
and call-to-return.

Normal ﬂow function. Normal ﬂow functions are applied
at all statements that are neither calls nor returns. In Flow-
Droid, only method calls can be the original source of a
taint. Thus, a normal ﬂow function can never generate new
taints, it can only transfer, preserve, or “kill” existing taints.
FlowDroid is insensitive to array indices, tainting the
entire set of array elements even if the program taints just
a single element. To be sound, FlowDroid thus needs to
assume that the entire contents remain tainted, even if the
single array element is overwritten by an untainted value
later-on. For an assignment statement s 2 Stmt with the
structure x.f n = y.f m with n, m 2 N0 the following rules
apply:

T [ {x.f n.f p} 8p : y.f m.f p 2 T
T\{x.f n}
T

y.f m.f⇤ /2 T ^ ¬arrayElem(x.f n)
otherwise

A special case is the new statement which creates a fresh

T s !8<:

object:
T x.f n=new...

        ! T\{x.f n.f⇤ 2 T|¬arrayElem(x.f n)}.

Assigning a fresh object erases the taints for the memory
location referred to by the left-hand side and all access paths
that could be reached through this reference.

Assignments of arithmetic operations such as x = a + b are
treated by tainting the left-hand side if any of the operands
are tainted. For now, FlowDroid uses a simple two-element
security lattice but it can easily be extended to track more
information about the kind of taint that is propagated.

Call ﬂow function. Call ﬂow functions handle ﬂows into
callees of calls such as c.m(a0, . . . , an), n 2 N0. To model
the context change from the body of the caller to the one of
the callee, FlowDroid builds taint set Tcallee based on the
caller’s set Tcaller, replacing references to actual parameters
ai by references to formal parameters pi. If a variable is
tainted in the caller’s context, FlowDroid converts it to
the callee context by replacing c with this.
{this.f m} c.f m 2 Tcaller
ai.f p 2 Tcaller
{pi.f p}
{y.f q}
x.f q 2 Tcaller ^ static(y.f q)

Tcallee

s ! [8<:

Return ﬂow function. At a return (both exceptional and
regular), the return ﬂow function maps taints from the callee’s
context back to the one of the caller. FlowDroid’s return
ﬂow functions specially treats immutable values. Such val-
ues, by their very nature, can never change their taint status.
Thus, if a parameter of an immutable type like String or int
was not tainted before the call it cannot be tainted by the
callee and is thus still guaranteed to be untainted on return.
In all other cases, the taint of all tainted access paths is
mapped back to the caller’s context. The following ﬂow func-
tion applies when the callee returns a variable r after being
called using a statement of the form b = c.m(a0, . . . , an):

Tcaller

s ! [8>><>>:

{c.f m}
this.f m 2 Tcallee
{ai.f p} pi.f p 2 Tcallee ^ ¬immut(ai)
x.f q 2 Tcallee ^ static(y.f q)
{y.f q}
{b.f v}
r.f v 2 Tcallee

Call-to-return ﬂow function. For every call there is also
intra-procedural edge propagating all taint values that are
independent of the callee.
In this function, we generate
taints at sources, through a simple pattern match against an
extensible list of method signatures. We also handle native
method calls here (for details, see Section 5). Again consider
a call b = c.m(a0, . . . , an):

T [ nativeT aint(s, T ) native(s) ^ ai.f m 2 T
T [ {x}
T

x 2 source(s)
otherwise

T s !8<:

4.2 On-demand alias analysis

During our research we experimented a lot with di↵er-
ent ways to resolve aliasing e↵ectively and e ciently. As it
turned out, using ahead-of-time analyses is usually too costly
(because the analysis computes alias information for all pro-
gram variables, not just those that carry taints) and too
imprecise (because the analysis would not support the same
level of context-sensitivity as our taint analysis). We hence
opted for a demand-driven approach by Tripp et al., which
executes within the same context-sensitive IFDS framework
as our taint analysis [27]. As Figure 3 shows, this on-demand
analysis is triggered at assignments to heap variables, i.e.,

statements of the form x.f = v. The alias analysis then walks
backward through the control-ﬂow graph. Whenever it ﬁnds
an alias, it triggers the forward analysis in turn, propagat-
ing an aliased taint from the location at which the alias
was found. Similar to the forward analysis, we deﬁne ﬂow
functions which compute the alias propagation information.
Let the set A deﬁne the alias information. The only ini-
tial element in A is the complete access path of the tainted
value which caused the alias lookup. The backward solver
terminates when A becomes empty.

source, sink and

entry-point detection

parse manifest ﬁle

generate

main method

parse .dex ﬁles

build call graph

parse layout xmls

perform taint

analysis

Normal ﬂow function. For a statement x.f = y.g the fol-
lowing rule applies:

A s ! [⇢ A\{x.f.f p} [ {y.g.f p} 8p : x.f.f p 2 A

otherwise

A

For new statements, FlowDroid erases all alias informa-
tion for the left-hand side, as fresh objects cannot be aliased:
A x.f =new...

       ! A\{8m : x.f.f⇤ 2 A}

Call ﬂow function. Since the backward analysis traverses
the control-ﬂow graph backwards, its call ﬂow function prop-
agates information from call sites to return sites in the callee.
Consider again a call b = c.m(a0, . . . , an) and a return site
returning a variable r:
b.f m 2 Acaller
{r.f m}
{this.f m} c.f m 2 Acaller
{y.f q}
y.f q 2 Acaller ^ static(y.f q)

Acallee

s ! [8<:

Return ﬂow function. In the backwards analysis, return
ﬂow functions propagate from the callee’s start point to just
before the call site. The return ﬂow function thus maps the
callee’s aliases at back to the caller while taking into account
renaming from formal parameters pi to actual parameters ai.
For a call site c.m(a0, . . . , an) we obtain:
this.f m 2 Acallee
y.f q 2 Acallee ^ static(y.f q)

{c.f m}
{ai.f p} pi.f p 2 Acallee
{y.f q}

Acaller

s ! [8<:
A s !8>><>>:

Call-to-return ﬂow function. For a call site b = c.m(a0, . . . , an),
the call-to-return ﬂow function handles aliases induced by
native calls and kills aliases of references obtained through b:

A [ nativeAlias(s) native(s)
^(ai.f m 2 A _ c.f n 2 A)
A\{b.f n}
b.f n 2 A
otherwise
A

5.

IMPLEMENTATION

FlowDroid extends the Soot framework [16] which pro-
vides important prerequisites for a precise analysis, in par-
ticular a very accurate call graph. Through a plugin called
Dexpler [5] Soot supports not only converting Java code but
also Android’s dex ﬁles into the Jimple intermediate repre-
sentation which allows us to implement our analysis for both
targets. FlowDroid further uses Heros [8] as an implemen-
tation of IFDS on top of Soot and Dexpler. We next explain
FlowDroid’s architecture, while the subsequent sections
explain interesting implementation details and FlowDroid’s
current limitations.

Figure 4: Overview of FlowDroid

Architecture. Figure 4 shows FlowDroid’s architecture.
Android applications are packaged in apk ﬁles (Android Pack-
ages), which are essentially zip-compressed archives. After
unzipping an archive, FlowDroid searches for lifecycle and
callback methods as well as calls to sources and sinks in the
application. This is done by parsing various Android-speciﬁc
ﬁles, including the layout XML ﬁles, the dex ﬁles contain-
ing the executable code and the manifest ﬁle deﬁning the
activities, services, broadcast receivers and content providers
in the application. We describe the detection of UI Inter-
actions in detail below. Next, FlowDroid generates the
main method from the list of lifecycle and callback methods
(see the Paragraphs Callbacks and Substitution Classes for
more information). This main method is then used to gener-
ate a call graph and an inter-procedural control-ﬂow graph
(ICFG). Starting at the detected sources, the taint analysis
then tracks taints by traversing the ICFG as explained in
Section 4. Native Calls require a special treatment which
is described below along with a performance optimization
called Taint Wrapping. At the end, FlowDroid reports all
discovered ﬂows from sources to sinks.

UI Interactions. UI elements can be taint sources, e.g., if
an application prompts the user for a password and then
sends it out to the Internet. FlowDroid thus scans the
layout XML ﬁles in the apk ﬁle for text inputs and links
them to the source-code statements where they are accessed.
This is non-trivial, as the Android operating system manages
access to such resources at runtime and a static analysis tool
must simulate these runtime APIs as precisely as possible.
Note that we need to over-approximate resource accesses in
the general case, though. In Android, resource mappings can
be conﬁguration-dependent, for instance to support di↵erent
layouts for smartphones and tablets. In this case, we can
only assume all cases as possible. Not all data in text ﬁelds
is sensitive, though. FlowDroid can be conﬁgured to either
consider all text ﬁelds or to restrict itself to special sensitive
ﬁelds like password input ﬁelds (the default).

Callbacks. To model the app lifecycle correctly (see Sec-
tion 3), FlowDroid contains a list of callback interfaces
extracted from the Android documentation. FlowDroid
ﬁrst computes a call graph ignoring callbacks, to determine
which activity will potentially register which kind of callback
at runtime. Next, FlowDroid generates a customized main
method for each activity, taking the respective discovered
callbacks into account.

Substitution Classes. J2EE and Android applications some-
times operate on interface types or abstract class types that
at runtime receive objects instantiated within the J2EE or

Android framework. FlowDroid’s main-method generator
cannot easily be aware of those concrete subtypes. Flow-
Droid thus allows the analysis designer to provide a list of
so-called substitution classes. A substitution class provides
a concrete implementation for one or more of these inter-
faces, simply for the purpose of the analysis. The user can
choose whether to provide a stub or a real implementation,
depending on whether the designer aims for higher precision
or scalability. For Android, substitution classes are required,
for instance, for the abstract class android.context.Context.

Native Calls. Both Java and the Android platform support
invoking native methods written in C or other unmanaged
languages. For a Java-based analysis, such methods are black
boxes which cannot be resolved. We thus deﬁned explicit
taint propagation rules for the most common native methods,
such as arraycopy in java.lang.System. In this example, third
argument (the output array) will become tainted if the ﬁrst
argument (the input array) is tainted before the call. For
native methods without an explicit rule, we assume call
arguments and the return value to become tainted if at
least one parameter was tainted before. This is neither
entirely sound nor maximally precise but is probably the
only practical approximation in a black-box setting.

Taint Wrapping. Including the full JRE or Android plat-
form runtime in the analysis requires a lot of time and mem-
ory and can lead to unwanted imprecisions. Thus, while
explicit taint-propagation rules are required for native meth-
ods, they can be useful for regular Java methods as well:
their use can prevent the taint propagation from having
to analyze the library’s internals. FlowDroid supports a
simple textual ﬁle format for deﬁning such “shortcut rules”.
Predeﬁned rules handle collection classes, string bu↵ers and
similar commonly used data structures.

Limitations. At the moment FlowDroid ignores reﬂective
calls, which is unsound. While specialized static string anal-
yses can be used to simulate reﬂection to some extent, past
research has found such analyses to be incomplete [9], as
reﬂective call targets are often determined by external conﬁg-
uration ﬁles. On the Java platform, reﬂection-analysis tools
such as TamiFlex [9] can be used to make static analysis
tools aware of reﬂective calls. Such tool require load-time
instrumentation through java.lang.instrument, however, which
the Android platform does not currently support.

As described above, native code is approximated conser-
vatively using taint wrapping. Another limitation of Flow-
Droid is its current focus on explicit data ﬂows. Implicit
ﬂows caused by control-ﬂow dependencies are currently ig-
nored, but we plan to include them in the near future. Flow-
Droid also ignores probabilistic and possibilistic leaks caused
by multi-threading [13].

6. EXPERIMANTAL EVALUATION

Our evaluation addresses the following research questions:

RQ1 How does FlowDroid compare to commercial taint-
analysis tools for Android, both in terms of precision
and recall?

RQ2 Can FlowDroid ﬁnd all privacy leaks in Insecure-
Bank, an app speciﬁcally designed by others to chal-

lenge vulnerability-detection tools for Android [21], and
what is its performance?

RQ3 Can FlowDroid ﬁnd leaks in real-world applications

and how fast is it?

RQ4 How well does FlowDroid perform when being ap-
plied to taint-analysis problems related to Java, not
Android, both in terms of precision and recall?

The next sections address each research question in detail.
Section 6.5 explains why, unfortunately, we were unable to
directly compare FlowDroid to academic Android analysis
tools published elsewhere.
6.1 RQ1: Commercial taint-analysis tools

While there are benchmark suites for analyzing web appli-
cations or speciﬁcally for detecting di↵erent kinds of Java vul-
nerabilities [17], at the moment there is no Android-speciﬁc
analysis benchmark suite. This is problematic because the
generic Java test suites do not cover aspects like the An-
droid lifecycle, callbacks or interactions with UI elements
like password ﬁelds. Thus, they cannot be used for assessing
the practical e↵ectiveness of Android analysis tools.

DroidBench. Speciﬁcally for this work, we therefore de-
veloped an Android-speciﬁc test suite called DroidBench
containing 39 small Android apps. The suite can be used
to assess both static and dynamic taint analyses, but in
particular it contains test cases for interesting static-analysis
problems (ﬁeld sensitivity, object sensitivity, tradeo↵s in
access-path lengths etc.) as well as for Android-speciﬁc
challenges like correctly modeling an application’s lifecycle,
adequately handling asynchronous callbacks and interacting
with the UI. Table 3 contains a list of all apps in the suite
together with their respective names and short descriptions.
The table also indicates whether an analysis tool must model
the Android lifecycle or callback infrastructure to be able to
successfully analyze the app. We envision our test suite to
be extended by other researchers as well and then be used
to compare the completeness and correctness of the various
taint analysis approaches. DroidBench is available from
our project website.

Table 5 presents the analysis results for FlowDroid and
two commercial analysis tools explained in the following.
As the results show, FlowDroid generally performs quite
well. As explained before, for performance reasons, Flow-
Droid handles array indices imprecisely. The same limi-
tation applies to ListAccess1, causing false positives in the
ﬁrst category. Handling indices precisely and e ciently is an
interesting open research question. Button2 causes a false
positive because FlowDroid does not currently support
strong updates. In result, it cannot kill taints for certain
button combinations. Strong updates would require a must-
alias analysis which is hard to achieve inter-procedurally.
IntentSink1 is not detected because the test case contains no
actual sink. Instead, the tainted value is stored in an intent
which is then handed back to the activity by the framework.
Such cases are hard to handle without special treatment.
StaticInitialization1 fails because Soot currently assumes
all static initializers to execute at the beginning of the pro-
gram, which in this case is not correct. We plan to add
better support in the future. As most known taint-analysis
tools, FlowDroid currently disregards implicit ﬂows caused
through control-ﬂow dependencies.

Comparison with IBM AppScan Source. We compared
FlowDroid against IBM AppScan Source [2] version 8.7, on
all tests from DroidBench. AppScan Source distinguishes
three di↵erent categories of ﬁndings: vulnerabilities, excep-
tions of type 1 and exceptions of type 2. Vulnerabilities
include a complete path from source to sink. For a type 1
exception, there is a ﬂow from source to sink as well, but
the semantics of some methods along the propagation path
is unknown (e.g. possible sanitization). Since FlowDroid
does not support sanitization at the moment, we consider
both vulnerabilities and type 1 exceptions as ﬁndings. For
type 2 exceptions on the other hand, there is no trace. These
reports are generated when certain code constructs (e.g. writ-
ing a variable value into the log ﬁle) are detected. As these
ﬁndings are highly imprecise and completely disregard data
ﬂow, we do not count them as ﬁndings. As Table 5 shows,
AppScan Source ﬁnds only about 38% of all leaks (50% if
ignoring implicit ﬂows). Major problems occur with the
handling of callbacks, the Android component lifecycle and
implicit ﬂows.

Comparison with Fortify SCA. Fortify SCA [1] by HP is
another commercial tool widely used by security analysts.
Similar to IBM AppScan Source, Fortify also provides di↵er-
ent kinds of ﬁndings, such as data ﬂows from sensitive sources
to public sinks, requests for security-sensitive permissions,
calls to security-sensitive methods, etc. In our evaluation,
we only considered ﬁndings about data ﬂows. All tests were
carried out using version 5.14. As can be seen in Table 5, For-
tify SCA shows problems similar to those of IBM AppScan
(cf. Section 6.1), like the handling of the Android component
lifecycle, the callbacks and implicit ﬂows. Figure 5 shows
that Fortify detects 4 out of 6 data leaks for the lifecycle
tests, but closer inspection shows that this only happens
by chance. In these tests, the data source involves a static
ﬁeld, which Fortify apparently treats in a special way which
coincidentally causes a leak to be reported. When removing
the static modiﬁer, which does not the semantics of the test
case, Fortify does not detect the leak any longer.

Conclusion. From our experiments we conclude that, to not
overburden the user with false positives, AppScan Source and
Fortify SCA aim for relatively high precision while sacriﬁcing
recall, thus risking to miss actual privacy leaks. In compari-
son, FlowDroid shows higher precision with a signiﬁcantly
higher recall.
6.2 RQ2: Performance on InsecureBank

InsecureBank [21] is a vulnerable Android app created
by Paladion Inc. speciﬁcally for the purpose of evaluating
analysis tools such as FlowDroid. It contains various vul-
nerabilities and data leaks similar to those found in real-world
applications. Analyzing the application takes about 31 sec-
onds on a laptop computer with an Intel Core 2 Centrino
CPU and 4 GB of physical memory running on Windows 7
with Oracle’s Java Runtime version 1.7 (64 bit) in its default
settings. FlowDroid found all seven data leaks which we
all veriﬁed by hand. There were no false positives nor false
negatives.

6.3 RQ3: Real-World Applications

The above experiments give a very good indication that
FlowDroid yields correct and precise results, not just for
small test case but also for more realistic apps such as In-
secureBank [21]. To strengthen the external validity of our
experiments, we nevertheless performed an additional qualita-
tive analysis on a random selection of popular apps from the
Google Play store. While the obtained analysis reports do
not indicate any malicious apps in this selection, the majority
of apps is reported to—probably accidentally—leak informa-
tion into logs and preference ﬁles. Samsung’s Push Service,
for instance, logs the phones IMEI. Logs are problematic,
as the OS does not impose the same access restrictions on
logs as it does on ﬁles: all logs are readable by any app that
has the READ LOGS permission. The game Hugo Runner
stores longitude and latitude into a preferences ﬁle. As we
veriﬁed by hand, though, those preferences were correctly
written in private mode, precluding any access by other apps.
This indicates that taint analyses could gain precision by
considering auxiliary information such as the write mode
mentioned above. For most examined apps FlowDroid
terminated in under a minute. The longest-running instance,
Samsung’s Push Service took about 4.5 minutes to analyze.
6.4 RQ4: SecuriBench Micro

FlowDroid was speciﬁcally designed for Android, and
in this space gains much precision through its complete and
precise handling of Android’s lifecycle. Nevertheless, there is
nothing that would preclude software developers from apply-
ing FlowDroid to Java applications as well. To assess how
well FlowDroid is set up for this use case, we evaluated
FlowDroid against Stanford SecuriBench Micro [17] version
1.08, a common set of 96 J2EE micro benchmarks originally
intended for web-based applications. For each of the bench-
marks in the suite, we manually deﬁned the necessary lists of
sources, sinks and entry points. Since FlowDroid supports
a simple textual ﬁle format for deﬁning these parameters,
and since all benchmarks cases have the same structure, this
was not much e↵ort. For the interfaces HTTPServletRequest
and HTTPServletResponse we needed to provide substitution
classes (see Section 5), as we had no access to framework
code that would provide their implementations. We omit-
ted from our experiments test cases involving sanitization,
reﬂection, predicates and multi-threading. As we explained
earlier, such features are out of scope for our analysis tool,
just as they are for all other existing Android analysis tools.
Table 4 shows our test results grouped by test categories.
The TP column shows the true positives, i.e., the number
of actual leaks that FlowDroid found. For the example of
basic, for instance, FlowDroid found 58 out of 60. The FP
column shows the number of false positives, i.e., the ﬁnding
that FlowDroid reported that did not correspond to actual
leaks, but were rather artifacts of an overly approximate
analysis. In most cases this number is reasonably low or
even zero, except for the Arrays category. This is due to an
imprecision that FlowDroid shares with most other static
analyses: for performance reasons, the tools not di↵erentiate
between multiple components inside the same collection,
e.g., di↵erent indices in arrays or di↵erent positions in lists.
Treating such cases precisely and e ciently is an interesting
open issue in the static-analysis community. The n/a entries
in the table correspond to test categories such as reﬂection,
which we identiﬁed to be out of scope.

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

The IFDS framework
Our inter-procedural dataﬂow analysis problem is formulated
in terms of the IFDS framework by Reps et al. [25] and can
therefore be reduced to a graph-reachability problem. IFDS
solves inter-procedural, ﬁnite, distributive subset problems
and works by creating a so-called exploded supergraph based
on ﬂow functions associated with the program statements.
A ﬂow function deﬁnes the impact of a statement on a set
of ﬂow facts. For example, the statement x = y would be
associated with a ﬂow function that maps a fact set {y} (i.e.
y is tainted) to a fact set {x, y} (x and y are both tainted).
Function calls are modeled using summary functions, which
makes the approach precise, yet very e cient: at di↵erent
call sites to the same method m, the summary function for
m is just reused (gaining e ciency) but it is applied to the
taint information at that very call site (thus yielding full
context sensitivity). Section 4 gives more details about how
FlowDroid constructs the supergraph.

Once the supergraph is constructed, the algorithm decides
whether a variable x at a statement s is tainted simply by
computing whether the node representing (s, x) is reachable
within this graph. Because all method calls have been ab-
stracted through summary functions, those queries are fully
intra-procedural and therefore highly e cient.
Attacker model
We assume an attacker that can supply an app with arbi-
trary malicious bytecode, obfuscated or not. In the scenario
treated in this paper, the attacker’s goal is to leak private
data through a dangerously broad set of permissions granted
by the user [4]. Our analysis makes sound assumptions on the
installation environment and app inputs, meaning that the
attacker is free to tamper with those as well. FlowDroid
does assume, however, that the attacker has no way of cir-
cumventing the security measures of the Android platform.
Also, right now no static analysis for Android, including
FlowDroid has a way of dealing with dynamic loading and
reﬂection. Bodden et al. showed how those features can be
handled in general [9], however their approach requires access
to a load-time instrumentation API, which is something that
Android does not currently support. We are in contact with
Google to see if such an API can be supported in the future.

3. PRECISE MODELLING OF LIFECYCLE

Multiple entry points. Unlike Java programs, Android ap-
plications do not have a main method. Apps instead comprise
many entry points, i.e., methods that are implicitly called
by the Android framework. The Android operating system
deﬁnes a complete lifecycle for all components in an applica-
tion. There are four di↵erent components an app developer
can deﬁne: activities are single focused user actions, ser-
vices perform background tasks, content providers deﬁne a
database-like storage, and broadcast receivers listen for global
events. All these components are implemented by deriving
a custom class from a predeﬁned operating system class,
registering it in the AndroidManifest.xml ﬁle and overwrit-
ing the lifecycle methods. The Android system calls these
methods at runtime to start or stop the component, or pause
or resume it, depending on environment needs. It can, e.g.,
stop an application because of low memory, and later restart
it when the user returns to it. Figure 1 shows the lifecycle

Activity
launched

onCreate()

User navigates
to the activity

onStart()

onRestart()

User

returns
to the
activity

User navigates
to the activity

App process

killed

Apps with

higher priority
needs memory

onResume()

Activity
running

Another

activity comes

into the foreground

onPause()

The activity is
no longer visible

onStop()

The activity is ﬁnishing or

being destroyed by the system

onDestroy()

Activity
shut down

Figure 1: Android Activity Lifecycle

for an activity. In result, when constructing a call graph,
Android analyses cannot simply start by inspecting a pre-
deﬁned “main” method. Instead, all possible transitions in
the Android lifecycle must be modeled precisely. To cope
with this problem, FlowDroid constructs a custom dummy
main method emulating the lifecycle. However, the lifecycle
is more complex than depicted and explicitly documented.
There are additional methods for saving and restoring state,
as well as callbacks that notify the app about additional state
changes. If not taken into account, a malicious application
could exploit these methods and send out secret information
without being noticed.

Asynchronously executing components. An application
can contain multiple components, e.g., three activities and
one service. The activities run sequentially, however, one can-
not pre-estimate their order. One activity could, for instance,
be the main one initially visible to the user and then launch
either one of the others depending on user input. Services run
in parallel. FlowDroid thus conservatively assumes that all
components (activities, services, etc.) inside an application
to run in an arbitrary sequential order. Within a component,
the analysis is fully ﬂow-sensitive, though. Additionally, the
Android operating system allows applications to register call-
backs for various types of information, e.g., location updates
or UI interactions. Callbacks implement predeﬁned interfaces
declaring methods that are then called asynchronously by
the operating system. FlowDroid models these callbacks
in its dummy main method, for instance to recognize cases
where an application stores to the heap the location data
that is passed into the callback as a parameter, and later
sends this data to the internet when the activity is stopped.
The order in which callbacks are invoked cannot generally
be predicted, which is why FlowDroid conservatively as-

LeakageApp la = new LeakageApp();

la.onCreate();

la.onStart();

la.onResume();

p

p

la.onPause();

p

la.onStop();

p

p

la.onDestroy();

la.sendMessage();

la.onRestart();

5

4

void foo( z ) {

x = z.g;
w = source(); 
x.f = w;

a.g.f

6

void main() { 
7
b.f

a = new A();
b = a.g;
foo(a);
sink(b.f);

}

x.f
} 

3

x.f
2

z.g.f

w

1

Figure 3: Taint analysis under realistic aliasing

Name
V arId
F ieldId
Stmt
Loc
V al = Loc [ {null}
Env : V arId ! V al
Heap : Loc ⇥ F ieldId ! V al Heap
States = Env ⇥ Heap

Description
Program variables
Field identiﬁers
Statements2
Memory locations
Values
Environment

Program States

Figure 2: CFG for dummy main method

Table 1: Formalization Domains

sumes that all callbacks can be invoked in any possible order.
Some static analysis are path-sensitive, i.e., consider each
possible program paths separately. In such cases, considering
all possible orderings would be very expensive. Fortunately,
FlowDroid bases its analysis on IFDS, which is not path-
sensitive and instead joins analysis results immediately at
any control-ﬂow merge point. For FlowDroid can thus
generate a main method in which every order of individual
component lifecycles and callbacks is possible, it does not
need to simulate all possible paths.

Example. In Figure 2 we show the control-ﬂow graph of the
dummy main method for our example. In this ﬁgure, p repre-
sents an opaque predicate of which we know that FlowDroid
won’t be able to evaluate it statically (for instance, a check
involving an environment variable). In result, the analysis
will automatically consider on equal terms both branches for
conditions involving p. Note that, to gain maximal precision,
we generate an individual dummy main method for each app
analyzed. Each main method will only involve the fraction of
the lifecycle that, according to the app’s XML conﬁguration
ﬁles, can actually occur. Disabled activities are automati-
cally ﬁltered and callback methods are only invoked in the
contexts of the components to which they actually belong.
A button click handler is for instance only analyzed in the
context of its respective activity.

4. CONTEXT, OBJECT, FIELD AND FLOW-

SENSITIVE ANALYSIS

One major di culty in the analysis is how to handle alias-
ing with high object sensitivity. Figure 3 shows how Flow-
Droid combines a forward-taint analysis and an on-demand
backward-alias analysis to decide that b.f is tainted at the
3 , where the forward analysis
sink. The important step is
assigns a taint to x.f. On such assignments to the heap, the
backward analysis searches upwards for aliases of x.f, an

idea borrowed from Andromeda [27]. At
is found and then propagated forward.

7 , the alias b.f

To increase the reproducibility of our approach, in this
section we give important details about the di↵erent transfer
functions our analysis associates with program statements.
In the following, ﬁrst we deﬁne an abstract heap model. Sec-
tion 4.1 explains our general taint analysis, while Section 4.2
explains our on-demand alias analysis.

FlowDroid leverages IFDS to propagate each tainted
value individually, using a multi-threaded implementation.
When processing any given statement, the set T of incoming
taints are transformed into a set of outgoing taints. We deﬁne
the abstract analysis semantics with the standard notation
used similarly by Tripp et al. [27]. Table 1 shows our abstract
domain. For representing the e↵ects of program statements,
FlowDroid uses the semantics deﬁned in Table 2. H 2
Heap deﬁnes the current heap, and E 2 Env the current
environment. A program state is deﬁned as   = hE, Hi 2
States.
To be able to explain our taint propagation algorithm in

detail we declare the following helper functions:

arrayElem(x) : V arId ! Boolean returns true i↵ x refer-

ences an array element

static(x) : F ieldId ! Boolean returns true i↵ x is a static

ﬁeld

2FlowDroid operates on an intermediate representation
that represents compound statements through individual
atomic statements.

Statement
x = new Object()
x = y
x.f = y
x = y.f

Semantics
  =  [x ! o 2 Loc. o is fresh]
  =  [E(x) ! E(y)]
  =  [H((E(x), f )) ! E(y)]
  =  [E(x) ! H((E(y), f ))]

Table 2: Program Semantics

immut(x) : V arId ! Boolean returns true i↵ x is a primi-

tive or immutable data type (int, String, etc.)

source(s) : Stmt ! P (V arId) returns a set of variable names
tainted by the source statement s or ; if s is no source
native(s) : Stmt ! Boolean returns true i↵ s contains a call

to a native method

nativeT aint(s) : Stmt ! P (V arId) returns values which are
tainted after the native call s 2 Stmt. Such values can
include the base object on which the method was in-
voked, the return value, or one or more of the input
parameters.

nativeAlias(s) : Stmt ! P (V arId) returns possible aliases
of tainted values before the native call s 2 Stmt (back-
wards analysis)

To model deep object sensitivity, FlowDroid does not
simply propagate simple ﬁelds like x.f but instead so-called
access paths [27] up to a ﬁxed length. x.f.g.h for instance
models an access path of length 3. We use the notation
x.f n to describe an arbitrary but ﬁxed access path of length
n, rooted at x. For example x.f 3 represents paths such as
x.f.g.h. Note that x.f 0 is equal to x. The notation allows
us to split ﬁeld accesses such that x.f p = x.f n.f m where
p = m + n. In result, T is actually a set of currently tainted
access paths.

A concrete state is a program state extended by the set
of tainted access paths T resulting in a triple   = hE, H, Ti.
At the beginning it holds that T = ;. Tainted access paths
are added to the set whenever the analysis reaches a call to
a source, or when processing a statement that propagates an
existing taint to a new memory location. We next explain
the di↵erent transfer functions that FlowDroid uses to
compute taints. Section 4.2 explains how we use access paths
to deal with aliasing.
4.1 Taint analysis

The taint analysis starts directly at each of the identiﬁed
and reachable sources. The IFDS framework distinguishes
four di↵erent kinds of ﬂow functions: normal, call, return
and call-to-return.

Normal ﬂow function. Normal ﬂow functions are applied
at all statements that are neither calls nor returns. In Flow-
Droid, only method calls can be the original source of a
taint. Thus, a normal ﬂow function can never generate new
taints, it can only transfer, preserve, or “kill” existing taints.
FlowDroid is insensitive to array indices, tainting the
entire set of array elements even if the program taints just
a single element. To be sound, FlowDroid thus needs to
assume that the entire contents remain tainted, even if the
single array element is overwritten by an untainted value
later-on. For an assignment statement s 2 Stmt with the
structure x.f n = y.f m with n, m 2 N0 the following rules
apply:

T [ {x.f n.f p} 8p : y.f m.f p 2 T
T\{x.f n}
T

y.f m.f⇤ /2 T ^ ¬arrayElem(x.f n)
otherwise

A special case is the new statement which creates a fresh

T s !8<:

object:
T x.f n=new...

        ! T\{x.f n.f⇤ 2 T|¬arrayElem(x.f n)}.

Assigning a fresh object erases the taints for the memory
location referred to by the left-hand side and all access paths
that could be reached through this reference.

Assignments of arithmetic operations such as x = a + b are
treated by tainting the left-hand side if any of the operands
are tainted. For now, FlowDroid uses a simple two-element
security lattice but it can easily be extended to track more
information about the kind of taint that is propagated.

Call ﬂow function. Call ﬂow functions handle ﬂows into
callees of calls such as c.m(a0, . . . , an), n 2 N0. To model
the context change from the body of the caller to the one of
the callee, FlowDroid builds taint set Tcallee based on the
caller’s set Tcaller, replacing references to actual parameters
ai by references to formal parameters pi. If a variable is
tainted in the caller’s context, FlowDroid converts it to
the callee context by replacing c with this.
{this.f m} c.f m 2 Tcaller
ai.f p 2 Tcaller
{pi.f p}
{y.f q}
x.f q 2 Tcaller ^ static(y.f q)

Tcallee

s ! [8<:

Return ﬂow function. At a return (both exceptional and
regular), the return ﬂow function maps taints from the callee’s
context back to the one of the caller. FlowDroid’s return
ﬂow functions specially treats immutable values. Such val-
ues, by their very nature, can never change their taint status.
Thus, if a parameter of an immutable type like String or int
was not tainted before the call it cannot be tainted by the
callee and is thus still guaranteed to be untainted on return.
In all other cases, the taint of all tainted access paths is
mapped back to the caller’s context. The following ﬂow func-
tion applies when the callee returns a variable r after being
called using a statement of the form b = c.m(a0, . . . , an):

Tcaller

s ! [8>><>>:

{c.f m}
this.f m 2 Tcallee
{ai.f p} pi.f p 2 Tcallee ^ ¬immut(ai)
x.f q 2 Tcallee ^ static(y.f q)
{y.f q}
{b.f v}
r.f v 2 Tcallee

Call-to-return ﬂow function. For every call there is also
intra-procedural edge propagating all taint values that are
independent of the callee.
In this function, we generate
taints at sources, through a simple pattern match against an
extensible list of method signatures. We also handle native
method calls here (for details, see Section 5). Again consider
a call b = c.m(a0, . . . , an):

T [ nativeT aint(s, T ) native(s) ^ ai.f m 2 T
T [ {x}
T

x 2 source(s)
otherwise

T s !8<:

4.2 On-demand alias analysis

During our research we experimented a lot with di↵er-
ent ways to resolve aliasing e↵ectively and e ciently. As it
turned out, using ahead-of-time analyses is usually too costly
(because the analysis computes alias information for all pro-
gram variables, not just those that carry taints) and too
imprecise (because the analysis would not support the same
level of context-sensitivity as our taint analysis). We hence
opted for a demand-driven approach by Tripp et al., which
executes within the same context-sensitive IFDS framework
as our taint analysis [27]. As Figure 3 shows, this on-demand
analysis is triggered at assignments to heap variables, i.e.,

statements of the form x.f = v. The alias analysis then walks
backward through the control-ﬂow graph. Whenever it ﬁnds
an alias, it triggers the forward analysis in turn, propagat-
ing an aliased taint from the location at which the alias
was found. Similar to the forward analysis, we deﬁne ﬂow
functions which compute the alias propagation information.
Let the set A deﬁne the alias information. The only ini-
tial element in A is the complete access path of the tainted
value which caused the alias lookup. The backward solver
terminates when A becomes empty.

source, sink and

entry-point detection

parse manifest ﬁle

generate

main method

parse .dex ﬁles

build call graph

parse layout xmls

perform taint

analysis

Normal ﬂow function. For a statement x.f = y.g the fol-
lowing rule applies:

A s ! [⇢ A\{x.f.f p} [ {y.g.f p} 8p : x.f.f p 2 A

otherwise

A

For new statements, FlowDroid erases all alias informa-
tion for the left-hand side, as fresh objects cannot be aliased:
A x.f =new...

       ! A\{8m : x.f.f⇤ 2 A}

Call ﬂow function. Since the backward analysis traverses
the control-ﬂow graph backwards, its call ﬂow function prop-
agates information from call sites to return sites in the callee.
Consider again a call b = c.m(a0, . . . , an) and a return site
returning a variable r:
b.f m 2 Acaller
{r.f m}
{this.f m} c.f m 2 Acaller
{y.f q}
y.f q 2 Acaller ^ static(y.f q)

Acallee

s ! [8<:

Return ﬂow function. In the backwards analysis, return
ﬂow functions propagate from the callee’s start point to just
before the call site. The return ﬂow function thus maps the
callee’s aliases at back to the caller while taking into account
renaming from formal parameters pi to actual parameters ai.
For a call site c.m(a0, . . . , an) we obtain:
this.f m 2 Acallee
y.f q 2 Acallee ^ static(y.f q)

{c.f m}
{ai.f p} pi.f p 2 Acallee
{y.f q}

Acaller

s ! [8<:
A s !8>><>>:

Call-to-return ﬂow function. For a call site b = c.m(a0, . . . , an),
the call-to-return ﬂow function handles aliases induced by
native calls and kills aliases of references obtained through b:

A [ nativeAlias(s) native(s)
^(ai.f m 2 A _ c.f n 2 A)
A\{b.f n}
b.f n 2 A
otherwise
A

5.

IMPLEMENTATION

FlowDroid extends the Soot framework [16] which pro-
vides important prerequisites for a precise analysis, in par-
ticular a very accurate call graph. Through a plugin called
Dexpler [5] Soot supports not only converting Java code but
also Android’s dex ﬁles into the Jimple intermediate repre-
sentation which allows us to implement our analysis for both
targets. FlowDroid further uses Heros [8] as an implemen-
tation of IFDS on top of Soot and Dexpler. We next explain
FlowDroid’s architecture, while the subsequent sections
explain interesting implementation details and FlowDroid’s
current limitations.

Figure 4: Overview of FlowDroid

Architecture. Figure 4 shows FlowDroid’s architecture.
Android applications are packaged in apk ﬁles (Android Pack-
ages), which are essentially zip-compressed archives. After
unzipping an archive, FlowDroid searches for lifecycle and
callback methods as well as calls to sources and sinks in the
application. This is done by parsing various Android-speciﬁc
ﬁles, including the layout XML ﬁles, the dex ﬁles contain-
ing the executable code and the manifest ﬁle deﬁning the
activities, services, broadcast receivers and content providers
in the application. We describe the detection of UI Inter-
actions in detail below. Next, FlowDroid generates the
main method from the list of lifecycle and callback methods
(see the Paragraphs Callbacks and Substitution Classes for
more information). This main method is then used to gener-
ate a call graph and an inter-procedural control-ﬂow graph
(ICFG). Starting at the detected sources, the taint analysis
then tracks taints by traversing the ICFG as explained in
Section 4. Native Calls require a special treatment which
is described below along with a performance optimization
called Taint Wrapping. At the end, FlowDroid reports all
discovered ﬂows from sources to sinks.

UI Interactions. UI elements can be taint sources, e.g., if
an application prompts the user for a password and then
sends it out to the Internet. FlowDroid thus scans the
layout XML ﬁles in the apk ﬁle for text inputs and links
them to the source-code statements where they are accessed.
This is non-trivial, as the Android operating system manages
access to such resources at runtime and a static analysis tool
must simulate these runtime APIs as precisely as possible.
Note that we need to over-approximate resource accesses in
the general case, though. In Android, resource mappings can
be conﬁguration-dependent, for instance to support di↵erent
layouts for smartphones and tablets. In this case, we can
only assume all cases as possible. Not all data in text ﬁelds
is sensitive, though. FlowDroid can be conﬁgured to either
consider all text ﬁelds or to restrict itself to special sensitive
ﬁelds like password input ﬁelds (the default).

Callbacks. To model the app lifecycle correctly (see Sec-
tion 3), FlowDroid contains a list of callback interfaces
extracted from the Android documentation. FlowDroid
ﬁrst computes a call graph ignoring callbacks, to determine
which activity will potentially register which kind of callback
at runtime. Next, FlowDroid generates a customized main
method for each activity, taking the respective discovered
callbacks into account.

Substitution Classes. J2EE and Android applications some-
times operate on interface types or abstract class types that
at runtime receive objects instantiated within the J2EE or

Android framework. FlowDroid’s main-method generator
cannot easily be aware of those concrete subtypes. Flow-
Droid thus allows the analysis designer to provide a list of
so-called substitution classes. A substitution class provides
a concrete implementation for one or more of these inter-
faces, simply for the purpose of the analysis. The user can
choose whether to provide a stub or a real implementation,
depending on whether the designer aims for higher precision
or scalability. For Android, substitution classes are required,
for instance, for the abstract class android.context.Context.

Native Calls. Both Java and the Android platform support
invoking native methods written in C or other unmanaged
languages. For a Java-based analysis, such methods are black
boxes which cannot be resolved. We thus deﬁned explicit
taint propagation rules for the most common native methods,
such as arraycopy in java.lang.System. In this example, third
argument (the output array) will become tainted if the ﬁrst
argument (the input array) is tainted before the call. For
native methods without an explicit rule, we assume call
arguments and the return value to become tainted if at
least one parameter was tainted before. This is neither
entirely sound nor maximally precise but is probably the
only practical approximation in a black-box setting.

Taint Wrapping. Including the full JRE or Android plat-
form runtime in the analysis requires a lot of time and mem-
ory and can lead to unwanted imprecisions. Thus, while
explicit taint-propagation rules are required for native meth-
ods, they can be useful for regular Java methods as well:
their use can prevent the taint propagation from having
to analyze the library’s internals. FlowDroid supports a
simple textual ﬁle format for deﬁning such “shortcut rules”.
Predeﬁned rules handle collection classes, string bu↵ers and
similar commonly used data structures.

Limitations. At the moment FlowDroid ignores reﬂective
calls, which is unsound. While specialized static string anal-
yses can be used to simulate reﬂection to some extent, past
research has found such analyses to be incomplete [9], as
reﬂective call targets are often determined by external conﬁg-
uration ﬁles. On the Java platform, reﬂection-analysis tools
such as TamiFlex [9] can be used to make static analysis
tools aware of reﬂective calls. Such tool require load-time
instrumentation through java.lang.instrument, however, which
the Android platform does not currently support.

As described above, native code is approximated conser-
vatively using taint wrapping. Another limitation of Flow-
Droid is its current focus on explicit data ﬂows. Implicit
ﬂows caused by control-ﬂow dependencies are currently ig-
nored, but we plan to include them in the near future. Flow-
Droid also ignores probabilistic and possibilistic leaks caused
by multi-threading [13].

6. EXPERIMANTAL EVALUATION

Our evaluation addresses the following research questions:

RQ1 How does FlowDroid compare to commercial taint-
analysis tools for Android, both in terms of precision
and recall?

RQ2 Can FlowDroid ﬁnd all privacy leaks in Insecure-
Bank, an app speciﬁcally designed by others to chal-

lenge vulnerability-detection tools for Android [21], and
what is its performance?

RQ3 Can FlowDroid ﬁnd leaks in real-world applications

and how fast is it?

RQ4 How well does FlowDroid perform when being ap-
plied to taint-analysis problems related to Java, not
Android, both in terms of precision and recall?

The next sections address each research question in detail.
Section 6.5 explains why, unfortunately, we were unable to
directly compare FlowDroid to academic Android analysis
tools published elsewhere.
6.1 RQ1: Commercial taint-analysis tools

While there are benchmark suites for analyzing web appli-
cations or speciﬁcally for detecting di↵erent kinds of Java vul-
nerabilities [17], at the moment there is no Android-speciﬁc
analysis benchmark suite. This is problematic because the
generic Java test suites do not cover aspects like the An-
droid lifecycle, callbacks or interactions with UI elements
like password ﬁelds. Thus, they cannot be used for assessing
the practical e↵ectiveness of Android analysis tools.

DroidBench. Speciﬁcally for this work, we therefore de-
veloped an Android-speciﬁc test suite called DroidBench
containing 39 small Android apps. The suite can be used
to assess both static and dynamic taint analyses, but in
particular it contains test cases for interesting static-analysis
problems (ﬁeld sensitivity, object sensitivity, tradeo↵s in
access-path lengths etc.) as well as for Android-speciﬁc
challenges like correctly modeling an application’s lifecycle,
adequately handling asynchronous callbacks and interacting
with the UI. Table 3 contains a list of all apps in the suite
together with their respective names and short descriptions.
The table also indicates whether an analysis tool must model
the Android lifecycle or callback infrastructure to be able to
successfully analyze the app. We envision our test suite to
be extended by other researchers as well and then be used
to compare the completeness and correctness of the various
taint analysis approaches. DroidBench is available from
our project website.

Table 5 presents the analysis results for FlowDroid and
two commercial analysis tools explained in the following.
As the results show, FlowDroid generally performs quite
well. As explained before, for performance reasons, Flow-
Droid handles array indices imprecisely. The same limi-
tation applies to ListAccess1, causing false positives in the
ﬁrst category. Handling indices precisely and e ciently is an
interesting open research question. Button2 causes a false
positive because FlowDroid does not currently support
strong updates. In result, it cannot kill taints for certain
button combinations. Strong updates would require a must-
alias analysis which is hard to achieve inter-procedurally.
IntentSink1 is not detected because the test case contains no
actual sink. Instead, the tainted value is stored in an intent
which is then handed back to the activity by the framework.
Such cases are hard to handle without special treatment.
StaticInitialization1 fails because Soot currently assumes
all static initializers to execute at the beginning of the pro-
gram, which in this case is not correct. We plan to add
better support in the future. As most known taint-analysis
tools, FlowDroid currently disregards implicit ﬂows caused
through control-ﬂow dependencies.

Comparison with IBM AppScan Source. We compared
FlowDroid against IBM AppScan Source [2] version 8.7, on
all tests from DroidBench. AppScan Source distinguishes
three di↵erent categories of ﬁndings: vulnerabilities, excep-
tions of type 1 and exceptions of type 2. Vulnerabilities
include a complete path from source to sink. For a type 1
exception, there is a ﬂow from source to sink as well, but
the semantics of some methods along the propagation path
is unknown (e.g. possible sanitization). Since FlowDroid
does not support sanitization at the moment, we consider
both vulnerabilities and type 1 exceptions as ﬁndings. For
type 2 exceptions on the other hand, there is no trace. These
reports are generated when certain code constructs (e.g. writ-
ing a variable value into the log ﬁle) are detected. As these
ﬁndings are highly imprecise and completely disregard data
ﬂow, we do not count them as ﬁndings. As Table 5 shows,
AppScan Source ﬁnds only about 38% of all leaks (50% if
ignoring implicit ﬂows). Major problems occur with the
handling of callbacks, the Android component lifecycle and
implicit ﬂows.

Comparison with Fortify SCA. Fortify SCA [1] by HP is
another commercial tool widely used by security analysts.
Similar to IBM AppScan Source, Fortify also provides di↵er-
ent kinds of ﬁndings, such as data ﬂows from sensitive sources
to public sinks, requests for security-sensitive permissions,
calls to security-sensitive methods, etc. In our evaluation,
we only considered ﬁndings about data ﬂows. All tests were
carried out using version 5.14. As can be seen in Table 5, For-
tify SCA shows problems similar to those of IBM AppScan
(cf. Section 6.1), like the handling of the Android component
lifecycle, the callbacks and implicit ﬂows. Figure 5 shows
that Fortify detects 4 out of 6 data leaks for the lifecycle
tests, but closer inspection shows that this only happens
by chance. In these tests, the data source involves a static
ﬁeld, which Fortify apparently treats in a special way which
coincidentally causes a leak to be reported. When removing
the static modiﬁer, which does not the semantics of the test
case, Fortify does not detect the leak any longer.

Conclusion. From our experiments we conclude that, to not
overburden the user with false positives, AppScan Source and
Fortify SCA aim for relatively high precision while sacriﬁcing
recall, thus risking to miss actual privacy leaks. In compari-
son, FlowDroid shows higher precision with a signiﬁcantly
higher recall.
6.2 RQ2: Performance on InsecureBank

InsecureBank [21] is a vulnerable Android app created
by Paladion Inc. speciﬁcally for the purpose of evaluating
analysis tools such as FlowDroid. It contains various vul-
nerabilities and data leaks similar to those found in real-world
applications. Analyzing the application takes about 31 sec-
onds on a laptop computer with an Intel Core 2 Centrino
CPU and 4 GB of physical memory running on Windows 7
with Oracle’s Java Runtime version 1.7 (64 bit) in its default
settings. FlowDroid found all seven data leaks which we
all veriﬁed by hand. There were no false positives nor false
negatives.

6.3 RQ3: Real-World Applications

The above experiments give a very good indication that
FlowDroid yields correct and precise results, not just for
small test case but also for more realistic apps such as In-
secureBank [21]. To strengthen the external validity of our
experiments, we nevertheless performed an additional qualita-
tive analysis on a random selection of popular apps from the
Google Play store. While the obtained analysis reports do
not indicate any malicious apps in this selection, the majority
of apps is reported to—probably accidentally—leak informa-
tion into logs and preference ﬁles. Samsung’s Push Service,
for instance, logs the phones IMEI. Logs are problematic,
as the OS does not impose the same access restrictions on
logs as it does on ﬁles: all logs are readable by any app that
has the READ LOGS permission. The game Hugo Runner
stores longitude and latitude into a preferences ﬁle. As we
veriﬁed by hand, though, those preferences were correctly
written in private mode, precluding any access by other apps.
This indicates that taint analyses could gain precision by
considering auxiliary information such as the write mode
mentioned above. For most examined apps FlowDroid
terminated in under a minute. The longest-running instance,
Samsung’s Push Service took about 4.5 minutes to analyze.
6.4 RQ4: SecuriBench Micro

FlowDroid was speciﬁcally designed for Android, and
in this space gains much precision through its complete and
precise handling of Android’s lifecycle. Nevertheless, there is
nothing that would preclude software developers from apply-
ing FlowDroid to Java applications as well. To assess how
well FlowDroid is set up for this use case, we evaluated
FlowDroid against Stanford SecuriBench Micro [17] version
1.08, a common set of 96 J2EE micro benchmarks originally
intended for web-based applications. For each of the bench-
marks in the suite, we manually deﬁned the necessary lists of
sources, sinks and entry points. Since FlowDroid supports
a simple textual ﬁle format for deﬁning these parameters,
and since all benchmarks cases have the same structure, this
was not much e↵ort. For the interfaces HTTPServletRequest
and HTTPServletResponse we needed to provide substitution
classes (see Section 5), as we had no access to framework
code that would provide their implementations. We omit-
ted from our experiments test cases involving sanitization,
reﬂection, predicates and multi-threading. As we explained
earlier, such features are out of scope for our analysis tool,
just as they are for all other existing Android analysis tools.
Table 4 shows our test results grouped by test categories.
The TP column shows the true positives, i.e., the number
of actual leaks that FlowDroid found. For the example of
basic, for instance, FlowDroid found 58 out of 60. The FP
column shows the number of false positives, i.e., the ﬁnding
that FlowDroid reported that did not correspond to actual
leaks, but were rather artifacts of an overly approximate
analysis. In most cases this number is reasonably low or
even zero, except for the Arrays category. This is due to an
imprecision that FlowDroid shares with most other static
analyses: for performance reasons, the tools not di↵erentiate
between multiple components inside the same collection,
e.g., di↵erent indices in arrays or di↵erent positions in lists.
Treating such cases precisely and e ciently is an interesting
open issue in the static-analysis community. The n/a entries
in the table correspond to test categories such as reﬂection,
which we identiﬁed to be out of scope.

Test-case group
Aliasing
Arrays
Basic
Collections
Datastructure
Factory
Inter
Pred
Reﬂection
Sanitizer
Session
StrongUpdates
Sum

TP
11/11
9/9
58/60
14/14
5/5
3/3
14/16
n/a
n/a
n/a
3/3
0/0

117/121

FP
0
6
0
3
0
0
0

n/a
n/a
n/a

0
0
9

Table 4: SecuriBench Micro test results

6.5 Comparison with Other Tools

We also tried to compare FlowDroid to a number of other
tools from the scientiﬁc literature, namely TrustDroid [31],
LeakMiner [30], and the tool by Batyuk et al. [6]. Unfor-
tunately none of those tools are available online, and even
worse the respective authors did not reply to our inquiries.
We tried to run DroidBench on SCanDroid [11], but
faced technical di culties. The tool did not report any
ﬁndings at all in our setup. Though being in contact with the
authors, we were unable to ﬁx these issues by the submission
deadline. The authors of AndroidLeaks [12] promised to
run their tool on DroidBench but never delivered. We
also contacted the authors of CHEX [18], but they were
unable to provide the tool or any benchmark results due to
intellectual property claimed by NEC. Starostin [19] declined
to participate in the experiment as his tool ignores aliasing,
making any comparison meaningless.

In result, we were unable to successfully evaluate even a
single scientiﬁc taint-analysis tool for Android. We believe
that the lack of such comparative experiments is hindering
scientiﬁc progress a lot, which is why we make available our
entire implementation, documentation and benchmarks as
open source.

7. RELATED WORK

There are several approaches to static analysis of Android
applications di↵ering in precision, runtime, scope and focus.
One of the most sophisticated ones is CHEX [18], a tool
to detect component hijacking vulnerabilities in Android
applications by tracking taints between externally accessible
interfaces and sensitive sources or sinks. Although not built
for the task, CHEX can, in principle, be used for taint anal-
ysis. However, since CHEX looks for vulnerabilities, target
applications are supposed to be benign. The derived assump-
tions (no obfuscation etc.) do not hold for malicious apps.
Furthermore, CHEX does not analyze calls into Android
framework itself but instead requires a (hopefully complete)
model of the framework. In FlowDroid such a model is
optional and, except for native calls, is used only to increase
performance. CHEX’s entry point model requires an enumer-
ation of all possible split orderings which is not necessary in
FlowDroid.

LeakMiner [30] appears similar to our approach from a
technical point of view:
like FlowDroid, it is based on
Soot, uses Spark for call-graph generation, it implements the

Android lifecycle, and the paper states that an app can be
analyzed in 2.5 minutes on average. However, the analysis
is not context-sensitive which is likely a major source of
imprecision. Unfortunately we were unable to perform a
systematic comparison as the authors did not respond to our
inquiries.

AndroidLeaks [12] also states the ability to handle the
Android Lifecycle including callback methods. It is based on
WALA’s context-sensitive System Dependence Graph with a
context-insensitive overlay for heap tracking, but is not as
precise as FlowDroid, because it taints the whole object if
tainted data is stored in one of its ﬁelds. As noted before,
we contacted the authors but they failed to provide us any
data for a comparative evaluation.

SCanDroid [11] is another tool for reasoning about data
ﬂows in Android applications. Its main focus is the inter-
component (e.g. between two activities in the same app)
and inter-app data ﬂow. This poses the challenge of con-
necting intent senders to their respective receivers in other
applications. SCanDroid prunes all call edges to Android
OS methods and conservatively assumes the base object,
the parameters, and the return value to inherit taints from
arguments which is much less precise than FlowDroid’s
treatment. FlowDroid, on the other hand, currently does
not resolve intent-based communication. Such a feature
would require string analysis, which we leave to future work.
Other approaches like CopperDroid [24] dynamically ob-
serve interactions between the Android components and the
underlying Linux system to reconstruct higher-level behavior.
Special stimulation techniques are used for exercising the
application to ﬁnd malicious activities. Attackers, however,
can easily modify an app to detect whether it is running
inside a virtual machine and then leak no data during that
time. Alternatively, data leaks might only occur after a cer-
tain runtime threshold. Aurasium [28] and DroidScope [29]
largely su↵er from the same shortcomings with respect to
static leak detection.

There are also approaches with a much broader focus
like [6]. This approach not only tracks data ﬂows, but also
generate a user-friendly report and sanitizes malicious apps
by replacing their sources with safe equivalents like UUID
generators. The paper gives no details on the implementation,
which is why we were unable to conduct a detailed comparison
to our approach.

The approach by Payet et al. [22] tries to aid the developer
by checking for common programming errors using di↵erent
checks, for example a nullness analysis. In contrast to Flow-
Droid, their approach cannot perform a dataﬂow analysis
and is not focused on security.

8. CONCLUSIONS

We have presented FlowDroid, a novel and highly pre-
cise static taint-analysis tool for Android applications. We
have shown that many existing approaches do not adequately
model Android-speciﬁc challenges like the application life-
cycle or callback methods, leading to either missed leaks
or false positives. For assessing the e↵ectiveness of analysis
tools, we have proposed the Android-speciﬁc benchmark suite
DroidBench and used it for comparing FlowDroid to the
commercial tools AppScan Source and Fortify SCA, showing
that besides ﬁnding more real leaks, FlowDroid also has
a higher precision resulting in less false positives. We hope

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

The IFDS framework
Our inter-procedural dataﬂow analysis problem is formulated
in terms of the IFDS framework by Reps et al. [25] and can
therefore be reduced to a graph-reachability problem. IFDS
solves inter-procedural, ﬁnite, distributive subset problems
and works by creating a so-called exploded supergraph based
on ﬂow functions associated with the program statements.
A ﬂow function deﬁnes the impact of a statement on a set
of ﬂow facts. For example, the statement x = y would be
associated with a ﬂow function that maps a fact set {y} (i.e.
y is tainted) to a fact set {x, y} (x and y are both tainted).
Function calls are modeled using summary functions, which
makes the approach precise, yet very e cient: at di↵erent
call sites to the same method m, the summary function for
m is just reused (gaining e ciency) but it is applied to the
taint information at that very call site (thus yielding full
context sensitivity). Section 4 gives more details about how
FlowDroid constructs the supergraph.

Once the supergraph is constructed, the algorithm decides
whether a variable x at a statement s is tainted simply by
computing whether the node representing (s, x) is reachable
within this graph. Because all method calls have been ab-
stracted through summary functions, those queries are fully
intra-procedural and therefore highly e cient.
Attacker model
We assume an attacker that can supply an app with arbi-
trary malicious bytecode, obfuscated or not. In the scenario
treated in this paper, the attacker’s goal is to leak private
data through a dangerously broad set of permissions granted
by the user [4]. Our analysis makes sound assumptions on the
installation environment and app inputs, meaning that the
attacker is free to tamper with those as well. FlowDroid
does assume, however, that the attacker has no way of cir-
cumventing the security measures of the Android platform.
Also, right now no static analysis for Android, including
FlowDroid has a way of dealing with dynamic loading and
reﬂection. Bodden et al. showed how those features can be
handled in general [9], however their approach requires access
to a load-time instrumentation API, which is something that
Android does not currently support. We are in contact with
Google to see if such an API can be supported in the future.

3. PRECISE MODELLING OF LIFECYCLE

Multiple entry points. Unlike Java programs, Android ap-
plications do not have a main method. Apps instead comprise
many entry points, i.e., methods that are implicitly called
by the Android framework. The Android operating system
deﬁnes a complete lifecycle for all components in an applica-
tion. There are four di↵erent components an app developer
can deﬁne: activities are single focused user actions, ser-
vices perform background tasks, content providers deﬁne a
database-like storage, and broadcast receivers listen for global
events. All these components are implemented by deriving
a custom class from a predeﬁned operating system class,
registering it in the AndroidManifest.xml ﬁle and overwrit-
ing the lifecycle methods. The Android system calls these
methods at runtime to start or stop the component, or pause
or resume it, depending on environment needs. It can, e.g.,
stop an application because of low memory, and later restart
it when the user returns to it. Figure 1 shows the lifecycle

Activity
launched

onCreate()

User navigates
to the activity

onStart()

onRestart()

User

returns
to the
activity

User navigates
to the activity

App process

killed

Apps with

higher priority
needs memory

onResume()

Activity
running

Another

activity comes

into the foreground

onPause()

The activity is
no longer visible

onStop()

The activity is ﬁnishing or

being destroyed by the system

onDestroy()

Activity
shut down

Figure 1: Android Activity Lifecycle

for an activity. In result, when constructing a call graph,
Android analyses cannot simply start by inspecting a pre-
deﬁned “main” method. Instead, all possible transitions in
the Android lifecycle must be modeled precisely. To cope
with this problem, FlowDroid constructs a custom dummy
main method emulating the lifecycle. However, the lifecycle
is more complex than depicted and explicitly documented.
There are additional methods for saving and restoring state,
as well as callbacks that notify the app about additional state
changes. If not taken into account, a malicious application
could exploit these methods and send out secret information
without being noticed.

Asynchronously executing components. An application
can contain multiple components, e.g., three activities and
one service. The activities run sequentially, however, one can-
not pre-estimate their order. One activity could, for instance,
be the main one initially visible to the user and then launch
either one of the others depending on user input. Services run
in parallel. FlowDroid thus conservatively assumes that all
components (activities, services, etc.) inside an application
to run in an arbitrary sequential order. Within a component,
the analysis is fully ﬂow-sensitive, though. Additionally, the
Android operating system allows applications to register call-
backs for various types of information, e.g., location updates
or UI interactions. Callbacks implement predeﬁned interfaces
declaring methods that are then called asynchronously by
the operating system. FlowDroid models these callbacks
in its dummy main method, for instance to recognize cases
where an application stores to the heap the location data
that is passed into the callback as a parameter, and later
sends this data to the internet when the activity is stopped.
The order in which callbacks are invoked cannot generally
be predicted, which is why FlowDroid conservatively as-

LeakageApp la = new LeakageApp();

la.onCreate();

la.onStart();

la.onResume();

p

p

la.onPause();

p

la.onStop();

p

p

la.onDestroy();

la.sendMessage();

la.onRestart();

5

4

void foo( z ) {

x = z.g;
w = source(); 
x.f = w;

a.g.f

6

void main() { 
7
b.f

a = new A();
b = a.g;
foo(a);
sink(b.f);

}

x.f
} 

3

x.f
2

z.g.f

w

1

Figure 3: Taint analysis under realistic aliasing

Name
V arId
F ieldId
Stmt
Loc
V al = Loc [ {null}
Env : V arId ! V al
Heap : Loc ⇥ F ieldId ! V al Heap
States = Env ⇥ Heap

Description
Program variables
Field identiﬁers
Statements2
Memory locations
Values
Environment

Program States

Figure 2: CFG for dummy main method

Table 1: Formalization Domains

sumes that all callbacks can be invoked in any possible order.
Some static analysis are path-sensitive, i.e., consider each
possible program paths separately. In such cases, considering
all possible orderings would be very expensive. Fortunately,
FlowDroid bases its analysis on IFDS, which is not path-
sensitive and instead joins analysis results immediately at
any control-ﬂow merge point. For FlowDroid can thus
generate a main method in which every order of individual
component lifecycles and callbacks is possible, it does not
need to simulate all possible paths.

Example. In Figure 2 we show the control-ﬂow graph of the
dummy main method for our example. In this ﬁgure, p repre-
sents an opaque predicate of which we know that FlowDroid
won’t be able to evaluate it statically (for instance, a check
involving an environment variable). In result, the analysis
will automatically consider on equal terms both branches for
conditions involving p. Note that, to gain maximal precision,
we generate an individual dummy main method for each app
analyzed. Each main method will only involve the fraction of
the lifecycle that, according to the app’s XML conﬁguration
ﬁles, can actually occur. Disabled activities are automati-
cally ﬁltered and callback methods are only invoked in the
contexts of the components to which they actually belong.
A button click handler is for instance only analyzed in the
context of its respective activity.

4. CONTEXT, OBJECT, FIELD AND FLOW-

SENSITIVE ANALYSIS

One major di culty in the analysis is how to handle alias-
ing with high object sensitivity. Figure 3 shows how Flow-
Droid combines a forward-taint analysis and an on-demand
backward-alias analysis to decide that b.f is tainted at the
3 , where the forward analysis
sink. The important step is
assigns a taint to x.f. On such assignments to the heap, the
backward analysis searches upwards for aliases of x.f, an

idea borrowed from Andromeda [27]. At
is found and then propagated forward.

7 , the alias b.f

To increase the reproducibility of our approach, in this
section we give important details about the di↵erent transfer
functions our analysis associates with program statements.
In the following, ﬁrst we deﬁne an abstract heap model. Sec-
tion 4.1 explains our general taint analysis, while Section 4.2
explains our on-demand alias analysis.

FlowDroid leverages IFDS to propagate each tainted
value individually, using a multi-threaded implementation.
When processing any given statement, the set T of incoming
taints are transformed into a set of outgoing taints. We deﬁne
the abstract analysis semantics with the standard notation
used similarly by Tripp et al. [27]. Table 1 shows our abstract
domain. For representing the e↵ects of program statements,
FlowDroid uses the semantics deﬁned in Table 2. H 2
Heap deﬁnes the current heap, and E 2 Env the current
environment. A program state is deﬁned as   = hE, Hi 2
States.
To be able to explain our taint propagation algorithm in

detail we declare the following helper functions:

arrayElem(x) : V arId ! Boolean returns true i↵ x refer-

ences an array element

static(x) : F ieldId ! Boolean returns true i↵ x is a static

ﬁeld

2FlowDroid operates on an intermediate representation
that represents compound statements through individual
atomic statements.

Statement
x = new Object()
x = y
x.f = y
x = y.f

Semantics
  =  [x ! o 2 Loc. o is fresh]
  =  [E(x) ! E(y)]
  =  [H((E(x), f )) ! E(y)]
  =  [E(x) ! H((E(y), f ))]

Table 2: Program Semantics

immut(x) : V arId ! Boolean returns true i↵ x is a primi-

tive or immutable data type (int, String, etc.)

source(s) : Stmt ! P (V arId) returns a set of variable names
tainted by the source statement s or ; if s is no source
native(s) : Stmt ! Boolean returns true i↵ s contains a call

to a native method

nativeT aint(s) : Stmt ! P (V arId) returns values which are
tainted after the native call s 2 Stmt. Such values can
include the base object on which the method was in-
voked, the return value, or one or more of the input
parameters.

nativeAlias(s) : Stmt ! P (V arId) returns possible aliases
of tainted values before the native call s 2 Stmt (back-
wards analysis)

To model deep object sensitivity, FlowDroid does not
simply propagate simple ﬁelds like x.f but instead so-called
access paths [27] up to a ﬁxed length. x.f.g.h for instance
models an access path of length 3. We use the notation
x.f n to describe an arbitrary but ﬁxed access path of length
n, rooted at x. For example x.f 3 represents paths such as
x.f.g.h. Note that x.f 0 is equal to x. The notation allows
us to split ﬁeld accesses such that x.f p = x.f n.f m where
p = m + n. In result, T is actually a set of currently tainted
access paths.

A concrete state is a program state extended by the set
of tainted access paths T resulting in a triple   = hE, H, Ti.
At the beginning it holds that T = ;. Tainted access paths
are added to the set whenever the analysis reaches a call to
a source, or when processing a statement that propagates an
existing taint to a new memory location. We next explain
the di↵erent transfer functions that FlowDroid uses to
compute taints. Section 4.2 explains how we use access paths
to deal with aliasing.
4.1 Taint analysis

The taint analysis starts directly at each of the identiﬁed
and reachable sources. The IFDS framework distinguishes
four di↵erent kinds of ﬂow functions: normal, call, return
and call-to-return.

Normal ﬂow function. Normal ﬂow functions are applied
at all statements that are neither calls nor returns. In Flow-
Droid, only method calls can be the original source of a
taint. Thus, a normal ﬂow function can never generate new
taints, it can only transfer, preserve, or “kill” existing taints.
FlowDroid is insensitive to array indices, tainting the
entire set of array elements even if the program taints just
a single element. To be sound, FlowDroid thus needs to
assume that the entire contents remain tainted, even if the
single array element is overwritten by an untainted value
later-on. For an assignment statement s 2 Stmt with the
structure x.f n = y.f m with n, m 2 N0 the following rules
apply:

T [ {x.f n.f p} 8p : y.f m.f p 2 T
T\{x.f n}
T

y.f m.f⇤ /2 T ^ ¬arrayElem(x.f n)
otherwise

A special case is the new statement which creates a fresh

T s !8<:

object:
T x.f n=new...

        ! T\{x.f n.f⇤ 2 T|¬arrayElem(x.f n)}.

Assigning a fresh object erases the taints for the memory
location referred to by the left-hand side and all access paths
that could be reached through this reference.

Assignments of arithmetic operations such as x = a + b are
treated by tainting the left-hand side if any of the operands
are tainted. For now, FlowDroid uses a simple two-element
security lattice but it can easily be extended to track more
information about the kind of taint that is propagated.

Call ﬂow function. Call ﬂow functions handle ﬂows into
callees of calls such as c.m(a0, . . . , an), n 2 N0. To model
the context change from the body of the caller to the one of
the callee, FlowDroid builds taint set Tcallee based on the
caller’s set Tcaller, replacing references to actual parameters
ai by references to formal parameters pi. If a variable is
tainted in the caller’s context, FlowDroid converts it to
the callee context by replacing c with this.
{this.f m} c.f m 2 Tcaller
ai.f p 2 Tcaller
{pi.f p}
{y.f q}
x.f q 2 Tcaller ^ static(y.f q)

Tcallee

s ! [8<:

Return ﬂow function. At a return (both exceptional and
regular), the return ﬂow function maps taints from the callee’s
context back to the one of the caller. FlowDroid’s return
ﬂow functions specially treats immutable values. Such val-
ues, by their very nature, can never change their taint status.
Thus, if a parameter of an immutable type like String or int
was not tainted before the call it cannot be tainted by the
callee and is thus still guaranteed to be untainted on return.
In all other cases, the taint of all tainted access paths is
mapped back to the caller’s context. The following ﬂow func-
tion applies when the callee returns a variable r after being
called using a statement of the form b = c.m(a0, . . . , an):

Tcaller

s ! [8>><>>:

{c.f m}
this.f m 2 Tcallee
{ai.f p} pi.f p 2 Tcallee ^ ¬immut(ai)
x.f q 2 Tcallee ^ static(y.f q)
{y.f q}
{b.f v}
r.f v 2 Tcallee

Call-to-return ﬂow function. For every call there is also
intra-procedural edge propagating all taint values that are
independent of the callee.
In this function, we generate
taints at sources, through a simple pattern match against an
extensible list of method signatures. We also handle native
method calls here (for details, see Section 5). Again consider
a call b = c.m(a0, . . . , an):

T [ nativeT aint(s, T ) native(s) ^ ai.f m 2 T
T [ {x}
T

x 2 source(s)
otherwise

T s !8<:

4.2 On-demand alias analysis

During our research we experimented a lot with di↵er-
ent ways to resolve aliasing e↵ectively and e ciently. As it
turned out, using ahead-of-time analyses is usually too costly
(because the analysis computes alias information for all pro-
gram variables, not just those that carry taints) and too
imprecise (because the analysis would not support the same
level of context-sensitivity as our taint analysis). We hence
opted for a demand-driven approach by Tripp et al., which
executes within the same context-sensitive IFDS framework
as our taint analysis [27]. As Figure 3 shows, this on-demand
analysis is triggered at assignments to heap variables, i.e.,

statements of the form x.f = v. The alias analysis then walks
backward through the control-ﬂow graph. Whenever it ﬁnds
an alias, it triggers the forward analysis in turn, propagat-
ing an aliased taint from the location at which the alias
was found. Similar to the forward analysis, we deﬁne ﬂow
functions which compute the alias propagation information.
Let the set A deﬁne the alias information. The only ini-
tial element in A is the complete access path of the tainted
value which caused the alias lookup. The backward solver
terminates when A becomes empty.

source, sink and

entry-point detection

parse manifest ﬁle

generate

main method

parse .dex ﬁles

build call graph

parse layout xmls

perform taint

analysis

Normal ﬂow function. For a statement x.f = y.g the fol-
lowing rule applies:

A s ! [⇢ A\{x.f.f p} [ {y.g.f p} 8p : x.f.f p 2 A

otherwise

A

For new statements, FlowDroid erases all alias informa-
tion for the left-hand side, as fresh objects cannot be aliased:
A x.f =new...

       ! A\{8m : x.f.f⇤ 2 A}

Call ﬂow function. Since the backward analysis traverses
the control-ﬂow graph backwards, its call ﬂow function prop-
agates information from call sites to return sites in the callee.
Consider again a call b = c.m(a0, . . . , an) and a return site
returning a variable r:
b.f m 2 Acaller
{r.f m}
{this.f m} c.f m 2 Acaller
{y.f q}
y.f q 2 Acaller ^ static(y.f q)

Acallee

s ! [8<:

Return ﬂow function. In the backwards analysis, return
ﬂow functions propagate from the callee’s start point to just
before the call site. The return ﬂow function thus maps the
callee’s aliases at back to the caller while taking into account
renaming from formal parameters pi to actual parameters ai.
For a call site c.m(a0, . . . , an) we obtain:
this.f m 2 Acallee
y.f q 2 Acallee ^ static(y.f q)

{c.f m}
{ai.f p} pi.f p 2 Acallee
{y.f q}

Acaller

s ! [8<:
A s !8>><>>:

Call-to-return ﬂow function. For a call site b = c.m(a0, . . . , an),
the call-to-return ﬂow function handles aliases induced by
native calls and kills aliases of references obtained through b:

A [ nativeAlias(s) native(s)
^(ai.f m 2 A _ c.f n 2 A)
A\{b.f n}
b.f n 2 A
otherwise
A

5.

IMPLEMENTATION

FlowDroid extends the Soot framework [16] which pro-
vides important prerequisites for a precise analysis, in par-
ticular a very accurate call graph. Through a plugin called
Dexpler [5] Soot supports not only converting Java code but
also Android’s dex ﬁles into the Jimple intermediate repre-
sentation which allows us to implement our analysis for both
targets. FlowDroid further uses Heros [8] as an implemen-
tation of IFDS on top of Soot and Dexpler. We next explain
FlowDroid’s architecture, while the subsequent sections
explain interesting implementation details and FlowDroid’s
current limitations.

Figure 4: Overview of FlowDroid

Architecture. Figure 4 shows FlowDroid’s architecture.
Android applications are packaged in apk ﬁles (Android Pack-
ages), which are essentially zip-compressed archives. After
unzipping an archive, FlowDroid searches for lifecycle and
callback methods as well as calls to sources and sinks in the
application. This is done by parsing various Android-speciﬁc
ﬁles, including the layout XML ﬁles, the dex ﬁles contain-
ing the executable code and the manifest ﬁle deﬁning the
activities, services, broadcast receivers and content providers
in the application. We describe the detection of UI Inter-
actions in detail below. Next, FlowDroid generates the
main method from the list of lifecycle and callback methods
(see the Paragraphs Callbacks and Substitution Classes for
more information). This main method is then used to gener-
ate a call graph and an inter-procedural control-ﬂow graph
(ICFG). Starting at the detected sources, the taint analysis
then tracks taints by traversing the ICFG as explained in
Section 4. Native Calls require a special treatment which
is described below along with a performance optimization
called Taint Wrapping. At the end, FlowDroid reports all
discovered ﬂows from sources to sinks.

UI Interactions. UI elements can be taint sources, e.g., if
an application prompts the user for a password and then
sends it out to the Internet. FlowDroid thus scans the
layout XML ﬁles in the apk ﬁle for text inputs and links
them to the source-code statements where they are accessed.
This is non-trivial, as the Android operating system manages
access to such resources at runtime and a static analysis tool
must simulate these runtime APIs as precisely as possible.
Note that we need to over-approximate resource accesses in
the general case, though. In Android, resource mappings can
be conﬁguration-dependent, for instance to support di↵erent
layouts for smartphones and tablets. In this case, we can
only assume all cases as possible. Not all data in text ﬁelds
is sensitive, though. FlowDroid can be conﬁgured to either
consider all text ﬁelds or to restrict itself to special sensitive
ﬁelds like password input ﬁelds (the default).

Callbacks. To model the app lifecycle correctly (see Sec-
tion 3), FlowDroid contains a list of callback interfaces
extracted from the Android documentation. FlowDroid
ﬁrst computes a call graph ignoring callbacks, to determine
which activity will potentially register which kind of callback
at runtime. Next, FlowDroid generates a customized main
method for each activity, taking the respective discovered
callbacks into account.

Substitution Classes. J2EE and Android applications some-
times operate on interface types or abstract class types that
at runtime receive objects instantiated within the J2EE or

Android framework. FlowDroid’s main-method generator
cannot easily be aware of those concrete subtypes. Flow-
Droid thus allows the analysis designer to provide a list of
so-called substitution classes. A substitution class provides
a concrete implementation for one or more of these inter-
faces, simply for the purpose of the analysis. The user can
choose whether to provide a stub or a real implementation,
depending on whether the designer aims for higher precision
or scalability. For Android, substitution classes are required,
for instance, for the abstract class android.context.Context.

Native Calls. Both Java and the Android platform support
invoking native methods written in C or other unmanaged
languages. For a Java-based analysis, such methods are black
boxes which cannot be resolved. We thus deﬁned explicit
taint propagation rules for the most common native methods,
such as arraycopy in java.lang.System. In this example, third
argument (the output array) will become tainted if the ﬁrst
argument (the input array) is tainted before the call. For
native methods without an explicit rule, we assume call
arguments and the return value to become tainted if at
least one parameter was tainted before. This is neither
entirely sound nor maximally precise but is probably the
only practical approximation in a black-box setting.

Taint Wrapping. Including the full JRE or Android plat-
form runtime in the analysis requires a lot of time and mem-
ory and can lead to unwanted imprecisions. Thus, while
explicit taint-propagation rules are required for native meth-
ods, they can be useful for regular Java methods as well:
their use can prevent the taint propagation from having
to analyze the library’s internals. FlowDroid supports a
simple textual ﬁle format for deﬁning such “shortcut rules”.
Predeﬁned rules handle collection classes, string bu↵ers and
similar commonly used data structures.

Limitations. At the moment FlowDroid ignores reﬂective
calls, which is unsound. While specialized static string anal-
yses can be used to simulate reﬂection to some extent, past
research has found such analyses to be incomplete [9], as
reﬂective call targets are often determined by external conﬁg-
uration ﬁles. On the Java platform, reﬂection-analysis tools
such as TamiFlex [9] can be used to make static analysis
tools aware of reﬂective calls. Such tool require load-time
instrumentation through java.lang.instrument, however, which
the Android platform does not currently support.

As described above, native code is approximated conser-
vatively using taint wrapping. Another limitation of Flow-
Droid is its current focus on explicit data ﬂows. Implicit
ﬂows caused by control-ﬂow dependencies are currently ig-
nored, but we plan to include them in the near future. Flow-
Droid also ignores probabilistic and possibilistic leaks caused
by multi-threading [13].

6. EXPERIMANTAL EVALUATION

Our evaluation addresses the following research questions:

RQ1 How does FlowDroid compare to commercial taint-
analysis tools for Android, both in terms of precision
and recall?

RQ2 Can FlowDroid ﬁnd all privacy leaks in Insecure-
Bank, an app speciﬁcally designed by others to chal-

lenge vulnerability-detection tools for Android [21], and
what is its performance?

RQ3 Can FlowDroid ﬁnd leaks in real-world applications

and how fast is it?

RQ4 How well does FlowDroid perform when being ap-
plied to taint-analysis problems related to Java, not
Android, both in terms of precision and recall?

The next sections address each research question in detail.
Section 6.5 explains why, unfortunately, we were unable to
directly compare FlowDroid to academic Android analysis
tools published elsewhere.
6.1 RQ1: Commercial taint-analysis tools

While there are benchmark suites for analyzing web appli-
cations or speciﬁcally for detecting di↵erent kinds of Java vul-
nerabilities [17], at the moment there is no Android-speciﬁc
analysis benchmark suite. This is problematic because the
generic Java test suites do not cover aspects like the An-
droid lifecycle, callbacks or interactions with UI elements
like password ﬁelds. Thus, they cannot be used for assessing
the practical e↵ectiveness of Android analysis tools.

DroidBench. Speciﬁcally for this work, we therefore de-
veloped an Android-speciﬁc test suite called DroidBench
containing 39 small Android apps. The suite can be used
to assess both static and dynamic taint analyses, but in
particular it contains test cases for interesting static-analysis
problems (ﬁeld sensitivity, object sensitivity, tradeo↵s in
access-path lengths etc.) as well as for Android-speciﬁc
challenges like correctly modeling an application’s lifecycle,
adequately handling asynchronous callbacks and interacting
with the UI. Table 3 contains a list of all apps in the suite
together with their respective names and short descriptions.
The table also indicates whether an analysis tool must model
the Android lifecycle or callback infrastructure to be able to
successfully analyze the app. We envision our test suite to
be extended by other researchers as well and then be used
to compare the completeness and correctness of the various
taint analysis approaches. DroidBench is available from
our project website.

Table 5 presents the analysis results for FlowDroid and
two commercial analysis tools explained in the following.
As the results show, FlowDroid generally performs quite
well. As explained before, for performance reasons, Flow-
Droid handles array indices imprecisely. The same limi-
tation applies to ListAccess1, causing false positives in the
ﬁrst category. Handling indices precisely and e ciently is an
interesting open research question. Button2 causes a false
positive because FlowDroid does not currently support
strong updates. In result, it cannot kill taints for certain
button combinations. Strong updates would require a must-
alias analysis which is hard to achieve inter-procedurally.
IntentSink1 is not detected because the test case contains no
actual sink. Instead, the tainted value is stored in an intent
which is then handed back to the activity by the framework.
Such cases are hard to handle without special treatment.
StaticInitialization1 fails because Soot currently assumes
all static initializers to execute at the beginning of the pro-
gram, which in this case is not correct. We plan to add
better support in the future. As most known taint-analysis
tools, FlowDroid currently disregards implicit ﬂows caused
through control-ﬂow dependencies.

Comparison with IBM AppScan Source. We compared
FlowDroid against IBM AppScan Source [2] version 8.7, on
all tests from DroidBench. AppScan Source distinguishes
three di↵erent categories of ﬁndings: vulnerabilities, excep-
tions of type 1 and exceptions of type 2. Vulnerabilities
include a complete path from source to sink. For a type 1
exception, there is a ﬂow from source to sink as well, but
the semantics of some methods along the propagation path
is unknown (e.g. possible sanitization). Since FlowDroid
does not support sanitization at the moment, we consider
both vulnerabilities and type 1 exceptions as ﬁndings. For
type 2 exceptions on the other hand, there is no trace. These
reports are generated when certain code constructs (e.g. writ-
ing a variable value into the log ﬁle) are detected. As these
ﬁndings are highly imprecise and completely disregard data
ﬂow, we do not count them as ﬁndings. As Table 5 shows,
AppScan Source ﬁnds only about 38% of all leaks (50% if
ignoring implicit ﬂows). Major problems occur with the
handling of callbacks, the Android component lifecycle and
implicit ﬂows.

Comparison with Fortify SCA. Fortify SCA [1] by HP is
another commercial tool widely used by security analysts.
Similar to IBM AppScan Source, Fortify also provides di↵er-
ent kinds of ﬁndings, such as data ﬂows from sensitive sources
to public sinks, requests for security-sensitive permissions,
calls to security-sensitive methods, etc. In our evaluation,
we only considered ﬁndings about data ﬂows. All tests were
carried out using version 5.14. As can be seen in Table 5, For-
tify SCA shows problems similar to those of IBM AppScan
(cf. Section 6.1), like the handling of the Android component
lifecycle, the callbacks and implicit ﬂows. Figure 5 shows
that Fortify detects 4 out of 6 data leaks for the lifecycle
tests, but closer inspection shows that this only happens
by chance. In these tests, the data source involves a static
ﬁeld, which Fortify apparently treats in a special way which
coincidentally causes a leak to be reported. When removing
the static modiﬁer, which does not the semantics of the test
case, Fortify does not detect the leak any longer.

Conclusion. From our experiments we conclude that, to not
overburden the user with false positives, AppScan Source and
Fortify SCA aim for relatively high precision while sacriﬁcing
recall, thus risking to miss actual privacy leaks. In compari-
son, FlowDroid shows higher precision with a signiﬁcantly
higher recall.
6.2 RQ2: Performance on InsecureBank

InsecureBank [21] is a vulnerable Android app created
by Paladion Inc. speciﬁcally for the purpose of evaluating
analysis tools such as FlowDroid. It contains various vul-
nerabilities and data leaks similar to those found in real-world
applications. Analyzing the application takes about 31 sec-
onds on a laptop computer with an Intel Core 2 Centrino
CPU and 4 GB of physical memory running on Windows 7
with Oracle’s Java Runtime version 1.7 (64 bit) in its default
settings. FlowDroid found all seven data leaks which we
all veriﬁed by hand. There were no false positives nor false
negatives.

6.3 RQ3: Real-World Applications

The above experiments give a very good indication that
FlowDroid yields correct and precise results, not just for
small test case but also for more realistic apps such as In-
secureBank [21]. To strengthen the external validity of our
experiments, we nevertheless performed an additional qualita-
tive analysis on a random selection of popular apps from the
Google Play store. While the obtained analysis reports do
not indicate any malicious apps in this selection, the majority
of apps is reported to—probably accidentally—leak informa-
tion into logs and preference ﬁles. Samsung’s Push Service,
for instance, logs the phones IMEI. Logs are problematic,
as the OS does not impose the same access restrictions on
logs as it does on ﬁles: all logs are readable by any app that
has the READ LOGS permission. The game Hugo Runner
stores longitude and latitude into a preferences ﬁle. As we
veriﬁed by hand, though, those preferences were correctly
written in private mode, precluding any access by other apps.
This indicates that taint analyses could gain precision by
considering auxiliary information such as the write mode
mentioned above. For most examined apps FlowDroid
terminated in under a minute. The longest-running instance,
Samsung’s Push Service took about 4.5 minutes to analyze.
6.4 RQ4: SecuriBench Micro

FlowDroid was speciﬁcally designed for Android, and
in this space gains much precision through its complete and
precise handling of Android’s lifecycle. Nevertheless, there is
nothing that would preclude software developers from apply-
ing FlowDroid to Java applications as well. To assess how
well FlowDroid is set up for this use case, we evaluated
FlowDroid against Stanford SecuriBench Micro [17] version
1.08, a common set of 96 J2EE micro benchmarks originally
intended for web-based applications. For each of the bench-
marks in the suite, we manually deﬁned the necessary lists of
sources, sinks and entry points. Since FlowDroid supports
a simple textual ﬁle format for deﬁning these parameters,
and since all benchmarks cases have the same structure, this
was not much e↵ort. For the interfaces HTTPServletRequest
and HTTPServletResponse we needed to provide substitution
classes (see Section 5), as we had no access to framework
code that would provide their implementations. We omit-
ted from our experiments test cases involving sanitization,
reﬂection, predicates and multi-threading. As we explained
earlier, such features are out of scope for our analysis tool,
just as they are for all other existing Android analysis tools.
Table 4 shows our test results grouped by test categories.
The TP column shows the true positives, i.e., the number
of actual leaks that FlowDroid found. For the example of
basic, for instance, FlowDroid found 58 out of 60. The FP
column shows the number of false positives, i.e., the ﬁnding
that FlowDroid reported that did not correspond to actual
leaks, but were rather artifacts of an overly approximate
analysis. In most cases this number is reasonably low or
even zero, except for the Arrays category. This is due to an
imprecision that FlowDroid shares with most other static
analyses: for performance reasons, the tools not di↵erentiate
between multiple components inside the same collection,
e.g., di↵erent indices in arrays or di↵erent positions in lists.
Treating such cases precisely and e ciently is an interesting
open issue in the static-analysis community. The n/a entries
in the table correspond to test categories such as reﬂection,
which we identiﬁed to be out of scope.

Test-case group
Aliasing
Arrays
Basic
Collections
Datastructure
Factory
Inter
Pred
Reﬂection
Sanitizer
Session
StrongUpdates
Sum

TP
11/11
9/9
58/60
14/14
5/5
3/3
14/16
n/a
n/a
n/a
3/3
0/0

117/121

FP
0
6
0
3
0
0
0

n/a
n/a
n/a

0
0
9

Table 4: SecuriBench Micro test results

6.5 Comparison with Other Tools

We also tried to compare FlowDroid to a number of other
tools from the scientiﬁc literature, namely TrustDroid [31],
LeakMiner [30], and the tool by Batyuk et al. [6]. Unfor-
tunately none of those tools are available online, and even
worse the respective authors did not reply to our inquiries.
We tried to run DroidBench on SCanDroid [11], but
faced technical di culties. The tool did not report any
ﬁndings at all in our setup. Though being in contact with the
authors, we were unable to ﬁx these issues by the submission
deadline. The authors of AndroidLeaks [12] promised to
run their tool on DroidBench but never delivered. We
also contacted the authors of CHEX [18], but they were
unable to provide the tool or any benchmark results due to
intellectual property claimed by NEC. Starostin [19] declined
to participate in the experiment as his tool ignores aliasing,
making any comparison meaningless.

In result, we were unable to successfully evaluate even a
single scientiﬁc taint-analysis tool for Android. We believe
that the lack of such comparative experiments is hindering
scientiﬁc progress a lot, which is why we make available our
entire implementation, documentation and benchmarks as
open source.

7. RELATED WORK

There are several approaches to static analysis of Android
applications di↵ering in precision, runtime, scope and focus.
One of the most sophisticated ones is CHEX [18], a tool
to detect component hijacking vulnerabilities in Android
applications by tracking taints between externally accessible
interfaces and sensitive sources or sinks. Although not built
for the task, CHEX can, in principle, be used for taint anal-
ysis. However, since CHEX looks for vulnerabilities, target
applications are supposed to be benign. The derived assump-
tions (no obfuscation etc.) do not hold for malicious apps.
Furthermore, CHEX does not analyze calls into Android
framework itself but instead requires a (hopefully complete)
model of the framework. In FlowDroid such a model is
optional and, except for native calls, is used only to increase
performance. CHEX’s entry point model requires an enumer-
ation of all possible split orderings which is not necessary in
FlowDroid.

LeakMiner [30] appears similar to our approach from a
technical point of view:
like FlowDroid, it is based on
Soot, uses Spark for call-graph generation, it implements the

Android lifecycle, and the paper states that an app can be
analyzed in 2.5 minutes on average. However, the analysis
is not context-sensitive which is likely a major source of
imprecision. Unfortunately we were unable to perform a
systematic comparison as the authors did not respond to our
inquiries.

AndroidLeaks [12] also states the ability to handle the
Android Lifecycle including callback methods. It is based on
WALA’s context-sensitive System Dependence Graph with a
context-insensitive overlay for heap tracking, but is not as
precise as FlowDroid, because it taints the whole object if
tainted data is stored in one of its ﬁelds. As noted before,
we contacted the authors but they failed to provide us any
data for a comparative evaluation.

SCanDroid [11] is another tool for reasoning about data
ﬂows in Android applications. Its main focus is the inter-
component (e.g. between two activities in the same app)
and inter-app data ﬂow. This poses the challenge of con-
necting intent senders to their respective receivers in other
applications. SCanDroid prunes all call edges to Android
OS methods and conservatively assumes the base object,
the parameters, and the return value to inherit taints from
arguments which is much less precise than FlowDroid’s
treatment. FlowDroid, on the other hand, currently does
not resolve intent-based communication. Such a feature
would require string analysis, which we leave to future work.
Other approaches like CopperDroid [24] dynamically ob-
serve interactions between the Android components and the
underlying Linux system to reconstruct higher-level behavior.
Special stimulation techniques are used for exercising the
application to ﬁnd malicious activities. Attackers, however,
can easily modify an app to detect whether it is running
inside a virtual machine and then leak no data during that
time. Alternatively, data leaks might only occur after a cer-
tain runtime threshold. Aurasium [28] and DroidScope [29]
largely su↵er from the same shortcomings with respect to
static leak detection.

There are also approaches with a much broader focus
like [6]. This approach not only tracks data ﬂows, but also
generate a user-friendly report and sanitizes malicious apps
by replacing their sources with safe equivalents like UUID
generators. The paper gives no details on the implementation,
which is why we were unable to conduct a detailed comparison
to our approach.

The approach by Payet et al. [22] tries to aid the developer
by checking for common programming errors using di↵erent
checks, for example a nullness analysis. In contrast to Flow-
Droid, their approach cannot perform a dataﬂow analysis
and is not focused on security.

8. CONCLUSIONS

We have presented FlowDroid, a novel and highly pre-
cise static taint-analysis tool for Android applications. We
have shown that many existing approaches do not adequately
model Android-speciﬁc challenges like the application life-
cycle or callback methods, leading to either missed leaks
or false positives. For assessing the e↵ectiveness of analysis
tools, we have proposed the Android-speciﬁc benchmark suite
DroidBench and used it for comparing FlowDroid to the
commercial tools AppScan Source and Fortify SCA, showing
that besides ﬁnding more real leaks, FlowDroid also has
a higher precision resulting in less false positives. We hope

that in the future DroidBench will serve as a standard test
set for Android taint analyses.

Acknowledgements.

We would like to thank Stephan Huber from Fraunhofer
SIT for supporting us with real-world applications from the
Google Play market and Dr. Karsten Sohr from TZi Bremen
for supporting us with the Fortify SCA evaluation. This
work was supported by a Google Faculty Research Award,
by the BMBF within EC SPRIDE, by the Hessian LOEWE
excellence initiative within CASED, and by the DFG within
the project RUNSECURE.

9. REFERENCES
[1] Fortify 360 Source Code Analyzer (SCA), April 2013.

http://www8.hp.com/us/en/software-solutions/
software.html?compURI=1214365#.UW6CVKuAtfQ.

[2] Ibm rational appscan, April 2013. http:

//www-01.ibm.com/software/de/rational/appscan/.

[3] Android. Android security overview, December 2012.

http://source.android.com/tech/security/.

[4] Alexandre Bartel, Jacques Klein, Yves Le Traon, and

Martin Monperrus. Automatically securing
permission-based software by reducing the attack
surface: an application to android. In Proceedings of
the 27th IEEE/ACM International Conference on
Automated Software Engineering, ASE 2012, pages
274–277, New York, NY, USA, 2012. ACM.

[5] Alexandre Bartel, Jacques Klein, Yves Le Traon, and

Martin Monperrus. Dexpler: converting android dalvik
bytecode to jimple for static analysis with soot. In
Proceedings of the ACM SIGPLAN International
Workshop on State of the Art in Java Program analysis,
SOAP ’12, pages 27–38, New York, NY, USA, 2012.
ACM.

[6] L. Batyuk, M. Herpich, S.A. Camtepe, K. Raddatz,

A.-D. Schmidt, and S. Albayrak. Using static analysis
for automatic assessment and mitigation of unwanted
and malicious activities within android applications. In
Malicious and Unwanted Software (MALWARE), 2011
6th International Conference on, pages 66–72, 2011.

[7] Bit9. Pausing google play: More than 100,000 android

apps may pose security risks, November 2012.
http://www.bit9.com/pausing-google-play/.

[8] Eric Bodden. Inter-procedural data-ﬂow analysis with

ifds/ide and soot. In Proceedings of the ACM
SIGPLAN International Workshop on State of the Art
in Java Program analysis, SOAP ’12, pages 3–8, New
York, NY, USA, 2012. ACM.

[9] Eric Bodden, Andreas Sewe, Jan Sinschek, Hela

Oueslati, and Mira Mezini. Taming reﬂection: Aiding
static analysis in the presence of reﬂection and custom
class loaders. In ICSE ’11: International Conference on
Software Engineering, pages 241–250. ACM, May 2011.

[10] International Data Corporation. Worldwide quarterly

mobile phone tracker 3q12, November 2012.
http://www.idc.com/tracker/showproductinfo.
jsp?prod_id=37.

[11] Adam P. Fuchs, Avik Chaudhuri, and Je↵rey S. Foster.
Scandroid: Automated security certiﬁcation of android
applications.

[12] Clint Gibler, Jonathan Crussell, Jeremy Erickson, and

Hao Chen. Androidleaks: automatically detecting
potential privacy leaks in android applications on a
large scale. In Proceedings of the 5th international
conference on Trust and Trustworthy Computing,
TRUST’12, pages 291–307. Springer, 2012.

[13] Dennis Gi↵horn and Gregor Snelting. Probabilistic

noninterference based on program dependence graphs.
Technical Report 06/2012, KIT, Faculty of Informatics,
June 2012. revised 2013, submitted for publication.

[14] Google Inc. Permissions, December 2012.

http://developer.android.com/guide/topics/
security/permissions.html.

[15] Google Inc. Android and security, November 2012.

http://googlemobile.blogspot.de/2012/02/
android-and-security.html.

[16] Patrick Lam, Eric Bodden, Ondrej Lhotak, and Laurie

Hendren. The soot framework for java program
analysis: a retrospective. In Cetus Users and Compiler
Infastructure Workshop (CETUS 2011), Oktober 2011.

[17] Ben Livshits. Securibench micro, March 2013.
http://suif.stanford.edu/~livshits/work/
securibench-micro/.

[18] Long Lu, Zhichun Li, Zhenyu Wu, Wenke Lee, and

Guofei Jiang. Chex: statically vetting android apps for
component hijacking vulnerabilities. In Proceedings of
the 2012 ACM conference on Computer and
communications security, CCS ’12, pages 229–240, New
York, NY, USA, 2012. ACM.

[19] Christopher Mann and Artem Starostin. A framework

for static detection of privacy leaks in android
applications. In Proceedings of the 27th Annual ACM
Symposium on Applied Computing, SAC ’12, pages
1457–1462, New York, NY, USA, 2012. ACM.

[20] Mohammad Nauman, Sohail Khan, and Xinwen Zhang.

Apex: extending android permission model and
enforcement with user-deﬁned runtime constraints. In
ASIACCS ’10, pages 328–332, New York, NY, USA,
2010. ACM.

[21] Paladion. Insecurebank test app.

http://www.paladion.net/downloadapp.html.

[22] ´Etienne Payet and Fausto Spoto. Static analysis of

android programs. In Proceedings of the 23rd
international conference on Automated deduction,
CADE’11, pages 439–445, Berlin, Heidelberg, 2011.
Springer-Verlag.

[23] Nicholas J Percoco and Sean Schulte. Adventures in

bouncerland. Blackhat USA, 2012.

[24] Alessandro Reina, Aristide Fattori, and Lorenzo

Cavallaro. A system call-centric analysis and
stimulation technique to automatically reconstruct
android malware behaviors. In EUROSEC, Prague,
Czech Republic, April 2013.

[25] Thomas Reps, Susan Horwitz, and Mooly Sagiv.

Precise interprocedural dataﬂow analysis via graph
reachability. In POPL ’95, pages 49–61, 1995.

[26] Yannis Smaragdakis, Martin Bravenboer, and Ondrej

Lhot´ak. Pick your contexts well: understanding
object-sensitivity. In Proceedings of the 38th annual
ACM SIGPLAN-SIGACT symposium on Principles of
programming languages, POPL ’11, pages 17–30, New
York, NY, USA, 2011. ACM.

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

The IFDS framework
Our inter-procedural dataﬂow analysis problem is formulated
in terms of the IFDS framework by Reps et al. [25] and can
therefore be reduced to a graph-reachability problem. IFDS
solves inter-procedural, ﬁnite, distributive subset problems
and works by creating a so-called exploded supergraph based
on ﬂow functions associated with the program statements.
A ﬂow function deﬁnes the impact of a statement on a set
of ﬂow facts. For example, the statement x = y would be
associated with a ﬂow function that maps a fact set {y} (i.e.
y is tainted) to a fact set {x, y} (x and y are both tainted).
Function calls are modeled using summary functions, which
makes the approach precise, yet very e cient: at di↵erent
call sites to the same method m, the summary function for
m is just reused (gaining e ciency) but it is applied to the
taint information at that very call site (thus yielding full
context sensitivity). Section 4 gives more details about how
FlowDroid constructs the supergraph.

Once the supergraph is constructed, the algorithm decides
whether a variable x at a statement s is tainted simply by
computing whether the node representing (s, x) is reachable
within this graph. Because all method calls have been ab-
stracted through summary functions, those queries are fully
intra-procedural and therefore highly e cient.
Attacker model
We assume an attacker that can supply an app with arbi-
trary malicious bytecode, obfuscated or not. In the scenario
treated in this paper, the attacker’s goal is to leak private
data through a dangerously broad set of permissions granted
by the user [4]. Our analysis makes sound assumptions on the
installation environment and app inputs, meaning that the
attacker is free to tamper with those as well. FlowDroid
does assume, however, that the attacker has no way of cir-
cumventing the security measures of the Android platform.
Also, right now no static analysis for Android, including
FlowDroid has a way of dealing with dynamic loading and
reﬂection. Bodden et al. showed how those features can be
handled in general [9], however their approach requires access
to a load-time instrumentation API, which is something that
Android does not currently support. We are in contact with
Google to see if such an API can be supported in the future.

3. PRECISE MODELLING OF LIFECYCLE

Multiple entry points. Unlike Java programs, Android ap-
plications do not have a main method. Apps instead comprise
many entry points, i.e., methods that are implicitly called
by the Android framework. The Android operating system
deﬁnes a complete lifecycle for all components in an applica-
tion. There are four di↵erent components an app developer
can deﬁne: activities are single focused user actions, ser-
vices perform background tasks, content providers deﬁne a
database-like storage, and broadcast receivers listen for global
events. All these components are implemented by deriving
a custom class from a predeﬁned operating system class,
registering it in the AndroidManifest.xml ﬁle and overwrit-
ing the lifecycle methods. The Android system calls these
methods at runtime to start or stop the component, or pause
or resume it, depending on environment needs. It can, e.g.,
stop an application because of low memory, and later restart
it when the user returns to it. Figure 1 shows the lifecycle

Activity
launched

onCreate()

User navigates
to the activity

onStart()

onRestart()

User

returns
to the
activity

User navigates
to the activity

App process

killed

Apps with

higher priority
needs memory

onResume()

Activity
running

Another

activity comes

into the foreground

onPause()

The activity is
no longer visible

onStop()

The activity is ﬁnishing or

being destroyed by the system

onDestroy()

Activity
shut down

Figure 1: Android Activity Lifecycle

for an activity. In result, when constructing a call graph,
Android analyses cannot simply start by inspecting a pre-
deﬁned “main” method. Instead, all possible transitions in
the Android lifecycle must be modeled precisely. To cope
with this problem, FlowDroid constructs a custom dummy
main method emulating the lifecycle. However, the lifecycle
is more complex than depicted and explicitly documented.
There are additional methods for saving and restoring state,
as well as callbacks that notify the app about additional state
changes. If not taken into account, a malicious application
could exploit these methods and send out secret information
without being noticed.

Asynchronously executing components. An application
can contain multiple components, e.g., three activities and
one service. The activities run sequentially, however, one can-
not pre-estimate their order. One activity could, for instance,
be the main one initially visible to the user and then launch
either one of the others depending on user input. Services run
in parallel. FlowDroid thus conservatively assumes that all
components (activities, services, etc.) inside an application
to run in an arbitrary sequential order. Within a component,
the analysis is fully ﬂow-sensitive, though. Additionally, the
Android operating system allows applications to register call-
backs for various types of information, e.g., location updates
or UI interactions. Callbacks implement predeﬁned interfaces
declaring methods that are then called asynchronously by
the operating system. FlowDroid models these callbacks
in its dummy main method, for instance to recognize cases
where an application stores to the heap the location data
that is passed into the callback as a parameter, and later
sends this data to the internet when the activity is stopped.
The order in which callbacks are invoked cannot generally
be predicted, which is why FlowDroid conservatively as-

LeakageApp la = new LeakageApp();

la.onCreate();

la.onStart();

la.onResume();

p

p

la.onPause();

p

la.onStop();

p

p

la.onDestroy();

la.sendMessage();

la.onRestart();

5

4

void foo( z ) {

x = z.g;
w = source(); 
x.f = w;

a.g.f

6

void main() { 
7
b.f

a = new A();
b = a.g;
foo(a);
sink(b.f);

}

x.f
} 

3

x.f
2

z.g.f

w

1

Figure 3: Taint analysis under realistic aliasing

Name
V arId
F ieldId
Stmt
Loc
V al = Loc [ {null}
Env : V arId ! V al
Heap : Loc ⇥ F ieldId ! V al Heap
States = Env ⇥ Heap

Description
Program variables
Field identiﬁers
Statements2
Memory locations
Values
Environment

Program States

Figure 2: CFG for dummy main method

Table 1: Formalization Domains

sumes that all callbacks can be invoked in any possible order.
Some static analysis are path-sensitive, i.e., consider each
possible program paths separately. In such cases, considering
all possible orderings would be very expensive. Fortunately,
FlowDroid bases its analysis on IFDS, which is not path-
sensitive and instead joins analysis results immediately at
any control-ﬂow merge point. For FlowDroid can thus
generate a main method in which every order of individual
component lifecycles and callbacks is possible, it does not
need to simulate all possible paths.

Example. In Figure 2 we show the control-ﬂow graph of the
dummy main method for our example. In this ﬁgure, p repre-
sents an opaque predicate of which we know that FlowDroid
won’t be able to evaluate it statically (for instance, a check
involving an environment variable). In result, the analysis
will automatically consider on equal terms both branches for
conditions involving p. Note that, to gain maximal precision,
we generate an individual dummy main method for each app
analyzed. Each main method will only involve the fraction of
the lifecycle that, according to the app’s XML conﬁguration
ﬁles, can actually occur. Disabled activities are automati-
cally ﬁltered and callback methods are only invoked in the
contexts of the components to which they actually belong.
A button click handler is for instance only analyzed in the
context of its respective activity.

4. CONTEXT, OBJECT, FIELD AND FLOW-

SENSITIVE ANALYSIS

One major di culty in the analysis is how to handle alias-
ing with high object sensitivity. Figure 3 shows how Flow-
Droid combines a forward-taint analysis and an on-demand
backward-alias analysis to decide that b.f is tainted at the
3 , where the forward analysis
sink. The important step is
assigns a taint to x.f. On such assignments to the heap, the
backward analysis searches upwards for aliases of x.f, an

idea borrowed from Andromeda [27]. At
is found and then propagated forward.

7 , the alias b.f

To increase the reproducibility of our approach, in this
section we give important details about the di↵erent transfer
functions our analysis associates with program statements.
In the following, ﬁrst we deﬁne an abstract heap model. Sec-
tion 4.1 explains our general taint analysis, while Section 4.2
explains our on-demand alias analysis.

FlowDroid leverages IFDS to propagate each tainted
value individually, using a multi-threaded implementation.
When processing any given statement, the set T of incoming
taints are transformed into a set of outgoing taints. We deﬁne
the abstract analysis semantics with the standard notation
used similarly by Tripp et al. [27]. Table 1 shows our abstract
domain. For representing the e↵ects of program statements,
FlowDroid uses the semantics deﬁned in Table 2. H 2
Heap deﬁnes the current heap, and E 2 Env the current
environment. A program state is deﬁned as   = hE, Hi 2
States.
To be able to explain our taint propagation algorithm in

detail we declare the following helper functions:

arrayElem(x) : V arId ! Boolean returns true i↵ x refer-

ences an array element

static(x) : F ieldId ! Boolean returns true i↵ x is a static

ﬁeld

2FlowDroid operates on an intermediate representation
that represents compound statements through individual
atomic statements.

Statement
x = new Object()
x = y
x.f = y
x = y.f

Semantics
  =  [x ! o 2 Loc. o is fresh]
  =  [E(x) ! E(y)]
  =  [H((E(x), f )) ! E(y)]
  =  [E(x) ! H((E(y), f ))]

Table 2: Program Semantics

immut(x) : V arId ! Boolean returns true i↵ x is a primi-

tive or immutable data type (int, String, etc.)

source(s) : Stmt ! P (V arId) returns a set of variable names
tainted by the source statement s or ; if s is no source
native(s) : Stmt ! Boolean returns true i↵ s contains a call

to a native method

nativeT aint(s) : Stmt ! P (V arId) returns values which are
tainted after the native call s 2 Stmt. Such values can
include the base object on which the method was in-
voked, the return value, or one or more of the input
parameters.

nativeAlias(s) : Stmt ! P (V arId) returns possible aliases
of tainted values before the native call s 2 Stmt (back-
wards analysis)

To model deep object sensitivity, FlowDroid does not
simply propagate simple ﬁelds like x.f but instead so-called
access paths [27] up to a ﬁxed length. x.f.g.h for instance
models an access path of length 3. We use the notation
x.f n to describe an arbitrary but ﬁxed access path of length
n, rooted at x. For example x.f 3 represents paths such as
x.f.g.h. Note that x.f 0 is equal to x. The notation allows
us to split ﬁeld accesses such that x.f p = x.f n.f m where
p = m + n. In result, T is actually a set of currently tainted
access paths.

A concrete state is a program state extended by the set
of tainted access paths T resulting in a triple   = hE, H, Ti.
At the beginning it holds that T = ;. Tainted access paths
are added to the set whenever the analysis reaches a call to
a source, or when processing a statement that propagates an
existing taint to a new memory location. We next explain
the di↵erent transfer functions that FlowDroid uses to
compute taints. Section 4.2 explains how we use access paths
to deal with aliasing.
4.1 Taint analysis

The taint analysis starts directly at each of the identiﬁed
and reachable sources. The IFDS framework distinguishes
four di↵erent kinds of ﬂow functions: normal, call, return
and call-to-return.

Normal ﬂow function. Normal ﬂow functions are applied
at all statements that are neither calls nor returns. In Flow-
Droid, only method calls can be the original source of a
taint. Thus, a normal ﬂow function can never generate new
taints, it can only transfer, preserve, or “kill” existing taints.
FlowDroid is insensitive to array indices, tainting the
entire set of array elements even if the program taints just
a single element. To be sound, FlowDroid thus needs to
assume that the entire contents remain tainted, even if the
single array element is overwritten by an untainted value
later-on. For an assignment statement s 2 Stmt with the
structure x.f n = y.f m with n, m 2 N0 the following rules
apply:

T [ {x.f n.f p} 8p : y.f m.f p 2 T
T\{x.f n}
T

y.f m.f⇤ /2 T ^ ¬arrayElem(x.f n)
otherwise

A special case is the new statement which creates a fresh

T s !8<:

object:
T x.f n=new...

        ! T\{x.f n.f⇤ 2 T|¬arrayElem(x.f n)}.

Assigning a fresh object erases the taints for the memory
location referred to by the left-hand side and all access paths
that could be reached through this reference.

Assignments of arithmetic operations such as x = a + b are
treated by tainting the left-hand side if any of the operands
are tainted. For now, FlowDroid uses a simple two-element
security lattice but it can easily be extended to track more
information about the kind of taint that is propagated.

Call ﬂow function. Call ﬂow functions handle ﬂows into
callees of calls such as c.m(a0, . . . , an), n 2 N0. To model
the context change from the body of the caller to the one of
the callee, FlowDroid builds taint set Tcallee based on the
caller’s set Tcaller, replacing references to actual parameters
ai by references to formal parameters pi. If a variable is
tainted in the caller’s context, FlowDroid converts it to
the callee context by replacing c with this.
{this.f m} c.f m 2 Tcaller
ai.f p 2 Tcaller
{pi.f p}
{y.f q}
x.f q 2 Tcaller ^ static(y.f q)

Tcallee

s ! [8<:

Return ﬂow function. At a return (both exceptional and
regular), the return ﬂow function maps taints from the callee’s
context back to the one of the caller. FlowDroid’s return
ﬂow functions specially treats immutable values. Such val-
ues, by their very nature, can never change their taint status.
Thus, if a parameter of an immutable type like String or int
was not tainted before the call it cannot be tainted by the
callee and is thus still guaranteed to be untainted on return.
In all other cases, the taint of all tainted access paths is
mapped back to the caller’s context. The following ﬂow func-
tion applies when the callee returns a variable r after being
called using a statement of the form b = c.m(a0, . . . , an):

Tcaller

s ! [8>><>>:

{c.f m}
this.f m 2 Tcallee
{ai.f p} pi.f p 2 Tcallee ^ ¬immut(ai)
x.f q 2 Tcallee ^ static(y.f q)
{y.f q}
{b.f v}
r.f v 2 Tcallee

Call-to-return ﬂow function. For every call there is also
intra-procedural edge propagating all taint values that are
independent of the callee.
In this function, we generate
taints at sources, through a simple pattern match against an
extensible list of method signatures. We also handle native
method calls here (for details, see Section 5). Again consider
a call b = c.m(a0, . . . , an):

T [ nativeT aint(s, T ) native(s) ^ ai.f m 2 T
T [ {x}
T

x 2 source(s)
otherwise

T s !8<:

4.2 On-demand alias analysis

During our research we experimented a lot with di↵er-
ent ways to resolve aliasing e↵ectively and e ciently. As it
turned out, using ahead-of-time analyses is usually too costly
(because the analysis computes alias information for all pro-
gram variables, not just those that carry taints) and too
imprecise (because the analysis would not support the same
level of context-sensitivity as our taint analysis). We hence
opted for a demand-driven approach by Tripp et al., which
executes within the same context-sensitive IFDS framework
as our taint analysis [27]. As Figure 3 shows, this on-demand
analysis is triggered at assignments to heap variables, i.e.,

statements of the form x.f = v. The alias analysis then walks
backward through the control-ﬂow graph. Whenever it ﬁnds
an alias, it triggers the forward analysis in turn, propagat-
ing an aliased taint from the location at which the alias
was found. Similar to the forward analysis, we deﬁne ﬂow
functions which compute the alias propagation information.
Let the set A deﬁne the alias information. The only ini-
tial element in A is the complete access path of the tainted
value which caused the alias lookup. The backward solver
terminates when A becomes empty.

source, sink and

entry-point detection

parse manifest ﬁle

generate

main method

parse .dex ﬁles

build call graph

parse layout xmls

perform taint

analysis

Normal ﬂow function. For a statement x.f = y.g the fol-
lowing rule applies:

A s ! [⇢ A\{x.f.f p} [ {y.g.f p} 8p : x.f.f p 2 A

otherwise

A

For new statements, FlowDroid erases all alias informa-
tion for the left-hand side, as fresh objects cannot be aliased:
A x.f =new...

       ! A\{8m : x.f.f⇤ 2 A}

Call ﬂow function. Since the backward analysis traverses
the control-ﬂow graph backwards, its call ﬂow function prop-
agates information from call sites to return sites in the callee.
Consider again a call b = c.m(a0, . . . , an) and a return site
returning a variable r:
b.f m 2 Acaller
{r.f m}
{this.f m} c.f m 2 Acaller
{y.f q}
y.f q 2 Acaller ^ static(y.f q)

Acallee

s ! [8<:

Return ﬂow function. In the backwards analysis, return
ﬂow functions propagate from the callee’s start point to just
before the call site. The return ﬂow function thus maps the
callee’s aliases at back to the caller while taking into account
renaming from formal parameters pi to actual parameters ai.
For a call site c.m(a0, . . . , an) we obtain:
this.f m 2 Acallee
y.f q 2 Acallee ^ static(y.f q)

{c.f m}
{ai.f p} pi.f p 2 Acallee
{y.f q}

Acaller

s ! [8<:
A s !8>><>>:

Call-to-return ﬂow function. For a call site b = c.m(a0, . . . , an),
the call-to-return ﬂow function handles aliases induced by
native calls and kills aliases of references obtained through b:

A [ nativeAlias(s) native(s)
^(ai.f m 2 A _ c.f n 2 A)
A\{b.f n}
b.f n 2 A
otherwise
A

5.

IMPLEMENTATION

FlowDroid extends the Soot framework [16] which pro-
vides important prerequisites for a precise analysis, in par-
ticular a very accurate call graph. Through a plugin called
Dexpler [5] Soot supports not only converting Java code but
also Android’s dex ﬁles into the Jimple intermediate repre-
sentation which allows us to implement our analysis for both
targets. FlowDroid further uses Heros [8] as an implemen-
tation of IFDS on top of Soot and Dexpler. We next explain
FlowDroid’s architecture, while the subsequent sections
explain interesting implementation details and FlowDroid’s
current limitations.

Figure 4: Overview of FlowDroid

Architecture. Figure 4 shows FlowDroid’s architecture.
Android applications are packaged in apk ﬁles (Android Pack-
ages), which are essentially zip-compressed archives. After
unzipping an archive, FlowDroid searches for lifecycle and
callback methods as well as calls to sources and sinks in the
application. This is done by parsing various Android-speciﬁc
ﬁles, including the layout XML ﬁles, the dex ﬁles contain-
ing the executable code and the manifest ﬁle deﬁning the
activities, services, broadcast receivers and content providers
in the application. We describe the detection of UI Inter-
actions in detail below. Next, FlowDroid generates the
main method from the list of lifecycle and callback methods
(see the Paragraphs Callbacks and Substitution Classes for
more information). This main method is then used to gener-
ate a call graph and an inter-procedural control-ﬂow graph
(ICFG). Starting at the detected sources, the taint analysis
then tracks taints by traversing the ICFG as explained in
Section 4. Native Calls require a special treatment which
is described below along with a performance optimization
called Taint Wrapping. At the end, FlowDroid reports all
discovered ﬂows from sources to sinks.

UI Interactions. UI elements can be taint sources, e.g., if
an application prompts the user for a password and then
sends it out to the Internet. FlowDroid thus scans the
layout XML ﬁles in the apk ﬁle for text inputs and links
them to the source-code statements where they are accessed.
This is non-trivial, as the Android operating system manages
access to such resources at runtime and a static analysis tool
must simulate these runtime APIs as precisely as possible.
Note that we need to over-approximate resource accesses in
the general case, though. In Android, resource mappings can
be conﬁguration-dependent, for instance to support di↵erent
layouts for smartphones and tablets. In this case, we can
only assume all cases as possible. Not all data in text ﬁelds
is sensitive, though. FlowDroid can be conﬁgured to either
consider all text ﬁelds or to restrict itself to special sensitive
ﬁelds like password input ﬁelds (the default).

Callbacks. To model the app lifecycle correctly (see Sec-
tion 3), FlowDroid contains a list of callback interfaces
extracted from the Android documentation. FlowDroid
ﬁrst computes a call graph ignoring callbacks, to determine
which activity will potentially register which kind of callback
at runtime. Next, FlowDroid generates a customized main
method for each activity, taking the respective discovered
callbacks into account.

Substitution Classes. J2EE and Android applications some-
times operate on interface types or abstract class types that
at runtime receive objects instantiated within the J2EE or

Android framework. FlowDroid’s main-method generator
cannot easily be aware of those concrete subtypes. Flow-
Droid thus allows the analysis designer to provide a list of
so-called substitution classes. A substitution class provides
a concrete implementation for one or more of these inter-
faces, simply for the purpose of the analysis. The user can
choose whether to provide a stub or a real implementation,
depending on whether the designer aims for higher precision
or scalability. For Android, substitution classes are required,
for instance, for the abstract class android.context.Context.

Native Calls. Both Java and the Android platform support
invoking native methods written in C or other unmanaged
languages. For a Java-based analysis, such methods are black
boxes which cannot be resolved. We thus deﬁned explicit
taint propagation rules for the most common native methods,
such as arraycopy in java.lang.System. In this example, third
argument (the output array) will become tainted if the ﬁrst
argument (the input array) is tainted before the call. For
native methods without an explicit rule, we assume call
arguments and the return value to become tainted if at
least one parameter was tainted before. This is neither
entirely sound nor maximally precise but is probably the
only practical approximation in a black-box setting.

Taint Wrapping. Including the full JRE or Android plat-
form runtime in the analysis requires a lot of time and mem-
ory and can lead to unwanted imprecisions. Thus, while
explicit taint-propagation rules are required for native meth-
ods, they can be useful for regular Java methods as well:
their use can prevent the taint propagation from having
to analyze the library’s internals. FlowDroid supports a
simple textual ﬁle format for deﬁning such “shortcut rules”.
Predeﬁned rules handle collection classes, string bu↵ers and
similar commonly used data structures.

Limitations. At the moment FlowDroid ignores reﬂective
calls, which is unsound. While specialized static string anal-
yses can be used to simulate reﬂection to some extent, past
research has found such analyses to be incomplete [9], as
reﬂective call targets are often determined by external conﬁg-
uration ﬁles. On the Java platform, reﬂection-analysis tools
such as TamiFlex [9] can be used to make static analysis
tools aware of reﬂective calls. Such tool require load-time
instrumentation through java.lang.instrument, however, which
the Android platform does not currently support.

As described above, native code is approximated conser-
vatively using taint wrapping. Another limitation of Flow-
Droid is its current focus on explicit data ﬂows. Implicit
ﬂows caused by control-ﬂow dependencies are currently ig-
nored, but we plan to include them in the near future. Flow-
Droid also ignores probabilistic and possibilistic leaks caused
by multi-threading [13].

6. EXPERIMANTAL EVALUATION

Our evaluation addresses the following research questions:

RQ1 How does FlowDroid compare to commercial taint-
analysis tools for Android, both in terms of precision
and recall?

RQ2 Can FlowDroid ﬁnd all privacy leaks in Insecure-
Bank, an app speciﬁcally designed by others to chal-

lenge vulnerability-detection tools for Android [21], and
what is its performance?

RQ3 Can FlowDroid ﬁnd leaks in real-world applications

and how fast is it?

RQ4 How well does FlowDroid perform when being ap-
plied to taint-analysis problems related to Java, not
Android, both in terms of precision and recall?

The next sections address each research question in detail.
Section 6.5 explains why, unfortunately, we were unable to
directly compare FlowDroid to academic Android analysis
tools published elsewhere.
6.1 RQ1: Commercial taint-analysis tools

While there are benchmark suites for analyzing web appli-
cations or speciﬁcally for detecting di↵erent kinds of Java vul-
nerabilities [17], at the moment there is no Android-speciﬁc
analysis benchmark suite. This is problematic because the
generic Java test suites do not cover aspects like the An-
droid lifecycle, callbacks or interactions with UI elements
like password ﬁelds. Thus, they cannot be used for assessing
the practical e↵ectiveness of Android analysis tools.

DroidBench. Speciﬁcally for this work, we therefore de-
veloped an Android-speciﬁc test suite called DroidBench
containing 39 small Android apps. The suite can be used
to assess both static and dynamic taint analyses, but in
particular it contains test cases for interesting static-analysis
problems (ﬁeld sensitivity, object sensitivity, tradeo↵s in
access-path lengths etc.) as well as for Android-speciﬁc
challenges like correctly modeling an application’s lifecycle,
adequately handling asynchronous callbacks and interacting
with the UI. Table 3 contains a list of all apps in the suite
together with their respective names and short descriptions.
The table also indicates whether an analysis tool must model
the Android lifecycle or callback infrastructure to be able to
successfully analyze the app. We envision our test suite to
be extended by other researchers as well and then be used
to compare the completeness and correctness of the various
taint analysis approaches. DroidBench is available from
our project website.

Table 5 presents the analysis results for FlowDroid and
two commercial analysis tools explained in the following.
As the results show, FlowDroid generally performs quite
well. As explained before, for performance reasons, Flow-
Droid handles array indices imprecisely. The same limi-
tation applies to ListAccess1, causing false positives in the
ﬁrst category. Handling indices precisely and e ciently is an
interesting open research question. Button2 causes a false
positive because FlowDroid does not currently support
strong updates. In result, it cannot kill taints for certain
button combinations. Strong updates would require a must-
alias analysis which is hard to achieve inter-procedurally.
IntentSink1 is not detected because the test case contains no
actual sink. Instead, the tainted value is stored in an intent
which is then handed back to the activity by the framework.
Such cases are hard to handle without special treatment.
StaticInitialization1 fails because Soot currently assumes
all static initializers to execute at the beginning of the pro-
gram, which in this case is not correct. We plan to add
better support in the future. As most known taint-analysis
tools, FlowDroid currently disregards implicit ﬂows caused
through control-ﬂow dependencies.

Comparison with IBM AppScan Source. We compared
FlowDroid against IBM AppScan Source [2] version 8.7, on
all tests from DroidBench. AppScan Source distinguishes
three di↵erent categories of ﬁndings: vulnerabilities, excep-
tions of type 1 and exceptions of type 2. Vulnerabilities
include a complete path from source to sink. For a type 1
exception, there is a ﬂow from source to sink as well, but
the semantics of some methods along the propagation path
is unknown (e.g. possible sanitization). Since FlowDroid
does not support sanitization at the moment, we consider
both vulnerabilities and type 1 exceptions as ﬁndings. For
type 2 exceptions on the other hand, there is no trace. These
reports are generated when certain code constructs (e.g. writ-
ing a variable value into the log ﬁle) are detected. As these
ﬁndings are highly imprecise and completely disregard data
ﬂow, we do not count them as ﬁndings. As Table 5 shows,
AppScan Source ﬁnds only about 38% of all leaks (50% if
ignoring implicit ﬂows). Major problems occur with the
handling of callbacks, the Android component lifecycle and
implicit ﬂows.

Comparison with Fortify SCA. Fortify SCA [1] by HP is
another commercial tool widely used by security analysts.
Similar to IBM AppScan Source, Fortify also provides di↵er-
ent kinds of ﬁndings, such as data ﬂows from sensitive sources
to public sinks, requests for security-sensitive permissions,
calls to security-sensitive methods, etc. In our evaluation,
we only considered ﬁndings about data ﬂows. All tests were
carried out using version 5.14. As can be seen in Table 5, For-
tify SCA shows problems similar to those of IBM AppScan
(cf. Section 6.1), like the handling of the Android component
lifecycle, the callbacks and implicit ﬂows. Figure 5 shows
that Fortify detects 4 out of 6 data leaks for the lifecycle
tests, but closer inspection shows that this only happens
by chance. In these tests, the data source involves a static
ﬁeld, which Fortify apparently treats in a special way which
coincidentally causes a leak to be reported. When removing
the static modiﬁer, which does not the semantics of the test
case, Fortify does not detect the leak any longer.

Conclusion. From our experiments we conclude that, to not
overburden the user with false positives, AppScan Source and
Fortify SCA aim for relatively high precision while sacriﬁcing
recall, thus risking to miss actual privacy leaks. In compari-
son, FlowDroid shows higher precision with a signiﬁcantly
higher recall.
6.2 RQ2: Performance on InsecureBank

InsecureBank [21] is a vulnerable Android app created
by Paladion Inc. speciﬁcally for the purpose of evaluating
analysis tools such as FlowDroid. It contains various vul-
nerabilities and data leaks similar to those found in real-world
applications. Analyzing the application takes about 31 sec-
onds on a laptop computer with an Intel Core 2 Centrino
CPU and 4 GB of physical memory running on Windows 7
with Oracle’s Java Runtime version 1.7 (64 bit) in its default
settings. FlowDroid found all seven data leaks which we
all veriﬁed by hand. There were no false positives nor false
negatives.

6.3 RQ3: Real-World Applications

The above experiments give a very good indication that
FlowDroid yields correct and precise results, not just for
small test case but also for more realistic apps such as In-
secureBank [21]. To strengthen the external validity of our
experiments, we nevertheless performed an additional qualita-
tive analysis on a random selection of popular apps from the
Google Play store. While the obtained analysis reports do
not indicate any malicious apps in this selection, the majority
of apps is reported to—probably accidentally—leak informa-
tion into logs and preference ﬁles. Samsung’s Push Service,
for instance, logs the phones IMEI. Logs are problematic,
as the OS does not impose the same access restrictions on
logs as it does on ﬁles: all logs are readable by any app that
has the READ LOGS permission. The game Hugo Runner
stores longitude and latitude into a preferences ﬁle. As we
veriﬁed by hand, though, those preferences were correctly
written in private mode, precluding any access by other apps.
This indicates that taint analyses could gain precision by
considering auxiliary information such as the write mode
mentioned above. For most examined apps FlowDroid
terminated in under a minute. The longest-running instance,
Samsung’s Push Service took about 4.5 minutes to analyze.
6.4 RQ4: SecuriBench Micro

FlowDroid was speciﬁcally designed for Android, and
in this space gains much precision through its complete and
precise handling of Android’s lifecycle. Nevertheless, there is
nothing that would preclude software developers from apply-
ing FlowDroid to Java applications as well. To assess how
well FlowDroid is set up for this use case, we evaluated
FlowDroid against Stanford SecuriBench Micro [17] version
1.08, a common set of 96 J2EE micro benchmarks originally
intended for web-based applications. For each of the bench-
marks in the suite, we manually deﬁned the necessary lists of
sources, sinks and entry points. Since FlowDroid supports
a simple textual ﬁle format for deﬁning these parameters,
and since all benchmarks cases have the same structure, this
was not much e↵ort. For the interfaces HTTPServletRequest
and HTTPServletResponse we needed to provide substitution
classes (see Section 5), as we had no access to framework
code that would provide their implementations. We omit-
ted from our experiments test cases involving sanitization,
reﬂection, predicates and multi-threading. As we explained
earlier, such features are out of scope for our analysis tool,
just as they are for all other existing Android analysis tools.
Table 4 shows our test results grouped by test categories.
The TP column shows the true positives, i.e., the number
of actual leaks that FlowDroid found. For the example of
basic, for instance, FlowDroid found 58 out of 60. The FP
column shows the number of false positives, i.e., the ﬁnding
that FlowDroid reported that did not correspond to actual
leaks, but were rather artifacts of an overly approximate
analysis. In most cases this number is reasonably low or
even zero, except for the Arrays category. This is due to an
imprecision that FlowDroid shares with most other static
analyses: for performance reasons, the tools not di↵erentiate
between multiple components inside the same collection,
e.g., di↵erent indices in arrays or di↵erent positions in lists.
Treating such cases precisely and e ciently is an interesting
open issue in the static-analysis community. The n/a entries
in the table correspond to test categories such as reﬂection,
which we identiﬁed to be out of scope.

Test-case group
Aliasing
Arrays
Basic
Collections
Datastructure
Factory
Inter
Pred
Reﬂection
Sanitizer
Session
StrongUpdates
Sum

TP
11/11
9/9
58/60
14/14
5/5
3/3
14/16
n/a
n/a
n/a
3/3
0/0

117/121

FP
0
6
0
3
0
0
0

n/a
n/a
n/a

0
0
9

Table 4: SecuriBench Micro test results

6.5 Comparison with Other Tools

We also tried to compare FlowDroid to a number of other
tools from the scientiﬁc literature, namely TrustDroid [31],
LeakMiner [30], and the tool by Batyuk et al. [6]. Unfor-
tunately none of those tools are available online, and even
worse the respective authors did not reply to our inquiries.
We tried to run DroidBench on SCanDroid [11], but
faced technical di culties. The tool did not report any
ﬁndings at all in our setup. Though being in contact with the
authors, we were unable to ﬁx these issues by the submission
deadline. The authors of AndroidLeaks [12] promised to
run their tool on DroidBench but never delivered. We
also contacted the authors of CHEX [18], but they were
unable to provide the tool or any benchmark results due to
intellectual property claimed by NEC. Starostin [19] declined
to participate in the experiment as his tool ignores aliasing,
making any comparison meaningless.

In result, we were unable to successfully evaluate even a
single scientiﬁc taint-analysis tool for Android. We believe
that the lack of such comparative experiments is hindering
scientiﬁc progress a lot, which is why we make available our
entire implementation, documentation and benchmarks as
open source.

7. RELATED WORK

There are several approaches to static analysis of Android
applications di↵ering in precision, runtime, scope and focus.
One of the most sophisticated ones is CHEX [18], a tool
to detect component hijacking vulnerabilities in Android
applications by tracking taints between externally accessible
interfaces and sensitive sources or sinks. Although not built
for the task, CHEX can, in principle, be used for taint anal-
ysis. However, since CHEX looks for vulnerabilities, target
applications are supposed to be benign. The derived assump-
tions (no obfuscation etc.) do not hold for malicious apps.
Furthermore, CHEX does not analyze calls into Android
framework itself but instead requires a (hopefully complete)
model of the framework. In FlowDroid such a model is
optional and, except for native calls, is used only to increase
performance. CHEX’s entry point model requires an enumer-
ation of all possible split orderings which is not necessary in
FlowDroid.

LeakMiner [30] appears similar to our approach from a
technical point of view:
like FlowDroid, it is based on
Soot, uses Spark for call-graph generation, it implements the

Android lifecycle, and the paper states that an app can be
analyzed in 2.5 minutes on average. However, the analysis
is not context-sensitive which is likely a major source of
imprecision. Unfortunately we were unable to perform a
systematic comparison as the authors did not respond to our
inquiries.

AndroidLeaks [12] also states the ability to handle the
Android Lifecycle including callback methods. It is based on
WALA’s context-sensitive System Dependence Graph with a
context-insensitive overlay for heap tracking, but is not as
precise as FlowDroid, because it taints the whole object if
tainted data is stored in one of its ﬁelds. As noted before,
we contacted the authors but they failed to provide us any
data for a comparative evaluation.

SCanDroid [11] is another tool for reasoning about data
ﬂows in Android applications. Its main focus is the inter-
component (e.g. between two activities in the same app)
and inter-app data ﬂow. This poses the challenge of con-
necting intent senders to their respective receivers in other
applications. SCanDroid prunes all call edges to Android
OS methods and conservatively assumes the base object,
the parameters, and the return value to inherit taints from
arguments which is much less precise than FlowDroid’s
treatment. FlowDroid, on the other hand, currently does
not resolve intent-based communication. Such a feature
would require string analysis, which we leave to future work.
Other approaches like CopperDroid [24] dynamically ob-
serve interactions between the Android components and the
underlying Linux system to reconstruct higher-level behavior.
Special stimulation techniques are used for exercising the
application to ﬁnd malicious activities. Attackers, however,
can easily modify an app to detect whether it is running
inside a virtual machine and then leak no data during that
time. Alternatively, data leaks might only occur after a cer-
tain runtime threshold. Aurasium [28] and DroidScope [29]
largely su↵er from the same shortcomings with respect to
static leak detection.

There are also approaches with a much broader focus
like [6]. This approach not only tracks data ﬂows, but also
generate a user-friendly report and sanitizes malicious apps
by replacing their sources with safe equivalents like UUID
generators. The paper gives no details on the implementation,
which is why we were unable to conduct a detailed comparison
to our approach.

The approach by Payet et al. [22] tries to aid the developer
by checking for common programming errors using di↵erent
checks, for example a nullness analysis. In contrast to Flow-
Droid, their approach cannot perform a dataﬂow analysis
and is not focused on security.

8. CONCLUSIONS

We have presented FlowDroid, a novel and highly pre-
cise static taint-analysis tool for Android applications. We
have shown that many existing approaches do not adequately
model Android-speciﬁc challenges like the application life-
cycle or callback methods, leading to either missed leaks
or false positives. For assessing the e↵ectiveness of analysis
tools, we have proposed the Android-speciﬁc benchmark suite
DroidBench and used it for comparing FlowDroid to the
commercial tools AppScan Source and Fortify SCA, showing
that besides ﬁnding more real leaks, FlowDroid also has
a higher precision resulting in less false positives. We hope

that in the future DroidBench will serve as a standard test
set for Android taint analyses.

Acknowledgements.

We would like to thank Stephan Huber from Fraunhofer
SIT for supporting us with real-world applications from the
Google Play market and Dr. Karsten Sohr from TZi Bremen
for supporting us with the Fortify SCA evaluation. This
work was supported by a Google Faculty Research Award,
by the BMBF within EC SPRIDE, by the Hessian LOEWE
excellence initiative within CASED, and by the DFG within
the project RUNSECURE.

9. REFERENCES
[1] Fortify 360 Source Code Analyzer (SCA), April 2013.

http://www8.hp.com/us/en/software-solutions/
software.html?compURI=1214365#.UW6CVKuAtfQ.

[2] Ibm rational appscan, April 2013. http:

//www-01.ibm.com/software/de/rational/appscan/.

[3] Android. Android security overview, December 2012.

http://source.android.com/tech/security/.

[4] Alexandre Bartel, Jacques Klein, Yves Le Traon, and

Martin Monperrus. Automatically securing
permission-based software by reducing the attack
surface: an application to android. In Proceedings of
the 27th IEEE/ACM International Conference on
Automated Software Engineering, ASE 2012, pages
274–277, New York, NY, USA, 2012. ACM.

[5] Alexandre Bartel, Jacques Klein, Yves Le Traon, and

Martin Monperrus. Dexpler: converting android dalvik
bytecode to jimple for static analysis with soot. In
Proceedings of the ACM SIGPLAN International
Workshop on State of the Art in Java Program analysis,
SOAP ’12, pages 27–38, New York, NY, USA, 2012.
ACM.

[6] L. Batyuk, M. Herpich, S.A. Camtepe, K. Raddatz,

A.-D. Schmidt, and S. Albayrak. Using static analysis
for automatic assessment and mitigation of unwanted
and malicious activities within android applications. In
Malicious and Unwanted Software (MALWARE), 2011
6th International Conference on, pages 66–72, 2011.

[7] Bit9. Pausing google play: More than 100,000 android

apps may pose security risks, November 2012.
http://www.bit9.com/pausing-google-play/.

[8] Eric Bodden. Inter-procedural data-ﬂow analysis with

ifds/ide and soot. In Proceedings of the ACM
SIGPLAN International Workshop on State of the Art
in Java Program analysis, SOAP ’12, pages 3–8, New
York, NY, USA, 2012. ACM.

[9] Eric Bodden, Andreas Sewe, Jan Sinschek, Hela

Oueslati, and Mira Mezini. Taming reﬂection: Aiding
static analysis in the presence of reﬂection and custom
class loaders. In ICSE ’11: International Conference on
Software Engineering, pages 241–250. ACM, May 2011.

[10] International Data Corporation. Worldwide quarterly

mobile phone tracker 3q12, November 2012.
http://www.idc.com/tracker/showproductinfo.
jsp?prod_id=37.

[11] Adam P. Fuchs, Avik Chaudhuri, and Je↵rey S. Foster.
Scandroid: Automated security certiﬁcation of android
applications.

[12] Clint Gibler, Jonathan Crussell, Jeremy Erickson, and

Hao Chen. Androidleaks: automatically detecting
potential privacy leaks in android applications on a
large scale. In Proceedings of the 5th international
conference on Trust and Trustworthy Computing,
TRUST’12, pages 291–307. Springer, 2012.

[13] Dennis Gi↵horn and Gregor Snelting. Probabilistic

noninterference based on program dependence graphs.
Technical Report 06/2012, KIT, Faculty of Informatics,
June 2012. revised 2013, submitted for publication.

[14] Google Inc. Permissions, December 2012.

http://developer.android.com/guide/topics/
security/permissions.html.

[15] Google Inc. Android and security, November 2012.

http://googlemobile.blogspot.de/2012/02/
android-and-security.html.

[16] Patrick Lam, Eric Bodden, Ondrej Lhotak, and Laurie

Hendren. The soot framework for java program
analysis: a retrospective. In Cetus Users and Compiler
Infastructure Workshop (CETUS 2011), Oktober 2011.

[17] Ben Livshits. Securibench micro, March 2013.
http://suif.stanford.edu/~livshits/work/
securibench-micro/.

[18] Long Lu, Zhichun Li, Zhenyu Wu, Wenke Lee, and

Guofei Jiang. Chex: statically vetting android apps for
component hijacking vulnerabilities. In Proceedings of
the 2012 ACM conference on Computer and
communications security, CCS ’12, pages 229–240, New
York, NY, USA, 2012. ACM.

[19] Christopher Mann and Artem Starostin. A framework

for static detection of privacy leaks in android
applications. In Proceedings of the 27th Annual ACM
Symposium on Applied Computing, SAC ’12, pages
1457–1462, New York, NY, USA, 2012. ACM.

[20] Mohammad Nauman, Sohail Khan, and Xinwen Zhang.

Apex: extending android permission model and
enforcement with user-deﬁned runtime constraints. In
ASIACCS ’10, pages 328–332, New York, NY, USA,
2010. ACM.

[21] Paladion. Insecurebank test app.

http://www.paladion.net/downloadapp.html.

[22] ´Etienne Payet and Fausto Spoto. Static analysis of

android programs. In Proceedings of the 23rd
international conference on Automated deduction,
CADE’11, pages 439–445, Berlin, Heidelberg, 2011.
Springer-Verlag.

[23] Nicholas J Percoco and Sean Schulte. Adventures in

bouncerland. Blackhat USA, 2012.

[24] Alessandro Reina, Aristide Fattori, and Lorenzo

Cavallaro. A system call-centric analysis and
stimulation technique to automatically reconstruct
android malware behaviors. In EUROSEC, Prague,
Czech Republic, April 2013.

[25] Thomas Reps, Susan Horwitz, and Mooly Sagiv.

Precise interprocedural dataﬂow analysis via graph
reachability. In POPL ’95, pages 49–61, 1995.

[26] Yannis Smaragdakis, Martin Bravenboer, and Ondrej

Lhot´ak. Pick your contexts well: understanding
object-sensitivity. In Proceedings of the 38th annual
ACM SIGPLAN-SIGACT symposium on Principles of
programming languages, POPL ’11, pages 17–30, New
York, NY, USA, 2011. ACM.

[27] Omer Tripp, Marco Pistoia, Patrick Cousot, Radhia

World Congress on, pages 101–104, 2012.

Cousot, and Salvatore Guarnieri. Andromeda:
Accurate and scalable security analysis of web
applications. In Proceedings of the 16th international
conference on Fundamental Approaches to Software
Engineering, FASE’13, pages 210–225, 2013.

[28] Rubin Xu, Hassen Sa¨ıdi, and Ross Anderson. Aurasium:

practical policy enforcement for android applications.
In USENIX Security 2012, Security’12, pages 27–27,
Berkeley, CA, USA, 2012. USENIX Association.

[29] Lok Kwong Yan and Heng Yin. Droidscope: seamlessly

reconstructing the os and dalvik semantic views for
dynamic android malware analysis. In USENIX
Security 2012, Security’12, pages 29–29, Berkeley, CA,
USA, 2012. USENIX Association.

[30] Zhemin Yang and Min Yang. Leakminer: Detect
information leakage on android with static taint
analysis. In Software Engineering (WCSE), 2012 Third

[31] Zhibo Zhao and F.C.C. Osono. Trustdroid: Preventing

the use of smartphones for information leaking in
corporate networks through the used of static analysis
taint tracking. In Malicious and Unwanted Software
(MALWARE), 2012 7th International Conference on,
pages 135–143, 2012.

[32] Yajin Zhou and Xuxian Jiang. Dissecting android

malware: Characterization and evolution. In
Proceedings of the 2012 IEEE Symposium on Security
and Privacy, SP ’12, pages 95–109, Washington, DC,
USA, 2012. IEEE Computer Society.

[33] Yajin Zhou, Xinwen Zhang, Xuxian Jiang, and
Vincent W. Freeh. Taming information-stealing
smartphone applications (on android). In Proc. of the
4th international conference on Trust and trustworthy
computing, TRUST’11, pages 93–107. Springer, 2011.

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

The IFDS framework
Our inter-procedural dataﬂow analysis problem is formulated
in terms of the IFDS framework by Reps et al. [25] and can
therefore be reduced to a graph-reachability problem. IFDS
solves inter-procedural, ﬁnite, distributive subset problems
and works by creating a so-called exploded supergraph based
on ﬂow functions associated with the program statements.
A ﬂow function deﬁnes the impact of a statement on a set
of ﬂow facts. For example, the statement x = y would be
associated with a ﬂow function that maps a fact set {y} (i.e.
y is tainted) to a fact set {x, y} (x and y are both tainted).
Function calls are modeled using summary functions, which
makes the approach precise, yet very e cient: at di↵erent
call sites to the same method m, the summary function for
m is just reused (gaining e ciency) but it is applied to the
taint information at that very call site (thus yielding full
context sensitivity). Section 4 gives more details about how
FlowDroid constructs the supergraph.

Once the supergraph is constructed, the algorithm decides
whether a variable x at a statement s is tainted simply by
computing whether the node representing (s, x) is reachable
within this graph. Because all method calls have been ab-
stracted through summary functions, those queries are fully
intra-procedural and therefore highly e cient.
Attacker model
We assume an attacker that can supply an app with arbi-
trary malicious bytecode, obfuscated or not. In the scenario
treated in this paper, the attacker’s goal is to leak private
data through a dangerously broad set of permissions granted
by the user [4]. Our analysis makes sound assumptions on the
installation environment and app inputs, meaning that the
attacker is free to tamper with those as well. FlowDroid
does assume, however, that the attacker has no way of cir-
cumventing the security measures of the Android platform.
Also, right now no static analysis for Android, including
FlowDroid has a way of dealing with dynamic loading and
reﬂection. Bodden et al. showed how those features can be
handled in general [9], however their approach requires access
to a load-time instrumentation API, which is something that
Android does not currently support. We are in contact with
Google to see if such an API can be supported in the future.

3. PRECISE MODELLING OF LIFECYCLE

Multiple entry points. Unlike Java programs, Android ap-
plications do not have a main method. Apps instead comprise
many entry points, i.e., methods that are implicitly called
by the Android framework. The Android operating system
deﬁnes a complete lifecycle for all components in an applica-
tion. There are four di↵erent components an app developer
can deﬁne: activities are single focused user actions, ser-
vices perform background tasks, content providers deﬁne a
database-like storage, and broadcast receivers listen for global
events. All these components are implemented by deriving
a custom class from a predeﬁned operating system class,
registering it in the AndroidManifest.xml ﬁle and overwrit-
ing the lifecycle methods. The Android system calls these
methods at runtime to start or stop the component, or pause
or resume it, depending on environment needs. It can, e.g.,
stop an application because of low memory, and later restart
it when the user returns to it. Figure 1 shows the lifecycle

Activity
launched

onCreate()

User navigates
to the activity

onStart()

onRestart()

User

returns
to the
activity

User navigates
to the activity

App process

killed

Apps with

higher priority
needs memory

onResume()

Activity
running

Another

activity comes

into the foreground

onPause()

The activity is
no longer visible

onStop()

The activity is ﬁnishing or

being destroyed by the system

onDestroy()

Activity
shut down

Figure 1: Android Activity Lifecycle

for an activity. In result, when constructing a call graph,
Android analyses cannot simply start by inspecting a pre-
deﬁned “main” method. Instead, all possible transitions in
the Android lifecycle must be modeled precisely. To cope
with this problem, FlowDroid constructs a custom dummy
main method emulating the lifecycle. However, the lifecycle
is more complex than depicted and explicitly documented.
There are additional methods for saving and restoring state,
as well as callbacks that notify the app about additional state
changes. If not taken into account, a malicious application
could exploit these methods and send out secret information
without being noticed.

Asynchronously executing components. An application
can contain multiple components, e.g., three activities and
one service. The activities run sequentially, however, one can-
not pre-estimate their order. One activity could, for instance,
be the main one initially visible to the user and then launch
either one of the others depending on user input. Services run
in parallel. FlowDroid thus conservatively assumes that all
components (activities, services, etc.) inside an application
to run in an arbitrary sequential order. Within a component,
the analysis is fully ﬂow-sensitive, though. Additionally, the
Android operating system allows applications to register call-
backs for various types of information, e.g., location updates
or UI interactions. Callbacks implement predeﬁned interfaces
declaring methods that are then called asynchronously by
the operating system. FlowDroid models these callbacks
in its dummy main method, for instance to recognize cases
where an application stores to the heap the location data
that is passed into the callback as a parameter, and later
sends this data to the internet when the activity is stopped.
The order in which callbacks are invoked cannot generally
be predicted, which is why FlowDroid conservatively as-

LeakageApp la = new LeakageApp();

la.onCreate();

la.onStart();

la.onResume();

p

p

la.onPause();

p

la.onStop();

p

p

la.onDestroy();

la.sendMessage();

la.onRestart();

5

4

void foo( z ) {

x = z.g;
w = source(); 
x.f = w;

a.g.f

6

void main() { 
7
b.f

a = new A();
b = a.g;
foo(a);
sink(b.f);

}

x.f
} 

3

x.f
2

z.g.f

w

1

Figure 3: Taint analysis under realistic aliasing

Name
V arId
F ieldId
Stmt
Loc
V al = Loc [ {null}
Env : V arId ! V al
Heap : Loc ⇥ F ieldId ! V al Heap
States = Env ⇥ Heap

Description
Program variables
Field identiﬁers
Statements2
Memory locations
Values
Environment

Program States

Figure 2: CFG for dummy main method

Table 1: Formalization Domains

sumes that all callbacks can be invoked in any possible order.
Some static analysis are path-sensitive, i.e., consider each
possible program paths separately. In such cases, considering
all possible orderings would be very expensive. Fortunately,
FlowDroid bases its analysis on IFDS, which is not path-
sensitive and instead joins analysis results immediately at
any control-ﬂow merge point. For FlowDroid can thus
generate a main method in which every order of individual
component lifecycles and callbacks is possible, it does not
need to simulate all possible paths.

Example. In Figure 2 we show the control-ﬂow graph of the
dummy main method for our example. In this ﬁgure, p repre-
sents an opaque predicate of which we know that FlowDroid
won’t be able to evaluate it statically (for instance, a check
involving an environment variable). In result, the analysis
will automatically consider on equal terms both branches for
conditions involving p. Note that, to gain maximal precision,
we generate an individual dummy main method for each app
analyzed. Each main method will only involve the fraction of
the lifecycle that, according to the app’s XML conﬁguration
ﬁles, can actually occur. Disabled activities are automati-
cally ﬁltered and callback methods are only invoked in the
contexts of the components to which they actually belong.
A button click handler is for instance only analyzed in the
context of its respective activity.

4. CONTEXT, OBJECT, FIELD AND FLOW-

SENSITIVE ANALYSIS

One major di culty in the analysis is how to handle alias-
ing with high object sensitivity. Figure 3 shows how Flow-
Droid combines a forward-taint analysis and an on-demand
backward-alias analysis to decide that b.f is tainted at the
3 , where the forward analysis
sink. The important step is
assigns a taint to x.f. On such assignments to the heap, the
backward analysis searches upwards for aliases of x.f, an

idea borrowed from Andromeda [27]. At
is found and then propagated forward.

7 , the alias b.f

To increase the reproducibility of our approach, in this
section we give important details about the di↵erent transfer
functions our analysis associates with program statements.
In the following, ﬁrst we deﬁne an abstract heap model. Sec-
tion 4.1 explains our general taint analysis, while Section 4.2
explains our on-demand alias analysis.

FlowDroid leverages IFDS to propagate each tainted
value individually, using a multi-threaded implementation.
When processing any given statement, the set T of incoming
taints are transformed into a set of outgoing taints. We deﬁne
the abstract analysis semantics with the standard notation
used similarly by Tripp et al. [27]. Table 1 shows our abstract
domain. For representing the e↵ects of program statements,
FlowDroid uses the semantics deﬁned in Table 2. H 2
Heap deﬁnes the current heap, and E 2 Env the current
environment. A program state is deﬁned as   = hE, Hi 2
States.
To be able to explain our taint propagation algorithm in

detail we declare the following helper functions:

arrayElem(x) : V arId ! Boolean returns true i↵ x refer-

ences an array element

static(x) : F ieldId ! Boolean returns true i↵ x is a static

ﬁeld

2FlowDroid operates on an intermediate representation
that represents compound statements through individual
atomic statements.

Statement
x = new Object()
x = y
x.f = y
x = y.f

Semantics
  =  [x ! o 2 Loc. o is fresh]
  =  [E(x) ! E(y)]
  =  [H((E(x), f )) ! E(y)]
  =  [E(x) ! H((E(y), f ))]

Table 2: Program Semantics

immut(x) : V arId ! Boolean returns true i↵ x is a primi-

tive or immutable data type (int, String, etc.)

source(s) : Stmt ! P (V arId) returns a set of variable names
tainted by the source statement s or ; if s is no source
native(s) : Stmt ! Boolean returns true i↵ s contains a call

to a native method

nativeT aint(s) : Stmt ! P (V arId) returns values which are
tainted after the native call s 2 Stmt. Such values can
include the base object on which the method was in-
voked, the return value, or one or more of the input
parameters.

nativeAlias(s) : Stmt ! P (V arId) returns possible aliases
of tainted values before the native call s 2 Stmt (back-
wards analysis)

To model deep object sensitivity, FlowDroid does not
simply propagate simple ﬁelds like x.f but instead so-called
access paths [27] up to a ﬁxed length. x.f.g.h for instance
models an access path of length 3. We use the notation
x.f n to describe an arbitrary but ﬁxed access path of length
n, rooted at x. For example x.f 3 represents paths such as
x.f.g.h. Note that x.f 0 is equal to x. The notation allows
us to split ﬁeld accesses such that x.f p = x.f n.f m where
p = m + n. In result, T is actually a set of currently tainted
access paths.

A concrete state is a program state extended by the set
of tainted access paths T resulting in a triple   = hE, H, Ti.
At the beginning it holds that T = ;. Tainted access paths
are added to the set whenever the analysis reaches a call to
a source, or when processing a statement that propagates an
existing taint to a new memory location. We next explain
the di↵erent transfer functions that FlowDroid uses to
compute taints. Section 4.2 explains how we use access paths
to deal with aliasing.
4.1 Taint analysis

The taint analysis starts directly at each of the identiﬁed
and reachable sources. The IFDS framework distinguishes
four di↵erent kinds of ﬂow functions: normal, call, return
and call-to-return.

Normal ﬂow function. Normal ﬂow functions are applied
at all statements that are neither calls nor returns. In Flow-
Droid, only method calls can be the original source of a
taint. Thus, a normal ﬂow function can never generate new
taints, it can only transfer, preserve, or “kill” existing taints.
FlowDroid is insensitive to array indices, tainting the
entire set of array elements even if the program taints just
a single element. To be sound, FlowDroid thus needs to
assume that the entire contents remain tainted, even if the
single array element is overwritten by an untainted value
later-on. For an assignment statement s 2 Stmt with the
structure x.f n = y.f m with n, m 2 N0 the following rules
apply:

T [ {x.f n.f p} 8p : y.f m.f p 2 T
T\{x.f n}
T

y.f m.f⇤ /2 T ^ ¬arrayElem(x.f n)
otherwise

A special case is the new statement which creates a fresh

T s !8<:

object:
T x.f n=new...

        ! T\{x.f n.f⇤ 2 T|¬arrayElem(x.f n)}.

Assigning a fresh object erases the taints for the memory
location referred to by the left-hand side and all access paths
that could be reached through this reference.

Assignments of arithmetic operations such as x = a + b are
treated by tainting the left-hand side if any of the operands
are tainted. For now, FlowDroid uses a simple two-element
security lattice but it can easily be extended to track more
information about the kind of taint that is propagated.

Call ﬂow function. Call ﬂow functions handle ﬂows into
callees of calls such as c.m(a0, . . . , an), n 2 N0. To model
the context change from the body of the caller to the one of
the callee, FlowDroid builds taint set Tcallee based on the
caller’s set Tcaller, replacing references to actual parameters
ai by references to formal parameters pi. If a variable is
tainted in the caller’s context, FlowDroid converts it to
the callee context by replacing c with this.
{this.f m} c.f m 2 Tcaller
ai.f p 2 Tcaller
{pi.f p}
{y.f q}
x.f q 2 Tcaller ^ static(y.f q)

Tcallee

s ! [8<:

Return ﬂow function. At a return (both exceptional and
regular), the return ﬂow function maps taints from the callee’s
context back to the one of the caller. FlowDroid’s return
ﬂow functions specially treats immutable values. Such val-
ues, by their very nature, can never change their taint status.
Thus, if a parameter of an immutable type like String or int
was not tainted before the call it cannot be tainted by the
callee and is thus still guaranteed to be untainted on return.
In all other cases, the taint of all tainted access paths is
mapped back to the caller’s context. The following ﬂow func-
tion applies when the callee returns a variable r after being
called using a statement of the form b = c.m(a0, . . . , an):

Tcaller

s ! [8>><>>:

{c.f m}
this.f m 2 Tcallee
{ai.f p} pi.f p 2 Tcallee ^ ¬immut(ai)
x.f q 2 Tcallee ^ static(y.f q)
{y.f q}
{b.f v}
r.f v 2 Tcallee

Call-to-return ﬂow function. For every call there is also
intra-procedural edge propagating all taint values that are
independent of the callee.
In this function, we generate
taints at sources, through a simple pattern match against an
extensible list of method signatures. We also handle native
method calls here (for details, see Section 5). Again consider
a call b = c.m(a0, . . . , an):

T [ nativeT aint(s, T ) native(s) ^ ai.f m 2 T
T [ {x}
T

x 2 source(s)
otherwise

T s !8<:

4.2 On-demand alias analysis

During our research we experimented a lot with di↵er-
ent ways to resolve aliasing e↵ectively and e ciently. As it
turned out, using ahead-of-time analyses is usually too costly
(because the analysis computes alias information for all pro-
gram variables, not just those that carry taints) and too
imprecise (because the analysis would not support the same
level of context-sensitivity as our taint analysis). We hence
opted for a demand-driven approach by Tripp et al., which
executes within the same context-sensitive IFDS framework
as our taint analysis [27]. As Figure 3 shows, this on-demand
analysis is triggered at assignments to heap variables, i.e.,

statements of the form x.f = v. The alias analysis then walks
backward through the control-ﬂow graph. Whenever it ﬁnds
an alias, it triggers the forward analysis in turn, propagat-
ing an aliased taint from the location at which the alias
was found. Similar to the forward analysis, we deﬁne ﬂow
functions which compute the alias propagation information.
Let the set A deﬁne the alias information. The only ini-
tial element in A is the complete access path of the tainted
value which caused the alias lookup. The backward solver
terminates when A becomes empty.

source, sink and

entry-point detection

parse manifest ﬁle

generate

main method

parse .dex ﬁles

build call graph

parse layout xmls

perform taint

analysis

Normal ﬂow function. For a statement x.f = y.g the fol-
lowing rule applies:

A s ! [⇢ A\{x.f.f p} [ {y.g.f p} 8p : x.f.f p 2 A

otherwise

A

For new statements, FlowDroid erases all alias informa-
tion for the left-hand side, as fresh objects cannot be aliased:
A x.f =new...

       ! A\{8m : x.f.f⇤ 2 A}

Call ﬂow function. Since the backward analysis traverses
the control-ﬂow graph backwards, its call ﬂow function prop-
agates information from call sites to return sites in the callee.
Consider again a call b = c.m(a0, . . . , an) and a return site
returning a variable r:
b.f m 2 Acaller
{r.f m}
{this.f m} c.f m 2 Acaller
{y.f q}
y.f q 2 Acaller ^ static(y.f q)

Acallee

s ! [8<:

Return ﬂow function. In the backwards analysis, return
ﬂow functions propagate from the callee’s start point to just
before the call site. The return ﬂow function thus maps the
callee’s aliases at back to the caller while taking into account
renaming from formal parameters pi to actual parameters ai.
For a call site c.m(a0, . . . , an) we obtain:
this.f m 2 Acallee
y.f q 2 Acallee ^ static(y.f q)

{c.f m}
{ai.f p} pi.f p 2 Acallee
{y.f q}

Acaller

s ! [8<:
A s !8>><>>:

Call-to-return ﬂow function. For a call site b = c.m(a0, . . . , an),
the call-to-return ﬂow function handles aliases induced by
native calls and kills aliases of references obtained through b:

A [ nativeAlias(s) native(s)
^(ai.f m 2 A _ c.f n 2 A)
A\{b.f n}
b.f n 2 A
otherwise
A

5.

IMPLEMENTATION

FlowDroid extends the Soot framework [16] which pro-
vides important prerequisites for a precise analysis, in par-
ticular a very accurate call graph. Through a plugin called
Dexpler [5] Soot supports not only converting Java code but
also Android’s dex ﬁles into the Jimple intermediate repre-
sentation which allows us to implement our analysis for both
targets. FlowDroid further uses Heros [8] as an implemen-
tation of IFDS on top of Soot and Dexpler. We next explain
FlowDroid’s architecture, while the subsequent sections
explain interesting implementation details and FlowDroid’s
current limitations.

Figure 4: Overview of FlowDroid

Architecture. Figure 4 shows FlowDroid’s architecture.
Android applications are packaged in apk ﬁles (Android Pack-
ages), which are essentially zip-compressed archives. After
unzipping an archive, FlowDroid searches for lifecycle and
callback methods as well as calls to sources and sinks in the
application. This is done by parsing various Android-speciﬁc
ﬁles, including the layout XML ﬁles, the dex ﬁles contain-
ing the executable code and the manifest ﬁle deﬁning the
activities, services, broadcast receivers and content providers
in the application. We describe the detection of UI Inter-
actions in detail below. Next, FlowDroid generates the
main method from the list of lifecycle and callback methods
(see the Paragraphs Callbacks and Substitution Classes for
more information). This main method is then used to gener-
ate a call graph and an inter-procedural control-ﬂow graph
(ICFG). Starting at the detected sources, the taint analysis
then tracks taints by traversing the ICFG as explained in
Section 4. Native Calls require a special treatment which
is described below along with a performance optimization
called Taint Wrapping. At the end, FlowDroid reports all
discovered ﬂows from sources to sinks.

UI Interactions. UI elements can be taint sources, e.g., if
an application prompts the user for a password and then
sends it out to the Internet. FlowDroid thus scans the
layout XML ﬁles in the apk ﬁle for text inputs and links
them to the source-code statements where they are accessed.
This is non-trivial, as the Android operating system manages
access to such resources at runtime and a static analysis tool
must simulate these runtime APIs as precisely as possible.
Note that we need to over-approximate resource accesses in
the general case, though. In Android, resource mappings can
be conﬁguration-dependent, for instance to support di↵erent
layouts for smartphones and tablets. In this case, we can
only assume all cases as possible. Not all data in text ﬁelds
is sensitive, though. FlowDroid can be conﬁgured to either
consider all text ﬁelds or to restrict itself to special sensitive
ﬁelds like password input ﬁelds (the default).

Callbacks. To model the app lifecycle correctly (see Sec-
tion 3), FlowDroid contains a list of callback interfaces
extracted from the Android documentation. FlowDroid
ﬁrst computes a call graph ignoring callbacks, to determine
which activity will potentially register which kind of callback
at runtime. Next, FlowDroid generates a customized main
method for each activity, taking the respective discovered
callbacks into account.

Substitution Classes. J2EE and Android applications some-
times operate on interface types or abstract class types that
at runtime receive objects instantiated within the J2EE or

Android framework. FlowDroid’s main-method generator
cannot easily be aware of those concrete subtypes. Flow-
Droid thus allows the analysis designer to provide a list of
so-called substitution classes. A substitution class provides
a concrete implementation for one or more of these inter-
faces, simply for the purpose of the analysis. The user can
choose whether to provide a stub or a real implementation,
depending on whether the designer aims for higher precision
or scalability. For Android, substitution classes are required,
for instance, for the abstract class android.context.Context.

Native Calls. Both Java and the Android platform support
invoking native methods written in C or other unmanaged
languages. For a Java-based analysis, such methods are black
boxes which cannot be resolved. We thus deﬁned explicit
taint propagation rules for the most common native methods,
such as arraycopy in java.lang.System. In this example, third
argument (the output array) will become tainted if the ﬁrst
argument (the input array) is tainted before the call. For
native methods without an explicit rule, we assume call
arguments and the return value to become tainted if at
least one parameter was tainted before. This is neither
entirely sound nor maximally precise but is probably the
only practical approximation in a black-box setting.

Taint Wrapping. Including the full JRE or Android plat-
form runtime in the analysis requires a lot of time and mem-
ory and can lead to unwanted imprecisions. Thus, while
explicit taint-propagation rules are required for native meth-
ods, they can be useful for regular Java methods as well:
their use can prevent the taint propagation from having
to analyze the library’s internals. FlowDroid supports a
simple textual ﬁle format for deﬁning such “shortcut rules”.
Predeﬁned rules handle collection classes, string bu↵ers and
similar commonly used data structures.

Limitations. At the moment FlowDroid ignores reﬂective
calls, which is unsound. While specialized static string anal-
yses can be used to simulate reﬂection to some extent, past
research has found such analyses to be incomplete [9], as
reﬂective call targets are often determined by external conﬁg-
uration ﬁles. On the Java platform, reﬂection-analysis tools
such as TamiFlex [9] can be used to make static analysis
tools aware of reﬂective calls. Such tool require load-time
instrumentation through java.lang.instrument, however, which
the Android platform does not currently support.

As described above, native code is approximated conser-
vatively using taint wrapping. Another limitation of Flow-
Droid is its current focus on explicit data ﬂows. Implicit
ﬂows caused by control-ﬂow dependencies are currently ig-
nored, but we plan to include them in the near future. Flow-
Droid also ignores probabilistic and possibilistic leaks caused
by multi-threading [13].

6. EXPERIMANTAL EVALUATION

Our evaluation addresses the following research questions:

RQ1 How does FlowDroid compare to commercial taint-
analysis tools for Android, both in terms of precision
and recall?

RQ2 Can FlowDroid ﬁnd all privacy leaks in Insecure-
Bank, an app speciﬁcally designed by others to chal-

lenge vulnerability-detection tools for Android [21], and
what is its performance?

RQ3 Can FlowDroid ﬁnd leaks in real-world applications

and how fast is it?

RQ4 How well does FlowDroid perform when being ap-
plied to taint-analysis problems related to Java, not
Android, both in terms of precision and recall?

The next sections address each research question in detail.
Section 6.5 explains why, unfortunately, we were unable to
directly compare FlowDroid to academic Android analysis
tools published elsewhere.
6.1 RQ1: Commercial taint-analysis tools

While there are benchmark suites for analyzing web appli-
cations or speciﬁcally for detecting di↵erent kinds of Java vul-
nerabilities [17], at the moment there is no Android-speciﬁc
analysis benchmark suite. This is problematic because the
generic Java test suites do not cover aspects like the An-
droid lifecycle, callbacks or interactions with UI elements
like password ﬁelds. Thus, they cannot be used for assessing
the practical e↵ectiveness of Android analysis tools.

DroidBench. Speciﬁcally for this work, we therefore de-
veloped an Android-speciﬁc test suite called DroidBench
containing 39 small Android apps. The suite can be used
to assess both static and dynamic taint analyses, but in
particular it contains test cases for interesting static-analysis
problems (ﬁeld sensitivity, object sensitivity, tradeo↵s in
access-path lengths etc.) as well as for Android-speciﬁc
challenges like correctly modeling an application’s lifecycle,
adequately handling asynchronous callbacks and interacting
with the UI. Table 3 contains a list of all apps in the suite
together with their respective names and short descriptions.
The table also indicates whether an analysis tool must model
the Android lifecycle or callback infrastructure to be able to
successfully analyze the app. We envision our test suite to
be extended by other researchers as well and then be used
to compare the completeness and correctness of the various
taint analysis approaches. DroidBench is available from
our project website.

Table 5 presents the analysis results for FlowDroid and
two commercial analysis tools explained in the following.
As the results show, FlowDroid generally performs quite
well. As explained before, for performance reasons, Flow-
Droid handles array indices imprecisely. The same limi-
tation applies to ListAccess1, causing false positives in the
ﬁrst category. Handling indices precisely and e ciently is an
interesting open research question. Button2 causes a false
positive because FlowDroid does not currently support
strong updates. In result, it cannot kill taints for certain
button combinations. Strong updates would require a must-
alias analysis which is hard to achieve inter-procedurally.
IntentSink1 is not detected because the test case contains no
actual sink. Instead, the tainted value is stored in an intent
which is then handed back to the activity by the framework.
Such cases are hard to handle without special treatment.
StaticInitialization1 fails because Soot currently assumes
all static initializers to execute at the beginning of the pro-
gram, which in this case is not correct. We plan to add
better support in the future. As most known taint-analysis
tools, FlowDroid currently disregards implicit ﬂows caused
through control-ﬂow dependencies.

Comparison with IBM AppScan Source. We compared
FlowDroid against IBM AppScan Source [2] version 8.7, on
all tests from DroidBench. AppScan Source distinguishes
three di↵erent categories of ﬁndings: vulnerabilities, excep-
tions of type 1 and exceptions of type 2. Vulnerabilities
include a complete path from source to sink. For a type 1
exception, there is a ﬂow from source to sink as well, but
the semantics of some methods along the propagation path
is unknown (e.g. possible sanitization). Since FlowDroid
does not support sanitization at the moment, we consider
both vulnerabilities and type 1 exceptions as ﬁndings. For
type 2 exceptions on the other hand, there is no trace. These
reports are generated when certain code constructs (e.g. writ-
ing a variable value into the log ﬁle) are detected. As these
ﬁndings are highly imprecise and completely disregard data
ﬂow, we do not count them as ﬁndings. As Table 5 shows,
AppScan Source ﬁnds only about 38% of all leaks (50% if
ignoring implicit ﬂows). Major problems occur with the
handling of callbacks, the Android component lifecycle and
implicit ﬂows.

Comparison with Fortify SCA. Fortify SCA [1] by HP is
another commercial tool widely used by security analysts.
Similar to IBM AppScan Source, Fortify also provides di↵er-
ent kinds of ﬁndings, such as data ﬂows from sensitive sources
to public sinks, requests for security-sensitive permissions,
calls to security-sensitive methods, etc. In our evaluation,
we only considered ﬁndings about data ﬂows. All tests were
carried out using version 5.14. As can be seen in Table 5, For-
tify SCA shows problems similar to those of IBM AppScan
(cf. Section 6.1), like the handling of the Android component
lifecycle, the callbacks and implicit ﬂows. Figure 5 shows
that Fortify detects 4 out of 6 data leaks for the lifecycle
tests, but closer inspection shows that this only happens
by chance. In these tests, the data source involves a static
ﬁeld, which Fortify apparently treats in a special way which
coincidentally causes a leak to be reported. When removing
the static modiﬁer, which does not the semantics of the test
case, Fortify does not detect the leak any longer.

Conclusion. From our experiments we conclude that, to not
overburden the user with false positives, AppScan Source and
Fortify SCA aim for relatively high precision while sacriﬁcing
recall, thus risking to miss actual privacy leaks. In compari-
son, FlowDroid shows higher precision with a signiﬁcantly
higher recall.
6.2 RQ2: Performance on InsecureBank

InsecureBank [21] is a vulnerable Android app created
by Paladion Inc. speciﬁcally for the purpose of evaluating
analysis tools such as FlowDroid. It contains various vul-
nerabilities and data leaks similar to those found in real-world
applications. Analyzing the application takes about 31 sec-
onds on a laptop computer with an Intel Core 2 Centrino
CPU and 4 GB of physical memory running on Windows 7
with Oracle’s Java Runtime version 1.7 (64 bit) in its default
settings. FlowDroid found all seven data leaks which we
all veriﬁed by hand. There were no false positives nor false
negatives.

6.3 RQ3: Real-World Applications

The above experiments give a very good indication that
FlowDroid yields correct and precise results, not just for
small test case but also for more realistic apps such as In-
secureBank [21]. To strengthen the external validity of our
experiments, we nevertheless performed an additional qualita-
tive analysis on a random selection of popular apps from the
Google Play store. While the obtained analysis reports do
not indicate any malicious apps in this selection, the majority
of apps is reported to—probably accidentally—leak informa-
tion into logs and preference ﬁles. Samsung’s Push Service,
for instance, logs the phones IMEI. Logs are problematic,
as the OS does not impose the same access restrictions on
logs as it does on ﬁles: all logs are readable by any app that
has the READ LOGS permission. The game Hugo Runner
stores longitude and latitude into a preferences ﬁle. As we
veriﬁed by hand, though, those preferences were correctly
written in private mode, precluding any access by other apps.
This indicates that taint analyses could gain precision by
considering auxiliary information such as the write mode
mentioned above. For most examined apps FlowDroid
terminated in under a minute. The longest-running instance,
Samsung’s Push Service took about 4.5 minutes to analyze.
6.4 RQ4: SecuriBench Micro

FlowDroid was speciﬁcally designed for Android, and
in this space gains much precision through its complete and
precise handling of Android’s lifecycle. Nevertheless, there is
nothing that would preclude software developers from apply-
ing FlowDroid to Java applications as well. To assess how
well FlowDroid is set up for this use case, we evaluated
FlowDroid against Stanford SecuriBench Micro [17] version
1.08, a common set of 96 J2EE micro benchmarks originally
intended for web-based applications. For each of the bench-
marks in the suite, we manually deﬁned the necessary lists of
sources, sinks and entry points. Since FlowDroid supports
a simple textual ﬁle format for deﬁning these parameters,
and since all benchmarks cases have the same structure, this
was not much e↵ort. For the interfaces HTTPServletRequest
and HTTPServletResponse we needed to provide substitution
classes (see Section 5), as we had no access to framework
code that would provide their implementations. We omit-
ted from our experiments test cases involving sanitization,
reﬂection, predicates and multi-threading. As we explained
earlier, such features are out of scope for our analysis tool,
just as they are for all other existing Android analysis tools.
Table 4 shows our test results grouped by test categories.
The TP column shows the true positives, i.e., the number
of actual leaks that FlowDroid found. For the example of
basic, for instance, FlowDroid found 58 out of 60. The FP
column shows the number of false positives, i.e., the ﬁnding
that FlowDroid reported that did not correspond to actual
leaks, but were rather artifacts of an overly approximate
analysis. In most cases this number is reasonably low or
even zero, except for the Arrays category. This is due to an
imprecision that FlowDroid shares with most other static
analyses: for performance reasons, the tools not di↵erentiate
between multiple components inside the same collection,
e.g., di↵erent indices in arrays or di↵erent positions in lists.
Treating such cases precisely and e ciently is an interesting
open issue in the static-analysis community. The n/a entries
in the table correspond to test categories such as reﬂection,
which we identiﬁed to be out of scope.

Test-case group
Aliasing
Arrays
Basic
Collections
Datastructure
Factory
Inter
Pred
Reﬂection
Sanitizer
Session
StrongUpdates
Sum

TP
11/11
9/9
58/60
14/14
5/5
3/3
14/16
n/a
n/a
n/a
3/3
0/0

117/121

FP
0
6
0
3
0
0
0

n/a
n/a
n/a

0
0
9

Table 4: SecuriBench Micro test results

6.5 Comparison with Other Tools

We also tried to compare FlowDroid to a number of other
tools from the scientiﬁc literature, namely TrustDroid [31],
LeakMiner [30], and the tool by Batyuk et al. [6]. Unfor-
tunately none of those tools are available online, and even
worse the respective authors did not reply to our inquiries.
We tried to run DroidBench on SCanDroid [11], but
faced technical di culties. The tool did not report any
ﬁndings at all in our setup. Though being in contact with the
authors, we were unable to ﬁx these issues by the submission
deadline. The authors of AndroidLeaks [12] promised to
run their tool on DroidBench but never delivered. We
also contacted the authors of CHEX [18], but they were
unable to provide the tool or any benchmark results due to
intellectual property claimed by NEC. Starostin [19] declined
to participate in the experiment as his tool ignores aliasing,
making any comparison meaningless.

In result, we were unable to successfully evaluate even a
single scientiﬁc taint-analysis tool for Android. We believe
that the lack of such comparative experiments is hindering
scientiﬁc progress a lot, which is why we make available our
entire implementation, documentation and benchmarks as
open source.

7. RELATED WORK

There are several approaches to static analysis of Android
applications di↵ering in precision, runtime, scope and focus.
One of the most sophisticated ones is CHEX [18], a tool
to detect component hijacking vulnerabilities in Android
applications by tracking taints between externally accessible
interfaces and sensitive sources or sinks. Although not built
for the task, CHEX can, in principle, be used for taint anal-
ysis. However, since CHEX looks for vulnerabilities, target
applications are supposed to be benign. The derived assump-
tions (no obfuscation etc.) do not hold for malicious apps.
Furthermore, CHEX does not analyze calls into Android
framework itself but instead requires a (hopefully complete)
model of the framework. In FlowDroid such a model is
optional and, except for native calls, is used only to increase
performance. CHEX’s entry point model requires an enumer-
ation of all possible split orderings which is not necessary in
FlowDroid.

LeakMiner [30] appears similar to our approach from a
technical point of view:
like FlowDroid, it is based on
Soot, uses Spark for call-graph generation, it implements the

Android lifecycle, and the paper states that an app can be
analyzed in 2.5 minutes on average. However, the analysis
is not context-sensitive which is likely a major source of
imprecision. Unfortunately we were unable to perform a
systematic comparison as the authors did not respond to our
inquiries.

AndroidLeaks [12] also states the ability to handle the
Android Lifecycle including callback methods. It is based on
WALA’s context-sensitive System Dependence Graph with a
context-insensitive overlay for heap tracking, but is not as
precise as FlowDroid, because it taints the whole object if
tainted data is stored in one of its ﬁelds. As noted before,
we contacted the authors but they failed to provide us any
data for a comparative evaluation.

SCanDroid [11] is another tool for reasoning about data
ﬂows in Android applications. Its main focus is the inter-
component (e.g. between two activities in the same app)
and inter-app data ﬂow. This poses the challenge of con-
necting intent senders to their respective receivers in other
applications. SCanDroid prunes all call edges to Android
OS methods and conservatively assumes the base object,
the parameters, and the return value to inherit taints from
arguments which is much less precise than FlowDroid’s
treatment. FlowDroid, on the other hand, currently does
not resolve intent-based communication. Such a feature
would require string analysis, which we leave to future work.
Other approaches like CopperDroid [24] dynamically ob-
serve interactions between the Android components and the
underlying Linux system to reconstruct higher-level behavior.
Special stimulation techniques are used for exercising the
application to ﬁnd malicious activities. Attackers, however,
can easily modify an app to detect whether it is running
inside a virtual machine and then leak no data during that
time. Alternatively, data leaks might only occur after a cer-
tain runtime threshold. Aurasium [28] and DroidScope [29]
largely su↵er from the same shortcomings with respect to
static leak detection.

There are also approaches with a much broader focus
like [6]. This approach not only tracks data ﬂows, but also
generate a user-friendly report and sanitizes malicious apps
by replacing their sources with safe equivalents like UUID
generators. The paper gives no details on the implementation,
which is why we were unable to conduct a detailed comparison
to our approach.

The approach by Payet et al. [22] tries to aid the developer
by checking for common programming errors using di↵erent
checks, for example a nullness analysis. In contrast to Flow-
Droid, their approach cannot perform a dataﬂow analysis
and is not focused on security.

8. CONCLUSIONS

We have presented FlowDroid, a novel and highly pre-
cise static taint-analysis tool for Android applications. We
have shown that many existing approaches do not adequately
model Android-speciﬁc challenges like the application life-
cycle or callback methods, leading to either missed leaks
or false positives. For assessing the e↵ectiveness of analysis
tools, we have proposed the Android-speciﬁc benchmark suite
DroidBench and used it for comparing FlowDroid to the
commercial tools AppScan Source and Fortify SCA, showing
that besides ﬁnding more real leaks, FlowDroid also has
a higher precision resulting in less false positives. We hope

that in the future DroidBench will serve as a standard test
set for Android taint analyses.

Acknowledgements.

We would like to thank Stephan Huber from Fraunhofer
SIT for supporting us with real-world applications from the
Google Play market and Dr. Karsten Sohr from TZi Bremen
for supporting us with the Fortify SCA evaluation. This
work was supported by a Google Faculty Research Award,
by the BMBF within EC SPRIDE, by the Hessian LOEWE
excellence initiative within CASED, and by the DFG within
the project RUNSECURE.

9. REFERENCES
[1] Fortify 360 Source Code Analyzer (SCA), April 2013.

http://www8.hp.com/us/en/software-solutions/
software.html?compURI=1214365#.UW6CVKuAtfQ.

[2] Ibm rational appscan, April 2013. http:

//www-01.ibm.com/software/de/rational/appscan/.

[3] Android. Android security overview, December 2012.

http://source.android.com/tech/security/.

[4] Alexandre Bartel, Jacques Klein, Yves Le Traon, and

Martin Monperrus. Automatically securing
permission-based software by reducing the attack
surface: an application to android. In Proceedings of
the 27th IEEE/ACM International Conference on
Automated Software Engineering, ASE 2012, pages
274–277, New York, NY, USA, 2012. ACM.

[5] Alexandre Bartel, Jacques Klein, Yves Le Traon, and

Martin Monperrus. Dexpler: converting android dalvik
bytecode to jimple for static analysis with soot. In
Proceedings of the ACM SIGPLAN International
Workshop on State of the Art in Java Program analysis,
SOAP ’12, pages 27–38, New York, NY, USA, 2012.
ACM.

[6] L. Batyuk, M. Herpich, S.A. Camtepe, K. Raddatz,

A.-D. Schmidt, and S. Albayrak. Using static analysis
for automatic assessment and mitigation of unwanted
and malicious activities within android applications. In
Malicious and Unwanted Software (MALWARE), 2011
6th International Conference on, pages 66–72, 2011.

[7] Bit9. Pausing google play: More than 100,000 android

apps may pose security risks, November 2012.
http://www.bit9.com/pausing-google-play/.

[8] Eric Bodden. Inter-procedural data-ﬂow analysis with

ifds/ide and soot. In Proceedings of the ACM
SIGPLAN International Workshop on State of the Art
in Java Program analysis, SOAP ’12, pages 3–8, New
York, NY, USA, 2012. ACM.

[9] Eric Bodden, Andreas Sewe, Jan Sinschek, Hela

Oueslati, and Mira Mezini. Taming reﬂection: Aiding
static analysis in the presence of reﬂection and custom
class loaders. In ICSE ’11: International Conference on
Software Engineering, pages 241–250. ACM, May 2011.

[10] International Data Corporation. Worldwide quarterly

mobile phone tracker 3q12, November 2012.
http://www.idc.com/tracker/showproductinfo.
jsp?prod_id=37.

[11] Adam P. Fuchs, Avik Chaudhuri, and Je↵rey S. Foster.
Scandroid: Automated security certiﬁcation of android
applications.

[12] Clint Gibler, Jonathan Crussell, Jeremy Erickson, and

Hao Chen. Androidleaks: automatically detecting
potential privacy leaks in android applications on a
large scale. In Proceedings of the 5th international
conference on Trust and Trustworthy Computing,
TRUST’12, pages 291–307. Springer, 2012.

[13] Dennis Gi↵horn and Gregor Snelting. Probabilistic

noninterference based on program dependence graphs.
Technical Report 06/2012, KIT, Faculty of Informatics,
June 2012. revised 2013, submitted for publication.

[14] Google Inc. Permissions, December 2012.

http://developer.android.com/guide/topics/
security/permissions.html.

[15] Google Inc. Android and security, November 2012.

http://googlemobile.blogspot.de/2012/02/
android-and-security.html.

[16] Patrick Lam, Eric Bodden, Ondrej Lhotak, and Laurie

Hendren. The soot framework for java program
analysis: a retrospective. In Cetus Users and Compiler
Infastructure Workshop (CETUS 2011), Oktober 2011.

[17] Ben Livshits. Securibench micro, March 2013.
http://suif.stanford.edu/~livshits/work/
securibench-micro/.

[18] Long Lu, Zhichun Li, Zhenyu Wu, Wenke Lee, and

Guofei Jiang. Chex: statically vetting android apps for
component hijacking vulnerabilities. In Proceedings of
the 2012 ACM conference on Computer and
communications security, CCS ’12, pages 229–240, New
York, NY, USA, 2012. ACM.

[19] Christopher Mann and Artem Starostin. A framework

for static detection of privacy leaks in android
applications. In Proceedings of the 27th Annual ACM
Symposium on Applied Computing, SAC ’12, pages
1457–1462, New York, NY, USA, 2012. ACM.

[20] Mohammad Nauman, Sohail Khan, and Xinwen Zhang.

Apex: extending android permission model and
enforcement with user-deﬁned runtime constraints. In
ASIACCS ’10, pages 328–332, New York, NY, USA,
2010. ACM.

[21] Paladion. Insecurebank test app.

http://www.paladion.net/downloadapp.html.

[22] ´Etienne Payet and Fausto Spoto. Static analysis of

android programs. In Proceedings of the 23rd
international conference on Automated deduction,
CADE’11, pages 439–445, Berlin, Heidelberg, 2011.
Springer-Verlag.

[23] Nicholas J Percoco and Sean Schulte. Adventures in

bouncerland. Blackhat USA, 2012.

[24] Alessandro Reina, Aristide Fattori, and Lorenzo

Cavallaro. A system call-centric analysis and
stimulation technique to automatically reconstruct
android malware behaviors. In EUROSEC, Prague,
Czech Republic, April 2013.

[25] Thomas Reps, Susan Horwitz, and Mooly Sagiv.

Precise interprocedural dataﬂow analysis via graph
reachability. In POPL ’95, pages 49–61, 1995.

[26] Yannis Smaragdakis, Martin Bravenboer, and Ondrej

Lhot´ak. Pick your contexts well: understanding
object-sensitivity. In Proceedings of the 38th annual
ACM SIGPLAN-SIGACT symposium on Principles of
programming languages, POPL ’11, pages 17–30, New
York, NY, USA, 2011. ACM.

[27] Omer Tripp, Marco Pistoia, Patrick Cousot, Radhia

World Congress on, pages 101–104, 2012.

Cousot, and Salvatore Guarnieri. Andromeda:
Accurate and scalable security analysis of web
applications. In Proceedings of the 16th international
conference on Fundamental Approaches to Software
Engineering, FASE’13, pages 210–225, 2013.

[28] Rubin Xu, Hassen Sa¨ıdi, and Ross Anderson. Aurasium:

practical policy enforcement for android applications.
In USENIX Security 2012, Security’12, pages 27–27,
Berkeley, CA, USA, 2012. USENIX Association.

[29] Lok Kwong Yan and Heng Yin. Droidscope: seamlessly

reconstructing the os and dalvik semantic views for
dynamic android malware analysis. In USENIX
Security 2012, Security’12, pages 29–29, Berkeley, CA,
USA, 2012. USENIX Association.

[30] Zhemin Yang and Min Yang. Leakminer: Detect
information leakage on android with static taint
analysis. In Software Engineering (WCSE), 2012 Third

[31] Zhibo Zhao and F.C.C. Osono. Trustdroid: Preventing

the use of smartphones for information leaking in
corporate networks through the used of static analysis
taint tracking. In Malicious and Unwanted Software
(MALWARE), 2012 7th International Conference on,
pages 135–143, 2012.

[32] Yajin Zhou and Xuxian Jiang. Dissecting android

malware: Characterization and evolution. In
Proceedings of the 2012 IEEE Symposium on Security
and Privacy, SP ’12, pages 95–109, Washington, DC,
USA, 2012. IEEE Computer Society.

[33] Yajin Zhou, Xinwen Zhang, Xuxian Jiang, and
Vincent W. Freeh. Taming information-stealing
smartphone applications (on android). In Proc. of the
4th international conference on Trust and trustworthy
computing, TRUST’11, pages 93–107. Springer, 2011.

App Name

Description

Leak Lifecycle Callbacks

ArrayAccess1

ArrayAccess2

ListAccess1

AnonymousClass1

Button1

Button2
LocationLeak1

LocationLeak2

MethodOverride1

FieldSensitivity1

FieldSensitivity2

FieldSensitivity3

FieldSensitivity4
InheritedObjects1

ObjectSensitivity1

ObjectSensitivity2

IntentSink1
IntentSink2

ActivityCommunication1

Arrays and Lists

Stores both a tainted and an untainted value in an array and
then leaks the untainted one. Array indices are constants.
Stores both a tainted and an untainted value in an array and
then leaks the untainted one. Array indices are calculated.
Both a tainted and an untainted value are stored in a list. Only
the untainted value is leaked.

Callbacks

Registers a callback handler for location updates in an anony-
mous inner class and leaks the incoming location data inside
the callback.
The sink is called after the user clicks a button. The button
handler is deﬁned via XML.
Only clicking buttons in a speciﬁc order leads to a data leak.
Registers a listener for location updates, stores the value and
leaks it later in the lifecycle.
Similar to LocationLeak1, but the activity class directly imple-
ments the callback interface.
Overwrites an internal Android method to hide a leak.

Field and Object Sensitivity

Both tainted and untainted data is stored in a data object; the
untainted value is leaked.
Similar to FieldSensitivity1, but source and sink calls are dis-
tributed across the lifecycle.
Both tainted and untainted data is stored in a data object; the
tainted value is leaked. Source and sink calls are distributed
across the lifecycle.
Field contents are sent before tainting the ﬁeld.
Chooses an object’s actual type based on a conditional. Only
one possible type leads to a leak.
Writes a tainted value into an object and an untainted one into
another object of the same type. Leaks the untainted value.
Writes a tainted value into a ﬁeld and then overwrites it with
untainted data.

Inter-App Communication

A tainted value is leaked to another application using an intent.
Similar to IntentSink, but the value is sent out in a callback
method deﬁned in XML.
Contains two activities that communicate using static ﬁelds.

Lifecycle

BroadcastReceiverLifecycle1 Calls to sources and sinks distributed across a broadcast receiver

ActivityLifecycle1
ActivityLifecycle2

ActivityLifecycle3

ActivityLifecycle4

ServiceLifecycle1

Loop1
Loop2

SourceCodeSpeciﬁc1
StaticInitialization1
UnreachableCode

PrivateDataLeak1
PrivateDataLeak2
DirectLeak1

InactiveActivity
LogNoLeak

lifecycle.
Calls to sources and sinks distributed across an activity lifecycle.
Activity class inherited from a superclass containing the lifecycle
method which leaks the tainted value.
Calls to sources and sinks distributed across instance state
handling methods.
A tainted value is obtained on onPause() and leaked when the
activity is restarted later.
Calls to sources and sinks distributed across a service lifecycle.

General Java
Contains a simple loop and a data leak.
Retrieves location information through a callback and leaks it
via nested loops.
Uses unusual code construct a = p ? b : c.
Passes a tainted value into a static initialization method.
Passes tainted data into a method that is never called.

Miscellaneous Android-Speciﬁc

Summary test case containing various challenges.
Leaks a value from a password ﬁeld.
The device id is read out and sent via SMS on the activity’s
onCreate() event.
Data leak in a disabled activity.
Writes untainted data into a log ﬁle.

Implicit Flows

ImplicitFlow1-4

Test case for implicit ﬂows.

Table 3: DroidBench 1.0 test cases

 

 

  Technical Report 

 
 
  Nr. TUD-CS-2013-0113 

 
 
May 8th, 2013 
 

 

 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 

 

 

Highly Precise Taint Analysis 
for Android Applications 
 

Authors 
Christian Fritz (EC SPRIDE) 
Steven Arzt (EC SPRIDE) 
Siegfried Rasthofer (EC SPRIDE) 
Eric Bodden (EC SPRIDE) 
Alexandre Bartel (SnT, University of Luxembourg) 
Jacques Klein (SnT, University of Luxembourg) 
Yves le Traon (SnT, University of Luxembourg) 
Damien Octeau (Penn State University) 
Patrick McDaniel (Penn State University) 

 

 

Highly Precise Taint Analysis for Android Application

Christian Fritz1, Steven Arzt1, Siegfried Rasthofer1, Eric Bodden1, Alexandre Bartel2,

Jacques Klein2, Yves le Traon2, Damien Octeau3 and Patrick McDaniel3

1Secure Software Engineering Group, EC SPRIDE

2SnT, University of Luxembourg
eric.bodden@ec-spride.de

3Penn State University

ABSTRACT
Today’s smart phones are a ubiquitous source of private and
conﬁdential data. At the same time, smartphone users are
plagued by malicious apps that exploit their given privileges
to steal such sensitive data, or to track users without their
consent or even the users noticing. Dynamic program analy-
ses fail to discover such malicious activity because apps have
learned to recognize the analyses as they execute.

In this work we present FlowDroid, a novel and highly
precise taint analysis for Android applications. A precise
model of Android’s lifecycle allows the analysis to prop-
erly handle callbacks, while context, ﬂow, ﬁeld and object-
sensitivity allows the analysis to track taints with a degree
of precision unheard of from previous Android analyses.

We also propose DroidBench, an open test suite for
evaluating the e↵ectiveness and accuracy of taint-analysis
tools speciﬁcally for Android apps. As we show through a set
of experiments using SecuriBench Micro, DroidBench and
a set of well-known Android test applications, our approach
ﬁnds a very high fraction of data leaks while keeping the
rate of false positives low. On DroidBench, our approach
achieves 93% recall and 86% precision, greatly outperforming
the commercial tools AppScan Source and Fortify SCA.

Categories and Subject Descriptors
F.3.2 [Semantics of Programming Languages]: Pro-
gram analysis; D.4.6 [Security and Protection]: Infor-
mation ﬂow controls

General Terms
Experimentation, Security, Veriﬁcation

Keywords
Static analysis, Android, taint analysis

1.

INTRODUCTION

According to a recent study [10], Android now has about
75% market share in the mobile-phone market, with a 91.5%
growth rate over the past year. With Android phones being
ubiquitous, they become a worthwhile target for security and
privacy violations. Attacks range from broad data collection
for the purpose of targeted advertisement, to targeted at-
tacks, such as the case of industrial espionage. Attacks are
most likely to be motivated primarily by a social element: a
signiﬁcant number of mobile-phone owners use their device
both for private and work-related communication [7]. Fur-
thermore, the vast majority of users install apps containing
code whose trustworthiness they cannot judge and which
they cannot e↵ectively control.

These problems are well known, and indeed the Android
platform does implement state-of-the-practice measures to
impede attacks. The Android platform is built as a stack,
with various layers running on top of each other [3]. The lower
levels consist of an embedded Linux system and its libraries,
with Android applications residing at the very top. Users
typically acquire these applications through various channels
(e.g., the Google Play Store1). The underlying embedded
Linux system provides the enforcement mechanisms common
to the Linux kernel, such as a user-based permission model,
process isolation and secure inter-process communication.

By default, an application is not allowed to directly inter-
act with other applications, operating system processes, or
a user’s private data [14]. The latter includes, for example,
access to the contacts list. Android regulates access to such
private data via a permission-based security model where,
to access security-sensitive API functions, applications have
to statically declare the permissions they require. An ap-
plication may only be installed following the user’s consent,
yet users currently have little control over the installation
process, as they must either grant all of the permissions that
an app demands, or else forego installation. The problem is
aggravated by the coarse-grained nature of Android permis-
sions [20, 33]. For instance, an app may require internet and
phone book access permissions to function correctly, in which
case revoking either would not be an option. Nevertheless,
one may wish to forbid the app from transmitting phone
book entries over the internet. Android’s existing permission
system does not allow for such ﬁne-grained restrictions on
information ﬂow. Unfortunately, practice shows that, as a
result of this limitation, users grant too many permissions
too often, thus running the risk to give malicious apps access
to private data.

EC SPRIDE Technical Report TUD-CS-2013-0113

1Available at https://play.google.com/

The industry has acknowledged the problem of malware,
and has thus started to take measures through dynamic
analyses. One example is Google’s Bouncer [15], which test-
runs apps for ﬁve minutes as they are uploaded into the
Play Store. Unfortunately, apps can easily circumvent such
measures by just holding o↵ from suspicious activity for the
prescribed time, or by recognizing the analysis environment
through their IP addresses or other clues [23].

One possible solution to the problem are static analyses
that analyze the apps’ code without requiring their execu-
tion. But while static analyses for Android have made some
progress over the past years, as we show, they still lack
the necessary precision to be e↵ectively useful in practice.
One major challenge is the fact that Android apps are not
just closed programs but run within the Android framework,
which imposes a complex lifecycle on those apps, invoking
a range of pre-deﬁned or user-deﬁned callback methods at
di↵erent times during the app’s execution. To be able to
e↵ectively predict the app’s control ﬂow, static analyses
must model this lifecycle precisely. Another source of im-
precision in previous analyses is their typically context and
object-insensitive nature. A context-insensitive analysis joins
together the analysis results for a method m at all call sites
to m even if the arguments to m at those call sites di↵er.
Similarly, an object-insensitive analysis lumps together anal-
ysis information for all objects that reach the same virtual
call site. As previous work has shown, context and object
sensitivity is key to successful static analyses [26].

In this work we thus present FlowDroid, to the best
of our knowledge the ﬁrst static taint-analysis system that
is fully context, ﬂow, ﬁeld and object-sensitive while pre-
cisely modeling the complete Android lifecycle, including the
correct handling of user-deﬁned UI widgets within the apps.
Another contribution of this work is DroidBench, a novel
open micro-benchmark suite for comparing the e↵ectiveness
of taint analyses for Android. We intend to extend and
maintain this suite as a community e↵ort and hope that in
the future it will be used for empirical evaluations that are
more systematic and comparative than the ones that have
appeared in the scientiﬁc literature to date.

A set of experiments with SecuriBench Micro, Droid-
Bench and some well-known apps containing data leaks
shows that FlowDroid ﬁnds a very high fraction of data
leaks while keeping the rate of false positives low. On Droid-
Bench, our approach achieves 93% recall and 86% preci-
sion, greatly outperforming the commercial tools AppScan
Source [2] and Fortify SCA [1]. FlowDroid thus sets a new
gold standard for the static taint analysis of Android appli-
cations. We make available online our full implementation
as an open source project, along with all benchmarks and
scripts to reproduce our experimental results:

http://sseblog.ec-spride.de/flowdroid/

To summarize, this work presents the following original

contributions:

• FlowDroid, the ﬁrst fully context, object and ﬂow-
sensitive taint analysis to consider the Android appli-
cation lifecycle and UI widgets; it can be conﬁgured
easily to run with new Android versions;

• as one of few approaches in the ﬁeld: an open-source

implementation of the above analysis,

• DroidBench, a novel, open and comprehensive micro

benchmark suite for Android ﬂow analyses, and

• a set of experiments comparing the relative precision
and recall of FlowDroid with the commercial tools
AppScan Source and Fortify SCA.

2. BACKGROUND AND EXAMPLE

We start by giving a motivating example. We then give a
short introduction into the IFDS framework on which Flow-
Droid bases its analysis and explain our attacker model.

The example code shown below reads a password from
a text ﬁeld (line5) whenever the application is restarted.
When the user clicks on a button of the activity, it is sent
to some constant telephone number via SMS (line22). This
constitutes a data ﬂow from the password ﬁeld (the source)
to the SMS API (the sink). Though this is a small example,
similar code is known to exist in real-world malware apps [32].

1 public class LeakageApp extends Activity {
2
3
4

private User user = null ;
protected void onRestart () {

EditText usernameText =
( EditText ) findViewById ( R . id . username ) ;
EditText passwordText =
( EditText )findViewById(R.id.password);
String uname = usernameText . toString () ;
String pwd = passwordText . toString () ;
this . user = new User ( uname , pwd ) ;

}
// Callback method ; name defined in Layout - XML
public void sendMessage ( View view ) {

if ( user != null ) {

Password pwdObject = user . getPwdObject () ;
String password = pwdObject . getPassword () ;
String obfPwd = " " ; // must track primitives
for ( char c : password . toCharArray () )

obfPwd += c + " _ " ; // must handle concat .

String message = " User : " +

user . getUsername () + " | Pwd : " + obfPwd ;

SmsManager sms = SmsManager . getDefault () ;
sms.sendTextMessage( " +44 020 7321 0905 " , null ,

message , null , null ) ;

}

}

5

6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26 }

In this example, sendMessage() is associated with a button
in the app’s UI. It is a callback method that gets triggered
by an onClick event. In Android, listeners are deﬁned either
directly in the code or in the layout XML ﬁle, as is assumed
here. Thus, analyzing the source code alone is insu cient—
one must also process the meta data ﬁles to correctly associate
all callback methods.

In this code a leak only occurs if onRestart() is called,
initializing the user variable, before sendMessage() executes.
To be both sound and precise, a taint analysis must model
the app lifecycle correctly, recognizing that a user may indeed
hit the button after an app restart.

Field-sensitivity is needed due to the user object containing
two ﬁelds, a string for the user name and another one for
the password, but only one of them should be considered
a high value. Object-sensitivity, while not required for this
example, is essential to distinguish objects originating at
di↵erent allocation sites but reaching the same code locations.
Operations such as string concatenation (line 17) require a
security lattice that deﬁnes how data ﬂows through those
operations.

The IFDS framework
Our inter-procedural dataﬂow analysis problem is formulated
in terms of the IFDS framework by Reps et al. [25] and can
therefore be reduced to a graph-reachability problem. IFDS
solves inter-procedural, ﬁnite, distributive subset problems
and works by creating a so-called exploded supergraph based
on ﬂow functions associated with the program statements.
A ﬂow function deﬁnes the impact of a statement on a set
of ﬂow facts. For example, the statement x = y would be
associated with a ﬂow function that maps a fact set {y} (i.e.
y is tainted) to a fact set {x, y} (x and y are both tainted).
Function calls are modeled using summary functions, which
makes the approach precise, yet very e cient: at di↵erent
call sites to the same method m, the summary function for
m is just reused (gaining e ciency) but it is applied to the
taint information at that very call site (thus yielding full
context sensitivity). Section 4 gives more details about how
FlowDroid constructs the supergraph.

Once the supergraph is constructed, the algorithm decides
whether a variable x at a statement s is tainted simply by
computing whether the node representing (s, x) is reachable
within this graph. Because all method calls have been ab-
stracted through summary functions, those queries are fully
intra-procedural and therefore highly e cient.
Attacker model
We assume an attacker that can supply an app with arbi-
trary malicious bytecode, obfuscated or not. In the scenario
treated in this paper, the attacker’s goal is to leak private
data through a dangerously broad set of permissions granted
by the user [4]. Our analysis makes sound assumptions on the
installation environment and app inputs, meaning that the
attacker is free to tamper with those as well. FlowDroid
does assume, however, that the attacker has no way of cir-
cumventing the security measures of the Android platform.
Also, right now no static analysis for Android, including
FlowDroid has a way of dealing with dynamic loading and
reﬂection. Bodden et al. showed how those features can be
handled in general [9], however their approach requires access
to a load-time instrumentation API, which is something that
Android does not currently support. We are in contact with
Google to see if such an API can be supported in the future.

3. PRECISE MODELLING OF LIFECYCLE

Multiple entry points. Unlike Java programs, Android ap-
plications do not have a main method. Apps instead comprise
many entry points, i.e., methods that are implicitly called
by the Android framework. The Android operating system
deﬁnes a complete lifecycle for all components in an applica-
tion. There are four di↵erent components an app developer
can deﬁne: activities are single focused user actions, ser-
vices perform background tasks, content providers deﬁne a
database-like storage, and broadcast receivers listen for global
events. All these components are implemented by deriving
a custom class from a predeﬁned operating system class,
registering it in the AndroidManifest.xml ﬁle and overwrit-
ing the lifecycle methods. The Android system calls these
methods at runtime to start or stop the component, or pause
or resume it, depending on environment needs. It can, e.g.,
stop an application because of low memory, and later restart
it when the user returns to it. Figure 1 shows the lifecycle

Activity
launched

onCreate()

User navigates
to the activity

onStart()

onRestart()

User

returns
to the
activity

User navigates
to the activity

App process

killed

Apps with

higher priority
needs memory

onResume()

Activity
running

Another

activity comes

into the foreground

onPause()

The activity is
no longer visible

onStop()

The activity is ﬁnishing or

being destroyed by the system

onDestroy()

Activity
shut down

Figure 1: Android Activity Lifecycle

for an activity. In result, when constructing a call graph,
Android analyses cannot simply start by inspecting a pre-
deﬁned “main” method. Instead, all possible transitions in
the Android lifecycle must be modeled precisely. To cope
with this problem, FlowDroid constructs a custom dummy
main method emulating the lifecycle. However, the lifecycle
is more complex than depicted and explicitly documented.
There are additional methods for saving and restoring state,
as well as callbacks that notify the app about additional state
changes. If not taken into account, a malicious application
could exploit these methods and send out secret information
without being noticed.

Asynchronously executing components. An application
can contain multiple components, e.g., three activities and
one service. The activities run sequentially, however, one can-
not pre-estimate their order. One activity could, for instance,
be the main one initially visible to the user and then launch
either one of the others depending on user input. Services run
in parallel. FlowDroid thus conservatively assumes that all
components (activities, services, etc.) inside an application
to run in an arbitrary sequential order. Within a component,
the analysis is fully ﬂow-sensitive, though. Additionally, the
Android operating system allows applications to register call-
backs for various types of information, e.g., location updates
or UI interactions. Callbacks implement predeﬁned interfaces
declaring methods that are then called asynchronously by
the operating system. FlowDroid models these callbacks
in its dummy main method, for instance to recognize cases
where an application stores to the heap the location data
that is passed into the callback as a parameter, and later
sends this data to the internet when the activity is stopped.
The order in which callbacks are invoked cannot generally
be predicted, which is why FlowDroid conservatively as-

LeakageApp la = new LeakageApp();

la.onCreate();

la.onStart();

la.onResume();

p

p

la.onPause();

p

la.onStop();

p

p

la.onDestroy();

la.sendMessage();

la.onRestart();

5

4

void foo( z ) {

x = z.g;
w = source(); 
x.f = w;

a.g.f

6

void main() { 
7
b.f

a = new A();
b = a.g;
foo(a);
sink(b.f);

}

x.f
} 

3

x.f
2

z.g.f

w

1

Figure 3: Taint analysis under realistic aliasing

Name
V arId
F ieldId
Stmt
Loc
V al = Loc [ {null}
Env : V arId ! V al
Heap : Loc ⇥ F ieldId ! V al Heap
States = Env ⇥ Heap

Description
Program variables
Field identiﬁers
Statements2
Memory locations
Values
Environment

Program States

Figure 2: CFG for dummy main method

Table 1: Formalization Domains

sumes that all callbacks can be invoked in any possible order.
Some static analysis are path-sensitive, i.e., consider each
possible program paths separately. In such cases, considering
all possible orderings would be very expensive. Fortunately,
FlowDroid bases its analysis on IFDS, which is not path-
sensitive and instead joins analysis results immediately at
any control-ﬂow merge point. For FlowDroid can thus
generate a main method in which every order of individual
component lifecycles and callbacks is possible, it does not
need to simulate all possible paths.

Example. In Figure 2 we show the control-ﬂow graph of the
dummy main method for our example. In this ﬁgure, p repre-
sents an opaque predicate of which we know that FlowDroid
won’t be able to evaluate it statically (for instance, a check
involving an environment variable). In result, the analysis
will automatically consider on equal terms both branches for
conditions involving p. Note that, to gain maximal precision,
we generate an individual dummy main method for each app
analyzed. Each main method will only involve the fraction of
the lifecycle that, according to the app’s XML conﬁguration
ﬁles, can actually occur. Disabled activities are automati-
cally ﬁltered and callback methods are only invoked in the
contexts of the components to which they actually belong.
A button click handler is for instance only analyzed in the
context of its respective activity.

4. CONTEXT, OBJECT, FIELD AND FLOW-

SENSITIVE ANALYSIS

One major di culty in the analysis is how to handle alias-
ing with high object sensitivity. Figure 3 shows how Flow-
Droid combines a forward-taint analysis and an on-demand
backward-alias analysis to decide that b.f is tainted at the
3 , where the forward analysis
sink. The important step is
assigns a taint to x.f. On such assignments to the heap, the
backward analysis searches upwards for aliases of x.f, an

idea borrowed from Andromeda [27]. At
is found and then propagated forward.

7 , the alias b.f

To increase the reproducibility of our approach, in this
section we give important details about the di↵erent transfer
functions our analysis associates with program statements.
In the following, ﬁrst we deﬁne an abstract heap model. Sec-
tion 4.1 explains our general taint analysis, while Section 4.2
explains our on-demand alias analysis.

FlowDroid leverages IFDS to propagate each tainted
value individually, using a multi-threaded implementation.
When processing any given statement, the set T of incoming
taints are transformed into a set of outgoing taints. We deﬁne
the abstract analysis semantics with the standard notation
used similarly by Tripp et al. [27]. Table 1 shows our abstract
domain. For representing the e↵ects of program statements,
FlowDroid uses the semantics deﬁned in Table 2. H 2
Heap deﬁnes the current heap, and E 2 Env the current
environment. A program state is deﬁned as   = hE, Hi 2
States.
To be able to explain our taint propagation algorithm in

detail we declare the following helper functions:

arrayElem(x) : V arId ! Boolean returns true i↵ x refer-

ences an array element

static(x) : F ieldId ! Boolean returns true i↵ x is a static

ﬁeld

2FlowDroid operates on an intermediate representation
that represents compound statements through individual
atomic statements.

Statement
x = new Object()
x = y
x.f = y
x = y.f

Semantics
  =  [x ! o 2 Loc. o is fresh]
  =  [E(x) ! E(y)]
  =  [H((E(x), f )) ! E(y)]
  =  [E(x) ! H((E(y), f ))]

Table 2: Program Semantics

immut(x) : V arId ! Boolean returns true i↵ x is a primi-

tive or immutable data type (int, String, etc.)

source(s) : Stmt ! P (V arId) returns a set of variable names
tainted by the source statement s or ; if s is no source
native(s) : Stmt ! Boolean returns true i↵ s contains a call

to a native method

nativeT aint(s) : Stmt ! P (V arId) returns values which are
tainted after the native call s 2 Stmt. Such values can
include the base object on which the method was in-
voked, the return value, or one or more of the input
parameters.

nativeAlias(s) : Stmt ! P (V arId) returns possible aliases
of tainted values before the native call s 2 Stmt (back-
wards analysis)

To model deep object sensitivity, FlowDroid does not
simply propagate simple ﬁelds like x.f but instead so-called
access paths [27] up to a ﬁxed length. x.f.g.h for instance
models an access path of length 3. We use the notation
x.f n to describe an arbitrary but ﬁxed access path of length
n, rooted at x. For example x.f 3 represents paths such as
x.f.g.h. Note that x.f 0 is equal to x. The notation allows
us to split ﬁeld accesses such that x.f p = x.f n.f m where
p = m + n. In result, T is actually a set of currently tainted
access paths.

A concrete state is a program state extended by the set
of tainted access paths T resulting in a triple   = hE, H, Ti.
At the beginning it holds that T = ;. Tainted access paths
are added to the set whenever the analysis reaches a call to
a source, or when processing a statement that propagates an
existing taint to a new memory location. We next explain
the di↵erent transfer functions that FlowDroid uses to
compute taints. Section 4.2 explains how we use access paths
to deal with aliasing.
4.1 Taint analysis

The taint analysis starts directly at each of the identiﬁed
and reachable sources. The IFDS framework distinguishes
four di↵erent kinds of ﬂow functions: normal, call, return
and call-to-return.

Normal ﬂow function. Normal ﬂow functions are applied
at all statements that are neither calls nor returns. In Flow-
Droid, only method calls can be the original source of a
taint. Thus, a normal ﬂow function can never generate new
taints, it can only transfer, preserve, or “kill” existing taints.
FlowDroid is insensitive to array indices, tainting the
entire set of array elements even if the program taints just
a single element. To be sound, FlowDroid thus needs to
assume that the entire contents remain tainted, even if the
single array element is overwritten by an untainted value
later-on. For an assignment statement s 2 Stmt with the
structure x.f n = y.f m with n, m 2 N0 the following rules
apply:

T [ {x.f n.f p} 8p : y.f m.f p 2 T
T\{x.f n}
T

y.f m.f⇤ /2 T ^ ¬arrayElem(x.f n)
otherwise

A special case is the new statement which creates a fresh

T s !8<:

object:
T x.f n=new...

        ! T\{x.f n.f⇤ 2 T|¬arrayElem(x.f n)}.

Assigning a fresh object erases the taints for the memory
location referred to by the left-hand side and all access paths
that could be reached through this reference.

Assignments of arithmetic operations such as x = a + b are
treated by tainting the left-hand side if any of the operands
are tainted. For now, FlowDroid uses a simple two-element
security lattice but it can easily be extended to track more
information about the kind of taint that is propagated.

Call ﬂow function. Call ﬂow functions handle ﬂows into
callees of calls such as c.m(a0, . . . , an), n 2 N0. To model
the context change from the body of the caller to the one of
the callee, FlowDroid builds taint set Tcallee based on the
caller’s set Tcaller, replacing references to actual parameters
ai by references to formal parameters pi. If a variable is
tainted in the caller’s context, FlowDroid converts it to
the callee context by replacing c with this.
{this.f m} c.f m 2 Tcaller
ai.f p 2 Tcaller
{pi.f p}
{y.f q}
x.f q 2 Tcaller ^ static(y.f q)

Tcallee

s ! [8<:

Return ﬂow function. At a return (both exceptional and
regular), the return ﬂow function maps taints from the callee’s
context back to the one of the caller. FlowDroid’s return
ﬂow functions specially treats immutable values. Such val-
ues, by their very nature, can never change their taint status.
Thus, if a parameter of an immutable type like String or int
was not tainted before the call it cannot be tainted by the
callee and is thus still guaranteed to be untainted on return.
In all other cases, the taint of all tainted access paths is
mapped back to the caller’s context. The following ﬂow func-
tion applies when the callee returns a variable r after being
called using a statement of the form b = c.m(a0, . . . , an):

Tcaller

s ! [8>><>>:

{c.f m}
this.f m 2 Tcallee
{ai.f p} pi.f p 2 Tcallee ^ ¬immut(ai)
x.f q 2 Tcallee ^ static(y.f q)
{y.f q}
{b.f v}
r.f v 2 Tcallee

Call-to-return ﬂow function. For every call there is also
intra-procedural edge propagating all taint values that are
independent of the callee.
In this function, we generate
taints at sources, through a simple pattern match against an
extensible list of method signatures. We also handle native
method calls here (for details, see Section 5). Again consider
a call b = c.m(a0, . . . , an):

T [ nativeT aint(s, T ) native(s) ^ ai.f m 2 T
T [ {x}
T

x 2 source(s)
otherwise

T s !8<:

4.2 On-demand alias analysis

During our research we experimented a lot with di↵er-
ent ways to resolve aliasing e↵ectively and e ciently. As it
turned out, using ahead-of-time analyses is usually too costly
(because the analysis computes alias information for all pro-
gram variables, not just those that carry taints) and too
imprecise (because the analysis would not support the same
level of context-sensitivity as our taint analysis). We hence
opted for a demand-driven approach by Tripp et al., which
executes within the same context-sensitive IFDS framework
as our taint analysis [27]. As Figure 3 shows, this on-demand
analysis is triggered at assignments to heap variables, i.e.,

statements of the form x.f = v. The alias analysis then walks
backward through the control-ﬂow graph. Whenever it ﬁnds
an alias, it triggers the forward analysis in turn, propagat-
ing an aliased taint from the location at which the alias
was found. Similar to the forward analysis, we deﬁne ﬂow
functions which compute the alias propagation information.
Let the set A deﬁne the alias information. The only ini-
tial element in A is the complete access path of the tainted
value which caused the alias lookup. The backward solver
terminates when A becomes empty.

source, sink and

entry-point detection

parse manifest ﬁle

generate

main method

parse .dex ﬁles

build call graph

parse layout xmls

perform taint

analysis

Normal ﬂow function. For a statement x.f = y.g the fol-
lowing rule applies:

A s ! [⇢ A\{x.f.f p} [ {y.g.f p} 8p : x.f.f p 2 A

otherwise

A

For new statements, FlowDroid erases all alias informa-
tion for the left-hand side, as fresh objects cannot be aliased:
A x.f =new...

       ! A\{8m : x.f.f⇤ 2 A}

Call ﬂow function. Since the backward analysis traverses
the control-ﬂow graph backwards, its call ﬂow function prop-
agates information from call sites to return sites in the callee.
Consider again a call b = c.m(a0, . . . , an) and a return site
returning a variable r:
b.f m 2 Acaller
{r.f m}
{this.f m} c.f m 2 Acaller
{y.f q}
y.f q 2 Acaller ^ static(y.f q)

Acallee

s ! [8<:

Return ﬂow function. In the backwards analysis, return
ﬂow functions propagate from the callee’s start point to just
before the call site. The return ﬂow function thus maps the
callee’s aliases at back to the caller while taking into account
renaming from formal parameters pi to actual parameters ai.
For a call site c.m(a0, . . . , an) we obtain:
this.f m 2 Acallee
y.f q 2 Acallee ^ static(y.f q)

{c.f m}
{ai.f p} pi.f p 2 Acallee
{y.f q}

Acaller

s ! [8<:
A s !8>><>>:

Call-to-return ﬂow function. For a call site b = c.m(a0, . . . , an),
the call-to-return ﬂow function handles aliases induced by
native calls and kills aliases of references obtained through b:

A [ nativeAlias(s) native(s)
^(ai.f m 2 A _ c.f n 2 A)
A\{b.f n}
b.f n 2 A
otherwise
A

5.

IMPLEMENTATION

FlowDroid extends the Soot framework [16] which pro-
vides important prerequisites for a precise analysis, in par-
ticular a very accurate call graph. Through a plugin called
Dexpler [5] Soot supports not only converting Java code but
also Android’s dex ﬁles into the Jimple intermediate repre-
sentation which allows us to implement our analysis for both
targets. FlowDroid further uses Heros [8] as an implemen-
tation of IFDS on top of Soot and Dexpler. We next explain
FlowDroid’s architecture, while the subsequent sections
explain interesting implementation details and FlowDroid’s
current limitations.

Figure 4: Overview of FlowDroid

Architecture. Figure 4 shows FlowDroid’s architecture.
Android applications are packaged in apk ﬁles (Android Pack-
ages), which are essentially zip-compressed archives. After
unzipping an archive, FlowDroid searches for lifecycle and
callback methods as well as calls to sources and sinks in the
application. This is done by parsing various Android-speciﬁc
ﬁles, including the layout XML ﬁles, the dex ﬁles contain-
ing the executable code and the manifest ﬁle deﬁning the
activities, services, broadcast receivers and content providers
in the application. We describe the detection of UI Inter-
actions in detail below. Next, FlowDroid generates the
main method from the list of lifecycle and callback methods
(see the Paragraphs Callbacks and Substitution Classes for
more information). This main method is then used to gener-
ate a call graph and an inter-procedural control-ﬂow graph
(ICFG). Starting at the detected sources, the taint analysis
then tracks taints by traversing the ICFG as explained in
Section 4. Native Calls require a special treatment which
is described below along with a performance optimization
called Taint Wrapping. At the end, FlowDroid reports all
discovered ﬂows from sources to sinks.

UI Interactions. UI elements can be taint sources, e.g., if
an application prompts the user for a password and then
sends it out to the Internet. FlowDroid thus scans the
layout XML ﬁles in the apk ﬁle for text inputs and links
them to the source-code statements where they are accessed.
This is non-trivial, as the Android operating system manages
access to such resources at runtime and a static analysis tool
must simulate these runtime APIs as precisely as possible.
Note that we need to over-approximate resource accesses in
the general case, though. In Android, resource mappings can
be conﬁguration-dependent, for instance to support di↵erent
layouts for smartphones and tablets. In this case, we can
only assume all cases as possible. Not all data in text ﬁelds
is sensitive, though. FlowDroid can be conﬁgured to either
consider all text ﬁelds or to restrict itself to special sensitive
ﬁelds like password input ﬁelds (the default).

Callbacks. To model the app lifecycle correctly (see Sec-
tion 3), FlowDroid contains a list of callback interfaces
extracted from the Android documentation. FlowDroid
ﬁrst computes a call graph ignoring callbacks, to determine
which activity will potentially register which kind of callback
at runtime. Next, FlowDroid generates a customized main
method for each activity, taking the respective discovered
callbacks into account.

Substitution Classes. J2EE and Android applications some-
times operate on interface types or abstract class types that
at runtime receive objects instantiated within the J2EE or

Android framework. FlowDroid’s main-method generator
cannot easily be aware of those concrete subtypes. Flow-
Droid thus allows the analysis designer to provide a list of
so-called substitution classes. A substitution class provides
a concrete implementation for one or more of these inter-
faces, simply for the purpose of the analysis. The user can
choose whether to provide a stub or a real implementation,
depending on whether the designer aims for higher precision
or scalability. For Android, substitution classes are required,
for instance, for the abstract class android.context.Context.

Native Calls. Both Java and the Android platform support
invoking native methods written in C or other unmanaged
languages. For a Java-based analysis, such methods are black
boxes which cannot be resolved. We thus deﬁned explicit
taint propagation rules for the most common native methods,
such as arraycopy in java.lang.System. In this example, third
argument (the output array) will become tainted if the ﬁrst
argument (the input array) is tainted before the call. For
native methods without an explicit rule, we assume call
arguments and the return value to become tainted if at
least one parameter was tainted before. This is neither
entirely sound nor maximally precise but is probably the
only practical approximation in a black-box setting.

Taint Wrapping. Including the full JRE or Android plat-
form runtime in the analysis requires a lot of time and mem-
ory and can lead to unwanted imprecisions. Thus, while
explicit taint-propagation rules are required for native meth-
ods, they can be useful for regular Java methods as well:
their use can prevent the taint propagation from having
to analyze the library’s internals. FlowDroid supports a
simple textual ﬁle format for deﬁning such “shortcut rules”.
Predeﬁned rules handle collection classes, string bu↵ers and
similar commonly used data structures.

Limitations. At the moment FlowDroid ignores reﬂective
calls, which is unsound. While specialized static string anal-
yses can be used to simulate reﬂection to some extent, past
research has found such analyses to be incomplete [9], as
reﬂective call targets are often determined by external conﬁg-
uration ﬁles. On the Java platform, reﬂection-analysis tools
such as TamiFlex [9] can be used to make static analysis
tools aware of reﬂective calls. Such tool require load-time
instrumentation through java.lang.instrument, however, which
the Android platform does not currently support.

As described above, native code is approximated conser-
vatively using taint wrapping. Another limitation of Flow-
Droid is its current focus on explicit data ﬂows. Implicit
ﬂows caused by control-ﬂow dependencies are currently ig-
nored, but we plan to include them in the near future. Flow-
Droid also ignores probabilistic and possibilistic leaks caused
by multi-threading [13].

6. EXPERIMANTAL EVALUATION

Our evaluation addresses the following research questions:

RQ1 How does FlowDroid compare to commercial taint-
analysis tools for Android, both in terms of precision
and recall?

RQ2 Can FlowDroid ﬁnd all privacy leaks in Insecure-
Bank, an app speciﬁcally designed by others to chal-

lenge vulnerability-detection tools for Android [21], and
what is its performance?

RQ3 Can FlowDroid ﬁnd leaks in real-world applications

and how fast is it?

RQ4 How well does FlowDroid perform when being ap-
plied to taint-analysis problems related to Java, not
Android, both in terms of precision and recall?

The next sections address each research question in detail.
Section 6.5 explains why, unfortunately, we were unable to
directly compare FlowDroid to academic Android analysis
tools published elsewhere.
6.1 RQ1: Commercial taint-analysis tools

While there are benchmark suites for analyzing web appli-
cations or speciﬁcally for detecting di↵erent kinds of Java vul-
nerabilities [17], at the moment there is no Android-speciﬁc
analysis benchmark suite. This is problematic because the
generic Java test suites do not cover aspects like the An-
droid lifecycle, callbacks or interactions with UI elements
like password ﬁelds. Thus, they cannot be used for assessing
the practical e↵ectiveness of Android analysis tools.

DroidBench. Speciﬁcally for this work, we therefore de-
veloped an Android-speciﬁc test suite called DroidBench
containing 39 small Android apps. The suite can be used
to assess both static and dynamic taint analyses, but in
particular it contains test cases for interesting static-analysis
problems (ﬁeld sensitivity, object sensitivity, tradeo↵s in
access-path lengths etc.) as well as for Android-speciﬁc
challenges like correctly modeling an application’s lifecycle,
adequately handling asynchronous callbacks and interacting
with the UI. Table 3 contains a list of all apps in the suite
together with their respective names and short descriptions.
The table also indicates whether an analysis tool must model
the Android lifecycle or callback infrastructure to be able to
successfully analyze the app. We envision our test suite to
be extended by other researchers as well and then be used
to compare the completeness and correctness of the various
taint analysis approaches. DroidBench is available from
our project website.

Table 5 presents the analysis results for FlowDroid and
two commercial analysis tools explained in the following.
As the results show, FlowDroid generally performs quite
well. As explained before, for performance reasons, Flow-
Droid handles array indices imprecisely. The same limi-
tation applies to ListAccess1, causing false positives in the
ﬁrst category. Handling indices precisely and e ciently is an
interesting open research question. Button2 causes a false
positive because FlowDroid does not currently support
strong updates. In result, it cannot kill taints for certain
button combinations. Strong updates would require a must-
alias analysis which is hard to achieve inter-procedurally.
IntentSink1 is not detected because the test case contains no
actual sink. Instead, the tainted value is stored in an intent
which is then handed back to the activity by the framework.
Such cases are hard to handle without special treatment.
StaticInitialization1 fails because Soot currently assumes
all static initializers to execute at the beginning of the pro-
gram, which in this case is not correct. We plan to add
better support in the future. As most known taint-analysis
tools, FlowDroid currently disregards implicit ﬂows caused
through control-ﬂow dependencies.

Comparison with IBM AppScan Source. We compared
FlowDroid against IBM AppScan Source [2] version 8.7, on
all tests from DroidBench. AppScan Source distinguishes
three di↵erent categories of ﬁndings: vulnerabilities, excep-
tions of type 1 and exceptions of type 2. Vulnerabilities
include a complete path from source to sink. For a type 1
exception, there is a ﬂow from source to sink as well, but
the semantics of some methods along the propagation path
is unknown (e.g. possible sanitization). Since FlowDroid
does not support sanitization at the moment, we consider
both vulnerabilities and type 1 exceptions as ﬁndings. For
type 2 exceptions on the other hand, there is no trace. These
reports are generated when certain code constructs (e.g. writ-
ing a variable value into the log ﬁle) are detected. As these
ﬁndings are highly imprecise and completely disregard data
ﬂow, we do not count them as ﬁndings. As Table 5 shows,
AppScan Source ﬁnds only about 38% of all leaks (50% if
ignoring implicit ﬂows). Major problems occur with the
handling of callbacks, the Android component lifecycle and
implicit ﬂows.

Comparison with Fortify SCA. Fortify SCA [1] by HP is
another commercial tool widely used by security analysts.
Similar to IBM AppScan Source, Fortify also provides di↵er-
ent kinds of ﬁndings, such as data ﬂows from sensitive sources
to public sinks, requests for security-sensitive permissions,
calls to security-sensitive methods, etc. In our evaluation,
we only considered ﬁndings about data ﬂows. All tests were
carried out using version 5.14. As can be seen in Table 5, For-
tify SCA shows problems similar to those of IBM AppScan
(cf. Section 6.1), like the handling of the Android component
lifecycle, the callbacks and implicit ﬂows. Figure 5 shows
that Fortify detects 4 out of 6 data leaks for the lifecycle
tests, but closer inspection shows that this only happens
by chance. In these tests, the data source involves a static
ﬁeld, which Fortify apparently treats in a special way which
coincidentally causes a leak to be reported. When removing
the static modiﬁer, which does not the semantics of the test
case, Fortify does not detect the leak any longer.

Conclusion. From our experiments we conclude that, to not
overburden the user with false positives, AppScan Source and
Fortify SCA aim for relatively high precision while sacriﬁcing
recall, thus risking to miss actual privacy leaks. In compari-
son, FlowDroid shows higher precision with a signiﬁcantly
higher recall.
6.2 RQ2: Performance on InsecureBank

InsecureBank [21] is a vulnerable Android app created
by Paladion Inc. speciﬁcally for the purpose of evaluating
analysis tools such as FlowDroid. It contains various vul-
nerabilities and data leaks similar to those found in real-world
applications. Analyzing the application takes about 31 sec-
onds on a laptop computer with an Intel Core 2 Centrino
CPU and 4 GB of physical memory running on Windows 7
with Oracle’s Java Runtime version 1.7 (64 bit) in its default
settings. FlowDroid found all seven data leaks which we
all veriﬁed by hand. There were no false positives nor false
negatives.

6.3 RQ3: Real-World Applications

The above experiments give a very good indication that
FlowDroid yields correct and precise results, not just for
small test case but also for more realistic apps such as In-
secureBank [21]. To strengthen the external validity of our
experiments, we nevertheless performed an additional qualita-
tive analysis on a random selection of popular apps from the
Google Play store. While the obtained analysis reports do
not indicate any malicious apps in this selection, the majority
of apps is reported to—probably accidentally—leak informa-
tion into logs and preference ﬁles. Samsung’s Push Service,
for instance, logs the phones IMEI. Logs are problematic,
as the OS does not impose the same access restrictions on
logs as it does on ﬁles: all logs are readable by any app that
has the READ LOGS permission. The game Hugo Runner
stores longitude and latitude into a preferences ﬁle. As we
veriﬁed by hand, though, those preferences were correctly
written in private mode, precluding any access by other apps.
This indicates that taint analyses could gain precision by
considering auxiliary information such as the write mode
mentioned above. For most examined apps FlowDroid
terminated in under a minute. The longest-running instance,
Samsung’s Push Service took about 4.5 minutes to analyze.
6.4 RQ4: SecuriBench Micro

FlowDroid was speciﬁcally designed for Android, and
in this space gains much precision through its complete and
precise handling of Android’s lifecycle. Nevertheless, there is
nothing that would preclude software developers from apply-
ing FlowDroid to Java applications as well. To assess how
well FlowDroid is set up for this use case, we evaluated
FlowDroid against Stanford SecuriBench Micro [17] version
1.08, a common set of 96 J2EE micro benchmarks originally
intended for web-based applications. For each of the bench-
marks in the suite, we manually deﬁned the necessary lists of
sources, sinks and entry points. Since FlowDroid supports
a simple textual ﬁle format for deﬁning these parameters,
and since all benchmarks cases have the same structure, this
was not much e↵ort. For the interfaces HTTPServletRequest
and HTTPServletResponse we needed to provide substitution
classes (see Section 5), as we had no access to framework
code that would provide their implementations. We omit-
ted from our experiments test cases involving sanitization,
reﬂection, predicates and multi-threading. As we explained
earlier, such features are out of scope for our analysis tool,
just as they are for all other existing Android analysis tools.
Table 4 shows our test results grouped by test categories.
The TP column shows the true positives, i.e., the number
of actual leaks that FlowDroid found. For the example of
basic, for instance, FlowDroid found 58 out of 60. The FP
column shows the number of false positives, i.e., the ﬁnding
that FlowDroid reported that did not correspond to actual
leaks, but were rather artifacts of an overly approximate
analysis. In most cases this number is reasonably low or
even zero, except for the Arrays category. This is due to an
imprecision that FlowDroid shares with most other static
analyses: for performance reasons, the tools not di↵erentiate
between multiple components inside the same collection,
e.g., di↵erent indices in arrays or di↵erent positions in lists.
Treating such cases precisely and e ciently is an interesting
open issue in the static-analysis community. The n/a entries
in the table correspond to test categories such as reﬂection,
which we identiﬁed to be out of scope.

Test-case group
Aliasing
Arrays
Basic
Collections
Datastructure
Factory
Inter
Pred
Reﬂection
Sanitizer
Session
StrongUpdates
Sum

TP
11/11
9/9
58/60
14/14
5/5
3/3
14/16
n/a
n/a
n/a
3/3
0/0

117/121

FP
0
6
0
3
0
0
0

n/a
n/a
n/a

0
0
9

Table 4: SecuriBench Micro test results

6.5 Comparison with Other Tools

We also tried to compare FlowDroid to a number of other
tools from the scientiﬁc literature, namely TrustDroid [31],
LeakMiner [30], and the tool by Batyuk et al. [6]. Unfor-
tunately none of those tools are available online, and even
worse the respective authors did not reply to our inquiries.
We tried to run DroidBench on SCanDroid [11], but
faced technical di culties. The tool did not report any
ﬁndings at all in our setup. Though being in contact with the
authors, we were unable to ﬁx these issues by the submission
deadline. The authors of AndroidLeaks [12] promised to
run their tool on DroidBench but never delivered. We
also contacted the authors of CHEX [18], but they were
unable to provide the tool or any benchmark results due to
intellectual property claimed by NEC. Starostin [19] declined
to participate in the experiment as his tool ignores aliasing,
making any comparison meaningless.

In result, we were unable to successfully evaluate even a
single scientiﬁc taint-analysis tool for Android. We believe
that the lack of such comparative experiments is hindering
scientiﬁc progress a lot, which is why we make available our
entire implementation, documentation and benchmarks as
open source.

7. RELATED WORK

There are several approaches to static analysis of Android
applications di↵ering in precision, runtime, scope and focus.
One of the most sophisticated ones is CHEX [18], a tool
to detect component hijacking vulnerabilities in Android
applications by tracking taints between externally accessible
interfaces and sensitive sources or sinks. Although not built
for the task, CHEX can, in principle, be used for taint anal-
ysis. However, since CHEX looks for vulnerabilities, target
applications are supposed to be benign. The derived assump-
tions (no obfuscation etc.) do not hold for malicious apps.
Furthermore, CHEX does not analyze calls into Android
framework itself but instead requires a (hopefully complete)
model of the framework. In FlowDroid such a model is
optional and, except for native calls, is used only to increase
performance. CHEX’s entry point model requires an enumer-
ation of all possible split orderings which is not necessary in
FlowDroid.

LeakMiner [30] appears similar to our approach from a
technical point of view:
like FlowDroid, it is based on
Soot, uses Spark for call-graph generation, it implements the

Android lifecycle, and the paper states that an app can be
analyzed in 2.5 minutes on average. However, the analysis
is not context-sensitive which is likely a major source of
imprecision. Unfortunately we were unable to perform a
systematic comparison as the authors did not respond to our
inquiries.

AndroidLeaks [12] also states the ability to handle the
Android Lifecycle including callback methods. It is based on
WALA’s context-sensitive System Dependence Graph with a
context-insensitive overlay for heap tracking, but is not as
precise as FlowDroid, because it taints the whole object if
tainted data is stored in one of its ﬁelds. As noted before,
we contacted the authors but they failed to provide us any
data for a comparative evaluation.

SCanDroid [11] is another tool for reasoning about data
ﬂows in Android applications. Its main focus is the inter-
component (e.g. between two activities in the same app)
and inter-app data ﬂow. This poses the challenge of con-
necting intent senders to their respective receivers in other
applications. SCanDroid prunes all call edges to Android
OS methods and conservatively assumes the base object,
the parameters, and the return value to inherit taints from
arguments which is much less precise than FlowDroid’s
treatment. FlowDroid, on the other hand, currently does
not resolve intent-based communication. Such a feature
would require string analysis, which we leave to future work.
Other approaches like CopperDroid [24] dynamically ob-
serve interactions between the Android components and the
underlying Linux system to reconstruct higher-level behavior.
Special stimulation techniques are used for exercising the
application to ﬁnd malicious activities. Attackers, however,
can easily modify an app to detect whether it is running
inside a virtual machine and then leak no data during that
time. Alternatively, data leaks might only occur after a cer-
tain runtime threshold. Aurasium [28] and DroidScope [29]
largely su↵er from the same shortcomings with respect to
static leak detection.

There are also approaches with a much broader focus
like [6]. This approach not only tracks data ﬂows, but also
generate a user-friendly report and sanitizes malicious apps
by replacing their sources with safe equivalents like UUID
generators. The paper gives no details on the implementation,
which is why we were unable to conduct a detailed comparison
to our approach.

The approach by Payet et al. [22] tries to aid the developer
by checking for common programming errors using di↵erent
checks, for example a nullness analysis. In contrast to Flow-
Droid, their approach cannot perform a dataﬂow analysis
and is not focused on security.

8. CONCLUSIONS

We have presented FlowDroid, a novel and highly pre-
cise static taint-analysis tool for Android applications. We
have shown that many existing approaches do not adequately
model Android-speciﬁc challenges like the application life-
cycle or callback methods, leading to either missed leaks
or false positives. For assessing the e↵ectiveness of analysis
tools, we have proposed the Android-speciﬁc benchmark suite
DroidBench and used it for comparing FlowDroid to the
commercial tools AppScan Source and Fortify SCA, showing
that besides ﬁnding more real leaks, FlowDroid also has
a higher precision resulting in less false positives. We hope

that in the future DroidBench will serve as a standard test
set for Android taint analyses.

Acknowledgements.

We would like to thank Stephan Huber from Fraunhofer
SIT for supporting us with real-world applications from the
Google Play market and Dr. Karsten Sohr from TZi Bremen
for supporting us with the Fortify SCA evaluation. This
work was supported by a Google Faculty Research Award,
by the BMBF within EC SPRIDE, by the Hessian LOEWE
excellence initiative within CASED, and by the DFG within
the project RUNSECURE.

9. REFERENCES
[1] Fortify 360 Source Code Analyzer (SCA), April 2013.

http://www8.hp.com/us/en/software-solutions/
software.html?compURI=1214365#.UW6CVKuAtfQ.

[2] Ibm rational appscan, April 2013. http:

//www-01.ibm.com/software/de/rational/appscan/.

[3] Android. Android security overview, December 2012.

http://source.android.com/tech/security/.

[4] Alexandre Bartel, Jacques Klein, Yves Le Traon, and

Martin Monperrus. Automatically securing
permission-based software by reducing the attack
surface: an application to android. In Proceedings of
the 27th IEEE/ACM International Conference on
Automated Software Engineering, ASE 2012, pages
274–277, New York, NY, USA, 2012. ACM.

[5] Alexandre Bartel, Jacques Klein, Yves Le Traon, and

Martin Monperrus. Dexpler: converting android dalvik
bytecode to jimple for static analysis with soot. In
Proceedings of the ACM SIGPLAN International
Workshop on State of the Art in Java Program analysis,
SOAP ’12, pages 27–38, New York, NY, USA, 2012.
ACM.

[6] L. Batyuk, M. Herpich, S.A. Camtepe, K. Raddatz,

A.-D. Schmidt, and S. Albayrak. Using static analysis
for automatic assessment and mitigation of unwanted
and malicious activities within android applications. In
Malicious and Unwanted Software (MALWARE), 2011
6th International Conference on, pages 66–72, 2011.

[7] Bit9. Pausing google play: More than 100,000 android

apps may pose security risks, November 2012.
http://www.bit9.com/pausing-google-play/.

[8] Eric Bodden. Inter-procedural data-ﬂow analysis with

ifds/ide and soot. In Proceedings of the ACM
SIGPLAN International Workshop on State of the Art
in Java Program analysis, SOAP ’12, pages 3–8, New
York, NY, USA, 2012. ACM.

[9] Eric Bodden, Andreas Sewe, Jan Sinschek, Hela

Oueslati, and Mira Mezini. Taming reﬂection: Aiding
static analysis in the presence of reﬂection and custom
class loaders. In ICSE ’11: International Conference on
Software Engineering, pages 241–250. ACM, May 2011.

[10] International Data Corporation. Worldwide quarterly

mobile phone tracker 3q12, November 2012.
http://www.idc.com/tracker/showproductinfo.
jsp?prod_id=37.

[11] Adam P. Fuchs, Avik Chaudhuri, and Je↵rey S. Foster.
Scandroid: Automated security certiﬁcation of android
applications.

[12] Clint Gibler, Jonathan Crussell, Jeremy Erickson, and

Hao Chen. Androidleaks: automatically detecting
potential privacy leaks in android applications on a
large scale. In Proceedings of the 5th international
conference on Trust and Trustworthy Computing,
TRUST’12, pages 291–307. Springer, 2012.

[13] Dennis Gi↵horn and Gregor Snelting. Probabilistic

noninterference based on program dependence graphs.
Technical Report 06/2012, KIT, Faculty of Informatics,
June 2012. revised 2013, submitted for publication.

[14] Google Inc. Permissions, December 2012.

http://developer.android.com/guide/topics/
security/permissions.html.

[15] Google Inc. Android and security, November 2012.

http://googlemobile.blogspot.de/2012/02/
android-and-security.html.

[16] Patrick Lam, Eric Bodden, Ondrej Lhotak, and Laurie

Hendren. The soot framework for java program
analysis: a retrospective. In Cetus Users and Compiler
Infastructure Workshop (CETUS 2011), Oktober 2011.

[17] Ben Livshits. Securibench micro, March 2013.
http://suif.stanford.edu/~livshits/work/
securibench-micro/.

[18] Long Lu, Zhichun Li, Zhenyu Wu, Wenke Lee, and

Guofei Jiang. Chex: statically vetting android apps for
component hijacking vulnerabilities. In Proceedings of
the 2012 ACM conference on Computer and
communications security, CCS ’12, pages 229–240, New
York, NY, USA, 2012. ACM.

[19] Christopher Mann and Artem Starostin. A framework

for static detection of privacy leaks in android
applications. In Proceedings of the 27th Annual ACM
Symposium on Applied Computing, SAC ’12, pages
1457–1462, New York, NY, USA, 2012. ACM.

[20] Mohammad Nauman, Sohail Khan, and Xinwen Zhang.

Apex: extending android permission model and
enforcement with user-deﬁned runtime constraints. In
ASIACCS ’10, pages 328–332, New York, NY, USA,
2010. ACM.

[21] Paladion. Insecurebank test app.

http://www.paladion.net/downloadapp.html.

[22] ´Etienne Payet and Fausto Spoto. Static analysis of

android programs. In Proceedings of the 23rd
international conference on Automated deduction,
CADE’11, pages 439–445, Berlin, Heidelberg, 2011.
Springer-Verlag.

[23] Nicholas J Percoco and Sean Schulte. Adventures in

bouncerland. Blackhat USA, 2012.

[24] Alessandro Reina, Aristide Fattori, and Lorenzo

Cavallaro. A system call-centric analysis and
stimulation technique to automatically reconstruct
android malware behaviors. In EUROSEC, Prague,
Czech Republic, April 2013.

[25] Thomas Reps, Susan Horwitz, and Mooly Sagiv.

Precise interprocedural dataﬂow analysis via graph
reachability. In POPL ’95, pages 49–61, 1995.

[26] Yannis Smaragdakis, Martin Bravenboer, and Ondrej

Lhot´ak. Pick your contexts well: understanding
object-sensitivity. In Proceedings of the 38th annual
ACM SIGPLAN-SIGACT symposium on Principles of
programming languages, POPL ’11, pages 17–30, New
York, NY, USA, 2011. ACM.

[27] Omer Tripp, Marco Pistoia, Patrick Cousot, Radhia

World Congress on, pages 101–104, 2012.

Cousot, and Salvatore Guarnieri. Andromeda:
Accurate and scalable security analysis of web
applications. In Proceedings of the 16th international
conference on Fundamental Approaches to Software
Engineering, FASE’13, pages 210–225, 2013.

[28] Rubin Xu, Hassen Sa¨ıdi, and Ross Anderson. Aurasium:

practical policy enforcement for android applications.
In USENIX Security 2012, Security’12, pages 27–27,
Berkeley, CA, USA, 2012. USENIX Association.

[29] Lok Kwong Yan and Heng Yin. Droidscope: seamlessly

reconstructing the os and dalvik semantic views for
dynamic android malware analysis. In USENIX
Security 2012, Security’12, pages 29–29, Berkeley, CA,
USA, 2012. USENIX Association.

[30] Zhemin Yang and Min Yang. Leakminer: Detect
information leakage on android with static taint
analysis. In Software Engineering (WCSE), 2012 Third

[31] Zhibo Zhao and F.C.C. Osono. Trustdroid: Preventing

the use of smartphones for information leaking in
corporate networks through the used of static analysis
taint tracking. In Malicious and Unwanted Software
(MALWARE), 2012 7th International Conference on,
pages 135–143, 2012.

[32] Yajin Zhou and Xuxian Jiang. Dissecting android

malware: Characterization and evolution. In
Proceedings of the 2012 IEEE Symposium on Security
and Privacy, SP ’12, pages 95–109, Washington, DC,
USA, 2012. IEEE Computer Society.

[33] Yajin Zhou, Xinwen Zhang, Xuxian Jiang, and
Vincent W. Freeh. Taming information-stealing
smartphone applications (on android). In Proc. of the
4th international conference on Trust and trustworthy
computing, TRUST’11, pages 93–107. Springer, 2011.

App Name

Description

Leak Lifecycle Callbacks

ArrayAccess1

ArrayAccess2

ListAccess1

AnonymousClass1

Button1

Button2
LocationLeak1

LocationLeak2

MethodOverride1

FieldSensitivity1

FieldSensitivity2

FieldSensitivity3

FieldSensitivity4
InheritedObjects1

ObjectSensitivity1

ObjectSensitivity2

IntentSink1
IntentSink2

ActivityCommunication1

Arrays and Lists

Stores both a tainted and an untainted value in an array and
then leaks the untainted one. Array indices are constants.
Stores both a tainted and an untainted value in an array and
then leaks the untainted one. Array indices are calculated.
Both a tainted and an untainted value are stored in a list. Only
the untainted value is leaked.

Callbacks

Registers a callback handler for location updates in an anony-
mous inner class and leaks the incoming location data inside
the callback.
The sink is called after the user clicks a button. The button
handler is deﬁned via XML.
Only clicking buttons in a speciﬁc order leads to a data leak.
Registers a listener for location updates, stores the value and
leaks it later in the lifecycle.
Similar to LocationLeak1, but the activity class directly imple-
ments the callback interface.
Overwrites an internal Android method to hide a leak.

Field and Object Sensitivity

Both tainted and untainted data is stored in a data object; the
untainted value is leaked.
Similar to FieldSensitivity1, but source and sink calls are dis-
tributed across the lifecycle.
Both tainted and untainted data is stored in a data object; the
tainted value is leaked. Source and sink calls are distributed
across the lifecycle.
Field contents are sent before tainting the ﬁeld.
Chooses an object’s actual type based on a conditional. Only
one possible type leads to a leak.
Writes a tainted value into an object and an untainted one into
another object of the same type. Leaks the untainted value.
Writes a tainted value into a ﬁeld and then overwrites it with
untainted data.

Inter-App Communication

A tainted value is leaked to another application using an intent.
Similar to IntentSink, but the value is sent out in a callback
method deﬁned in XML.
Contains two activities that communicate using static ﬁelds.

Lifecycle

BroadcastReceiverLifecycle1 Calls to sources and sinks distributed across a broadcast receiver

ActivityLifecycle1
ActivityLifecycle2

ActivityLifecycle3

ActivityLifecycle4

ServiceLifecycle1

Loop1
Loop2

SourceCodeSpeciﬁc1
StaticInitialization1
UnreachableCode

PrivateDataLeak1
PrivateDataLeak2
DirectLeak1

InactiveActivity
LogNoLeak

lifecycle.
Calls to sources and sinks distributed across an activity lifecycle.
Activity class inherited from a superclass containing the lifecycle
method which leaks the tainted value.
Calls to sources and sinks distributed across instance state
handling methods.
A tainted value is obtained on onPause() and leaked when the
activity is restarted later.
Calls to sources and sinks distributed across a service lifecycle.

General Java
Contains a simple loop and a data leak.
Retrieves location information through a callback and leaks it
via nested loops.
Uses unusual code construct a = p ? b : c.
Passes a tainted value into a static initialization method.
Passes tainted data into a method that is never called.

Miscellaneous Android-Speciﬁc

Summary test case containing various challenges.
Leaks a value from a password ﬁeld.
The device id is read out and sent via SMS on the activity’s
onCreate() event.
Data leak in a disabled activity.
Writes untainted data into a log ﬁle.

Implicit Flows

ImplicitFlow1-4

Test case for implicit ﬂows.

Table 3: DroidBench 1.0 test cases

? = correct warning, ? = false warning,

= missed leak

multiple circles in one row: multiple leaks expected

all-empty row: no leaks expected, none reported

AppScan Source Fortify SCA FlowDroid
Arrays and Lists

Callbacks

?
?

?

?

?
?

?
?
?

?

Field and Object Sensitivity

?
?
?

?

?

?

Inter-App Communication

?
?
?

?
?

?
?
?

Lifecycle

General Java

?
?
?

?
?
?

?

?
?
?

Miscellaneous Android-Speciﬁc

?
?
?

?
?
?

Implicit Flows

App Name

ArrayAccess1
ArrayAccess2
ListAccess1

AnonymousClass1
Button1
Button2
LocationLeak1
LocationLeak2
MethodOverride1

FieldSensitivity1
FieldSensitivity2
FieldSensitivity3
FieldSensitivity4
InheritedObjects1
ObjectSensitivity1
ObjectSensitivity2

IntentSink1
IntentSink2
ActivityCommunication1

BroadcastReceiverLifecycle1
ActivityLifecycle1
ActivityLifecycle2
ActivityLifecycle3
ActivityLifecycle4
ServiceLifecycle1

Loop1
Loop2
SourceCodeSpeciﬁc1
StaticInitialization1
UnreachableCode

PrivateDataLeak1
PrivateDataLeak2
DirectLeak1
InactiveActivity
LogNoLeak

ImplicitFlow1
ImplicitFlow2
ImplicitFlow3
ImplicitFlow4

? ?

?
?
?

?
?
?

?
?
?
?
?
?

?

?

?
?

?
?
?
?
?
?

?
?
?

?
?
?

? , higher is better
? , lower is better
, lower is better

Sum, Precision and Recall — including implicit ﬂows
26
4
10
86%
72%
0.78

14
5
22
74%
39%
0.51

17
4
19
81%
47%
0.60

Precision p = ? /( ? + ?)
Recall r = ? /( ? + )
F-measure 2pr/(p + r)

? , higher is better
? , lower is better
, lower is better

Sum, Precision and Recall — excluding implicit ﬂows
26
4
2
86%
93%
0.89

14
5
14
74%
50%
0.60

17
4
11
81%
61%
0.70

Precision p = ? /( ? + ?)
Recall r = ? /( ? + )
F-measure 2pr/(p + r)

Table 5: DroidBench test results

