Calculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

Calculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36

an approach that combines hardware-based energy measurements
with program analysis and statistical modeling techniques. At a
high-level, the basic intuition is as follows: While measuring the
energy consumption of a smartphone, the approach uses efﬁcient
path proﬁling to identify which parts of the application are exe-
cuting and correlates these paths with the measured energy. Then,
the approach statically analyzes the paths to identify and adjust for
high-energy events, such as thread switching, before applying ro-
bust regression analysis to calculate each source line’s energy con-
sumption. Finally, the approach presents developers with a graph-
ical representation of the energy consumption by overlaying the
calculated energy with the source code of the application.

We also performed an empirical evaluation of our approach to
measure its accuracy and the time needed to perform the analysis.
Our approach was able to accurately calculate energy. For a set of
API invocations, we found that the calculated energy values were
within 10% of the ground truth measurements. The statistical mod-
els also matched the measured data very closely with a high R2
average of 0.93 and a low accumulated error rate. Importantly, in
our experiments, the approach was also able to detect the inﬂuence
of high-energy events, such as thread switching and garbage col-
lection, with 100% accuracy. The approach was also fast, it could
calculate source line level energy measurements for each of our
subject applications in less than three minutes. Overall, the results
of the evaluation were positive and indicate that our approach is an
effective and practical way to provide developers with source line
level energy information.

The remainder of this paper is organized as follows: In Section 2
we discuss several of the signiﬁcant challenges that shaped the de-
sign of our approach. We present the approach itself in Section 3.
The evaluation of the approach is described in Section 4. Finally,
we discuss related work and conclude in Sections 5 and 6.

2. BACKGROUND AND MOTIVATION

In this section we discuss several challenges to measuring and
calculating source line energy consumption. We break the chal-
lenges into three broad categories, hardware, runtime system, and
software level, and explain how they preclude a straightforward
solution for calculating source level energy consumption. To il-
lustrate these challenges, we make use of the code shown as Pro-
grams 1 and 2, which are excerpts from the open-source Google
Authenticator project that handles synchronizing a system clock.
In the example, method getNetworkTime (Program 1, line 1)
retrieves the time by sending an HTTP request to a timeserver
(line 7) and then parsing the response packet (lines 16, 20, 23,
26). Method runBackgroundSync (Program 2, line 2) calls the
getNetworkTime (line 6) and then starts a background thread
to handle errors (line 10).
2.1 Hardware Limitations

The primary hardware obstacle to directly measuring the energy
consumption of source lines is the difference in the speed at which
instructions execute and hardware devices can perform energy mea-
surements. On modern processors, individual instructions will ex-
ecute at a rate of several million per second. At best, power me-
ters can sample electrical power draw at several tens of KHz [16],
which means that each sample will include the power consumption
of hundreds, perhaps thousands, of instructions. For example, it
is possible for Program 2 to execute completely in the time that
transpires between two consecutive power samples by a relatively
fast power meter. There are reasons to believe that this order of
magnitude disparity will likely persist, since the bottleneck in high-
frequency power sampling is the storage system, which cannot save

p u b l i c long getNetworkTime ( )

throws

I O E x c e p t i o n {

HttpHead r e q u e s t = new HttpHead (URL ) ;
Log . i (LOG_TAG, "Sending request to "

+ r e q u e s t . getURI ( ) ) ;
H t t p R e s p o n s e h t t p R e s p o n s e ;
t r y {

h t t p R e s p o n s e = m H t t p C l i e n t . e x e c u t e ( r e q u e s t ) ;

} catch ( C l i e n t P r o t o c o l E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( S t r i n g . v a l u e O f ( e ) ) ;

} catch ( I O E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( "Failed due " +

"to connectivity issues: " + e ) ;

}

t r y {

Header d a t e H e a d e r =

h t t p R e s p o n s e . g e t L a s t H e a d e r ( "Date" ) ;

Log . i (LOG_TAG, "Received response with "

+"Date header: " + d a t e H e a d e r ) ;

i f

( d a t e H e a d e r == n u l l ) {

throw new I O E x c e p t i o n ( "No Date header" ) ;

}
S t r i n g d a t e H e a d e r V a l u e =

t ry {

Date networkDate =

d a t e H e a d e r . g e t V a l u e ( ) ;

D a t e U t i l s . p a r s e D a t e ( d a t e H e a d e r V a l u e ) ;

return networkDate . getTime ( ) ;

} catch ( D a t e P a r s e E x c e p t i o n e ) {

throw new I O E x c e p t i o n (

"Invalid Date header format " ) ;

}

} f i n a l l y {

. . . . . .

}

}

Program 1: Google Authenticator Method 1

power samples at the same frequency as the power meter can gen-
erate them [14, 15, 20], and there is no evidence to show that this
gap will be closed in the near future. Therefore, a challenge for our
approach is to reconcile power measurements samples and instruc-
tion execution, even though there is a several orders of magnitude
difference in their frequency.
2.2 Runtime System Challenges

The runtime system of an Android smartphone includes both the
Android operating system and the Dalvik Virtual Machine, the plat-
form on which marketplace apps are run. The runtime system im-
plements several types of behaviors that affect energy consumption
of an app, thread switching, garbage collection, and tail energy.
However, the details of the duration, frequency, and timing of these
events is, by design, hidden from the app. This makes it difﬁcult
to correctly attribute energy at the source level. Although it would
be straightforward to modify the runtime systems to track these
events, this would introduce considerable overhead and reduce the
portability of the approach, as it would be necessary to provide
custom runtime systems for each smartphone platform. Therefore,
one challenge for our approach is to account for these events with
information that is available at the app layer.

Thread switching causes several problems for calculating source
line level energy. The ﬁrst problem is that any energy measure-
ments for a given time period may also include energy for threads
that are not related to the application (i.e.,, operating system pro-
cesses). For example, at any point in the execution of the thread
in runBackgroundSync or getNetworkTime, the OS could
swap in a thread from another app or the OS. Any power samples
during this time would likely include instructions from both the
original and swapped-in thread. The second problem is that thread

Calculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36

an approach that combines hardware-based energy measurements
with program analysis and statistical modeling techniques. At a
high-level, the basic intuition is as follows: While measuring the
energy consumption of a smartphone, the approach uses efﬁcient
path proﬁling to identify which parts of the application are exe-
cuting and correlates these paths with the measured energy. Then,
the approach statically analyzes the paths to identify and adjust for
high-energy events, such as thread switching, before applying ro-
bust regression analysis to calculate each source line’s energy con-
sumption. Finally, the approach presents developers with a graph-
ical representation of the energy consumption by overlaying the
calculated energy with the source code of the application.

We also performed an empirical evaluation of our approach to
measure its accuracy and the time needed to perform the analysis.
Our approach was able to accurately calculate energy. For a set of
API invocations, we found that the calculated energy values were
within 10% of the ground truth measurements. The statistical mod-
els also matched the measured data very closely with a high R2
average of 0.93 and a low accumulated error rate. Importantly, in
our experiments, the approach was also able to detect the inﬂuence
of high-energy events, such as thread switching and garbage col-
lection, with 100% accuracy. The approach was also fast, it could
calculate source line level energy measurements for each of our
subject applications in less than three minutes. Overall, the results
of the evaluation were positive and indicate that our approach is an
effective and practical way to provide developers with source line
level energy information.

The remainder of this paper is organized as follows: In Section 2
we discuss several of the signiﬁcant challenges that shaped the de-
sign of our approach. We present the approach itself in Section 3.
The evaluation of the approach is described in Section 4. Finally,
we discuss related work and conclude in Sections 5 and 6.

2. BACKGROUND AND MOTIVATION

In this section we discuss several challenges to measuring and
calculating source line energy consumption. We break the chal-
lenges into three broad categories, hardware, runtime system, and
software level, and explain how they preclude a straightforward
solution for calculating source level energy consumption. To il-
lustrate these challenges, we make use of the code shown as Pro-
grams 1 and 2, which are excerpts from the open-source Google
Authenticator project that handles synchronizing a system clock.
In the example, method getNetworkTime (Program 1, line 1)
retrieves the time by sending an HTTP request to a timeserver
(line 7) and then parsing the response packet (lines 16, 20, 23,
26). Method runBackgroundSync (Program 2, line 2) calls the
getNetworkTime (line 6) and then starts a background thread
to handle errors (line 10).
2.1 Hardware Limitations

The primary hardware obstacle to directly measuring the energy
consumption of source lines is the difference in the speed at which
instructions execute and hardware devices can perform energy mea-
surements. On modern processors, individual instructions will ex-
ecute at a rate of several million per second. At best, power me-
ters can sample electrical power draw at several tens of KHz [16],
which means that each sample will include the power consumption
of hundreds, perhaps thousands, of instructions. For example, it
is possible for Program 2 to execute completely in the time that
transpires between two consecutive power samples by a relatively
fast power meter. There are reasons to believe that this order of
magnitude disparity will likely persist, since the bottleneck in high-
frequency power sampling is the storage system, which cannot save

p u b l i c long getNetworkTime ( )

throws

I O E x c e p t i o n {

HttpHead r e q u e s t = new HttpHead (URL ) ;
Log . i (LOG_TAG, "Sending request to "

+ r e q u e s t . getURI ( ) ) ;
H t t p R e s p o n s e h t t p R e s p o n s e ;
t r y {

h t t p R e s p o n s e = m H t t p C l i e n t . e x e c u t e ( r e q u e s t ) ;

} catch ( C l i e n t P r o t o c o l E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( S t r i n g . v a l u e O f ( e ) ) ;

} catch ( I O E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( "Failed due " +

"to connectivity issues: " + e ) ;

}

t r y {

Header d a t e H e a d e r =

h t t p R e s p o n s e . g e t L a s t H e a d e r ( "Date" ) ;

Log . i (LOG_TAG, "Received response with "

+"Date header: " + d a t e H e a d e r ) ;

i f

( d a t e H e a d e r == n u l l ) {

throw new I O E x c e p t i o n ( "No Date header" ) ;

}
S t r i n g d a t e H e a d e r V a l u e =

t ry {

Date networkDate =

d a t e H e a d e r . g e t V a l u e ( ) ;

D a t e U t i l s . p a r s e D a t e ( d a t e H e a d e r V a l u e ) ;

return networkDate . getTime ( ) ;

} catch ( D a t e P a r s e E x c e p t i o n e ) {

throw new I O E x c e p t i o n (

"Invalid Date header format " ) ;

}

} f i n a l l y {

. . . . . .

}

}

Program 1: Google Authenticator Method 1

power samples at the same frequency as the power meter can gen-
erate them [14, 15, 20], and there is no evidence to show that this
gap will be closed in the near future. Therefore, a challenge for our
approach is to reconcile power measurements samples and instruc-
tion execution, even though there is a several orders of magnitude
difference in their frequency.
2.2 Runtime System Challenges

The runtime system of an Android smartphone includes both the
Android operating system and the Dalvik Virtual Machine, the plat-
form on which marketplace apps are run. The runtime system im-
plements several types of behaviors that affect energy consumption
of an app, thread switching, garbage collection, and tail energy.
However, the details of the duration, frequency, and timing of these
events is, by design, hidden from the app. This makes it difﬁcult
to correctly attribute energy at the source level. Although it would
be straightforward to modify the runtime systems to track these
events, this would introduce considerable overhead and reduce the
portability of the approach, as it would be necessary to provide
custom runtime systems for each smartphone platform. Therefore,
one challenge for our approach is to account for these events with
information that is available at the app layer.

Thread switching causes several problems for calculating source
line level energy. The ﬁrst problem is that any energy measure-
ments for a given time period may also include energy for threads
that are not related to the application (i.e.,, operating system pro-
cesses). For example, at any point in the execution of the thread
in runBackgroundSync or getNetworkTime, the OS could
swap in a thread from another app or the OS. Any power samples
during this time would likely include instructions from both the
original and swapped-in thread. The second problem is that thread

p r i v a t e void

runBackgroundSync ( E x e c u t o r
long n e t w o r k T i m e M i l l i s ;
t r y {

n e t w o r k T i m e M i l l i s =

c a l l b a c k E x e c u t o r ) {

mNetworkTimeProvider . getNetworkTime ( ) ;

} catch ( I O E x c e p t i o n e ) {

Log .w(LOG_TAG, "Failed to obtain network " +
"time due to connectivity issues" ) ;

c a l l b a c k E x e c u t o r . e x e c u t e ( new Runnable ( ) {

@Override
p u b l i c void run ( ) {

f i n i s h ( R e s u l t . ERROR_CONNECTIVITY_ISSUE ) ;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

}
} ) ;
return ;

}

Program 2: Google Authenticator Method 2

switching itself introduces an energy overhead. For example, Line
10 of Program 2 will incur a signiﬁcant energy overhead for the
context switch that occurs when a new thread is started.

Periodically, the Android operating system will perform garbage
collection during the execution of an application. Typically, ap-
plications do not have control over garbage collection, it is man-
aged by the operating system and can occur anytime and within
any method. Although the Dalvik virtual machine logs garbage
collection, it timestamps the events via a millisecond based clock,
which does not provide enough precision to determine in which
path they occur (paths are tracked with nanosecond timestamps.)
As we note in Section 3.2.2, garbage collection incurs a signiﬁ-
cant energy cost and has the potential to signiﬁcantly distort en-
ergy measurements for an application. For example, consider if
garbage collection were to occur at line 20 of Program 1, which is
compiled as a simple jump on equality (ifeq), or line 6 of Pro-
gram 2, which is a relatively expensive method invocation. The
extremely high cost of the garbage collection would dwarf the cost
of both instructions making them appear to have a nearly identical
high energy cost. Therefore, an approach must be able to identify
and properly account for garbage collection while calculating the
source line level energy consumption of an application.

Smartphones exhibit tail energy usage, where certain hardware
components are optimistically kept active by the operating system,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. Tail energy manifests itself in two differ-
ent ways. The ﬁrst way is when an invocation to an API accesses a
hardware component and then returns. Even when no other invoca-
tions access the component, the component will remain active for
a time period Ttail and consume energy Etail. An example of this
kind of invocation is at line 7 of Program 1. The call to the network
will cause the radio to remain on for a period of time, even after
the request is ﬁnished, and consume energy during this time. The
second way is when two invocations access the component in se-
quence and the time interval between them is less than Ttail. Here,
only a portion of Etail will be consumed. The Etail for certain de-
vices can be quite high and a naive approach to measurement might
attribute the tail energy cost to subsequently executed instructions.
Referring back to the example invocation, the naive approach could
mistakenly attribute part of the invocation’s tail energy to its suc-
cessors, lines 16, 18, and 20, (depending on the length of its Ttail)
instead of to line 7. To be accurate, an approach must recognize
when tail energy occurs and attribute it to the source invocations
that started the component and kept it at a non-idle state.

2.3 Software-Level Challenges

Source level calculations require precise information about an
app’s execution. In particular, for each time period represented by
a power sample, it is necessary to know which instructions were
executed, their frequency, and their ordering — essentially, path
information. The primary challenge is that obtaining this type of
information at the software level is generally expensive and intru-
sive. For example, inserting instrumentation into an app to iso-
late and measure individual instructions can lead to high overhead.
Even optimizations, such as only instrumenting each basic block,
would still produce a high amount of instrumentation. Other ap-
proaches, such as instruction counting, do not allow developers to
know which instances of the instructions were executed.

It is also necessary to have precise information about API invoca-
tions. During execution, smartphone applications generally invoke
library functions and APIs to access hardware components, such
as GPS, network, and WiFi. For example, at line 7 of Program 1,
getNetworkTime() sends an HTTP request to Google by in-
voking HttpClient.execute(). This invocation consumes
a relatively large amount of energy due to its use of the network.
In contrast, a call to dataheader.getValue at line 24 of Pro-
gram 1, incurs a relatively small constant cost, since it is simply
returning the value of an HTTP header. This wide range of invo-
cation behavior causes problems for techniques that naively apply
statistical sampling or averaging-based approaches because, unlike
normal instructions, an invocation’s energy cost can vary based on
its target and the data provided for its arguments. Furthermore, it is
not feasible to precompute the cost of API calls, since that requires
sampling every point in each API calls input space to determine its
energy consumption.
3. APPROACH

The goal of our approach is to provide source line level energy
information for smartphone applications. An overview of our ap-
proach is shown in Figure 1. From a high-level, our approach has
two phases, Runtime Measurement and Ofﬂine Analysis. The in-
puts to the Runtime Measurement phase are the application under
analysis (AUA) and a set of use cases for which the tester wants
to obtain energy measurements. The App Instrumenter uses an
efﬁcient path proﬁling technique to guide the insertion of probes
into the AUA that will capture timestamps and path traversal infor-
mation. The tester executes the instrumented AUA on the Power
Measurement Platform. This causes the instrumentation to record
path information while the Power Measurement Platform records
power samples. The path and power samples are the inputs for the
Ofﬂine Analysis phase. The Path Adjuster performs a static anal-
ysis of the paths and makes modiﬁcations to the power samples to
account for the high-energy events. Then the Analyzer performs
the regression analysis in order to calculate each source line’s en-
ergy consumption. If the Analyzer ﬁnds there are not enough data
points to solve the regression analysis, then the process returns to
the Runtime Measurement phase so the developer can further exe-
cute the application. If this is not possible, then the Analyzer per-
forms approximations that we discuss in Section 3.2.2. Finally, the
Annotator uses the calculations to create graphical overlays of the
measurements on the source code for display in an integrated de-
velopment environment. We explain the approach in more detail in
the remainder of this section.
3.1 Runtime Measurement Phase

During the Runtime Measurement phase, information about the
paths executed in the AUA and power measurements are generated
by the approach. To do this, the App Instrumenter inserts probes

Calculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36

an approach that combines hardware-based energy measurements
with program analysis and statistical modeling techniques. At a
high-level, the basic intuition is as follows: While measuring the
energy consumption of a smartphone, the approach uses efﬁcient
path proﬁling to identify which parts of the application are exe-
cuting and correlates these paths with the measured energy. Then,
the approach statically analyzes the paths to identify and adjust for
high-energy events, such as thread switching, before applying ro-
bust regression analysis to calculate each source line’s energy con-
sumption. Finally, the approach presents developers with a graph-
ical representation of the energy consumption by overlaying the
calculated energy with the source code of the application.

We also performed an empirical evaluation of our approach to
measure its accuracy and the time needed to perform the analysis.
Our approach was able to accurately calculate energy. For a set of
API invocations, we found that the calculated energy values were
within 10% of the ground truth measurements. The statistical mod-
els also matched the measured data very closely with a high R2
average of 0.93 and a low accumulated error rate. Importantly, in
our experiments, the approach was also able to detect the inﬂuence
of high-energy events, such as thread switching and garbage col-
lection, with 100% accuracy. The approach was also fast, it could
calculate source line level energy measurements for each of our
subject applications in less than three minutes. Overall, the results
of the evaluation were positive and indicate that our approach is an
effective and practical way to provide developers with source line
level energy information.

The remainder of this paper is organized as follows: In Section 2
we discuss several of the signiﬁcant challenges that shaped the de-
sign of our approach. We present the approach itself in Section 3.
The evaluation of the approach is described in Section 4. Finally,
we discuss related work and conclude in Sections 5 and 6.

2. BACKGROUND AND MOTIVATION

In this section we discuss several challenges to measuring and
calculating source line energy consumption. We break the chal-
lenges into three broad categories, hardware, runtime system, and
software level, and explain how they preclude a straightforward
solution for calculating source level energy consumption. To il-
lustrate these challenges, we make use of the code shown as Pro-
grams 1 and 2, which are excerpts from the open-source Google
Authenticator project that handles synchronizing a system clock.
In the example, method getNetworkTime (Program 1, line 1)
retrieves the time by sending an HTTP request to a timeserver
(line 7) and then parsing the response packet (lines 16, 20, 23,
26). Method runBackgroundSync (Program 2, line 2) calls the
getNetworkTime (line 6) and then starts a background thread
to handle errors (line 10).
2.1 Hardware Limitations

The primary hardware obstacle to directly measuring the energy
consumption of source lines is the difference in the speed at which
instructions execute and hardware devices can perform energy mea-
surements. On modern processors, individual instructions will ex-
ecute at a rate of several million per second. At best, power me-
ters can sample electrical power draw at several tens of KHz [16],
which means that each sample will include the power consumption
of hundreds, perhaps thousands, of instructions. For example, it
is possible for Program 2 to execute completely in the time that
transpires between two consecutive power samples by a relatively
fast power meter. There are reasons to believe that this order of
magnitude disparity will likely persist, since the bottleneck in high-
frequency power sampling is the storage system, which cannot save

p u b l i c long getNetworkTime ( )

throws

I O E x c e p t i o n {

HttpHead r e q u e s t = new HttpHead (URL ) ;
Log . i (LOG_TAG, "Sending request to "

+ r e q u e s t . getURI ( ) ) ;
H t t p R e s p o n s e h t t p R e s p o n s e ;
t r y {

h t t p R e s p o n s e = m H t t p C l i e n t . e x e c u t e ( r e q u e s t ) ;

} catch ( C l i e n t P r o t o c o l E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( S t r i n g . v a l u e O f ( e ) ) ;

} catch ( I O E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( "Failed due " +

"to connectivity issues: " + e ) ;

}

t r y {

Header d a t e H e a d e r =

h t t p R e s p o n s e . g e t L a s t H e a d e r ( "Date" ) ;

Log . i (LOG_TAG, "Received response with "

+"Date header: " + d a t e H e a d e r ) ;

i f

( d a t e H e a d e r == n u l l ) {

throw new I O E x c e p t i o n ( "No Date header" ) ;

}
S t r i n g d a t e H e a d e r V a l u e =

t ry {

Date networkDate =

d a t e H e a d e r . g e t V a l u e ( ) ;

D a t e U t i l s . p a r s e D a t e ( d a t e H e a d e r V a l u e ) ;

return networkDate . getTime ( ) ;

} catch ( D a t e P a r s e E x c e p t i o n e ) {

throw new I O E x c e p t i o n (

"Invalid Date header format " ) ;

}

} f i n a l l y {

. . . . . .

}

}

Program 1: Google Authenticator Method 1

power samples at the same frequency as the power meter can gen-
erate them [14, 15, 20], and there is no evidence to show that this
gap will be closed in the near future. Therefore, a challenge for our
approach is to reconcile power measurements samples and instruc-
tion execution, even though there is a several orders of magnitude
difference in their frequency.
2.2 Runtime System Challenges

The runtime system of an Android smartphone includes both the
Android operating system and the Dalvik Virtual Machine, the plat-
form on which marketplace apps are run. The runtime system im-
plements several types of behaviors that affect energy consumption
of an app, thread switching, garbage collection, and tail energy.
However, the details of the duration, frequency, and timing of these
events is, by design, hidden from the app. This makes it difﬁcult
to correctly attribute energy at the source level. Although it would
be straightforward to modify the runtime systems to track these
events, this would introduce considerable overhead and reduce the
portability of the approach, as it would be necessary to provide
custom runtime systems for each smartphone platform. Therefore,
one challenge for our approach is to account for these events with
information that is available at the app layer.

Thread switching causes several problems for calculating source
line level energy. The ﬁrst problem is that any energy measure-
ments for a given time period may also include energy for threads
that are not related to the application (i.e.,, operating system pro-
cesses). For example, at any point in the execution of the thread
in runBackgroundSync or getNetworkTime, the OS could
swap in a thread from another app or the OS. Any power samples
during this time would likely include instructions from both the
original and swapped-in thread. The second problem is that thread

p r i v a t e void

runBackgroundSync ( E x e c u t o r
long n e t w o r k T i m e M i l l i s ;
t r y {

n e t w o r k T i m e M i l l i s =

c a l l b a c k E x e c u t o r ) {

mNetworkTimeProvider . getNetworkTime ( ) ;

} catch ( I O E x c e p t i o n e ) {

Log .w(LOG_TAG, "Failed to obtain network " +
"time due to connectivity issues" ) ;

c a l l b a c k E x e c u t o r . e x e c u t e ( new Runnable ( ) {

@Override
p u b l i c void run ( ) {

f i n i s h ( R e s u l t . ERROR_CONNECTIVITY_ISSUE ) ;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

}
} ) ;
return ;

}

Program 2: Google Authenticator Method 2

switching itself introduces an energy overhead. For example, Line
10 of Program 2 will incur a signiﬁcant energy overhead for the
context switch that occurs when a new thread is started.

Periodically, the Android operating system will perform garbage
collection during the execution of an application. Typically, ap-
plications do not have control over garbage collection, it is man-
aged by the operating system and can occur anytime and within
any method. Although the Dalvik virtual machine logs garbage
collection, it timestamps the events via a millisecond based clock,
which does not provide enough precision to determine in which
path they occur (paths are tracked with nanosecond timestamps.)
As we note in Section 3.2.2, garbage collection incurs a signiﬁ-
cant energy cost and has the potential to signiﬁcantly distort en-
ergy measurements for an application. For example, consider if
garbage collection were to occur at line 20 of Program 1, which is
compiled as a simple jump on equality (ifeq), or line 6 of Pro-
gram 2, which is a relatively expensive method invocation. The
extremely high cost of the garbage collection would dwarf the cost
of both instructions making them appear to have a nearly identical
high energy cost. Therefore, an approach must be able to identify
and properly account for garbage collection while calculating the
source line level energy consumption of an application.

Smartphones exhibit tail energy usage, where certain hardware
components are optimistically kept active by the operating system,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. Tail energy manifests itself in two differ-
ent ways. The ﬁrst way is when an invocation to an API accesses a
hardware component and then returns. Even when no other invoca-
tions access the component, the component will remain active for
a time period Ttail and consume energy Etail. An example of this
kind of invocation is at line 7 of Program 1. The call to the network
will cause the radio to remain on for a period of time, even after
the request is ﬁnished, and consume energy during this time. The
second way is when two invocations access the component in se-
quence and the time interval between them is less than Ttail. Here,
only a portion of Etail will be consumed. The Etail for certain de-
vices can be quite high and a naive approach to measurement might
attribute the tail energy cost to subsequently executed instructions.
Referring back to the example invocation, the naive approach could
mistakenly attribute part of the invocation’s tail energy to its suc-
cessors, lines 16, 18, and 20, (depending on the length of its Ttail)
instead of to line 7. To be accurate, an approach must recognize
when tail energy occurs and attribute it to the source invocations
that started the component and kept it at a non-idle state.

2.3 Software-Level Challenges

Source level calculations require precise information about an
app’s execution. In particular, for each time period represented by
a power sample, it is necessary to know which instructions were
executed, their frequency, and their ordering — essentially, path
information. The primary challenge is that obtaining this type of
information at the software level is generally expensive and intru-
sive. For example, inserting instrumentation into an app to iso-
late and measure individual instructions can lead to high overhead.
Even optimizations, such as only instrumenting each basic block,
would still produce a high amount of instrumentation. Other ap-
proaches, such as instruction counting, do not allow developers to
know which instances of the instructions were executed.

It is also necessary to have precise information about API invoca-
tions. During execution, smartphone applications generally invoke
library functions and APIs to access hardware components, such
as GPS, network, and WiFi. For example, at line 7 of Program 1,
getNetworkTime() sends an HTTP request to Google by in-
voking HttpClient.execute(). This invocation consumes
a relatively large amount of energy due to its use of the network.
In contrast, a call to dataheader.getValue at line 24 of Pro-
gram 1, incurs a relatively small constant cost, since it is simply
returning the value of an HTTP header. This wide range of invo-
cation behavior causes problems for techniques that naively apply
statistical sampling or averaging-based approaches because, unlike
normal instructions, an invocation’s energy cost can vary based on
its target and the data provided for its arguments. Furthermore, it is
not feasible to precompute the cost of API calls, since that requires
sampling every point in each API calls input space to determine its
energy consumption.
3. APPROACH

The goal of our approach is to provide source line level energy
information for smartphone applications. An overview of our ap-
proach is shown in Figure 1. From a high-level, our approach has
two phases, Runtime Measurement and Ofﬂine Analysis. The in-
puts to the Runtime Measurement phase are the application under
analysis (AUA) and a set of use cases for which the tester wants
to obtain energy measurements. The App Instrumenter uses an
efﬁcient path proﬁling technique to guide the insertion of probes
into the AUA that will capture timestamps and path traversal infor-
mation. The tester executes the instrumented AUA on the Power
Measurement Platform. This causes the instrumentation to record
path information while the Power Measurement Platform records
power samples. The path and power samples are the inputs for the
Ofﬂine Analysis phase. The Path Adjuster performs a static anal-
ysis of the paths and makes modiﬁcations to the power samples to
account for the high-energy events. Then the Analyzer performs
the regression analysis in order to calculate each source line’s en-
ergy consumption. If the Analyzer ﬁnds there are not enough data
points to solve the regression analysis, then the process returns to
the Runtime Measurement phase so the developer can further exe-
cute the application. If this is not possible, then the Analyzer per-
forms approximations that we discuss in Section 3.2.2. Finally, the
Annotator uses the calculations to create graphical overlays of the
measurements on the source code for display in an integrated de-
velopment environment. We explain the approach in more detail in
the remainder of this section.
3.1 Runtime Measurement Phase

During the Runtime Measurement phase, information about the
paths executed in the AUA and power measurements are generated
by the approach. To do this, the App Instrumenter inserts probes

Figure 1: Overview of the approach

into the AUA to record the information, and then the instrumented
AUA is executed by the developer while power samples are col-
lected by the Power Measurement Platform. The output of the Run-
time Measurement phase is set of timestamped paths executed by
the AUA and power measurements.

Instrumentation of the AUA: The instrumentation collects in-
formation about the paths executed by the developer. Namely, which
paths are traversed, their frequency, and timestamps of the path
traversals and invocation of certain APIs. To record the path infor-
mation, the App Instrumenter adapts a techniques for efﬁcient path
proﬁling proposed by Ball and Larus [5]. The approach ﬁrst builds
a control-ﬂow graph (CFG) of each method in the AUA. Then each
edge in the CFG is assigned a label so that each unique path in the
CFG has a unique path ID. The approach then calculates a maxi-
mal spanning tree over the CFG and uses this to guide the minimal
placement of instrumentation that will increment a path ID counter.
By design, the approach can use a single counter to identify the path
traversed in the method. We extended the Ball-Larus approach to
handle nested method calls, concurrency, and exceptions. The App
Instrumenter also inserts a probe at the method entry to initialize
the method’s path counter, record a timestamp of when the path
traversal began, and the current thread ID. At each exit point of
the method, another probe records the value of the path ID counter,
and another timestamp. After execution is ﬁnished, this informa-
tion allows the approach to generate a set of path tuples of the form
(cid:104)thread_id, path_id, enter_time, exit_time(cid:105) where thread_id
identiﬁes current thread, path_id is the traversed ID for paths, and
enter_time and exit_time are the time stamps that indicate when
a path starts and ends.

The App Instrumenter also inserts probes to obtain timestamps
before and after the invocation of certain APIs. As we explain
in Section 3.2.1, this information is used to allocate tail energy
and isolate the energy cost of certain APIs for which it is not
possible to model using linear regression (i.e., methods that have
non constant energy consumption.) For each of the invocations,
the instrumentation generates an invocation tuple of the form
(cid:104)method_id, enter_time, exit_time(cid:105), where method_id iden-
tiﬁes the invoking method, and enter_time and exit_time are
timestamps before invoking the method and after the method has
returned.

Execution of the Instrumented AUA: To generate the path and
invocation tuples, the instrumented AUA is executed on the Power
Measurement Platform. The Power Measurement Platform is based
on the LEAP node [25]. The LEAP is an x86 platform based on an

ATOM N550 processor that runs Android 3.2. Each component
in the LEAP (e.g., WiFi, GPS, memory, and CPU) is connected
to an analog to digital converter (DAQ) that samples current draw
at 10KHz. The LEAP also provides Android applications with the
ability to trigger a synchronization signal. This allows the approach
to synchronize the samples with the paths’ timestamps and avoid
inaccuracy due to clock skew. Each of the uses cases is executed
by the developer on the AUA while it is running on the LEAP. Note
that all of the measurements are recorded in hardware external to
the Android smartphone components, so the measurement process
does not introduce any interference or execution overhead.
3.2 Ofﬂine Analysis Phase

In the Ofﬂine Analysis phase, our approach analyzes the tuples
and power samples generated in the Runtime Measurement phase
to produce a mapping of energy to source lines. There are three
parts to this phase.
In the ﬁrst part, the Path Adjuster statically
examines each traversed path in the CFG and adjusts the corre-
sponding energy measurements to account for special API invoca-
tions, tail energy, and interleaving threads. The adjusted energy
measurements and paths are the inputs to the second part, the Ana-
lyzer, which uses robust regression techniques to calculate the cost
of each source line and identify paths along which garbage col-
lection and thread context switches occurred. The Analyzer also
determines if the testing process created enough data points to per-
form the linear regression and either reduces the grouping of vari-
ables to be solved in the regression or directs the tester to repeat
the test cases to provide more data points. Finally, in the third part,
the Annotator creates a graphic representation of the energy mea-
surements and overlays this with the source code. Note that in the
rest of the paper, we describe our approach in terms of bytecode
instructions, but it is straightforward to convert the bytecode-level
information to source-level using compiler provided debugging in-
formation.
3.2.1 Adjustment to Path Energy Samples
Before beginning the analysis, the Path Adjuster ﬁrst reconstructs
the paths traversed during execution of the AUA. The instructions
executed in a path can be identiﬁed using the path ID and the
CFG of the method containing the path, as described by Ball and
Larus [5]. Once the paths have been reconstructed, the Path Ad-
juster calculates the energy total for the path by summing the mea-
surements reported during the path’s time of execution. The Path
Adjuster can identify the corresponding path and power samples
due to the synchronized timestamps. Then, the Path Adjuster per-

App Instrumenter Path Adjuster Analyzer Annotator Runtime Measurement Phase  Offline Analysis Phase Application (AUA) Use  cases Energy Report Power Measurement Platform Visualization {<paths>} {<power>} Insufficient data? AUA´ Calculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36

an approach that combines hardware-based energy measurements
with program analysis and statistical modeling techniques. At a
high-level, the basic intuition is as follows: While measuring the
energy consumption of a smartphone, the approach uses efﬁcient
path proﬁling to identify which parts of the application are exe-
cuting and correlates these paths with the measured energy. Then,
the approach statically analyzes the paths to identify and adjust for
high-energy events, such as thread switching, before applying ro-
bust regression analysis to calculate each source line’s energy con-
sumption. Finally, the approach presents developers with a graph-
ical representation of the energy consumption by overlaying the
calculated energy with the source code of the application.

We also performed an empirical evaluation of our approach to
measure its accuracy and the time needed to perform the analysis.
Our approach was able to accurately calculate energy. For a set of
API invocations, we found that the calculated energy values were
within 10% of the ground truth measurements. The statistical mod-
els also matched the measured data very closely with a high R2
average of 0.93 and a low accumulated error rate. Importantly, in
our experiments, the approach was also able to detect the inﬂuence
of high-energy events, such as thread switching and garbage col-
lection, with 100% accuracy. The approach was also fast, it could
calculate source line level energy measurements for each of our
subject applications in less than three minutes. Overall, the results
of the evaluation were positive and indicate that our approach is an
effective and practical way to provide developers with source line
level energy information.

The remainder of this paper is organized as follows: In Section 2
we discuss several of the signiﬁcant challenges that shaped the de-
sign of our approach. We present the approach itself in Section 3.
The evaluation of the approach is described in Section 4. Finally,
we discuss related work and conclude in Sections 5 and 6.

2. BACKGROUND AND MOTIVATION

In this section we discuss several challenges to measuring and
calculating source line energy consumption. We break the chal-
lenges into three broad categories, hardware, runtime system, and
software level, and explain how they preclude a straightforward
solution for calculating source level energy consumption. To il-
lustrate these challenges, we make use of the code shown as Pro-
grams 1 and 2, which are excerpts from the open-source Google
Authenticator project that handles synchronizing a system clock.
In the example, method getNetworkTime (Program 1, line 1)
retrieves the time by sending an HTTP request to a timeserver
(line 7) and then parsing the response packet (lines 16, 20, 23,
26). Method runBackgroundSync (Program 2, line 2) calls the
getNetworkTime (line 6) and then starts a background thread
to handle errors (line 10).
2.1 Hardware Limitations

The primary hardware obstacle to directly measuring the energy
consumption of source lines is the difference in the speed at which
instructions execute and hardware devices can perform energy mea-
surements. On modern processors, individual instructions will ex-
ecute at a rate of several million per second. At best, power me-
ters can sample electrical power draw at several tens of KHz [16],
which means that each sample will include the power consumption
of hundreds, perhaps thousands, of instructions. For example, it
is possible for Program 2 to execute completely in the time that
transpires between two consecutive power samples by a relatively
fast power meter. There are reasons to believe that this order of
magnitude disparity will likely persist, since the bottleneck in high-
frequency power sampling is the storage system, which cannot save

p u b l i c long getNetworkTime ( )

throws

I O E x c e p t i o n {

HttpHead r e q u e s t = new HttpHead (URL ) ;
Log . i (LOG_TAG, "Sending request to "

+ r e q u e s t . getURI ( ) ) ;
H t t p R e s p o n s e h t t p R e s p o n s e ;
t r y {

h t t p R e s p o n s e = m H t t p C l i e n t . e x e c u t e ( r e q u e s t ) ;

} catch ( C l i e n t P r o t o c o l E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( S t r i n g . v a l u e O f ( e ) ) ;

} catch ( I O E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( "Failed due " +

"to connectivity issues: " + e ) ;

}

t r y {

Header d a t e H e a d e r =

h t t p R e s p o n s e . g e t L a s t H e a d e r ( "Date" ) ;

Log . i (LOG_TAG, "Received response with "

+"Date header: " + d a t e H e a d e r ) ;

i f

( d a t e H e a d e r == n u l l ) {

throw new I O E x c e p t i o n ( "No Date header" ) ;

}
S t r i n g d a t e H e a d e r V a l u e =

t ry {

Date networkDate =

d a t e H e a d e r . g e t V a l u e ( ) ;

D a t e U t i l s . p a r s e D a t e ( d a t e H e a d e r V a l u e ) ;

return networkDate . getTime ( ) ;

} catch ( D a t e P a r s e E x c e p t i o n e ) {

throw new I O E x c e p t i o n (

"Invalid Date header format " ) ;

}

} f i n a l l y {

. . . . . .

}

}

Program 1: Google Authenticator Method 1

power samples at the same frequency as the power meter can gen-
erate them [14, 15, 20], and there is no evidence to show that this
gap will be closed in the near future. Therefore, a challenge for our
approach is to reconcile power measurements samples and instruc-
tion execution, even though there is a several orders of magnitude
difference in their frequency.
2.2 Runtime System Challenges

The runtime system of an Android smartphone includes both the
Android operating system and the Dalvik Virtual Machine, the plat-
form on which marketplace apps are run. The runtime system im-
plements several types of behaviors that affect energy consumption
of an app, thread switching, garbage collection, and tail energy.
However, the details of the duration, frequency, and timing of these
events is, by design, hidden from the app. This makes it difﬁcult
to correctly attribute energy at the source level. Although it would
be straightforward to modify the runtime systems to track these
events, this would introduce considerable overhead and reduce the
portability of the approach, as it would be necessary to provide
custom runtime systems for each smartphone platform. Therefore,
one challenge for our approach is to account for these events with
information that is available at the app layer.

Thread switching causes several problems for calculating source
line level energy. The ﬁrst problem is that any energy measure-
ments for a given time period may also include energy for threads
that are not related to the application (i.e.,, operating system pro-
cesses). For example, at any point in the execution of the thread
in runBackgroundSync or getNetworkTime, the OS could
swap in a thread from another app or the OS. Any power samples
during this time would likely include instructions from both the
original and swapped-in thread. The second problem is that thread

p r i v a t e void

runBackgroundSync ( E x e c u t o r
long n e t w o r k T i m e M i l l i s ;
t r y {

n e t w o r k T i m e M i l l i s =

c a l l b a c k E x e c u t o r ) {

mNetworkTimeProvider . getNetworkTime ( ) ;

} catch ( I O E x c e p t i o n e ) {

Log .w(LOG_TAG, "Failed to obtain network " +
"time due to connectivity issues" ) ;

c a l l b a c k E x e c u t o r . e x e c u t e ( new Runnable ( ) {

@Override
p u b l i c void run ( ) {

f i n i s h ( R e s u l t . ERROR_CONNECTIVITY_ISSUE ) ;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

}
} ) ;
return ;

}

Program 2: Google Authenticator Method 2

switching itself introduces an energy overhead. For example, Line
10 of Program 2 will incur a signiﬁcant energy overhead for the
context switch that occurs when a new thread is started.

Periodically, the Android operating system will perform garbage
collection during the execution of an application. Typically, ap-
plications do not have control over garbage collection, it is man-
aged by the operating system and can occur anytime and within
any method. Although the Dalvik virtual machine logs garbage
collection, it timestamps the events via a millisecond based clock,
which does not provide enough precision to determine in which
path they occur (paths are tracked with nanosecond timestamps.)
As we note in Section 3.2.2, garbage collection incurs a signiﬁ-
cant energy cost and has the potential to signiﬁcantly distort en-
ergy measurements for an application. For example, consider if
garbage collection were to occur at line 20 of Program 1, which is
compiled as a simple jump on equality (ifeq), or line 6 of Pro-
gram 2, which is a relatively expensive method invocation. The
extremely high cost of the garbage collection would dwarf the cost
of both instructions making them appear to have a nearly identical
high energy cost. Therefore, an approach must be able to identify
and properly account for garbage collection while calculating the
source line level energy consumption of an application.

Smartphones exhibit tail energy usage, where certain hardware
components are optimistically kept active by the operating system,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. Tail energy manifests itself in two differ-
ent ways. The ﬁrst way is when an invocation to an API accesses a
hardware component and then returns. Even when no other invoca-
tions access the component, the component will remain active for
a time period Ttail and consume energy Etail. An example of this
kind of invocation is at line 7 of Program 1. The call to the network
will cause the radio to remain on for a period of time, even after
the request is ﬁnished, and consume energy during this time. The
second way is when two invocations access the component in se-
quence and the time interval between them is less than Ttail. Here,
only a portion of Etail will be consumed. The Etail for certain de-
vices can be quite high and a naive approach to measurement might
attribute the tail energy cost to subsequently executed instructions.
Referring back to the example invocation, the naive approach could
mistakenly attribute part of the invocation’s tail energy to its suc-
cessors, lines 16, 18, and 20, (depending on the length of its Ttail)
instead of to line 7. To be accurate, an approach must recognize
when tail energy occurs and attribute it to the source invocations
that started the component and kept it at a non-idle state.

2.3 Software-Level Challenges

Source level calculations require precise information about an
app’s execution. In particular, for each time period represented by
a power sample, it is necessary to know which instructions were
executed, their frequency, and their ordering — essentially, path
information. The primary challenge is that obtaining this type of
information at the software level is generally expensive and intru-
sive. For example, inserting instrumentation into an app to iso-
late and measure individual instructions can lead to high overhead.
Even optimizations, such as only instrumenting each basic block,
would still produce a high amount of instrumentation. Other ap-
proaches, such as instruction counting, do not allow developers to
know which instances of the instructions were executed.

It is also necessary to have precise information about API invoca-
tions. During execution, smartphone applications generally invoke
library functions and APIs to access hardware components, such
as GPS, network, and WiFi. For example, at line 7 of Program 1,
getNetworkTime() sends an HTTP request to Google by in-
voking HttpClient.execute(). This invocation consumes
a relatively large amount of energy due to its use of the network.
In contrast, a call to dataheader.getValue at line 24 of Pro-
gram 1, incurs a relatively small constant cost, since it is simply
returning the value of an HTTP header. This wide range of invo-
cation behavior causes problems for techniques that naively apply
statistical sampling or averaging-based approaches because, unlike
normal instructions, an invocation’s energy cost can vary based on
its target and the data provided for its arguments. Furthermore, it is
not feasible to precompute the cost of API calls, since that requires
sampling every point in each API calls input space to determine its
energy consumption.
3. APPROACH

The goal of our approach is to provide source line level energy
information for smartphone applications. An overview of our ap-
proach is shown in Figure 1. From a high-level, our approach has
two phases, Runtime Measurement and Ofﬂine Analysis. The in-
puts to the Runtime Measurement phase are the application under
analysis (AUA) and a set of use cases for which the tester wants
to obtain energy measurements. The App Instrumenter uses an
efﬁcient path proﬁling technique to guide the insertion of probes
into the AUA that will capture timestamps and path traversal infor-
mation. The tester executes the instrumented AUA on the Power
Measurement Platform. This causes the instrumentation to record
path information while the Power Measurement Platform records
power samples. The path and power samples are the inputs for the
Ofﬂine Analysis phase. The Path Adjuster performs a static anal-
ysis of the paths and makes modiﬁcations to the power samples to
account for the high-energy events. Then the Analyzer performs
the regression analysis in order to calculate each source line’s en-
ergy consumption. If the Analyzer ﬁnds there are not enough data
points to solve the regression analysis, then the process returns to
the Runtime Measurement phase so the developer can further exe-
cute the application. If this is not possible, then the Analyzer per-
forms approximations that we discuss in Section 3.2.2. Finally, the
Annotator uses the calculations to create graphical overlays of the
measurements on the source code for display in an integrated de-
velopment environment. We explain the approach in more detail in
the remainder of this section.
3.1 Runtime Measurement Phase

During the Runtime Measurement phase, information about the
paths executed in the AUA and power measurements are generated
by the approach. To do this, the App Instrumenter inserts probes

Figure 1: Overview of the approach

into the AUA to record the information, and then the instrumented
AUA is executed by the developer while power samples are col-
lected by the Power Measurement Platform. The output of the Run-
time Measurement phase is set of timestamped paths executed by
the AUA and power measurements.

Instrumentation of the AUA: The instrumentation collects in-
formation about the paths executed by the developer. Namely, which
paths are traversed, their frequency, and timestamps of the path
traversals and invocation of certain APIs. To record the path infor-
mation, the App Instrumenter adapts a techniques for efﬁcient path
proﬁling proposed by Ball and Larus [5]. The approach ﬁrst builds
a control-ﬂow graph (CFG) of each method in the AUA. Then each
edge in the CFG is assigned a label so that each unique path in the
CFG has a unique path ID. The approach then calculates a maxi-
mal spanning tree over the CFG and uses this to guide the minimal
placement of instrumentation that will increment a path ID counter.
By design, the approach can use a single counter to identify the path
traversed in the method. We extended the Ball-Larus approach to
handle nested method calls, concurrency, and exceptions. The App
Instrumenter also inserts a probe at the method entry to initialize
the method’s path counter, record a timestamp of when the path
traversal began, and the current thread ID. At each exit point of
the method, another probe records the value of the path ID counter,
and another timestamp. After execution is ﬁnished, this informa-
tion allows the approach to generate a set of path tuples of the form
(cid:104)thread_id, path_id, enter_time, exit_time(cid:105) where thread_id
identiﬁes current thread, path_id is the traversed ID for paths, and
enter_time and exit_time are the time stamps that indicate when
a path starts and ends.

The App Instrumenter also inserts probes to obtain timestamps
before and after the invocation of certain APIs. As we explain
in Section 3.2.1, this information is used to allocate tail energy
and isolate the energy cost of certain APIs for which it is not
possible to model using linear regression (i.e., methods that have
non constant energy consumption.) For each of the invocations,
the instrumentation generates an invocation tuple of the form
(cid:104)method_id, enter_time, exit_time(cid:105), where method_id iden-
tiﬁes the invoking method, and enter_time and exit_time are
timestamps before invoking the method and after the method has
returned.

Execution of the Instrumented AUA: To generate the path and
invocation tuples, the instrumented AUA is executed on the Power
Measurement Platform. The Power Measurement Platform is based
on the LEAP node [25]. The LEAP is an x86 platform based on an

ATOM N550 processor that runs Android 3.2. Each component
in the LEAP (e.g., WiFi, GPS, memory, and CPU) is connected
to an analog to digital converter (DAQ) that samples current draw
at 10KHz. The LEAP also provides Android applications with the
ability to trigger a synchronization signal. This allows the approach
to synchronize the samples with the paths’ timestamps and avoid
inaccuracy due to clock skew. Each of the uses cases is executed
by the developer on the AUA while it is running on the LEAP. Note
that all of the measurements are recorded in hardware external to
the Android smartphone components, so the measurement process
does not introduce any interference or execution overhead.
3.2 Ofﬂine Analysis Phase

In the Ofﬂine Analysis phase, our approach analyzes the tuples
and power samples generated in the Runtime Measurement phase
to produce a mapping of energy to source lines. There are three
parts to this phase.
In the ﬁrst part, the Path Adjuster statically
examines each traversed path in the CFG and adjusts the corre-
sponding energy measurements to account for special API invoca-
tions, tail energy, and interleaving threads. The adjusted energy
measurements and paths are the inputs to the second part, the Ana-
lyzer, which uses robust regression techniques to calculate the cost
of each source line and identify paths along which garbage col-
lection and thread context switches occurred. The Analyzer also
determines if the testing process created enough data points to per-
form the linear regression and either reduces the grouping of vari-
ables to be solved in the regression or directs the tester to repeat
the test cases to provide more data points. Finally, in the third part,
the Annotator creates a graphic representation of the energy mea-
surements and overlays this with the source code. Note that in the
rest of the paper, we describe our approach in terms of bytecode
instructions, but it is straightforward to convert the bytecode-level
information to source-level using compiler provided debugging in-
formation.
3.2.1 Adjustment to Path Energy Samples
Before beginning the analysis, the Path Adjuster ﬁrst reconstructs
the paths traversed during execution of the AUA. The instructions
executed in a path can be identiﬁed using the path ID and the
CFG of the method containing the path, as described by Ball and
Larus [5]. Once the paths have been reconstructed, the Path Ad-
juster calculates the energy total for the path by summing the mea-
surements reported during the path’s time of execution. The Path
Adjuster can identify the corresponding path and power samples
due to the synchronized timestamps. Then, the Path Adjuster per-

App Instrumenter Path Adjuster Analyzer Annotator Runtime Measurement Phase  Offline Analysis Phase Application (AUA) Use  cases Energy Report Power Measurement Platform Visualization {<paths>} {<power>} Insufficient data? AUA´ forms a static analysis of each path in order to adjust certain API
invocations due to non-constant and too-short API invocations, tail
energy, and thread interleaving. The Path Adjuster generates a
set of paths with the adjusted invocations removed from the paths
and their corresponding energy removed from the power measure-
ments.

API Invocations: Certain API invocations have a non-constant
energy cost associated with their execution. Therefore, it is not
possible to calculate their energy cost using the robust linear re-
gression techniques described in Section 3.2.2. To address this
problem, our approach uses the invocation tuples to identify the
time periods when these invocations are executing and calculates
the invocations’ energy cost by summing the power measurements
taken during that time.

Figure 2: Using longer execution windows for calculating the
energy of invocations with a short execution time.

In most cases, the execution time of an invocation is long enough
that the approach is able to get accurate energy measurements (i.e.,
the execution time is longer than several sampling periods.) How-
ever, in some cases the execution time of the invocation is too brief
(e.g., the execution time is shorter than a sampling period.) For
these invocations, the approach identiﬁes an execution time period
that includes the too short execution and for which the approach
does have enough power samples to accurately the energy con-
sumption. Then it calculates the ratio of the original execution time
versus the larger execution time and multiples that against the en-
ergy total for the larger execution time. To illustrate, consider the
example shown in Figure 2. In this ﬁgure, the horizontal bars in-
dicate the energy sampling interval. For example, the LEAP will
sample the power at t3 and then again at t4. If an invocation I exe-
cutes from time t1 until time t2, then there are no power samples to
be summed in order to ﬁnd the energy consumed by I (EI). When
this occurs, the Path Adjuster ﬁnds the next largest execution win-
dow for which it has sufﬁcient energy samples and uses this win-
dow to calculate EI. In the case of the example, the Path Adjuster
calculates EI as shown in Equation 1, where Ea,b denotes the en-
ergy consumption measured by the Power Measurement Platform
during interval [a, b].

t2 − t1
t4 − t3

Et3,t4

(1)

Note that this only approximates EI. We have found that for
functions whose execution time is so short, this is a reasonable ap-
proximation. These functions consume a very small portion of the
overall energy expended at runtime, on average about 6% of the
total API energy cost. For the general case, where the execution
time is of sufﬁcient length, our evaluation shows that we are able to
accurately measure most functions to within 9% of their measured
ground truth cost.

Figure 3: API invocations with tail energy

Tail Energy: As explained in Section 2, tail energy occurs when
the operating system keeps certain hardware components active,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. The result of this behavior is that the en-
ergy measurements for the time period following the component
access will be higher. Our approach adjusts the path energy total so
that the tail energy is attributed to the invocations that interact with
the hardware component. We assume the availability of tail energy
models, which are generally provided by either component manu-
facturers or power researchers [24]. The model speciﬁes the energy
consumption of the component after an invocation (Etail) and for
how long the device driver maintains this state (Ttail). To calcu-
late the adjustment, the Path Adjuster examines the reconstructed
paths to identify the sequence AD of invocations to methods that
cause tail energy for each device D of the smartphone. For each
such invocation ai ∈ AD, the adjuster compares the timestamp of
ai against the timestamp of ai+1. If the difference is greater than
Ttail then all of Etail is attributed to ai. If the difference is less
than Ttail then only a fraction of Etail is expended before ai+1
occurs and should be attributed to ai. The fraction is calculated as
shown in Equation 2, where TS returns the starting timestamp of an
invocation and TE returns the ending timestamp of an invocation.
Note that the invocation timestamps are known due to the invoca-
tion tuples collected during the Runtime Measurement phase.

TS(ai+1) − TE(ai)

Ttail

Etail

(2)

To illustrate these two scenarios, consider the two invocations
shown in Figure 3. Both of these, AP I_1 and AP I_2, access
the same device in sequence. Their tail energy consumptions are
shown as curved lines extending after the end of the invocations.
To calculate the tail energy associated with AP I_1, note that t2,
the start of the invocation to AP I_2, occurs before the Ttail time
has transpired. Therefore the tail energy assigned to AP I_1 is
t3−t1 ∗ Etail. When the invocation to AP I_2 returns
calculated as t2−t1
at t4, there is no other API accessing the same external device, so
we assign all of Etail, to AP I_2.

Thread Context-Switching During Invocations: A potential
problem that arises with the way the approach attributes energy to
API invocations is that it is possible for the thread containing the
invocation be switched out for another thread from the same appli-
cation. For example, this can happen because the invocation must
wait for a shared resource or another thread has higher priority.
The problem is that energy consumption by the other threads will
then also be measured in the corresponding power samples. As we
discussed earlier, this situation can be detected by modifying the
operating system to accurately track thread scheduling. However,
this would make the approach less portable, so we have devised a
software-level technique to address this problem.

Calculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36

an approach that combines hardware-based energy measurements
with program analysis and statistical modeling techniques. At a
high-level, the basic intuition is as follows: While measuring the
energy consumption of a smartphone, the approach uses efﬁcient
path proﬁling to identify which parts of the application are exe-
cuting and correlates these paths with the measured energy. Then,
the approach statically analyzes the paths to identify and adjust for
high-energy events, such as thread switching, before applying ro-
bust regression analysis to calculate each source line’s energy con-
sumption. Finally, the approach presents developers with a graph-
ical representation of the energy consumption by overlaying the
calculated energy with the source code of the application.

We also performed an empirical evaluation of our approach to
measure its accuracy and the time needed to perform the analysis.
Our approach was able to accurately calculate energy. For a set of
API invocations, we found that the calculated energy values were
within 10% of the ground truth measurements. The statistical mod-
els also matched the measured data very closely with a high R2
average of 0.93 and a low accumulated error rate. Importantly, in
our experiments, the approach was also able to detect the inﬂuence
of high-energy events, such as thread switching and garbage col-
lection, with 100% accuracy. The approach was also fast, it could
calculate source line level energy measurements for each of our
subject applications in less than three minutes. Overall, the results
of the evaluation were positive and indicate that our approach is an
effective and practical way to provide developers with source line
level energy information.

The remainder of this paper is organized as follows: In Section 2
we discuss several of the signiﬁcant challenges that shaped the de-
sign of our approach. We present the approach itself in Section 3.
The evaluation of the approach is described in Section 4. Finally,
we discuss related work and conclude in Sections 5 and 6.

2. BACKGROUND AND MOTIVATION

In this section we discuss several challenges to measuring and
calculating source line energy consumption. We break the chal-
lenges into three broad categories, hardware, runtime system, and
software level, and explain how they preclude a straightforward
solution for calculating source level energy consumption. To il-
lustrate these challenges, we make use of the code shown as Pro-
grams 1 and 2, which are excerpts from the open-source Google
Authenticator project that handles synchronizing a system clock.
In the example, method getNetworkTime (Program 1, line 1)
retrieves the time by sending an HTTP request to a timeserver
(line 7) and then parsing the response packet (lines 16, 20, 23,
26). Method runBackgroundSync (Program 2, line 2) calls the
getNetworkTime (line 6) and then starts a background thread
to handle errors (line 10).
2.1 Hardware Limitations

The primary hardware obstacle to directly measuring the energy
consumption of source lines is the difference in the speed at which
instructions execute and hardware devices can perform energy mea-
surements. On modern processors, individual instructions will ex-
ecute at a rate of several million per second. At best, power me-
ters can sample electrical power draw at several tens of KHz [16],
which means that each sample will include the power consumption
of hundreds, perhaps thousands, of instructions. For example, it
is possible for Program 2 to execute completely in the time that
transpires between two consecutive power samples by a relatively
fast power meter. There are reasons to believe that this order of
magnitude disparity will likely persist, since the bottleneck in high-
frequency power sampling is the storage system, which cannot save

p u b l i c long getNetworkTime ( )

throws

I O E x c e p t i o n {

HttpHead r e q u e s t = new HttpHead (URL ) ;
Log . i (LOG_TAG, "Sending request to "

+ r e q u e s t . getURI ( ) ) ;
H t t p R e s p o n s e h t t p R e s p o n s e ;
t r y {

h t t p R e s p o n s e = m H t t p C l i e n t . e x e c u t e ( r e q u e s t ) ;

} catch ( C l i e n t P r o t o c o l E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( S t r i n g . v a l u e O f ( e ) ) ;

} catch ( I O E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( "Failed due " +

"to connectivity issues: " + e ) ;

}

t r y {

Header d a t e H e a d e r =

h t t p R e s p o n s e . g e t L a s t H e a d e r ( "Date" ) ;

Log . i (LOG_TAG, "Received response with "

+"Date header: " + d a t e H e a d e r ) ;

i f

( d a t e H e a d e r == n u l l ) {

throw new I O E x c e p t i o n ( "No Date header" ) ;

}
S t r i n g d a t e H e a d e r V a l u e =

t ry {

Date networkDate =

d a t e H e a d e r . g e t V a l u e ( ) ;

D a t e U t i l s . p a r s e D a t e ( d a t e H e a d e r V a l u e ) ;

return networkDate . getTime ( ) ;

} catch ( D a t e P a r s e E x c e p t i o n e ) {

throw new I O E x c e p t i o n (

"Invalid Date header format " ) ;

}

} f i n a l l y {

. . . . . .

}

}

Program 1: Google Authenticator Method 1

power samples at the same frequency as the power meter can gen-
erate them [14, 15, 20], and there is no evidence to show that this
gap will be closed in the near future. Therefore, a challenge for our
approach is to reconcile power measurements samples and instruc-
tion execution, even though there is a several orders of magnitude
difference in their frequency.
2.2 Runtime System Challenges

The runtime system of an Android smartphone includes both the
Android operating system and the Dalvik Virtual Machine, the plat-
form on which marketplace apps are run. The runtime system im-
plements several types of behaviors that affect energy consumption
of an app, thread switching, garbage collection, and tail energy.
However, the details of the duration, frequency, and timing of these
events is, by design, hidden from the app. This makes it difﬁcult
to correctly attribute energy at the source level. Although it would
be straightforward to modify the runtime systems to track these
events, this would introduce considerable overhead and reduce the
portability of the approach, as it would be necessary to provide
custom runtime systems for each smartphone platform. Therefore,
one challenge for our approach is to account for these events with
information that is available at the app layer.

Thread switching causes several problems for calculating source
line level energy. The ﬁrst problem is that any energy measure-
ments for a given time period may also include energy for threads
that are not related to the application (i.e.,, operating system pro-
cesses). For example, at any point in the execution of the thread
in runBackgroundSync or getNetworkTime, the OS could
swap in a thread from another app or the OS. Any power samples
during this time would likely include instructions from both the
original and swapped-in thread. The second problem is that thread

p r i v a t e void

runBackgroundSync ( E x e c u t o r
long n e t w o r k T i m e M i l l i s ;
t r y {

n e t w o r k T i m e M i l l i s =

c a l l b a c k E x e c u t o r ) {

mNetworkTimeProvider . getNetworkTime ( ) ;

} catch ( I O E x c e p t i o n e ) {

Log .w(LOG_TAG, "Failed to obtain network " +
"time due to connectivity issues" ) ;

c a l l b a c k E x e c u t o r . e x e c u t e ( new Runnable ( ) {

@Override
p u b l i c void run ( ) {

f i n i s h ( R e s u l t . ERROR_CONNECTIVITY_ISSUE ) ;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

}
} ) ;
return ;

}

Program 2: Google Authenticator Method 2

switching itself introduces an energy overhead. For example, Line
10 of Program 2 will incur a signiﬁcant energy overhead for the
context switch that occurs when a new thread is started.

Periodically, the Android operating system will perform garbage
collection during the execution of an application. Typically, ap-
plications do not have control over garbage collection, it is man-
aged by the operating system and can occur anytime and within
any method. Although the Dalvik virtual machine logs garbage
collection, it timestamps the events via a millisecond based clock,
which does not provide enough precision to determine in which
path they occur (paths are tracked with nanosecond timestamps.)
As we note in Section 3.2.2, garbage collection incurs a signiﬁ-
cant energy cost and has the potential to signiﬁcantly distort en-
ergy measurements for an application. For example, consider if
garbage collection were to occur at line 20 of Program 1, which is
compiled as a simple jump on equality (ifeq), or line 6 of Pro-
gram 2, which is a relatively expensive method invocation. The
extremely high cost of the garbage collection would dwarf the cost
of both instructions making them appear to have a nearly identical
high energy cost. Therefore, an approach must be able to identify
and properly account for garbage collection while calculating the
source line level energy consumption of an application.

Smartphones exhibit tail energy usage, where certain hardware
components are optimistically kept active by the operating system,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. Tail energy manifests itself in two differ-
ent ways. The ﬁrst way is when an invocation to an API accesses a
hardware component and then returns. Even when no other invoca-
tions access the component, the component will remain active for
a time period Ttail and consume energy Etail. An example of this
kind of invocation is at line 7 of Program 1. The call to the network
will cause the radio to remain on for a period of time, even after
the request is ﬁnished, and consume energy during this time. The
second way is when two invocations access the component in se-
quence and the time interval between them is less than Ttail. Here,
only a portion of Etail will be consumed. The Etail for certain de-
vices can be quite high and a naive approach to measurement might
attribute the tail energy cost to subsequently executed instructions.
Referring back to the example invocation, the naive approach could
mistakenly attribute part of the invocation’s tail energy to its suc-
cessors, lines 16, 18, and 20, (depending on the length of its Ttail)
instead of to line 7. To be accurate, an approach must recognize
when tail energy occurs and attribute it to the source invocations
that started the component and kept it at a non-idle state.

2.3 Software-Level Challenges

Source level calculations require precise information about an
app’s execution. In particular, for each time period represented by
a power sample, it is necessary to know which instructions were
executed, their frequency, and their ordering — essentially, path
information. The primary challenge is that obtaining this type of
information at the software level is generally expensive and intru-
sive. For example, inserting instrumentation into an app to iso-
late and measure individual instructions can lead to high overhead.
Even optimizations, such as only instrumenting each basic block,
would still produce a high amount of instrumentation. Other ap-
proaches, such as instruction counting, do not allow developers to
know which instances of the instructions were executed.

It is also necessary to have precise information about API invoca-
tions. During execution, smartphone applications generally invoke
library functions and APIs to access hardware components, such
as GPS, network, and WiFi. For example, at line 7 of Program 1,
getNetworkTime() sends an HTTP request to Google by in-
voking HttpClient.execute(). This invocation consumes
a relatively large amount of energy due to its use of the network.
In contrast, a call to dataheader.getValue at line 24 of Pro-
gram 1, incurs a relatively small constant cost, since it is simply
returning the value of an HTTP header. This wide range of invo-
cation behavior causes problems for techniques that naively apply
statistical sampling or averaging-based approaches because, unlike
normal instructions, an invocation’s energy cost can vary based on
its target and the data provided for its arguments. Furthermore, it is
not feasible to precompute the cost of API calls, since that requires
sampling every point in each API calls input space to determine its
energy consumption.
3. APPROACH

The goal of our approach is to provide source line level energy
information for smartphone applications. An overview of our ap-
proach is shown in Figure 1. From a high-level, our approach has
two phases, Runtime Measurement and Ofﬂine Analysis. The in-
puts to the Runtime Measurement phase are the application under
analysis (AUA) and a set of use cases for which the tester wants
to obtain energy measurements. The App Instrumenter uses an
efﬁcient path proﬁling technique to guide the insertion of probes
into the AUA that will capture timestamps and path traversal infor-
mation. The tester executes the instrumented AUA on the Power
Measurement Platform. This causes the instrumentation to record
path information while the Power Measurement Platform records
power samples. The path and power samples are the inputs for the
Ofﬂine Analysis phase. The Path Adjuster performs a static anal-
ysis of the paths and makes modiﬁcations to the power samples to
account for the high-energy events. Then the Analyzer performs
the regression analysis in order to calculate each source line’s en-
ergy consumption. If the Analyzer ﬁnds there are not enough data
points to solve the regression analysis, then the process returns to
the Runtime Measurement phase so the developer can further exe-
cute the application. If this is not possible, then the Analyzer per-
forms approximations that we discuss in Section 3.2.2. Finally, the
Annotator uses the calculations to create graphical overlays of the
measurements on the source code for display in an integrated de-
velopment environment. We explain the approach in more detail in
the remainder of this section.
3.1 Runtime Measurement Phase

During the Runtime Measurement phase, information about the
paths executed in the AUA and power measurements are generated
by the approach. To do this, the App Instrumenter inserts probes

Figure 1: Overview of the approach

into the AUA to record the information, and then the instrumented
AUA is executed by the developer while power samples are col-
lected by the Power Measurement Platform. The output of the Run-
time Measurement phase is set of timestamped paths executed by
the AUA and power measurements.

Instrumentation of the AUA: The instrumentation collects in-
formation about the paths executed by the developer. Namely, which
paths are traversed, their frequency, and timestamps of the path
traversals and invocation of certain APIs. To record the path infor-
mation, the App Instrumenter adapts a techniques for efﬁcient path
proﬁling proposed by Ball and Larus [5]. The approach ﬁrst builds
a control-ﬂow graph (CFG) of each method in the AUA. Then each
edge in the CFG is assigned a label so that each unique path in the
CFG has a unique path ID. The approach then calculates a maxi-
mal spanning tree over the CFG and uses this to guide the minimal
placement of instrumentation that will increment a path ID counter.
By design, the approach can use a single counter to identify the path
traversed in the method. We extended the Ball-Larus approach to
handle nested method calls, concurrency, and exceptions. The App
Instrumenter also inserts a probe at the method entry to initialize
the method’s path counter, record a timestamp of when the path
traversal began, and the current thread ID. At each exit point of
the method, another probe records the value of the path ID counter,
and another timestamp. After execution is ﬁnished, this informa-
tion allows the approach to generate a set of path tuples of the form
(cid:104)thread_id, path_id, enter_time, exit_time(cid:105) where thread_id
identiﬁes current thread, path_id is the traversed ID for paths, and
enter_time and exit_time are the time stamps that indicate when
a path starts and ends.

The App Instrumenter also inserts probes to obtain timestamps
before and after the invocation of certain APIs. As we explain
in Section 3.2.1, this information is used to allocate tail energy
and isolate the energy cost of certain APIs for which it is not
possible to model using linear regression (i.e., methods that have
non constant energy consumption.) For each of the invocations,
the instrumentation generates an invocation tuple of the form
(cid:104)method_id, enter_time, exit_time(cid:105), where method_id iden-
tiﬁes the invoking method, and enter_time and exit_time are
timestamps before invoking the method and after the method has
returned.

Execution of the Instrumented AUA: To generate the path and
invocation tuples, the instrumented AUA is executed on the Power
Measurement Platform. The Power Measurement Platform is based
on the LEAP node [25]. The LEAP is an x86 platform based on an

ATOM N550 processor that runs Android 3.2. Each component
in the LEAP (e.g., WiFi, GPS, memory, and CPU) is connected
to an analog to digital converter (DAQ) that samples current draw
at 10KHz. The LEAP also provides Android applications with the
ability to trigger a synchronization signal. This allows the approach
to synchronize the samples with the paths’ timestamps and avoid
inaccuracy due to clock skew. Each of the uses cases is executed
by the developer on the AUA while it is running on the LEAP. Note
that all of the measurements are recorded in hardware external to
the Android smartphone components, so the measurement process
does not introduce any interference or execution overhead.
3.2 Ofﬂine Analysis Phase

In the Ofﬂine Analysis phase, our approach analyzes the tuples
and power samples generated in the Runtime Measurement phase
to produce a mapping of energy to source lines. There are three
parts to this phase.
In the ﬁrst part, the Path Adjuster statically
examines each traversed path in the CFG and adjusts the corre-
sponding energy measurements to account for special API invoca-
tions, tail energy, and interleaving threads. The adjusted energy
measurements and paths are the inputs to the second part, the Ana-
lyzer, which uses robust regression techniques to calculate the cost
of each source line and identify paths along which garbage col-
lection and thread context switches occurred. The Analyzer also
determines if the testing process created enough data points to per-
form the linear regression and either reduces the grouping of vari-
ables to be solved in the regression or directs the tester to repeat
the test cases to provide more data points. Finally, in the third part,
the Annotator creates a graphic representation of the energy mea-
surements and overlays this with the source code. Note that in the
rest of the paper, we describe our approach in terms of bytecode
instructions, but it is straightforward to convert the bytecode-level
information to source-level using compiler provided debugging in-
formation.
3.2.1 Adjustment to Path Energy Samples
Before beginning the analysis, the Path Adjuster ﬁrst reconstructs
the paths traversed during execution of the AUA. The instructions
executed in a path can be identiﬁed using the path ID and the
CFG of the method containing the path, as described by Ball and
Larus [5]. Once the paths have been reconstructed, the Path Ad-
juster calculates the energy total for the path by summing the mea-
surements reported during the path’s time of execution. The Path
Adjuster can identify the corresponding path and power samples
due to the synchronized timestamps. Then, the Path Adjuster per-

App Instrumenter Path Adjuster Analyzer Annotator Runtime Measurement Phase  Offline Analysis Phase Application (AUA) Use  cases Energy Report Power Measurement Platform Visualization {<paths>} {<power>} Insufficient data? AUA´ forms a static analysis of each path in order to adjust certain API
invocations due to non-constant and too-short API invocations, tail
energy, and thread interleaving. The Path Adjuster generates a
set of paths with the adjusted invocations removed from the paths
and their corresponding energy removed from the power measure-
ments.

API Invocations: Certain API invocations have a non-constant
energy cost associated with their execution. Therefore, it is not
possible to calculate their energy cost using the robust linear re-
gression techniques described in Section 3.2.2. To address this
problem, our approach uses the invocation tuples to identify the
time periods when these invocations are executing and calculates
the invocations’ energy cost by summing the power measurements
taken during that time.

Figure 2: Using longer execution windows for calculating the
energy of invocations with a short execution time.

In most cases, the execution time of an invocation is long enough
that the approach is able to get accurate energy measurements (i.e.,
the execution time is longer than several sampling periods.) How-
ever, in some cases the execution time of the invocation is too brief
(e.g., the execution time is shorter than a sampling period.) For
these invocations, the approach identiﬁes an execution time period
that includes the too short execution and for which the approach
does have enough power samples to accurately the energy con-
sumption. Then it calculates the ratio of the original execution time
versus the larger execution time and multiples that against the en-
ergy total for the larger execution time. To illustrate, consider the
example shown in Figure 2. In this ﬁgure, the horizontal bars in-
dicate the energy sampling interval. For example, the LEAP will
sample the power at t3 and then again at t4. If an invocation I exe-
cutes from time t1 until time t2, then there are no power samples to
be summed in order to ﬁnd the energy consumed by I (EI). When
this occurs, the Path Adjuster ﬁnds the next largest execution win-
dow for which it has sufﬁcient energy samples and uses this win-
dow to calculate EI. In the case of the example, the Path Adjuster
calculates EI as shown in Equation 1, where Ea,b denotes the en-
ergy consumption measured by the Power Measurement Platform
during interval [a, b].

t2 − t1
t4 − t3

Et3,t4

(1)

Note that this only approximates EI. We have found that for
functions whose execution time is so short, this is a reasonable ap-
proximation. These functions consume a very small portion of the
overall energy expended at runtime, on average about 6% of the
total API energy cost. For the general case, where the execution
time is of sufﬁcient length, our evaluation shows that we are able to
accurately measure most functions to within 9% of their measured
ground truth cost.

Figure 3: API invocations with tail energy

Tail Energy: As explained in Section 2, tail energy occurs when
the operating system keeps certain hardware components active,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. The result of this behavior is that the en-
ergy measurements for the time period following the component
access will be higher. Our approach adjusts the path energy total so
that the tail energy is attributed to the invocations that interact with
the hardware component. We assume the availability of tail energy
models, which are generally provided by either component manu-
facturers or power researchers [24]. The model speciﬁes the energy
consumption of the component after an invocation (Etail) and for
how long the device driver maintains this state (Ttail). To calcu-
late the adjustment, the Path Adjuster examines the reconstructed
paths to identify the sequence AD of invocations to methods that
cause tail energy for each device D of the smartphone. For each
such invocation ai ∈ AD, the adjuster compares the timestamp of
ai against the timestamp of ai+1. If the difference is greater than
Ttail then all of Etail is attributed to ai. If the difference is less
than Ttail then only a fraction of Etail is expended before ai+1
occurs and should be attributed to ai. The fraction is calculated as
shown in Equation 2, where TS returns the starting timestamp of an
invocation and TE returns the ending timestamp of an invocation.
Note that the invocation timestamps are known due to the invoca-
tion tuples collected during the Runtime Measurement phase.

TS(ai+1) − TE(ai)

Ttail

Etail

(2)

To illustrate these two scenarios, consider the two invocations
shown in Figure 3. Both of these, AP I_1 and AP I_2, access
the same device in sequence. Their tail energy consumptions are
shown as curved lines extending after the end of the invocations.
To calculate the tail energy associated with AP I_1, note that t2,
the start of the invocation to AP I_2, occurs before the Ttail time
has transpired. Therefore the tail energy assigned to AP I_1 is
t3−t1 ∗ Etail. When the invocation to AP I_2 returns
calculated as t2−t1
at t4, there is no other API accessing the same external device, so
we assign all of Etail, to AP I_2.

Thread Context-Switching During Invocations: A potential
problem that arises with the way the approach attributes energy to
API invocations is that it is possible for the thread containing the
invocation be switched out for another thread from the same appli-
cation. For example, this can happen because the invocation must
wait for a shared resource or another thread has higher priority.
The problem is that energy consumption by the other threads will
then also be measured in the corresponding power samples. As we
discussed earlier, this situation can be detected by modifying the
operating system to accurately track thread scheduling. However,
this would make the approach less portable, so we have devised a
software-level technique to address this problem.

ticular, the Analyzer uses RLR based on M-estimation [13], which
does iterative regression analysis. It begins by solving a normal
linear regression on the set of data points. Then at each iteration,
it calculates the residuals and gives each data point a weight based
on the standard deviations of the residuals. The regression analysis
is repeated on the weighted data to generate a new model and the
process repeats until the standard deviation of residuals does not
change between iterations. For the power samples, RLR is prefer-
able over the well-known ordinary least squares approach because
it is more robust in the presence of outliers. In this case, our data
sample has outliers, which are the paths whose energy measure-
ments are inﬂuenced by garbage collection and thread switching.

More speciﬁcally, at each iteration, given the linear function (cid:126)y =
X(cid:126)θ + (cid:126)u, the Analyzer solves Equation 3 and updates the standard
deviation of residuals. For the weighting function (ψ), we use
the well-known Tukey’s Bisquare function [37], which is shown
in Equation 4. The σ is the standard deviation of residuals in the
last iteration. The value of k is constant and is set according to
different use cases. In our experiments, we found that the average
energy cost of garbage collection and thread switching is about 10
to 70 times the average standard deviation of the residuals in the
ﬁrst iteration; therefore, we select the median 40 of this range as k.

(cid:88)
ψ(yi −(cid:88)
(cid:40)

k

i

ψk(x) =

xikθk)xij = 0

x(kσ − x2)2 −kσ < x < kσ
0

otherwise

(3)

(4)

The solution represents the energy cost of each instruction in the
path. Taken together with the measured energy cost of the invoca-
tions, the Analyzer now has the energy cost for the entire path. The
values for all of the paths are provided as input to the Annotator.
Two special cases are discussed below.

The ﬁrst special case is when it is not possible to solve for a
path’s instruction energy (i.e., m). This happens when the number
of unique bytecodes in a path is higher than the number of indepen-
dent data points. Solving linear system of equations requires that
there be at least as many independent data points as unknown vari-
ables. In this situation, the Analyzer recognizes that there are not
enough data points and can take two actions, which are repeated
until the equation is solvable. The ﬁrst is that the tester is notiﬁed
that the application should be executed more to generate additional
data points. The additional executions do not need to exactly repro-
duce the initial executions, but should represent similar use cases
to ensure a signiﬁcant amount of path overlap. Since this is not
always possible, the second possible action for the Analyzer is to
group counts of similar bytecodes. For example, all variations of
the iconst instruction. This gives fewer unknown variables for
the system of equations. Note that in our experience, even moder-
ate size marketplace apps were sufﬁciently complex that neither of
these actions were required in our evaluation.

The second special case are paths identiﬁed as outliers, which
contain external thread switching or garbage collection. The de-
tection of these outliers is discussed more below. Currently, the
Analyzer excludes these paths, which comprise about 1% of the
total path count. Although it is desirable to include these paths,
since excessive high-energy events could be a symptom of energy
inefﬁcient coding, there are two obstacles to this that we hope to
address in future work. First, the path must be adjusted to remove
the energy cost of the high-energy event. However, because the
measured energy of these events is so high compared to the path
energy, it is not clear how to accurately estimate and separate the

Figure 4: Concurrent threads during an API invocation.

The Path Adjuster determines the number of threads that were
executing while the invocation was executing. This is done by ex-
amining the starting and ending timestamps of each path tuple to
see which ones were active between the invocation’s timestamps.
Then, the Path Adjuster evenly allocates the energy among the con-
N , where N is the
current threads, assigning each the energy of 1
number of concurrent threads. To illustrate, consider the example
shown in Figure 4. T 1 is the original thread and contains an API
invocation at time t1. Threads T 2 and T 3 run while T 1 is per-
forming the invocation. T 1 and T 2 are concurrent in time interval
[t2, t3] and all three are concurrent in [t3, t4]. Therefore, the en-
ergy of T 1 will be Et1,t2 + 1
3 Et3,t4. This is similar to the
way prior approaches have handled concurrent thread energy [24].

2 Et2,t3 + 1

3.2.2 Calculating Source Line Energy Values
The second part of the Ofﬂine Analysis phase calculates the en-
ergy consumption of each source line. The input to the Analyzer
is the set of adjusted paths and energy samples produced by the
the Path Adjuster. At this point, adjustments for all of the API in-
vocations have been made, but the paths could still be inﬂuenced
by the occurrence of garbage collection and thread switching dur-
ing times when there is no API invocation. As we discussed in
Section 2, the energy costs associated with events, such as garbage
collection and thread switching, can skew the regression analysis,
but it is difﬁcult to identify when they occur. Our insight is that
characteristics of these events allow us to deﬁne them as statisti-
cal outliers and therefore the Analyzer can employ Robust Linear
Regression techniques to calculate each source lines’ energy con-
sumption and mitigate the inﬂuence of these high-energy events. In
the rest of this section, we ﬁrst explain the regression technique and
then discuss the insight that allows us to deﬁne garbage collection
and thread switching as statistical outliers.
Robust Linear Regression Analysis

The Analyzer uses linear regression analysis to calculate each
instruction’s energy consumption. We expect linear regression to
work well in this situation because prior work has found that the
cost of bytecodes will be constant given a particular hardware envi-
ronment [12, 29] and the Path Adjuster has removed the non-linear
cost invocations.

To perform the analysis, the Analyzer sets up the equations E =
mX, where E is the adjusted power measurements, X represents
the path traversals with each row representing a frequency vector of
bytecodes present in the measured path. (Note that the bytecodes
associated with the inserted instrumentation are included in this
matrix. Since the approach knows which paths were instrumented,
the associated results are simply removed before visualizing or re-
porting the ﬁnal source line level calculations.) Then the Analyzer
solves for the coefﬁcients m to determine the energy consumed by
the instructions in the path segment. To solve the equations, the An-
alyzer employs Robust Linear Regression (RLR) analysis. In par-

Calculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36

an approach that combines hardware-based energy measurements
with program analysis and statistical modeling techniques. At a
high-level, the basic intuition is as follows: While measuring the
energy consumption of a smartphone, the approach uses efﬁcient
path proﬁling to identify which parts of the application are exe-
cuting and correlates these paths with the measured energy. Then,
the approach statically analyzes the paths to identify and adjust for
high-energy events, such as thread switching, before applying ro-
bust regression analysis to calculate each source line’s energy con-
sumption. Finally, the approach presents developers with a graph-
ical representation of the energy consumption by overlaying the
calculated energy with the source code of the application.

We also performed an empirical evaluation of our approach to
measure its accuracy and the time needed to perform the analysis.
Our approach was able to accurately calculate energy. For a set of
API invocations, we found that the calculated energy values were
within 10% of the ground truth measurements. The statistical mod-
els also matched the measured data very closely with a high R2
average of 0.93 and a low accumulated error rate. Importantly, in
our experiments, the approach was also able to detect the inﬂuence
of high-energy events, such as thread switching and garbage col-
lection, with 100% accuracy. The approach was also fast, it could
calculate source line level energy measurements for each of our
subject applications in less than three minutes. Overall, the results
of the evaluation were positive and indicate that our approach is an
effective and practical way to provide developers with source line
level energy information.

The remainder of this paper is organized as follows: In Section 2
we discuss several of the signiﬁcant challenges that shaped the de-
sign of our approach. We present the approach itself in Section 3.
The evaluation of the approach is described in Section 4. Finally,
we discuss related work and conclude in Sections 5 and 6.

2. BACKGROUND AND MOTIVATION

In this section we discuss several challenges to measuring and
calculating source line energy consumption. We break the chal-
lenges into three broad categories, hardware, runtime system, and
software level, and explain how they preclude a straightforward
solution for calculating source level energy consumption. To il-
lustrate these challenges, we make use of the code shown as Pro-
grams 1 and 2, which are excerpts from the open-source Google
Authenticator project that handles synchronizing a system clock.
In the example, method getNetworkTime (Program 1, line 1)
retrieves the time by sending an HTTP request to a timeserver
(line 7) and then parsing the response packet (lines 16, 20, 23,
26). Method runBackgroundSync (Program 2, line 2) calls the
getNetworkTime (line 6) and then starts a background thread
to handle errors (line 10).
2.1 Hardware Limitations

The primary hardware obstacle to directly measuring the energy
consumption of source lines is the difference in the speed at which
instructions execute and hardware devices can perform energy mea-
surements. On modern processors, individual instructions will ex-
ecute at a rate of several million per second. At best, power me-
ters can sample electrical power draw at several tens of KHz [16],
which means that each sample will include the power consumption
of hundreds, perhaps thousands, of instructions. For example, it
is possible for Program 2 to execute completely in the time that
transpires between two consecutive power samples by a relatively
fast power meter. There are reasons to believe that this order of
magnitude disparity will likely persist, since the bottleneck in high-
frequency power sampling is the storage system, which cannot save

p u b l i c long getNetworkTime ( )

throws

I O E x c e p t i o n {

HttpHead r e q u e s t = new HttpHead (URL ) ;
Log . i (LOG_TAG, "Sending request to "

+ r e q u e s t . getURI ( ) ) ;
H t t p R e s p o n s e h t t p R e s p o n s e ;
t r y {

h t t p R e s p o n s e = m H t t p C l i e n t . e x e c u t e ( r e q u e s t ) ;

} catch ( C l i e n t P r o t o c o l E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( S t r i n g . v a l u e O f ( e ) ) ;

} catch ( I O E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( "Failed due " +

"to connectivity issues: " + e ) ;

}

t r y {

Header d a t e H e a d e r =

h t t p R e s p o n s e . g e t L a s t H e a d e r ( "Date" ) ;

Log . i (LOG_TAG, "Received response with "

+"Date header: " + d a t e H e a d e r ) ;

i f

( d a t e H e a d e r == n u l l ) {

throw new I O E x c e p t i o n ( "No Date header" ) ;

}
S t r i n g d a t e H e a d e r V a l u e =

t ry {

Date networkDate =

d a t e H e a d e r . g e t V a l u e ( ) ;

D a t e U t i l s . p a r s e D a t e ( d a t e H e a d e r V a l u e ) ;

return networkDate . getTime ( ) ;

} catch ( D a t e P a r s e E x c e p t i o n e ) {

throw new I O E x c e p t i o n (

"Invalid Date header format " ) ;

}

} f i n a l l y {

. . . . . .

}

}

Program 1: Google Authenticator Method 1

power samples at the same frequency as the power meter can gen-
erate them [14, 15, 20], and there is no evidence to show that this
gap will be closed in the near future. Therefore, a challenge for our
approach is to reconcile power measurements samples and instruc-
tion execution, even though there is a several orders of magnitude
difference in their frequency.
2.2 Runtime System Challenges

The runtime system of an Android smartphone includes both the
Android operating system and the Dalvik Virtual Machine, the plat-
form on which marketplace apps are run. The runtime system im-
plements several types of behaviors that affect energy consumption
of an app, thread switching, garbage collection, and tail energy.
However, the details of the duration, frequency, and timing of these
events is, by design, hidden from the app. This makes it difﬁcult
to correctly attribute energy at the source level. Although it would
be straightforward to modify the runtime systems to track these
events, this would introduce considerable overhead and reduce the
portability of the approach, as it would be necessary to provide
custom runtime systems for each smartphone platform. Therefore,
one challenge for our approach is to account for these events with
information that is available at the app layer.

Thread switching causes several problems for calculating source
line level energy. The ﬁrst problem is that any energy measure-
ments for a given time period may also include energy for threads
that are not related to the application (i.e.,, operating system pro-
cesses). For example, at any point in the execution of the thread
in runBackgroundSync or getNetworkTime, the OS could
swap in a thread from another app or the OS. Any power samples
during this time would likely include instructions from both the
original and swapped-in thread. The second problem is that thread

p r i v a t e void

runBackgroundSync ( E x e c u t o r
long n e t w o r k T i m e M i l l i s ;
t r y {

n e t w o r k T i m e M i l l i s =

c a l l b a c k E x e c u t o r ) {

mNetworkTimeProvider . getNetworkTime ( ) ;

} catch ( I O E x c e p t i o n e ) {

Log .w(LOG_TAG, "Failed to obtain network " +
"time due to connectivity issues" ) ;

c a l l b a c k E x e c u t o r . e x e c u t e ( new Runnable ( ) {

@Override
p u b l i c void run ( ) {

f i n i s h ( R e s u l t . ERROR_CONNECTIVITY_ISSUE ) ;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

}
} ) ;
return ;

}

Program 2: Google Authenticator Method 2

switching itself introduces an energy overhead. For example, Line
10 of Program 2 will incur a signiﬁcant energy overhead for the
context switch that occurs when a new thread is started.

Periodically, the Android operating system will perform garbage
collection during the execution of an application. Typically, ap-
plications do not have control over garbage collection, it is man-
aged by the operating system and can occur anytime and within
any method. Although the Dalvik virtual machine logs garbage
collection, it timestamps the events via a millisecond based clock,
which does not provide enough precision to determine in which
path they occur (paths are tracked with nanosecond timestamps.)
As we note in Section 3.2.2, garbage collection incurs a signiﬁ-
cant energy cost and has the potential to signiﬁcantly distort en-
ergy measurements for an application. For example, consider if
garbage collection were to occur at line 20 of Program 1, which is
compiled as a simple jump on equality (ifeq), or line 6 of Pro-
gram 2, which is a relatively expensive method invocation. The
extremely high cost of the garbage collection would dwarf the cost
of both instructions making them appear to have a nearly identical
high energy cost. Therefore, an approach must be able to identify
and properly account for garbage collection while calculating the
source line level energy consumption of an application.

Smartphones exhibit tail energy usage, where certain hardware
components are optimistically kept active by the operating system,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. Tail energy manifests itself in two differ-
ent ways. The ﬁrst way is when an invocation to an API accesses a
hardware component and then returns. Even when no other invoca-
tions access the component, the component will remain active for
a time period Ttail and consume energy Etail. An example of this
kind of invocation is at line 7 of Program 1. The call to the network
will cause the radio to remain on for a period of time, even after
the request is ﬁnished, and consume energy during this time. The
second way is when two invocations access the component in se-
quence and the time interval between them is less than Ttail. Here,
only a portion of Etail will be consumed. The Etail for certain de-
vices can be quite high and a naive approach to measurement might
attribute the tail energy cost to subsequently executed instructions.
Referring back to the example invocation, the naive approach could
mistakenly attribute part of the invocation’s tail energy to its suc-
cessors, lines 16, 18, and 20, (depending on the length of its Ttail)
instead of to line 7. To be accurate, an approach must recognize
when tail energy occurs and attribute it to the source invocations
that started the component and kept it at a non-idle state.

2.3 Software-Level Challenges

Source level calculations require precise information about an
app’s execution. In particular, for each time period represented by
a power sample, it is necessary to know which instructions were
executed, their frequency, and their ordering — essentially, path
information. The primary challenge is that obtaining this type of
information at the software level is generally expensive and intru-
sive. For example, inserting instrumentation into an app to iso-
late and measure individual instructions can lead to high overhead.
Even optimizations, such as only instrumenting each basic block,
would still produce a high amount of instrumentation. Other ap-
proaches, such as instruction counting, do not allow developers to
know which instances of the instructions were executed.

It is also necessary to have precise information about API invoca-
tions. During execution, smartphone applications generally invoke
library functions and APIs to access hardware components, such
as GPS, network, and WiFi. For example, at line 7 of Program 1,
getNetworkTime() sends an HTTP request to Google by in-
voking HttpClient.execute(). This invocation consumes
a relatively large amount of energy due to its use of the network.
In contrast, a call to dataheader.getValue at line 24 of Pro-
gram 1, incurs a relatively small constant cost, since it is simply
returning the value of an HTTP header. This wide range of invo-
cation behavior causes problems for techniques that naively apply
statistical sampling or averaging-based approaches because, unlike
normal instructions, an invocation’s energy cost can vary based on
its target and the data provided for its arguments. Furthermore, it is
not feasible to precompute the cost of API calls, since that requires
sampling every point in each API calls input space to determine its
energy consumption.
3. APPROACH

The goal of our approach is to provide source line level energy
information for smartphone applications. An overview of our ap-
proach is shown in Figure 1. From a high-level, our approach has
two phases, Runtime Measurement and Ofﬂine Analysis. The in-
puts to the Runtime Measurement phase are the application under
analysis (AUA) and a set of use cases for which the tester wants
to obtain energy measurements. The App Instrumenter uses an
efﬁcient path proﬁling technique to guide the insertion of probes
into the AUA that will capture timestamps and path traversal infor-
mation. The tester executes the instrumented AUA on the Power
Measurement Platform. This causes the instrumentation to record
path information while the Power Measurement Platform records
power samples. The path and power samples are the inputs for the
Ofﬂine Analysis phase. The Path Adjuster performs a static anal-
ysis of the paths and makes modiﬁcations to the power samples to
account for the high-energy events. Then the Analyzer performs
the regression analysis in order to calculate each source line’s en-
ergy consumption. If the Analyzer ﬁnds there are not enough data
points to solve the regression analysis, then the process returns to
the Runtime Measurement phase so the developer can further exe-
cute the application. If this is not possible, then the Analyzer per-
forms approximations that we discuss in Section 3.2.2. Finally, the
Annotator uses the calculations to create graphical overlays of the
measurements on the source code for display in an integrated de-
velopment environment. We explain the approach in more detail in
the remainder of this section.
3.1 Runtime Measurement Phase

During the Runtime Measurement phase, information about the
paths executed in the AUA and power measurements are generated
by the approach. To do this, the App Instrumenter inserts probes

Figure 1: Overview of the approach

into the AUA to record the information, and then the instrumented
AUA is executed by the developer while power samples are col-
lected by the Power Measurement Platform. The output of the Run-
time Measurement phase is set of timestamped paths executed by
the AUA and power measurements.

Instrumentation of the AUA: The instrumentation collects in-
formation about the paths executed by the developer. Namely, which
paths are traversed, their frequency, and timestamps of the path
traversals and invocation of certain APIs. To record the path infor-
mation, the App Instrumenter adapts a techniques for efﬁcient path
proﬁling proposed by Ball and Larus [5]. The approach ﬁrst builds
a control-ﬂow graph (CFG) of each method in the AUA. Then each
edge in the CFG is assigned a label so that each unique path in the
CFG has a unique path ID. The approach then calculates a maxi-
mal spanning tree over the CFG and uses this to guide the minimal
placement of instrumentation that will increment a path ID counter.
By design, the approach can use a single counter to identify the path
traversed in the method. We extended the Ball-Larus approach to
handle nested method calls, concurrency, and exceptions. The App
Instrumenter also inserts a probe at the method entry to initialize
the method’s path counter, record a timestamp of when the path
traversal began, and the current thread ID. At each exit point of
the method, another probe records the value of the path ID counter,
and another timestamp. After execution is ﬁnished, this informa-
tion allows the approach to generate a set of path tuples of the form
(cid:104)thread_id, path_id, enter_time, exit_time(cid:105) where thread_id
identiﬁes current thread, path_id is the traversed ID for paths, and
enter_time and exit_time are the time stamps that indicate when
a path starts and ends.

The App Instrumenter also inserts probes to obtain timestamps
before and after the invocation of certain APIs. As we explain
in Section 3.2.1, this information is used to allocate tail energy
and isolate the energy cost of certain APIs for which it is not
possible to model using linear regression (i.e., methods that have
non constant energy consumption.) For each of the invocations,
the instrumentation generates an invocation tuple of the form
(cid:104)method_id, enter_time, exit_time(cid:105), where method_id iden-
tiﬁes the invoking method, and enter_time and exit_time are
timestamps before invoking the method and after the method has
returned.

Execution of the Instrumented AUA: To generate the path and
invocation tuples, the instrumented AUA is executed on the Power
Measurement Platform. The Power Measurement Platform is based
on the LEAP node [25]. The LEAP is an x86 platform based on an

ATOM N550 processor that runs Android 3.2. Each component
in the LEAP (e.g., WiFi, GPS, memory, and CPU) is connected
to an analog to digital converter (DAQ) that samples current draw
at 10KHz. The LEAP also provides Android applications with the
ability to trigger a synchronization signal. This allows the approach
to synchronize the samples with the paths’ timestamps and avoid
inaccuracy due to clock skew. Each of the uses cases is executed
by the developer on the AUA while it is running on the LEAP. Note
that all of the measurements are recorded in hardware external to
the Android smartphone components, so the measurement process
does not introduce any interference or execution overhead.
3.2 Ofﬂine Analysis Phase

In the Ofﬂine Analysis phase, our approach analyzes the tuples
and power samples generated in the Runtime Measurement phase
to produce a mapping of energy to source lines. There are three
parts to this phase.
In the ﬁrst part, the Path Adjuster statically
examines each traversed path in the CFG and adjusts the corre-
sponding energy measurements to account for special API invoca-
tions, tail energy, and interleaving threads. The adjusted energy
measurements and paths are the inputs to the second part, the Ana-
lyzer, which uses robust regression techniques to calculate the cost
of each source line and identify paths along which garbage col-
lection and thread context switches occurred. The Analyzer also
determines if the testing process created enough data points to per-
form the linear regression and either reduces the grouping of vari-
ables to be solved in the regression or directs the tester to repeat
the test cases to provide more data points. Finally, in the third part,
the Annotator creates a graphic representation of the energy mea-
surements and overlays this with the source code. Note that in the
rest of the paper, we describe our approach in terms of bytecode
instructions, but it is straightforward to convert the bytecode-level
information to source-level using compiler provided debugging in-
formation.
3.2.1 Adjustment to Path Energy Samples
Before beginning the analysis, the Path Adjuster ﬁrst reconstructs
the paths traversed during execution of the AUA. The instructions
executed in a path can be identiﬁed using the path ID and the
CFG of the method containing the path, as described by Ball and
Larus [5]. Once the paths have been reconstructed, the Path Ad-
juster calculates the energy total for the path by summing the mea-
surements reported during the path’s time of execution. The Path
Adjuster can identify the corresponding path and power samples
due to the synchronized timestamps. Then, the Path Adjuster per-

App Instrumenter Path Adjuster Analyzer Annotator Runtime Measurement Phase  Offline Analysis Phase Application (AUA) Use  cases Energy Report Power Measurement Platform Visualization {<paths>} {<power>} Insufficient data? AUA´ forms a static analysis of each path in order to adjust certain API
invocations due to non-constant and too-short API invocations, tail
energy, and thread interleaving. The Path Adjuster generates a
set of paths with the adjusted invocations removed from the paths
and their corresponding energy removed from the power measure-
ments.

API Invocations: Certain API invocations have a non-constant
energy cost associated with their execution. Therefore, it is not
possible to calculate their energy cost using the robust linear re-
gression techniques described in Section 3.2.2. To address this
problem, our approach uses the invocation tuples to identify the
time periods when these invocations are executing and calculates
the invocations’ energy cost by summing the power measurements
taken during that time.

Figure 2: Using longer execution windows for calculating the
energy of invocations with a short execution time.

In most cases, the execution time of an invocation is long enough
that the approach is able to get accurate energy measurements (i.e.,
the execution time is longer than several sampling periods.) How-
ever, in some cases the execution time of the invocation is too brief
(e.g., the execution time is shorter than a sampling period.) For
these invocations, the approach identiﬁes an execution time period
that includes the too short execution and for which the approach
does have enough power samples to accurately the energy con-
sumption. Then it calculates the ratio of the original execution time
versus the larger execution time and multiples that against the en-
ergy total for the larger execution time. To illustrate, consider the
example shown in Figure 2. In this ﬁgure, the horizontal bars in-
dicate the energy sampling interval. For example, the LEAP will
sample the power at t3 and then again at t4. If an invocation I exe-
cutes from time t1 until time t2, then there are no power samples to
be summed in order to ﬁnd the energy consumed by I (EI). When
this occurs, the Path Adjuster ﬁnds the next largest execution win-
dow for which it has sufﬁcient energy samples and uses this win-
dow to calculate EI. In the case of the example, the Path Adjuster
calculates EI as shown in Equation 1, where Ea,b denotes the en-
ergy consumption measured by the Power Measurement Platform
during interval [a, b].

t2 − t1
t4 − t3

Et3,t4

(1)

Note that this only approximates EI. We have found that for
functions whose execution time is so short, this is a reasonable ap-
proximation. These functions consume a very small portion of the
overall energy expended at runtime, on average about 6% of the
total API energy cost. For the general case, where the execution
time is of sufﬁcient length, our evaluation shows that we are able to
accurately measure most functions to within 9% of their measured
ground truth cost.

Figure 3: API invocations with tail energy

Tail Energy: As explained in Section 2, tail energy occurs when
the operating system keeps certain hardware components active,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. The result of this behavior is that the en-
ergy measurements for the time period following the component
access will be higher. Our approach adjusts the path energy total so
that the tail energy is attributed to the invocations that interact with
the hardware component. We assume the availability of tail energy
models, which are generally provided by either component manu-
facturers or power researchers [24]. The model speciﬁes the energy
consumption of the component after an invocation (Etail) and for
how long the device driver maintains this state (Ttail). To calcu-
late the adjustment, the Path Adjuster examines the reconstructed
paths to identify the sequence AD of invocations to methods that
cause tail energy for each device D of the smartphone. For each
such invocation ai ∈ AD, the adjuster compares the timestamp of
ai against the timestamp of ai+1. If the difference is greater than
Ttail then all of Etail is attributed to ai. If the difference is less
than Ttail then only a fraction of Etail is expended before ai+1
occurs and should be attributed to ai. The fraction is calculated as
shown in Equation 2, where TS returns the starting timestamp of an
invocation and TE returns the ending timestamp of an invocation.
Note that the invocation timestamps are known due to the invoca-
tion tuples collected during the Runtime Measurement phase.

TS(ai+1) − TE(ai)

Ttail

Etail

(2)

To illustrate these two scenarios, consider the two invocations
shown in Figure 3. Both of these, AP I_1 and AP I_2, access
the same device in sequence. Their tail energy consumptions are
shown as curved lines extending after the end of the invocations.
To calculate the tail energy associated with AP I_1, note that t2,
the start of the invocation to AP I_2, occurs before the Ttail time
has transpired. Therefore the tail energy assigned to AP I_1 is
t3−t1 ∗ Etail. When the invocation to AP I_2 returns
calculated as t2−t1
at t4, there is no other API accessing the same external device, so
we assign all of Etail, to AP I_2.

Thread Context-Switching During Invocations: A potential
problem that arises with the way the approach attributes energy to
API invocations is that it is possible for the thread containing the
invocation be switched out for another thread from the same appli-
cation. For example, this can happen because the invocation must
wait for a shared resource or another thread has higher priority.
The problem is that energy consumption by the other threads will
then also be measured in the corresponding power samples. As we
discussed earlier, this situation can be detected by modifying the
operating system to accurately track thread scheduling. However,
this would make the approach less portable, so we have devised a
software-level technique to address this problem.

ticular, the Analyzer uses RLR based on M-estimation [13], which
does iterative regression analysis. It begins by solving a normal
linear regression on the set of data points. Then at each iteration,
it calculates the residuals and gives each data point a weight based
on the standard deviations of the residuals. The regression analysis
is repeated on the weighted data to generate a new model and the
process repeats until the standard deviation of residuals does not
change between iterations. For the power samples, RLR is prefer-
able over the well-known ordinary least squares approach because
it is more robust in the presence of outliers. In this case, our data
sample has outliers, which are the paths whose energy measure-
ments are inﬂuenced by garbage collection and thread switching.

More speciﬁcally, at each iteration, given the linear function (cid:126)y =
X(cid:126)θ + (cid:126)u, the Analyzer solves Equation 3 and updates the standard
deviation of residuals. For the weighting function (ψ), we use
the well-known Tukey’s Bisquare function [37], which is shown
in Equation 4. The σ is the standard deviation of residuals in the
last iteration. The value of k is constant and is set according to
different use cases. In our experiments, we found that the average
energy cost of garbage collection and thread switching is about 10
to 70 times the average standard deviation of the residuals in the
ﬁrst iteration; therefore, we select the median 40 of this range as k.

(cid:88)
ψ(yi −(cid:88)
(cid:40)

k

i

ψk(x) =

xikθk)xij = 0

x(kσ − x2)2 −kσ < x < kσ
0

otherwise

(3)

(4)

The solution represents the energy cost of each instruction in the
path. Taken together with the measured energy cost of the invoca-
tions, the Analyzer now has the energy cost for the entire path. The
values for all of the paths are provided as input to the Annotator.
Two special cases are discussed below.

The ﬁrst special case is when it is not possible to solve for a
path’s instruction energy (i.e., m). This happens when the number
of unique bytecodes in a path is higher than the number of indepen-
dent data points. Solving linear system of equations requires that
there be at least as many independent data points as unknown vari-
ables. In this situation, the Analyzer recognizes that there are not
enough data points and can take two actions, which are repeated
until the equation is solvable. The ﬁrst is that the tester is notiﬁed
that the application should be executed more to generate additional
data points. The additional executions do not need to exactly repro-
duce the initial executions, but should represent similar use cases
to ensure a signiﬁcant amount of path overlap. Since this is not
always possible, the second possible action for the Analyzer is to
group counts of similar bytecodes. For example, all variations of
the iconst instruction. This gives fewer unknown variables for
the system of equations. Note that in our experience, even moder-
ate size marketplace apps were sufﬁciently complex that neither of
these actions were required in our evaluation.

The second special case are paths identiﬁed as outliers, which
contain external thread switching or garbage collection. The de-
tection of these outliers is discussed more below. Currently, the
Analyzer excludes these paths, which comprise about 1% of the
total path count. Although it is desirable to include these paths,
since excessive high-energy events could be a symptom of energy
inefﬁcient coding, there are two obstacles to this that we hope to
address in future work. First, the path must be adjusted to remove
the energy cost of the high-energy event. However, because the
measured energy of these events is so high compared to the path
energy, it is not clear how to accurately estimate and separate the

Figure 4: Concurrent threads during an API invocation.

The Path Adjuster determines the number of threads that were
executing while the invocation was executing. This is done by ex-
amining the starting and ending timestamps of each path tuple to
see which ones were active between the invocation’s timestamps.
Then, the Path Adjuster evenly allocates the energy among the con-
N , where N is the
current threads, assigning each the energy of 1
number of concurrent threads. To illustrate, consider the example
shown in Figure 4. T 1 is the original thread and contains an API
invocation at time t1. Threads T 2 and T 3 run while T 1 is per-
forming the invocation. T 1 and T 2 are concurrent in time interval
[t2, t3] and all three are concurrent in [t3, t4]. Therefore, the en-
ergy of T 1 will be Et1,t2 + 1
3 Et3,t4. This is similar to the
way prior approaches have handled concurrent thread energy [24].

2 Et2,t3 + 1

3.2.2 Calculating Source Line Energy Values
The second part of the Ofﬂine Analysis phase calculates the en-
ergy consumption of each source line. The input to the Analyzer
is the set of adjusted paths and energy samples produced by the
the Path Adjuster. At this point, adjustments for all of the API in-
vocations have been made, but the paths could still be inﬂuenced
by the occurrence of garbage collection and thread switching dur-
ing times when there is no API invocation. As we discussed in
Section 2, the energy costs associated with events, such as garbage
collection and thread switching, can skew the regression analysis,
but it is difﬁcult to identify when they occur. Our insight is that
characteristics of these events allow us to deﬁne them as statisti-
cal outliers and therefore the Analyzer can employ Robust Linear
Regression techniques to calculate each source lines’ energy con-
sumption and mitigate the inﬂuence of these high-energy events. In
the rest of this section, we ﬁrst explain the regression technique and
then discuss the insight that allows us to deﬁne garbage collection
and thread switching as statistical outliers.
Robust Linear Regression Analysis

The Analyzer uses linear regression analysis to calculate each
instruction’s energy consumption. We expect linear regression to
work well in this situation because prior work has found that the
cost of bytecodes will be constant given a particular hardware envi-
ronment [12, 29] and the Path Adjuster has removed the non-linear
cost invocations.

To perform the analysis, the Analyzer sets up the equations E =
mX, where E is the adjusted power measurements, X represents
the path traversals with each row representing a frequency vector of
bytecodes present in the measured path. (Note that the bytecodes
associated with the inserted instrumentation are included in this
matrix. Since the approach knows which paths were instrumented,
the associated results are simply removed before visualizing or re-
porting the ﬁnal source line level calculations.) Then the Analyzer
solves for the coefﬁcients m to determine the energy consumed by
the instructions in the path segment. To solve the equations, the An-
alyzer employs Robust Linear Regression (RLR) analysis. In par-

Table 1: Subject applications

App
BBC Reader
Bubble Blaster II
Classic Alchemy
Skyﬁre
Textgram

C
590
932
751
684
632

M

4,923
6,060
4,434
3,976
5,315

BC

Application Information
Description
RSS reader for BBC news
Game to blast bubbles
Educational game

293,910
398,437
467,099
274,196 Web-browser
244,940

Text editor

Figure 5: Visualization of the energy measurements.

event energy versus the path energy. Second, although the energy
associated with these events is signiﬁcant and of interest to devel-
opers, its not clear which instructions should be attributed with the
cost. Currently, this number is tracked and reported as a separate
total.
High-energy Events as Statistical Outliers

The energy overhead of switching to external threads and garbage
collection is quite high. Our experiments show that these events
range from 20,000 to 150,000 times the cost of a normal instruc-
tion. Yet they occur rarely during execution. Our insight is that
the high energy cost and relative infrequency of these high energy
events allows them to be detected as statistical outliers. In small
scale experiments, we found that the energy cost of a path ranges
from 0.007mJ to 0.631mJ; garbage collection from 20mJ to 81mJ;
and thread switching overhead from 6.44mJ to 11.3mJ. This means
that the energy cost of paths with garbage collection and thread
switching will be signiﬁcantly larger than normal paths — 10 to
over 10,000 times larger. This difference in the range of values al-
lows us to identify the events by deﬁning them as outliers based on
their energy consumption (i.e., by setting an appropriate value of k
in Tukey’s Bisquare function.) Note that our approach detects out-
liers for a speciﬁc path and does not simply cluster all of the energy
measurements. A per-path outlier detection is necessary since it is
possible for a path to be long enough that it consumes more energy
than garbage collection or thread switching. In the evaluation, we
validate this approach to detecting garbage collection and thread
switching by showing that our approach is able to detect all known
occurrences of these types of events.

3.2.3 Visualizing the Energy Consumption
The Annotator presents a graphical representation of the source
line level information. Developers can use this visualization to
more readily understand the distribution of energy consumption
across the different parts of their application. The Annotator was
developed as part of our prior work [12], so it is not a research
contribution of this paper. Nonetheless, we consider it an integral
aspect of our approach that increases its usability, so we brieﬂy
summarize its function.

The Annotator is an Eclipse plugin that overlays power informa-
tion onto an application’s source code. A screenshot is shown in
Figure 5. The visualization uses a SeeSoft [9] like graphical rep-
resentation where different colors indicate the amount of energy
consumed by source lines. The color for each source code line is
obtained by ranking each source line according to the sum of its
associated bytecode energy costs. The ranking is then mapped to a
color within the spectrum. In our example, blue shows low energy

consumption and red indicates a high level of energy consumption.
In between values are different levels of red and blue (purple.)

4. EVALUATION

We evaluated two aspects of our approach, analysis time and ac-
curacy. For the evaluation, we implemented our approach as a pro-
totype tool, vLens, and designed several experiments to evaluate
these two aspects. We considered two broad research questions:

RQ1: What amount of analysis time is incurred by vLens?
RQ2: How accurately does vLens calculate the energy consump-

tion of the application?
4.1 Subject Applications

In the evaluation, we used a set of ﬁve application from the
Google Play Market. Table 1 shows the number of classes (C),
methods (M), and bytecodes (BC) for each application. All of the
applications are written for the Dalvik Virtual Machine, do not use
any native libraries, and can be translated to and from Java Virtual
Machine bytecodes by the dex2jar tool. These applications rep-
resent real-world marketplace applications and implement a diverse
range of functionality. For all of the experiments, we ran the appli-
cations using canonical usage scenarios for each application. For
example, we played a game several times (Bubble Blaster II and
Classic Alchemy), created and edited a text document (Textgram),
read a news article via the reader (BBC Reader), and opened a web
page (Skyﬁre).
4.2

Implementation

The vLens prototype is written in Java and works for Android ap-
plications written to run on the Dalvik Virtual Machine. We chose
to implement for Android because its open nature made it easier
to understand the OS inner workings. However, our approach is
applicable for other platforms, such as Windows Phone and iOS,
since it relies on energy measurements provided by external hard-
ware, statistical techniques, and instrumentation, which is available
on many platforms.

There are four main modules in the implementation: the Power
Measurement Platform, App Instrumenter, Analyzer, and Annota-
tor. For the Power Measurement Platform we utilized the LEAP
power measurement device [25] described in Section 3.1. The App
Instrumenter uses BCEL [4] to build intra-procedural control ﬂow
graphs for the efﬁcient path proﬁling and insert the required instru-
mentation. We use dex2jar [1] to convert Dalvik bytecodes to
Java bytecodes; then after instrumentation, we compile the classes
back to Dalvik with the dx tool provided by the Android SDK. The
Analyzer uses R [3] for the robust linear regression functions and
Java code to perform the path adjustments. Finally, the Annotator
is based on an Eclipse visualization plugin we built for prior work
in energy estimation [12].

4.3 RQ1: Analysis Overhead

For the ﬁrst research question, we consider three aspects of the

Calculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36

an approach that combines hardware-based energy measurements
with program analysis and statistical modeling techniques. At a
high-level, the basic intuition is as follows: While measuring the
energy consumption of a smartphone, the approach uses efﬁcient
path proﬁling to identify which parts of the application are exe-
cuting and correlates these paths with the measured energy. Then,
the approach statically analyzes the paths to identify and adjust for
high-energy events, such as thread switching, before applying ro-
bust regression analysis to calculate each source line’s energy con-
sumption. Finally, the approach presents developers with a graph-
ical representation of the energy consumption by overlaying the
calculated energy with the source code of the application.

We also performed an empirical evaluation of our approach to
measure its accuracy and the time needed to perform the analysis.
Our approach was able to accurately calculate energy. For a set of
API invocations, we found that the calculated energy values were
within 10% of the ground truth measurements. The statistical mod-
els also matched the measured data very closely with a high R2
average of 0.93 and a low accumulated error rate. Importantly, in
our experiments, the approach was also able to detect the inﬂuence
of high-energy events, such as thread switching and garbage col-
lection, with 100% accuracy. The approach was also fast, it could
calculate source line level energy measurements for each of our
subject applications in less than three minutes. Overall, the results
of the evaluation were positive and indicate that our approach is an
effective and practical way to provide developers with source line
level energy information.

The remainder of this paper is organized as follows: In Section 2
we discuss several of the signiﬁcant challenges that shaped the de-
sign of our approach. We present the approach itself in Section 3.
The evaluation of the approach is described in Section 4. Finally,
we discuss related work and conclude in Sections 5 and 6.

2. BACKGROUND AND MOTIVATION

In this section we discuss several challenges to measuring and
calculating source line energy consumption. We break the chal-
lenges into three broad categories, hardware, runtime system, and
software level, and explain how they preclude a straightforward
solution for calculating source level energy consumption. To il-
lustrate these challenges, we make use of the code shown as Pro-
grams 1 and 2, which are excerpts from the open-source Google
Authenticator project that handles synchronizing a system clock.
In the example, method getNetworkTime (Program 1, line 1)
retrieves the time by sending an HTTP request to a timeserver
(line 7) and then parsing the response packet (lines 16, 20, 23,
26). Method runBackgroundSync (Program 2, line 2) calls the
getNetworkTime (line 6) and then starts a background thread
to handle errors (line 10).
2.1 Hardware Limitations

The primary hardware obstacle to directly measuring the energy
consumption of source lines is the difference in the speed at which
instructions execute and hardware devices can perform energy mea-
surements. On modern processors, individual instructions will ex-
ecute at a rate of several million per second. At best, power me-
ters can sample electrical power draw at several tens of KHz [16],
which means that each sample will include the power consumption
of hundreds, perhaps thousands, of instructions. For example, it
is possible for Program 2 to execute completely in the time that
transpires between two consecutive power samples by a relatively
fast power meter. There are reasons to believe that this order of
magnitude disparity will likely persist, since the bottleneck in high-
frequency power sampling is the storage system, which cannot save

p u b l i c long getNetworkTime ( )

throws

I O E x c e p t i o n {

HttpHead r e q u e s t = new HttpHead (URL ) ;
Log . i (LOG_TAG, "Sending request to "

+ r e q u e s t . getURI ( ) ) ;
H t t p R e s p o n s e h t t p R e s p o n s e ;
t r y {

h t t p R e s p o n s e = m H t t p C l i e n t . e x e c u t e ( r e q u e s t ) ;

} catch ( C l i e n t P r o t o c o l E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( S t r i n g . v a l u e O f ( e ) ) ;

} catch ( I O E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( "Failed due " +

"to connectivity issues: " + e ) ;

}

t r y {

Header d a t e H e a d e r =

h t t p R e s p o n s e . g e t L a s t H e a d e r ( "Date" ) ;

Log . i (LOG_TAG, "Received response with "

+"Date header: " + d a t e H e a d e r ) ;

i f

( d a t e H e a d e r == n u l l ) {

throw new I O E x c e p t i o n ( "No Date header" ) ;

}
S t r i n g d a t e H e a d e r V a l u e =

t ry {

Date networkDate =

d a t e H e a d e r . g e t V a l u e ( ) ;

D a t e U t i l s . p a r s e D a t e ( d a t e H e a d e r V a l u e ) ;

return networkDate . getTime ( ) ;

} catch ( D a t e P a r s e E x c e p t i o n e ) {

throw new I O E x c e p t i o n (

"Invalid Date header format " ) ;

}

} f i n a l l y {

. . . . . .

}

}

Program 1: Google Authenticator Method 1

power samples at the same frequency as the power meter can gen-
erate them [14, 15, 20], and there is no evidence to show that this
gap will be closed in the near future. Therefore, a challenge for our
approach is to reconcile power measurements samples and instruc-
tion execution, even though there is a several orders of magnitude
difference in their frequency.
2.2 Runtime System Challenges

The runtime system of an Android smartphone includes both the
Android operating system and the Dalvik Virtual Machine, the plat-
form on which marketplace apps are run. The runtime system im-
plements several types of behaviors that affect energy consumption
of an app, thread switching, garbage collection, and tail energy.
However, the details of the duration, frequency, and timing of these
events is, by design, hidden from the app. This makes it difﬁcult
to correctly attribute energy at the source level. Although it would
be straightforward to modify the runtime systems to track these
events, this would introduce considerable overhead and reduce the
portability of the approach, as it would be necessary to provide
custom runtime systems for each smartphone platform. Therefore,
one challenge for our approach is to account for these events with
information that is available at the app layer.

Thread switching causes several problems for calculating source
line level energy. The ﬁrst problem is that any energy measure-
ments for a given time period may also include energy for threads
that are not related to the application (i.e.,, operating system pro-
cesses). For example, at any point in the execution of the thread
in runBackgroundSync or getNetworkTime, the OS could
swap in a thread from another app or the OS. Any power samples
during this time would likely include instructions from both the
original and swapped-in thread. The second problem is that thread

p r i v a t e void

runBackgroundSync ( E x e c u t o r
long n e t w o r k T i m e M i l l i s ;
t r y {

n e t w o r k T i m e M i l l i s =

c a l l b a c k E x e c u t o r ) {

mNetworkTimeProvider . getNetworkTime ( ) ;

} catch ( I O E x c e p t i o n e ) {

Log .w(LOG_TAG, "Failed to obtain network " +
"time due to connectivity issues" ) ;

c a l l b a c k E x e c u t o r . e x e c u t e ( new Runnable ( ) {

@Override
p u b l i c void run ( ) {

f i n i s h ( R e s u l t . ERROR_CONNECTIVITY_ISSUE ) ;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

}
} ) ;
return ;

}

Program 2: Google Authenticator Method 2

switching itself introduces an energy overhead. For example, Line
10 of Program 2 will incur a signiﬁcant energy overhead for the
context switch that occurs when a new thread is started.

Periodically, the Android operating system will perform garbage
collection during the execution of an application. Typically, ap-
plications do not have control over garbage collection, it is man-
aged by the operating system and can occur anytime and within
any method. Although the Dalvik virtual machine logs garbage
collection, it timestamps the events via a millisecond based clock,
which does not provide enough precision to determine in which
path they occur (paths are tracked with nanosecond timestamps.)
As we note in Section 3.2.2, garbage collection incurs a signiﬁ-
cant energy cost and has the potential to signiﬁcantly distort en-
ergy measurements for an application. For example, consider if
garbage collection were to occur at line 20 of Program 1, which is
compiled as a simple jump on equality (ifeq), or line 6 of Pro-
gram 2, which is a relatively expensive method invocation. The
extremely high cost of the garbage collection would dwarf the cost
of both instructions making them appear to have a nearly identical
high energy cost. Therefore, an approach must be able to identify
and properly account for garbage collection while calculating the
source line level energy consumption of an application.

Smartphones exhibit tail energy usage, where certain hardware
components are optimistically kept active by the operating system,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. Tail energy manifests itself in two differ-
ent ways. The ﬁrst way is when an invocation to an API accesses a
hardware component and then returns. Even when no other invoca-
tions access the component, the component will remain active for
a time period Ttail and consume energy Etail. An example of this
kind of invocation is at line 7 of Program 1. The call to the network
will cause the radio to remain on for a period of time, even after
the request is ﬁnished, and consume energy during this time. The
second way is when two invocations access the component in se-
quence and the time interval between them is less than Ttail. Here,
only a portion of Etail will be consumed. The Etail for certain de-
vices can be quite high and a naive approach to measurement might
attribute the tail energy cost to subsequently executed instructions.
Referring back to the example invocation, the naive approach could
mistakenly attribute part of the invocation’s tail energy to its suc-
cessors, lines 16, 18, and 20, (depending on the length of its Ttail)
instead of to line 7. To be accurate, an approach must recognize
when tail energy occurs and attribute it to the source invocations
that started the component and kept it at a non-idle state.

2.3 Software-Level Challenges

Source level calculations require precise information about an
app’s execution. In particular, for each time period represented by
a power sample, it is necessary to know which instructions were
executed, their frequency, and their ordering — essentially, path
information. The primary challenge is that obtaining this type of
information at the software level is generally expensive and intru-
sive. For example, inserting instrumentation into an app to iso-
late and measure individual instructions can lead to high overhead.
Even optimizations, such as only instrumenting each basic block,
would still produce a high amount of instrumentation. Other ap-
proaches, such as instruction counting, do not allow developers to
know which instances of the instructions were executed.

It is also necessary to have precise information about API invoca-
tions. During execution, smartphone applications generally invoke
library functions and APIs to access hardware components, such
as GPS, network, and WiFi. For example, at line 7 of Program 1,
getNetworkTime() sends an HTTP request to Google by in-
voking HttpClient.execute(). This invocation consumes
a relatively large amount of energy due to its use of the network.
In contrast, a call to dataheader.getValue at line 24 of Pro-
gram 1, incurs a relatively small constant cost, since it is simply
returning the value of an HTTP header. This wide range of invo-
cation behavior causes problems for techniques that naively apply
statistical sampling or averaging-based approaches because, unlike
normal instructions, an invocation’s energy cost can vary based on
its target and the data provided for its arguments. Furthermore, it is
not feasible to precompute the cost of API calls, since that requires
sampling every point in each API calls input space to determine its
energy consumption.
3. APPROACH

The goal of our approach is to provide source line level energy
information for smartphone applications. An overview of our ap-
proach is shown in Figure 1. From a high-level, our approach has
two phases, Runtime Measurement and Ofﬂine Analysis. The in-
puts to the Runtime Measurement phase are the application under
analysis (AUA) and a set of use cases for which the tester wants
to obtain energy measurements. The App Instrumenter uses an
efﬁcient path proﬁling technique to guide the insertion of probes
into the AUA that will capture timestamps and path traversal infor-
mation. The tester executes the instrumented AUA on the Power
Measurement Platform. This causes the instrumentation to record
path information while the Power Measurement Platform records
power samples. The path and power samples are the inputs for the
Ofﬂine Analysis phase. The Path Adjuster performs a static anal-
ysis of the paths and makes modiﬁcations to the power samples to
account for the high-energy events. Then the Analyzer performs
the regression analysis in order to calculate each source line’s en-
ergy consumption. If the Analyzer ﬁnds there are not enough data
points to solve the regression analysis, then the process returns to
the Runtime Measurement phase so the developer can further exe-
cute the application. If this is not possible, then the Analyzer per-
forms approximations that we discuss in Section 3.2.2. Finally, the
Annotator uses the calculations to create graphical overlays of the
measurements on the source code for display in an integrated de-
velopment environment. We explain the approach in more detail in
the remainder of this section.
3.1 Runtime Measurement Phase

During the Runtime Measurement phase, information about the
paths executed in the AUA and power measurements are generated
by the approach. To do this, the App Instrumenter inserts probes

Figure 1: Overview of the approach

into the AUA to record the information, and then the instrumented
AUA is executed by the developer while power samples are col-
lected by the Power Measurement Platform. The output of the Run-
time Measurement phase is set of timestamped paths executed by
the AUA and power measurements.

Instrumentation of the AUA: The instrumentation collects in-
formation about the paths executed by the developer. Namely, which
paths are traversed, their frequency, and timestamps of the path
traversals and invocation of certain APIs. To record the path infor-
mation, the App Instrumenter adapts a techniques for efﬁcient path
proﬁling proposed by Ball and Larus [5]. The approach ﬁrst builds
a control-ﬂow graph (CFG) of each method in the AUA. Then each
edge in the CFG is assigned a label so that each unique path in the
CFG has a unique path ID. The approach then calculates a maxi-
mal spanning tree over the CFG and uses this to guide the minimal
placement of instrumentation that will increment a path ID counter.
By design, the approach can use a single counter to identify the path
traversed in the method. We extended the Ball-Larus approach to
handle nested method calls, concurrency, and exceptions. The App
Instrumenter also inserts a probe at the method entry to initialize
the method’s path counter, record a timestamp of when the path
traversal began, and the current thread ID. At each exit point of
the method, another probe records the value of the path ID counter,
and another timestamp. After execution is ﬁnished, this informa-
tion allows the approach to generate a set of path tuples of the form
(cid:104)thread_id, path_id, enter_time, exit_time(cid:105) where thread_id
identiﬁes current thread, path_id is the traversed ID for paths, and
enter_time and exit_time are the time stamps that indicate when
a path starts and ends.

The App Instrumenter also inserts probes to obtain timestamps
before and after the invocation of certain APIs. As we explain
in Section 3.2.1, this information is used to allocate tail energy
and isolate the energy cost of certain APIs for which it is not
possible to model using linear regression (i.e., methods that have
non constant energy consumption.) For each of the invocations,
the instrumentation generates an invocation tuple of the form
(cid:104)method_id, enter_time, exit_time(cid:105), where method_id iden-
tiﬁes the invoking method, and enter_time and exit_time are
timestamps before invoking the method and after the method has
returned.

Execution of the Instrumented AUA: To generate the path and
invocation tuples, the instrumented AUA is executed on the Power
Measurement Platform. The Power Measurement Platform is based
on the LEAP node [25]. The LEAP is an x86 platform based on an

ATOM N550 processor that runs Android 3.2. Each component
in the LEAP (e.g., WiFi, GPS, memory, and CPU) is connected
to an analog to digital converter (DAQ) that samples current draw
at 10KHz. The LEAP also provides Android applications with the
ability to trigger a synchronization signal. This allows the approach
to synchronize the samples with the paths’ timestamps and avoid
inaccuracy due to clock skew. Each of the uses cases is executed
by the developer on the AUA while it is running on the LEAP. Note
that all of the measurements are recorded in hardware external to
the Android smartphone components, so the measurement process
does not introduce any interference or execution overhead.
3.2 Ofﬂine Analysis Phase

In the Ofﬂine Analysis phase, our approach analyzes the tuples
and power samples generated in the Runtime Measurement phase
to produce a mapping of energy to source lines. There are three
parts to this phase.
In the ﬁrst part, the Path Adjuster statically
examines each traversed path in the CFG and adjusts the corre-
sponding energy measurements to account for special API invoca-
tions, tail energy, and interleaving threads. The adjusted energy
measurements and paths are the inputs to the second part, the Ana-
lyzer, which uses robust regression techniques to calculate the cost
of each source line and identify paths along which garbage col-
lection and thread context switches occurred. The Analyzer also
determines if the testing process created enough data points to per-
form the linear regression and either reduces the grouping of vari-
ables to be solved in the regression or directs the tester to repeat
the test cases to provide more data points. Finally, in the third part,
the Annotator creates a graphic representation of the energy mea-
surements and overlays this with the source code. Note that in the
rest of the paper, we describe our approach in terms of bytecode
instructions, but it is straightforward to convert the bytecode-level
information to source-level using compiler provided debugging in-
formation.
3.2.1 Adjustment to Path Energy Samples
Before beginning the analysis, the Path Adjuster ﬁrst reconstructs
the paths traversed during execution of the AUA. The instructions
executed in a path can be identiﬁed using the path ID and the
CFG of the method containing the path, as described by Ball and
Larus [5]. Once the paths have been reconstructed, the Path Ad-
juster calculates the energy total for the path by summing the mea-
surements reported during the path’s time of execution. The Path
Adjuster can identify the corresponding path and power samples
due to the synchronized timestamps. Then, the Path Adjuster per-

App Instrumenter Path Adjuster Analyzer Annotator Runtime Measurement Phase  Offline Analysis Phase Application (AUA) Use  cases Energy Report Power Measurement Platform Visualization {<paths>} {<power>} Insufficient data? AUA´ forms a static analysis of each path in order to adjust certain API
invocations due to non-constant and too-short API invocations, tail
energy, and thread interleaving. The Path Adjuster generates a
set of paths with the adjusted invocations removed from the paths
and their corresponding energy removed from the power measure-
ments.

API Invocations: Certain API invocations have a non-constant
energy cost associated with their execution. Therefore, it is not
possible to calculate their energy cost using the robust linear re-
gression techniques described in Section 3.2.2. To address this
problem, our approach uses the invocation tuples to identify the
time periods when these invocations are executing and calculates
the invocations’ energy cost by summing the power measurements
taken during that time.

Figure 2: Using longer execution windows for calculating the
energy of invocations with a short execution time.

In most cases, the execution time of an invocation is long enough
that the approach is able to get accurate energy measurements (i.e.,
the execution time is longer than several sampling periods.) How-
ever, in some cases the execution time of the invocation is too brief
(e.g., the execution time is shorter than a sampling period.) For
these invocations, the approach identiﬁes an execution time period
that includes the too short execution and for which the approach
does have enough power samples to accurately the energy con-
sumption. Then it calculates the ratio of the original execution time
versus the larger execution time and multiples that against the en-
ergy total for the larger execution time. To illustrate, consider the
example shown in Figure 2. In this ﬁgure, the horizontal bars in-
dicate the energy sampling interval. For example, the LEAP will
sample the power at t3 and then again at t4. If an invocation I exe-
cutes from time t1 until time t2, then there are no power samples to
be summed in order to ﬁnd the energy consumed by I (EI). When
this occurs, the Path Adjuster ﬁnds the next largest execution win-
dow for which it has sufﬁcient energy samples and uses this win-
dow to calculate EI. In the case of the example, the Path Adjuster
calculates EI as shown in Equation 1, where Ea,b denotes the en-
ergy consumption measured by the Power Measurement Platform
during interval [a, b].

t2 − t1
t4 − t3

Et3,t4

(1)

Note that this only approximates EI. We have found that for
functions whose execution time is so short, this is a reasonable ap-
proximation. These functions consume a very small portion of the
overall energy expended at runtime, on average about 6% of the
total API energy cost. For the general case, where the execution
time is of sufﬁcient length, our evaluation shows that we are able to
accurately measure most functions to within 9% of their measured
ground truth cost.

Figure 3: API invocations with tail energy

Tail Energy: As explained in Section 2, tail energy occurs when
the operating system keeps certain hardware components active,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. The result of this behavior is that the en-
ergy measurements for the time period following the component
access will be higher. Our approach adjusts the path energy total so
that the tail energy is attributed to the invocations that interact with
the hardware component. We assume the availability of tail energy
models, which are generally provided by either component manu-
facturers or power researchers [24]. The model speciﬁes the energy
consumption of the component after an invocation (Etail) and for
how long the device driver maintains this state (Ttail). To calcu-
late the adjustment, the Path Adjuster examines the reconstructed
paths to identify the sequence AD of invocations to methods that
cause tail energy for each device D of the smartphone. For each
such invocation ai ∈ AD, the adjuster compares the timestamp of
ai against the timestamp of ai+1. If the difference is greater than
Ttail then all of Etail is attributed to ai. If the difference is less
than Ttail then only a fraction of Etail is expended before ai+1
occurs and should be attributed to ai. The fraction is calculated as
shown in Equation 2, where TS returns the starting timestamp of an
invocation and TE returns the ending timestamp of an invocation.
Note that the invocation timestamps are known due to the invoca-
tion tuples collected during the Runtime Measurement phase.

TS(ai+1) − TE(ai)

Ttail

Etail

(2)

To illustrate these two scenarios, consider the two invocations
shown in Figure 3. Both of these, AP I_1 and AP I_2, access
the same device in sequence. Their tail energy consumptions are
shown as curved lines extending after the end of the invocations.
To calculate the tail energy associated with AP I_1, note that t2,
the start of the invocation to AP I_2, occurs before the Ttail time
has transpired. Therefore the tail energy assigned to AP I_1 is
t3−t1 ∗ Etail. When the invocation to AP I_2 returns
calculated as t2−t1
at t4, there is no other API accessing the same external device, so
we assign all of Etail, to AP I_2.

Thread Context-Switching During Invocations: A potential
problem that arises with the way the approach attributes energy to
API invocations is that it is possible for the thread containing the
invocation be switched out for another thread from the same appli-
cation. For example, this can happen because the invocation must
wait for a shared resource or another thread has higher priority.
The problem is that energy consumption by the other threads will
then also be measured in the corresponding power samples. As we
discussed earlier, this situation can be detected by modifying the
operating system to accurately track thread scheduling. However,
this would make the approach less portable, so we have devised a
software-level technique to address this problem.

ticular, the Analyzer uses RLR based on M-estimation [13], which
does iterative regression analysis. It begins by solving a normal
linear regression on the set of data points. Then at each iteration,
it calculates the residuals and gives each data point a weight based
on the standard deviations of the residuals. The regression analysis
is repeated on the weighted data to generate a new model and the
process repeats until the standard deviation of residuals does not
change between iterations. For the power samples, RLR is prefer-
able over the well-known ordinary least squares approach because
it is more robust in the presence of outliers. In this case, our data
sample has outliers, which are the paths whose energy measure-
ments are inﬂuenced by garbage collection and thread switching.

More speciﬁcally, at each iteration, given the linear function (cid:126)y =
X(cid:126)θ + (cid:126)u, the Analyzer solves Equation 3 and updates the standard
deviation of residuals. For the weighting function (ψ), we use
the well-known Tukey’s Bisquare function [37], which is shown
in Equation 4. The σ is the standard deviation of residuals in the
last iteration. The value of k is constant and is set according to
different use cases. In our experiments, we found that the average
energy cost of garbage collection and thread switching is about 10
to 70 times the average standard deviation of the residuals in the
ﬁrst iteration; therefore, we select the median 40 of this range as k.

(cid:88)
ψ(yi −(cid:88)
(cid:40)

k

i

ψk(x) =

xikθk)xij = 0

x(kσ − x2)2 −kσ < x < kσ
0

otherwise

(3)

(4)

The solution represents the energy cost of each instruction in the
path. Taken together with the measured energy cost of the invoca-
tions, the Analyzer now has the energy cost for the entire path. The
values for all of the paths are provided as input to the Annotator.
Two special cases are discussed below.

The ﬁrst special case is when it is not possible to solve for a
path’s instruction energy (i.e., m). This happens when the number
of unique bytecodes in a path is higher than the number of indepen-
dent data points. Solving linear system of equations requires that
there be at least as many independent data points as unknown vari-
ables. In this situation, the Analyzer recognizes that there are not
enough data points and can take two actions, which are repeated
until the equation is solvable. The ﬁrst is that the tester is notiﬁed
that the application should be executed more to generate additional
data points. The additional executions do not need to exactly repro-
duce the initial executions, but should represent similar use cases
to ensure a signiﬁcant amount of path overlap. Since this is not
always possible, the second possible action for the Analyzer is to
group counts of similar bytecodes. For example, all variations of
the iconst instruction. This gives fewer unknown variables for
the system of equations. Note that in our experience, even moder-
ate size marketplace apps were sufﬁciently complex that neither of
these actions were required in our evaluation.

The second special case are paths identiﬁed as outliers, which
contain external thread switching or garbage collection. The de-
tection of these outliers is discussed more below. Currently, the
Analyzer excludes these paths, which comprise about 1% of the
total path count. Although it is desirable to include these paths,
since excessive high-energy events could be a symptom of energy
inefﬁcient coding, there are two obstacles to this that we hope to
address in future work. First, the path must be adjusted to remove
the energy cost of the high-energy event. However, because the
measured energy of these events is so high compared to the path
energy, it is not clear how to accurately estimate and separate the

Figure 4: Concurrent threads during an API invocation.

The Path Adjuster determines the number of threads that were
executing while the invocation was executing. This is done by ex-
amining the starting and ending timestamps of each path tuple to
see which ones were active between the invocation’s timestamps.
Then, the Path Adjuster evenly allocates the energy among the con-
N , where N is the
current threads, assigning each the energy of 1
number of concurrent threads. To illustrate, consider the example
shown in Figure 4. T 1 is the original thread and contains an API
invocation at time t1. Threads T 2 and T 3 run while T 1 is per-
forming the invocation. T 1 and T 2 are concurrent in time interval
[t2, t3] and all three are concurrent in [t3, t4]. Therefore, the en-
ergy of T 1 will be Et1,t2 + 1
3 Et3,t4. This is similar to the
way prior approaches have handled concurrent thread energy [24].

2 Et2,t3 + 1

3.2.2 Calculating Source Line Energy Values
The second part of the Ofﬂine Analysis phase calculates the en-
ergy consumption of each source line. The input to the Analyzer
is the set of adjusted paths and energy samples produced by the
the Path Adjuster. At this point, adjustments for all of the API in-
vocations have been made, but the paths could still be inﬂuenced
by the occurrence of garbage collection and thread switching dur-
ing times when there is no API invocation. As we discussed in
Section 2, the energy costs associated with events, such as garbage
collection and thread switching, can skew the regression analysis,
but it is difﬁcult to identify when they occur. Our insight is that
characteristics of these events allow us to deﬁne them as statisti-
cal outliers and therefore the Analyzer can employ Robust Linear
Regression techniques to calculate each source lines’ energy con-
sumption and mitigate the inﬂuence of these high-energy events. In
the rest of this section, we ﬁrst explain the regression technique and
then discuss the insight that allows us to deﬁne garbage collection
and thread switching as statistical outliers.
Robust Linear Regression Analysis

The Analyzer uses linear regression analysis to calculate each
instruction’s energy consumption. We expect linear regression to
work well in this situation because prior work has found that the
cost of bytecodes will be constant given a particular hardware envi-
ronment [12, 29] and the Path Adjuster has removed the non-linear
cost invocations.

To perform the analysis, the Analyzer sets up the equations E =
mX, where E is the adjusted power measurements, X represents
the path traversals with each row representing a frequency vector of
bytecodes present in the measured path. (Note that the bytecodes
associated with the inserted instrumentation are included in this
matrix. Since the approach knows which paths were instrumented,
the associated results are simply removed before visualizing or re-
porting the ﬁnal source line level calculations.) Then the Analyzer
solves for the coefﬁcients m to determine the energy consumed by
the instructions in the path segment. To solve the equations, the An-
alyzer employs Robust Linear Regression (RLR) analysis. In par-

Table 1: Subject applications

App
BBC Reader
Bubble Blaster II
Classic Alchemy
Skyﬁre
Textgram

C
590
932
751
684
632

M

4,923
6,060
4,434
3,976
5,315

BC

Application Information
Description
RSS reader for BBC news
Game to blast bubbles
Educational game

293,910
398,437
467,099
274,196 Web-browser
244,940

Text editor

Figure 5: Visualization of the energy measurements.

event energy versus the path energy. Second, although the energy
associated with these events is signiﬁcant and of interest to devel-
opers, its not clear which instructions should be attributed with the
cost. Currently, this number is tracked and reported as a separate
total.
High-energy Events as Statistical Outliers

The energy overhead of switching to external threads and garbage
collection is quite high. Our experiments show that these events
range from 20,000 to 150,000 times the cost of a normal instruc-
tion. Yet they occur rarely during execution. Our insight is that
the high energy cost and relative infrequency of these high energy
events allows them to be detected as statistical outliers. In small
scale experiments, we found that the energy cost of a path ranges
from 0.007mJ to 0.631mJ; garbage collection from 20mJ to 81mJ;
and thread switching overhead from 6.44mJ to 11.3mJ. This means
that the energy cost of paths with garbage collection and thread
switching will be signiﬁcantly larger than normal paths — 10 to
over 10,000 times larger. This difference in the range of values al-
lows us to identify the events by deﬁning them as outliers based on
their energy consumption (i.e., by setting an appropriate value of k
in Tukey’s Bisquare function.) Note that our approach detects out-
liers for a speciﬁc path and does not simply cluster all of the energy
measurements. A per-path outlier detection is necessary since it is
possible for a path to be long enough that it consumes more energy
than garbage collection or thread switching. In the evaluation, we
validate this approach to detecting garbage collection and thread
switching by showing that our approach is able to detect all known
occurrences of these types of events.

3.2.3 Visualizing the Energy Consumption
The Annotator presents a graphical representation of the source
line level information. Developers can use this visualization to
more readily understand the distribution of energy consumption
across the different parts of their application. The Annotator was
developed as part of our prior work [12], so it is not a research
contribution of this paper. Nonetheless, we consider it an integral
aspect of our approach that increases its usability, so we brieﬂy
summarize its function.

The Annotator is an Eclipse plugin that overlays power informa-
tion onto an application’s source code. A screenshot is shown in
Figure 5. The visualization uses a SeeSoft [9] like graphical rep-
resentation where different colors indicate the amount of energy
consumed by source lines. The color for each source code line is
obtained by ranking each source line according to the sum of its
associated bytecode energy costs. The ranking is then mapped to a
color within the spectrum. In our example, blue shows low energy

consumption and red indicates a high level of energy consumption.
In between values are different levels of red and blue (purple.)

4. EVALUATION

We evaluated two aspects of our approach, analysis time and ac-
curacy. For the evaluation, we implemented our approach as a pro-
totype tool, vLens, and designed several experiments to evaluate
these two aspects. We considered two broad research questions:

RQ1: What amount of analysis time is incurred by vLens?
RQ2: How accurately does vLens calculate the energy consump-

tion of the application?
4.1 Subject Applications

In the evaluation, we used a set of ﬁve application from the
Google Play Market. Table 1 shows the number of classes (C),
methods (M), and bytecodes (BC) for each application. All of the
applications are written for the Dalvik Virtual Machine, do not use
any native libraries, and can be translated to and from Java Virtual
Machine bytecodes by the dex2jar tool. These applications rep-
resent real-world marketplace applications and implement a diverse
range of functionality. For all of the experiments, we ran the appli-
cations using canonical usage scenarios for each application. For
example, we played a game several times (Bubble Blaster II and
Classic Alchemy), created and edited a text document (Textgram),
read a news article via the reader (BBC Reader), and opened a web
page (Skyﬁre).
4.2

Implementation

The vLens prototype is written in Java and works for Android ap-
plications written to run on the Dalvik Virtual Machine. We chose
to implement for Android because its open nature made it easier
to understand the OS inner workings. However, our approach is
applicable for other platforms, such as Windows Phone and iOS,
since it relies on energy measurements provided by external hard-
ware, statistical techniques, and instrumentation, which is available
on many platforms.

There are four main modules in the implementation: the Power
Measurement Platform, App Instrumenter, Analyzer, and Annota-
tor. For the Power Measurement Platform we utilized the LEAP
power measurement device [25] described in Section 3.1. The App
Instrumenter uses BCEL [4] to build intra-procedural control ﬂow
graphs for the efﬁcient path proﬁling and insert the required instru-
mentation. We use dex2jar [1] to convert Dalvik bytecodes to
Java bytecodes; then after instrumentation, we compile the classes
back to Dalvik with the dx tool provided by the Android SDK. The
Analyzer uses R [3] for the robust linear regression functions and
Java code to perform the path adjustments. Finally, the Annotator
is based on an Eclipse visualization plugin we built for prior work
in energy estimation [12].

4.3 RQ1: Analysis Overhead

For the ﬁrst research question, we consider three aspects of the

Table 2: Time and Accuracy

Timing Measurements

Accuracy

App
BBC Reader
Bubble Blaster II
Classic Alchemy
Skyﬁre
Textgram

TI (s)
353
460
873
277
298

TA(s)

TR(%)

158
145
128
97
63

0.51
3.24
8.77
1.12
6.33

R2

0.94
0.90
0.93
0.99
0.92

AEE (%)

6.5
8.6
3.4
4.8
6.3

approach’s analysis time. These are: (1) time to instrument each
application (TI), (2) time to perform the ofﬂine analysis (TA), and
(3) runtime overhead introduced by the instrumentation (TR). Ex-
periments to measure the ﬁrst two were performed on a desktop
platform containing an Intel i3@2.1Ghz with 2GB RAM and run-
ning Ubuntu 12.04. Overhead was measured on the LEAP plat-
form.

To determine TI, we measured the time to instrument each ap-
plication with vLens. After running the application and collecting
the path and invocation tuples, we determined TA by measuring the
time to analyze the tuples, perform path adjustments, and calculate
each source line’s energy using the regression analysis. The results
of these measurements are shown, in seconds, in Table 2. The time
to instrument ranged from ﬁve to twelve minutes, and the time to
analyze ranged from one to just under three minutes. Most of the
instrumentation time was due to the computational cost of building
and analyzing the control ﬂow graphs for each of the methods. The
majority of the ofﬂine analysis cost was due to the IO overhead of
reading all of the path tuples into memory so they could be con-
verted to the path matrices. Further optimizations, such as caching
path information during the ofﬂine analysis, could reduce this cost
further. However, since vLens is intended to be an experimental
prototype, we did not implement these improvements.

To determine the runtime overhead of the instrumentation (TR)
we could not take the straightforward approach of comparing an in-
strumented version of each application against the uninstrumented
version. The reason for this is that a signiﬁcant amount of appli-
cation time is actually spent idle, waiting for user input or data.
The normal user variation in entering this data masks the instru-
mentation overhead variation. Therefore we calculate the non-idle
execution time of the instrumented application and then determine
the percentage of that time that is caused by the instrumentation. A
key insight to measuring non-idle time is that the Android operat-
ing system is event driven, so it idles waiting for user input after a
method exits, and then when it receives input, comes out of the idle
state and executes the event handler method. Therefore, we can
calculate the non-idle time of the application by summing up all of
the time during which an application path was being traversed. For
example if path p1 executed from time 1 to 3 and path p2 executed
from time 2 to 4, then we can calculate the non-idle time as 3 units.
Note that this properly counts a time unit once regardless of how
many threads are executing. Next, we proﬁled the instrumentation
code that was inserted into the application and determined its exe-
cution time TInst. By examining the path tuples, we also know the
execution frequency n of the instrumentation. The resulting calcu-
lation for TR is shown in Equation 5. Here the denominator is the
special time summation described above.
n ∗ TInst

TR =

∪Ti

(5)

The results of this calculation are shown in Table 2 as TR. The
overhead costs range from 0.51% to 8.77% with an average just
under 4%. Overall, this is a low runtime overhead, representing

about 0.15 seconds. Anecdotally, this amount of overhead did not
cause a noticeable delay to the testers during execution.
4.4 RQ2: Measurement Accuracy

For the second research question, we consider the accuracy of
the measurements calculated by vLens. The primary challenge in
this evaluation is that there is no source line ground truth against
which we can compare for accuracy. As discussed in Section 2,
power samplers cannot measure at a frequency high enough to cap-
ture individual source lines. Therefore, we show accuracy of the
approach in several other ways. First we examine the accuracy of
the energy attributed to the APIs. Second, we use statistical tests
to show that the regression analysis results can describe the over-
all energy consumption relationship accurately and that each path
also accurately accounts for its energy. Lastly, we show that our
technique for identifying high-energy events via statistical outlier
analysis correctly identiﬁes paths that contain these events.

Figure 6: Comparison of API energy cost

4.4.1 Accuracy of the API Energy Measurements
To measure the accuracy of the API energy measurements, we
compared their measured cost against a proﬁled cost. To obtain
the measured cost, we ran the apps using vLens and extracted the
cost of each invocation that was executed during the test runs. Al-
together, there were invocations to over 3,722 unique APIs. From
this group we focused on a group of twenty-four APIs whose in-
vocations together comprised more than 70% of the total invoca-
tion related energy consumed by the ﬁve applications. For these
twenty-four, we recorded the arguments and execution context of
the invocations and then proﬁled their energy cost. The proﬁling
was performed on the LEAP platform by executing each invoca-
tion 100 times and then measuring the energy consumed during the
execution. We repeated this proﬁling ﬁve times and calculated the
mean and standard deviation of the experiment. The proﬁled cost
was then compared against the cost calculated by vLens. The re-
sult of this comparison are shown in Figure 6. Each of the APIs
are listed along the X-axis and the two different costs are shown on
the Y-axis, the values on the Y-axis are normalized to the cost of
proﬁled cost. One standard deviation off of the proﬁling mean is
shown with the additional horizontal lines.

Figure 6 shows that for nineteen of the twenty-four APIs, the
vLens measured cost was within an average of 9% of the proﬁled
costs and the gap was within one standard deviation in almost all
cases. For the remaining ﬁve, the measured cost was off signiﬁ-
cantly. We investigated these APIs to determine what caused this
high error rate. The ﬁrst four APIs are synchronized, which means
that they invoke monitor_enter and monitor_exit. This

  0.00  0.50  1.00  1.50  2.00123456789101112131415161718192021222324Normalized EnergyvLensProfilingCalculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36

an approach that combines hardware-based energy measurements
with program analysis and statistical modeling techniques. At a
high-level, the basic intuition is as follows: While measuring the
energy consumption of a smartphone, the approach uses efﬁcient
path proﬁling to identify which parts of the application are exe-
cuting and correlates these paths with the measured energy. Then,
the approach statically analyzes the paths to identify and adjust for
high-energy events, such as thread switching, before applying ro-
bust regression analysis to calculate each source line’s energy con-
sumption. Finally, the approach presents developers with a graph-
ical representation of the energy consumption by overlaying the
calculated energy with the source code of the application.

We also performed an empirical evaluation of our approach to
measure its accuracy and the time needed to perform the analysis.
Our approach was able to accurately calculate energy. For a set of
API invocations, we found that the calculated energy values were
within 10% of the ground truth measurements. The statistical mod-
els also matched the measured data very closely with a high R2
average of 0.93 and a low accumulated error rate. Importantly, in
our experiments, the approach was also able to detect the inﬂuence
of high-energy events, such as thread switching and garbage col-
lection, with 100% accuracy. The approach was also fast, it could
calculate source line level energy measurements for each of our
subject applications in less than three minutes. Overall, the results
of the evaluation were positive and indicate that our approach is an
effective and practical way to provide developers with source line
level energy information.

The remainder of this paper is organized as follows: In Section 2
we discuss several of the signiﬁcant challenges that shaped the de-
sign of our approach. We present the approach itself in Section 3.
The evaluation of the approach is described in Section 4. Finally,
we discuss related work and conclude in Sections 5 and 6.

2. BACKGROUND AND MOTIVATION

In this section we discuss several challenges to measuring and
calculating source line energy consumption. We break the chal-
lenges into three broad categories, hardware, runtime system, and
software level, and explain how they preclude a straightforward
solution for calculating source level energy consumption. To il-
lustrate these challenges, we make use of the code shown as Pro-
grams 1 and 2, which are excerpts from the open-source Google
Authenticator project that handles synchronizing a system clock.
In the example, method getNetworkTime (Program 1, line 1)
retrieves the time by sending an HTTP request to a timeserver
(line 7) and then parsing the response packet (lines 16, 20, 23,
26). Method runBackgroundSync (Program 2, line 2) calls the
getNetworkTime (line 6) and then starts a background thread
to handle errors (line 10).
2.1 Hardware Limitations

The primary hardware obstacle to directly measuring the energy
consumption of source lines is the difference in the speed at which
instructions execute and hardware devices can perform energy mea-
surements. On modern processors, individual instructions will ex-
ecute at a rate of several million per second. At best, power me-
ters can sample electrical power draw at several tens of KHz [16],
which means that each sample will include the power consumption
of hundreds, perhaps thousands, of instructions. For example, it
is possible for Program 2 to execute completely in the time that
transpires between two consecutive power samples by a relatively
fast power meter. There are reasons to believe that this order of
magnitude disparity will likely persist, since the bottleneck in high-
frequency power sampling is the storage system, which cannot save

p u b l i c long getNetworkTime ( )

throws

I O E x c e p t i o n {

HttpHead r e q u e s t = new HttpHead (URL ) ;
Log . i (LOG_TAG, "Sending request to "

+ r e q u e s t . getURI ( ) ) ;
H t t p R e s p o n s e h t t p R e s p o n s e ;
t r y {

h t t p R e s p o n s e = m H t t p C l i e n t . e x e c u t e ( r e q u e s t ) ;

} catch ( C l i e n t P r o t o c o l E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( S t r i n g . v a l u e O f ( e ) ) ;

} catch ( I O E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( "Failed due " +

"to connectivity issues: " + e ) ;

}

t r y {

Header d a t e H e a d e r =

h t t p R e s p o n s e . g e t L a s t H e a d e r ( "Date" ) ;

Log . i (LOG_TAG, "Received response with "

+"Date header: " + d a t e H e a d e r ) ;

i f

( d a t e H e a d e r == n u l l ) {

throw new I O E x c e p t i o n ( "No Date header" ) ;

}
S t r i n g d a t e H e a d e r V a l u e =

t ry {

Date networkDate =

d a t e H e a d e r . g e t V a l u e ( ) ;

D a t e U t i l s . p a r s e D a t e ( d a t e H e a d e r V a l u e ) ;

return networkDate . getTime ( ) ;

} catch ( D a t e P a r s e E x c e p t i o n e ) {

throw new I O E x c e p t i o n (

"Invalid Date header format " ) ;

}

} f i n a l l y {

. . . . . .

}

}

Program 1: Google Authenticator Method 1

power samples at the same frequency as the power meter can gen-
erate them [14, 15, 20], and there is no evidence to show that this
gap will be closed in the near future. Therefore, a challenge for our
approach is to reconcile power measurements samples and instruc-
tion execution, even though there is a several orders of magnitude
difference in their frequency.
2.2 Runtime System Challenges

The runtime system of an Android smartphone includes both the
Android operating system and the Dalvik Virtual Machine, the plat-
form on which marketplace apps are run. The runtime system im-
plements several types of behaviors that affect energy consumption
of an app, thread switching, garbage collection, and tail energy.
However, the details of the duration, frequency, and timing of these
events is, by design, hidden from the app. This makes it difﬁcult
to correctly attribute energy at the source level. Although it would
be straightforward to modify the runtime systems to track these
events, this would introduce considerable overhead and reduce the
portability of the approach, as it would be necessary to provide
custom runtime systems for each smartphone platform. Therefore,
one challenge for our approach is to account for these events with
information that is available at the app layer.

Thread switching causes several problems for calculating source
line level energy. The ﬁrst problem is that any energy measure-
ments for a given time period may also include energy for threads
that are not related to the application (i.e.,, operating system pro-
cesses). For example, at any point in the execution of the thread
in runBackgroundSync or getNetworkTime, the OS could
swap in a thread from another app or the OS. Any power samples
during this time would likely include instructions from both the
original and swapped-in thread. The second problem is that thread

p r i v a t e void

runBackgroundSync ( E x e c u t o r
long n e t w o r k T i m e M i l l i s ;
t r y {

n e t w o r k T i m e M i l l i s =

c a l l b a c k E x e c u t o r ) {

mNetworkTimeProvider . getNetworkTime ( ) ;

} catch ( I O E x c e p t i o n e ) {

Log .w(LOG_TAG, "Failed to obtain network " +
"time due to connectivity issues" ) ;

c a l l b a c k E x e c u t o r . e x e c u t e ( new Runnable ( ) {

@Override
p u b l i c void run ( ) {

f i n i s h ( R e s u l t . ERROR_CONNECTIVITY_ISSUE ) ;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

}
} ) ;
return ;

}

Program 2: Google Authenticator Method 2

switching itself introduces an energy overhead. For example, Line
10 of Program 2 will incur a signiﬁcant energy overhead for the
context switch that occurs when a new thread is started.

Periodically, the Android operating system will perform garbage
collection during the execution of an application. Typically, ap-
plications do not have control over garbage collection, it is man-
aged by the operating system and can occur anytime and within
any method. Although the Dalvik virtual machine logs garbage
collection, it timestamps the events via a millisecond based clock,
which does not provide enough precision to determine in which
path they occur (paths are tracked with nanosecond timestamps.)
As we note in Section 3.2.2, garbage collection incurs a signiﬁ-
cant energy cost and has the potential to signiﬁcantly distort en-
ergy measurements for an application. For example, consider if
garbage collection were to occur at line 20 of Program 1, which is
compiled as a simple jump on equality (ifeq), or line 6 of Pro-
gram 2, which is a relatively expensive method invocation. The
extremely high cost of the garbage collection would dwarf the cost
of both instructions making them appear to have a nearly identical
high energy cost. Therefore, an approach must be able to identify
and properly account for garbage collection while calculating the
source line level energy consumption of an application.

Smartphones exhibit tail energy usage, where certain hardware
components are optimistically kept active by the operating system,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. Tail energy manifests itself in two differ-
ent ways. The ﬁrst way is when an invocation to an API accesses a
hardware component and then returns. Even when no other invoca-
tions access the component, the component will remain active for
a time period Ttail and consume energy Etail. An example of this
kind of invocation is at line 7 of Program 1. The call to the network
will cause the radio to remain on for a period of time, even after
the request is ﬁnished, and consume energy during this time. The
second way is when two invocations access the component in se-
quence and the time interval between them is less than Ttail. Here,
only a portion of Etail will be consumed. The Etail for certain de-
vices can be quite high and a naive approach to measurement might
attribute the tail energy cost to subsequently executed instructions.
Referring back to the example invocation, the naive approach could
mistakenly attribute part of the invocation’s tail energy to its suc-
cessors, lines 16, 18, and 20, (depending on the length of its Ttail)
instead of to line 7. To be accurate, an approach must recognize
when tail energy occurs and attribute it to the source invocations
that started the component and kept it at a non-idle state.

2.3 Software-Level Challenges

Source level calculations require precise information about an
app’s execution. In particular, for each time period represented by
a power sample, it is necessary to know which instructions were
executed, their frequency, and their ordering — essentially, path
information. The primary challenge is that obtaining this type of
information at the software level is generally expensive and intru-
sive. For example, inserting instrumentation into an app to iso-
late and measure individual instructions can lead to high overhead.
Even optimizations, such as only instrumenting each basic block,
would still produce a high amount of instrumentation. Other ap-
proaches, such as instruction counting, do not allow developers to
know which instances of the instructions were executed.

It is also necessary to have precise information about API invoca-
tions. During execution, smartphone applications generally invoke
library functions and APIs to access hardware components, such
as GPS, network, and WiFi. For example, at line 7 of Program 1,
getNetworkTime() sends an HTTP request to Google by in-
voking HttpClient.execute(). This invocation consumes
a relatively large amount of energy due to its use of the network.
In contrast, a call to dataheader.getValue at line 24 of Pro-
gram 1, incurs a relatively small constant cost, since it is simply
returning the value of an HTTP header. This wide range of invo-
cation behavior causes problems for techniques that naively apply
statistical sampling or averaging-based approaches because, unlike
normal instructions, an invocation’s energy cost can vary based on
its target and the data provided for its arguments. Furthermore, it is
not feasible to precompute the cost of API calls, since that requires
sampling every point in each API calls input space to determine its
energy consumption.
3. APPROACH

The goal of our approach is to provide source line level energy
information for smartphone applications. An overview of our ap-
proach is shown in Figure 1. From a high-level, our approach has
two phases, Runtime Measurement and Ofﬂine Analysis. The in-
puts to the Runtime Measurement phase are the application under
analysis (AUA) and a set of use cases for which the tester wants
to obtain energy measurements. The App Instrumenter uses an
efﬁcient path proﬁling technique to guide the insertion of probes
into the AUA that will capture timestamps and path traversal infor-
mation. The tester executes the instrumented AUA on the Power
Measurement Platform. This causes the instrumentation to record
path information while the Power Measurement Platform records
power samples. The path and power samples are the inputs for the
Ofﬂine Analysis phase. The Path Adjuster performs a static anal-
ysis of the paths and makes modiﬁcations to the power samples to
account for the high-energy events. Then the Analyzer performs
the regression analysis in order to calculate each source line’s en-
ergy consumption. If the Analyzer ﬁnds there are not enough data
points to solve the regression analysis, then the process returns to
the Runtime Measurement phase so the developer can further exe-
cute the application. If this is not possible, then the Analyzer per-
forms approximations that we discuss in Section 3.2.2. Finally, the
Annotator uses the calculations to create graphical overlays of the
measurements on the source code for display in an integrated de-
velopment environment. We explain the approach in more detail in
the remainder of this section.
3.1 Runtime Measurement Phase

During the Runtime Measurement phase, information about the
paths executed in the AUA and power measurements are generated
by the approach. To do this, the App Instrumenter inserts probes

Figure 1: Overview of the approach

into the AUA to record the information, and then the instrumented
AUA is executed by the developer while power samples are col-
lected by the Power Measurement Platform. The output of the Run-
time Measurement phase is set of timestamped paths executed by
the AUA and power measurements.

Instrumentation of the AUA: The instrumentation collects in-
formation about the paths executed by the developer. Namely, which
paths are traversed, their frequency, and timestamps of the path
traversals and invocation of certain APIs. To record the path infor-
mation, the App Instrumenter adapts a techniques for efﬁcient path
proﬁling proposed by Ball and Larus [5]. The approach ﬁrst builds
a control-ﬂow graph (CFG) of each method in the AUA. Then each
edge in the CFG is assigned a label so that each unique path in the
CFG has a unique path ID. The approach then calculates a maxi-
mal spanning tree over the CFG and uses this to guide the minimal
placement of instrumentation that will increment a path ID counter.
By design, the approach can use a single counter to identify the path
traversed in the method. We extended the Ball-Larus approach to
handle nested method calls, concurrency, and exceptions. The App
Instrumenter also inserts a probe at the method entry to initialize
the method’s path counter, record a timestamp of when the path
traversal began, and the current thread ID. At each exit point of
the method, another probe records the value of the path ID counter,
and another timestamp. After execution is ﬁnished, this informa-
tion allows the approach to generate a set of path tuples of the form
(cid:104)thread_id, path_id, enter_time, exit_time(cid:105) where thread_id
identiﬁes current thread, path_id is the traversed ID for paths, and
enter_time and exit_time are the time stamps that indicate when
a path starts and ends.

The App Instrumenter also inserts probes to obtain timestamps
before and after the invocation of certain APIs. As we explain
in Section 3.2.1, this information is used to allocate tail energy
and isolate the energy cost of certain APIs for which it is not
possible to model using linear regression (i.e., methods that have
non constant energy consumption.) For each of the invocations,
the instrumentation generates an invocation tuple of the form
(cid:104)method_id, enter_time, exit_time(cid:105), where method_id iden-
tiﬁes the invoking method, and enter_time and exit_time are
timestamps before invoking the method and after the method has
returned.

Execution of the Instrumented AUA: To generate the path and
invocation tuples, the instrumented AUA is executed on the Power
Measurement Platform. The Power Measurement Platform is based
on the LEAP node [25]. The LEAP is an x86 platform based on an

ATOM N550 processor that runs Android 3.2. Each component
in the LEAP (e.g., WiFi, GPS, memory, and CPU) is connected
to an analog to digital converter (DAQ) that samples current draw
at 10KHz. The LEAP also provides Android applications with the
ability to trigger a synchronization signal. This allows the approach
to synchronize the samples with the paths’ timestamps and avoid
inaccuracy due to clock skew. Each of the uses cases is executed
by the developer on the AUA while it is running on the LEAP. Note
that all of the measurements are recorded in hardware external to
the Android smartphone components, so the measurement process
does not introduce any interference or execution overhead.
3.2 Ofﬂine Analysis Phase

In the Ofﬂine Analysis phase, our approach analyzes the tuples
and power samples generated in the Runtime Measurement phase
to produce a mapping of energy to source lines. There are three
parts to this phase.
In the ﬁrst part, the Path Adjuster statically
examines each traversed path in the CFG and adjusts the corre-
sponding energy measurements to account for special API invoca-
tions, tail energy, and interleaving threads. The adjusted energy
measurements and paths are the inputs to the second part, the Ana-
lyzer, which uses robust regression techniques to calculate the cost
of each source line and identify paths along which garbage col-
lection and thread context switches occurred. The Analyzer also
determines if the testing process created enough data points to per-
form the linear regression and either reduces the grouping of vari-
ables to be solved in the regression or directs the tester to repeat
the test cases to provide more data points. Finally, in the third part,
the Annotator creates a graphic representation of the energy mea-
surements and overlays this with the source code. Note that in the
rest of the paper, we describe our approach in terms of bytecode
instructions, but it is straightforward to convert the bytecode-level
information to source-level using compiler provided debugging in-
formation.
3.2.1 Adjustment to Path Energy Samples
Before beginning the analysis, the Path Adjuster ﬁrst reconstructs
the paths traversed during execution of the AUA. The instructions
executed in a path can be identiﬁed using the path ID and the
CFG of the method containing the path, as described by Ball and
Larus [5]. Once the paths have been reconstructed, the Path Ad-
juster calculates the energy total for the path by summing the mea-
surements reported during the path’s time of execution. The Path
Adjuster can identify the corresponding path and power samples
due to the synchronized timestamps. Then, the Path Adjuster per-

App Instrumenter Path Adjuster Analyzer Annotator Runtime Measurement Phase  Offline Analysis Phase Application (AUA) Use  cases Energy Report Power Measurement Platform Visualization {<paths>} {<power>} Insufficient data? AUA´ forms a static analysis of each path in order to adjust certain API
invocations due to non-constant and too-short API invocations, tail
energy, and thread interleaving. The Path Adjuster generates a
set of paths with the adjusted invocations removed from the paths
and their corresponding energy removed from the power measure-
ments.

API Invocations: Certain API invocations have a non-constant
energy cost associated with their execution. Therefore, it is not
possible to calculate their energy cost using the robust linear re-
gression techniques described in Section 3.2.2. To address this
problem, our approach uses the invocation tuples to identify the
time periods when these invocations are executing and calculates
the invocations’ energy cost by summing the power measurements
taken during that time.

Figure 2: Using longer execution windows for calculating the
energy of invocations with a short execution time.

In most cases, the execution time of an invocation is long enough
that the approach is able to get accurate energy measurements (i.e.,
the execution time is longer than several sampling periods.) How-
ever, in some cases the execution time of the invocation is too brief
(e.g., the execution time is shorter than a sampling period.) For
these invocations, the approach identiﬁes an execution time period
that includes the too short execution and for which the approach
does have enough power samples to accurately the energy con-
sumption. Then it calculates the ratio of the original execution time
versus the larger execution time and multiples that against the en-
ergy total for the larger execution time. To illustrate, consider the
example shown in Figure 2. In this ﬁgure, the horizontal bars in-
dicate the energy sampling interval. For example, the LEAP will
sample the power at t3 and then again at t4. If an invocation I exe-
cutes from time t1 until time t2, then there are no power samples to
be summed in order to ﬁnd the energy consumed by I (EI). When
this occurs, the Path Adjuster ﬁnds the next largest execution win-
dow for which it has sufﬁcient energy samples and uses this win-
dow to calculate EI. In the case of the example, the Path Adjuster
calculates EI as shown in Equation 1, where Ea,b denotes the en-
ergy consumption measured by the Power Measurement Platform
during interval [a, b].

t2 − t1
t4 − t3

Et3,t4

(1)

Note that this only approximates EI. We have found that for
functions whose execution time is so short, this is a reasonable ap-
proximation. These functions consume a very small portion of the
overall energy expended at runtime, on average about 6% of the
total API energy cost. For the general case, where the execution
time is of sufﬁcient length, our evaluation shows that we are able to
accurately measure most functions to within 9% of their measured
ground truth cost.

Figure 3: API invocations with tail energy

Tail Energy: As explained in Section 2, tail energy occurs when
the operating system keeps certain hardware components active,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. The result of this behavior is that the en-
ergy measurements for the time period following the component
access will be higher. Our approach adjusts the path energy total so
that the tail energy is attributed to the invocations that interact with
the hardware component. We assume the availability of tail energy
models, which are generally provided by either component manu-
facturers or power researchers [24]. The model speciﬁes the energy
consumption of the component after an invocation (Etail) and for
how long the device driver maintains this state (Ttail). To calcu-
late the adjustment, the Path Adjuster examines the reconstructed
paths to identify the sequence AD of invocations to methods that
cause tail energy for each device D of the smartphone. For each
such invocation ai ∈ AD, the adjuster compares the timestamp of
ai against the timestamp of ai+1. If the difference is greater than
Ttail then all of Etail is attributed to ai. If the difference is less
than Ttail then only a fraction of Etail is expended before ai+1
occurs and should be attributed to ai. The fraction is calculated as
shown in Equation 2, where TS returns the starting timestamp of an
invocation and TE returns the ending timestamp of an invocation.
Note that the invocation timestamps are known due to the invoca-
tion tuples collected during the Runtime Measurement phase.

TS(ai+1) − TE(ai)

Ttail

Etail

(2)

To illustrate these two scenarios, consider the two invocations
shown in Figure 3. Both of these, AP I_1 and AP I_2, access
the same device in sequence. Their tail energy consumptions are
shown as curved lines extending after the end of the invocations.
To calculate the tail energy associated with AP I_1, note that t2,
the start of the invocation to AP I_2, occurs before the Ttail time
has transpired. Therefore the tail energy assigned to AP I_1 is
t3−t1 ∗ Etail. When the invocation to AP I_2 returns
calculated as t2−t1
at t4, there is no other API accessing the same external device, so
we assign all of Etail, to AP I_2.

Thread Context-Switching During Invocations: A potential
problem that arises with the way the approach attributes energy to
API invocations is that it is possible for the thread containing the
invocation be switched out for another thread from the same appli-
cation. For example, this can happen because the invocation must
wait for a shared resource or another thread has higher priority.
The problem is that energy consumption by the other threads will
then also be measured in the corresponding power samples. As we
discussed earlier, this situation can be detected by modifying the
operating system to accurately track thread scheduling. However,
this would make the approach less portable, so we have devised a
software-level technique to address this problem.

ticular, the Analyzer uses RLR based on M-estimation [13], which
does iterative regression analysis. It begins by solving a normal
linear regression on the set of data points. Then at each iteration,
it calculates the residuals and gives each data point a weight based
on the standard deviations of the residuals. The regression analysis
is repeated on the weighted data to generate a new model and the
process repeats until the standard deviation of residuals does not
change between iterations. For the power samples, RLR is prefer-
able over the well-known ordinary least squares approach because
it is more robust in the presence of outliers. In this case, our data
sample has outliers, which are the paths whose energy measure-
ments are inﬂuenced by garbage collection and thread switching.

More speciﬁcally, at each iteration, given the linear function (cid:126)y =
X(cid:126)θ + (cid:126)u, the Analyzer solves Equation 3 and updates the standard
deviation of residuals. For the weighting function (ψ), we use
the well-known Tukey’s Bisquare function [37], which is shown
in Equation 4. The σ is the standard deviation of residuals in the
last iteration. The value of k is constant and is set according to
different use cases. In our experiments, we found that the average
energy cost of garbage collection and thread switching is about 10
to 70 times the average standard deviation of the residuals in the
ﬁrst iteration; therefore, we select the median 40 of this range as k.

(cid:88)
ψ(yi −(cid:88)
(cid:40)

k

i

ψk(x) =

xikθk)xij = 0

x(kσ − x2)2 −kσ < x < kσ
0

otherwise

(3)

(4)

The solution represents the energy cost of each instruction in the
path. Taken together with the measured energy cost of the invoca-
tions, the Analyzer now has the energy cost for the entire path. The
values for all of the paths are provided as input to the Annotator.
Two special cases are discussed below.

The ﬁrst special case is when it is not possible to solve for a
path’s instruction energy (i.e., m). This happens when the number
of unique bytecodes in a path is higher than the number of indepen-
dent data points. Solving linear system of equations requires that
there be at least as many independent data points as unknown vari-
ables. In this situation, the Analyzer recognizes that there are not
enough data points and can take two actions, which are repeated
until the equation is solvable. The ﬁrst is that the tester is notiﬁed
that the application should be executed more to generate additional
data points. The additional executions do not need to exactly repro-
duce the initial executions, but should represent similar use cases
to ensure a signiﬁcant amount of path overlap. Since this is not
always possible, the second possible action for the Analyzer is to
group counts of similar bytecodes. For example, all variations of
the iconst instruction. This gives fewer unknown variables for
the system of equations. Note that in our experience, even moder-
ate size marketplace apps were sufﬁciently complex that neither of
these actions were required in our evaluation.

The second special case are paths identiﬁed as outliers, which
contain external thread switching or garbage collection. The de-
tection of these outliers is discussed more below. Currently, the
Analyzer excludes these paths, which comprise about 1% of the
total path count. Although it is desirable to include these paths,
since excessive high-energy events could be a symptom of energy
inefﬁcient coding, there are two obstacles to this that we hope to
address in future work. First, the path must be adjusted to remove
the energy cost of the high-energy event. However, because the
measured energy of these events is so high compared to the path
energy, it is not clear how to accurately estimate and separate the

Figure 4: Concurrent threads during an API invocation.

The Path Adjuster determines the number of threads that were
executing while the invocation was executing. This is done by ex-
amining the starting and ending timestamps of each path tuple to
see which ones were active between the invocation’s timestamps.
Then, the Path Adjuster evenly allocates the energy among the con-
N , where N is the
current threads, assigning each the energy of 1
number of concurrent threads. To illustrate, consider the example
shown in Figure 4. T 1 is the original thread and contains an API
invocation at time t1. Threads T 2 and T 3 run while T 1 is per-
forming the invocation. T 1 and T 2 are concurrent in time interval
[t2, t3] and all three are concurrent in [t3, t4]. Therefore, the en-
ergy of T 1 will be Et1,t2 + 1
3 Et3,t4. This is similar to the
way prior approaches have handled concurrent thread energy [24].

2 Et2,t3 + 1

3.2.2 Calculating Source Line Energy Values
The second part of the Ofﬂine Analysis phase calculates the en-
ergy consumption of each source line. The input to the Analyzer
is the set of adjusted paths and energy samples produced by the
the Path Adjuster. At this point, adjustments for all of the API in-
vocations have been made, but the paths could still be inﬂuenced
by the occurrence of garbage collection and thread switching dur-
ing times when there is no API invocation. As we discussed in
Section 2, the energy costs associated with events, such as garbage
collection and thread switching, can skew the regression analysis,
but it is difﬁcult to identify when they occur. Our insight is that
characteristics of these events allow us to deﬁne them as statisti-
cal outliers and therefore the Analyzer can employ Robust Linear
Regression techniques to calculate each source lines’ energy con-
sumption and mitigate the inﬂuence of these high-energy events. In
the rest of this section, we ﬁrst explain the regression technique and
then discuss the insight that allows us to deﬁne garbage collection
and thread switching as statistical outliers.
Robust Linear Regression Analysis

The Analyzer uses linear regression analysis to calculate each
instruction’s energy consumption. We expect linear regression to
work well in this situation because prior work has found that the
cost of bytecodes will be constant given a particular hardware envi-
ronment [12, 29] and the Path Adjuster has removed the non-linear
cost invocations.

To perform the analysis, the Analyzer sets up the equations E =
mX, where E is the adjusted power measurements, X represents
the path traversals with each row representing a frequency vector of
bytecodes present in the measured path. (Note that the bytecodes
associated with the inserted instrumentation are included in this
matrix. Since the approach knows which paths were instrumented,
the associated results are simply removed before visualizing or re-
porting the ﬁnal source line level calculations.) Then the Analyzer
solves for the coefﬁcients m to determine the energy consumed by
the instructions in the path segment. To solve the equations, the An-
alyzer employs Robust Linear Regression (RLR) analysis. In par-

Table 1: Subject applications

App
BBC Reader
Bubble Blaster II
Classic Alchemy
Skyﬁre
Textgram

C
590
932
751
684
632

M

4,923
6,060
4,434
3,976
5,315

BC

Application Information
Description
RSS reader for BBC news
Game to blast bubbles
Educational game

293,910
398,437
467,099
274,196 Web-browser
244,940

Text editor

Figure 5: Visualization of the energy measurements.

event energy versus the path energy. Second, although the energy
associated with these events is signiﬁcant and of interest to devel-
opers, its not clear which instructions should be attributed with the
cost. Currently, this number is tracked and reported as a separate
total.
High-energy Events as Statistical Outliers

The energy overhead of switching to external threads and garbage
collection is quite high. Our experiments show that these events
range from 20,000 to 150,000 times the cost of a normal instruc-
tion. Yet they occur rarely during execution. Our insight is that
the high energy cost and relative infrequency of these high energy
events allows them to be detected as statistical outliers. In small
scale experiments, we found that the energy cost of a path ranges
from 0.007mJ to 0.631mJ; garbage collection from 20mJ to 81mJ;
and thread switching overhead from 6.44mJ to 11.3mJ. This means
that the energy cost of paths with garbage collection and thread
switching will be signiﬁcantly larger than normal paths — 10 to
over 10,000 times larger. This difference in the range of values al-
lows us to identify the events by deﬁning them as outliers based on
their energy consumption (i.e., by setting an appropriate value of k
in Tukey’s Bisquare function.) Note that our approach detects out-
liers for a speciﬁc path and does not simply cluster all of the energy
measurements. A per-path outlier detection is necessary since it is
possible for a path to be long enough that it consumes more energy
than garbage collection or thread switching. In the evaluation, we
validate this approach to detecting garbage collection and thread
switching by showing that our approach is able to detect all known
occurrences of these types of events.

3.2.3 Visualizing the Energy Consumption
The Annotator presents a graphical representation of the source
line level information. Developers can use this visualization to
more readily understand the distribution of energy consumption
across the different parts of their application. The Annotator was
developed as part of our prior work [12], so it is not a research
contribution of this paper. Nonetheless, we consider it an integral
aspect of our approach that increases its usability, so we brieﬂy
summarize its function.

The Annotator is an Eclipse plugin that overlays power informa-
tion onto an application’s source code. A screenshot is shown in
Figure 5. The visualization uses a SeeSoft [9] like graphical rep-
resentation where different colors indicate the amount of energy
consumed by source lines. The color for each source code line is
obtained by ranking each source line according to the sum of its
associated bytecode energy costs. The ranking is then mapped to a
color within the spectrum. In our example, blue shows low energy

consumption and red indicates a high level of energy consumption.
In between values are different levels of red and blue (purple.)

4. EVALUATION

We evaluated two aspects of our approach, analysis time and ac-
curacy. For the evaluation, we implemented our approach as a pro-
totype tool, vLens, and designed several experiments to evaluate
these two aspects. We considered two broad research questions:

RQ1: What amount of analysis time is incurred by vLens?
RQ2: How accurately does vLens calculate the energy consump-

tion of the application?
4.1 Subject Applications

In the evaluation, we used a set of ﬁve application from the
Google Play Market. Table 1 shows the number of classes (C),
methods (M), and bytecodes (BC) for each application. All of the
applications are written for the Dalvik Virtual Machine, do not use
any native libraries, and can be translated to and from Java Virtual
Machine bytecodes by the dex2jar tool. These applications rep-
resent real-world marketplace applications and implement a diverse
range of functionality. For all of the experiments, we ran the appli-
cations using canonical usage scenarios for each application. For
example, we played a game several times (Bubble Blaster II and
Classic Alchemy), created and edited a text document (Textgram),
read a news article via the reader (BBC Reader), and opened a web
page (Skyﬁre).
4.2

Implementation

The vLens prototype is written in Java and works for Android ap-
plications written to run on the Dalvik Virtual Machine. We chose
to implement for Android because its open nature made it easier
to understand the OS inner workings. However, our approach is
applicable for other platforms, such as Windows Phone and iOS,
since it relies on energy measurements provided by external hard-
ware, statistical techniques, and instrumentation, which is available
on many platforms.

There are four main modules in the implementation: the Power
Measurement Platform, App Instrumenter, Analyzer, and Annota-
tor. For the Power Measurement Platform we utilized the LEAP
power measurement device [25] described in Section 3.1. The App
Instrumenter uses BCEL [4] to build intra-procedural control ﬂow
graphs for the efﬁcient path proﬁling and insert the required instru-
mentation. We use dex2jar [1] to convert Dalvik bytecodes to
Java bytecodes; then after instrumentation, we compile the classes
back to Dalvik with the dx tool provided by the Android SDK. The
Analyzer uses R [3] for the robust linear regression functions and
Java code to perform the path adjustments. Finally, the Annotator
is based on an Eclipse visualization plugin we built for prior work
in energy estimation [12].

4.3 RQ1: Analysis Overhead

For the ﬁrst research question, we consider three aspects of the

Table 2: Time and Accuracy

Timing Measurements

Accuracy

App
BBC Reader
Bubble Blaster II
Classic Alchemy
Skyﬁre
Textgram

TI (s)
353
460
873
277
298

TA(s)

TR(%)

158
145
128
97
63

0.51
3.24
8.77
1.12
6.33

R2

0.94
0.90
0.93
0.99
0.92

AEE (%)

6.5
8.6
3.4
4.8
6.3

approach’s analysis time. These are: (1) time to instrument each
application (TI), (2) time to perform the ofﬂine analysis (TA), and
(3) runtime overhead introduced by the instrumentation (TR). Ex-
periments to measure the ﬁrst two were performed on a desktop
platform containing an Intel i3@2.1Ghz with 2GB RAM and run-
ning Ubuntu 12.04. Overhead was measured on the LEAP plat-
form.

To determine TI, we measured the time to instrument each ap-
plication with vLens. After running the application and collecting
the path and invocation tuples, we determined TA by measuring the
time to analyze the tuples, perform path adjustments, and calculate
each source line’s energy using the regression analysis. The results
of these measurements are shown, in seconds, in Table 2. The time
to instrument ranged from ﬁve to twelve minutes, and the time to
analyze ranged from one to just under three minutes. Most of the
instrumentation time was due to the computational cost of building
and analyzing the control ﬂow graphs for each of the methods. The
majority of the ofﬂine analysis cost was due to the IO overhead of
reading all of the path tuples into memory so they could be con-
verted to the path matrices. Further optimizations, such as caching
path information during the ofﬂine analysis, could reduce this cost
further. However, since vLens is intended to be an experimental
prototype, we did not implement these improvements.

To determine the runtime overhead of the instrumentation (TR)
we could not take the straightforward approach of comparing an in-
strumented version of each application against the uninstrumented
version. The reason for this is that a signiﬁcant amount of appli-
cation time is actually spent idle, waiting for user input or data.
The normal user variation in entering this data masks the instru-
mentation overhead variation. Therefore we calculate the non-idle
execution time of the instrumented application and then determine
the percentage of that time that is caused by the instrumentation. A
key insight to measuring non-idle time is that the Android operat-
ing system is event driven, so it idles waiting for user input after a
method exits, and then when it receives input, comes out of the idle
state and executes the event handler method. Therefore, we can
calculate the non-idle time of the application by summing up all of
the time during which an application path was being traversed. For
example if path p1 executed from time 1 to 3 and path p2 executed
from time 2 to 4, then we can calculate the non-idle time as 3 units.
Note that this properly counts a time unit once regardless of how
many threads are executing. Next, we proﬁled the instrumentation
code that was inserted into the application and determined its exe-
cution time TInst. By examining the path tuples, we also know the
execution frequency n of the instrumentation. The resulting calcu-
lation for TR is shown in Equation 5. Here the denominator is the
special time summation described above.
n ∗ TInst

TR =

∪Ti

(5)

The results of this calculation are shown in Table 2 as TR. The
overhead costs range from 0.51% to 8.77% with an average just
under 4%. Overall, this is a low runtime overhead, representing

about 0.15 seconds. Anecdotally, this amount of overhead did not
cause a noticeable delay to the testers during execution.
4.4 RQ2: Measurement Accuracy

For the second research question, we consider the accuracy of
the measurements calculated by vLens. The primary challenge in
this evaluation is that there is no source line ground truth against
which we can compare for accuracy. As discussed in Section 2,
power samplers cannot measure at a frequency high enough to cap-
ture individual source lines. Therefore, we show accuracy of the
approach in several other ways. First we examine the accuracy of
the energy attributed to the APIs. Second, we use statistical tests
to show that the regression analysis results can describe the over-
all energy consumption relationship accurately and that each path
also accurately accounts for its energy. Lastly, we show that our
technique for identifying high-energy events via statistical outlier
analysis correctly identiﬁes paths that contain these events.

Figure 6: Comparison of API energy cost

4.4.1 Accuracy of the API Energy Measurements
To measure the accuracy of the API energy measurements, we
compared their measured cost against a proﬁled cost. To obtain
the measured cost, we ran the apps using vLens and extracted the
cost of each invocation that was executed during the test runs. Al-
together, there were invocations to over 3,722 unique APIs. From
this group we focused on a group of twenty-four APIs whose in-
vocations together comprised more than 70% of the total invoca-
tion related energy consumed by the ﬁve applications. For these
twenty-four, we recorded the arguments and execution context of
the invocations and then proﬁled their energy cost. The proﬁling
was performed on the LEAP platform by executing each invoca-
tion 100 times and then measuring the energy consumed during the
execution. We repeated this proﬁling ﬁve times and calculated the
mean and standard deviation of the experiment. The proﬁled cost
was then compared against the cost calculated by vLens. The re-
sult of this comparison are shown in Figure 6. Each of the APIs
are listed along the X-axis and the two different costs are shown on
the Y-axis, the values on the Y-axis are normalized to the cost of
proﬁled cost. One standard deviation off of the proﬁling mean is
shown with the additional horizontal lines.

Figure 6 shows that for nineteen of the twenty-four APIs, the
vLens measured cost was within an average of 9% of the proﬁled
costs and the gap was within one standard deviation in almost all
cases. For the remaining ﬁve, the measured cost was off signiﬁ-
cantly. We investigated these APIs to determine what caused this
high error rate. The ﬁrst four APIs are synchronized, which means
that they invoke monitor_enter and monitor_exit. This

  0.00  0.50  1.00  1.50  2.00123456789101112131415161718192021222324Normalized EnergyvLensProfilingmade the execution time and energy consumption of their invoca-
tion vary widely as the acquisition and release of the synchroniza-
tion lock was non-deterministic. The ﬁfth API accessed an HTTP
response code, and we found that the code was cached after the
ﬁrst call to the method, which meant signiﬁcantly less computa-
tions had to be performed in subsequent invocations. Because the
proﬁling results for these ﬁve were skewed by these types of be-
haviors, we consider the nineteen to be a more accurate reﬂection
of the accuracy achieved by the vLens calculations.
4.4.2 Accuracy of Bytecode Energy Distribution
We evaluate the accuracy of the bytecode regression model in
two ways. First, we determine the accuracy of the regression model
at an application level by comparing the amount of application en-
ergy calculated using the regression model versus the amount of
application energy actually measured during the experiments. Sec-
ond, we look at the accuracy of the regression model at a path level
by determining the multiple correlation coefﬁcient of the calculated
paths values. The results of these experiments are reported in Ta-
ble 2. Note that we cannot perform this experiment at the bytecode
level because we do not have a way to establish the bytecodes’
ground truth measurements.

To determine the accuracy of the regression model at the applica-
tion level, we calculate the Accumulated Estimating Error (AEE).
This value represents the normalized difference between the amount
of energy that the regression model would calculate for the appli-
cation versus the amount of actually measured energy. Intuitively,
the AEE can be thought of as the amount of total energy not accu-
rately accounted for by the regression model and a lower ratio is a
stronger result. The AEE is shown in Equation 6. The ˆyi represents
the energy calculated for the ith path based on the regression model
and yi is the measured energy of the ith path produced by the Path
Adjuster (i.e., with the invocation energy removed.)

AEE =

|Σˆyi − Σyi|

Σyi

(6)

To determine the accuracy of the regression model at a path level,
we calculate the multiple correlation coefﬁcient (R2). The R2 is a
well-known statistical measure that shows how well a variable can
be predicted based on a linear function of multiple variables. In
our case the value to be predicted is the energy of the ith path (ˆyi)
calculated with the regression model, and the multiple variables
are the individual bytecodes solved for during the regression. The
value of R2 is obtained by calculating the solution to Equation 7.
As with the AEE in Equation 6, yi is the adjusted measured value
of the ith path, ˆyi is the path’s value calculated using the regression
model, and ¯y is the mean of the measured paths. The R2 value is
measured on the interval [0, 1] with a value close to 1 representing
a strong ﬁt of the data to the model and 0 representing a weak ﬁt.

R2 = 1 − Σ(yi − ˆyi)2
Σ(yi − ¯y)2

(7)

For the AEE, the numbers range from 3.4% to 8.6% with an av-
erage of just under 6%. This means that, on average, 6% of the
actual measured energy is not accounted for by the model. In gen-
eral, since linear regression is an approximation, a certain amount
of variance in the energy totals is to be expected. In this context,
we believe that 6% represents a low enough number that the overall
results of the analysis would still be informative and help to guide
the developer in making changes to the code. The R2 values range
from 0.9 to 0.99 with an average of 0.936. The high average R2
value shows that our model is able to ﬁt the measured data very

closely. Overall, these numbers show that our regression model
exhibits high accuracy with respect to its calculations at both the
application and path level.

4.4.3 Accuracy of Outlier Detection
We evaluated the accuracy of the RLR techniques to detect out-
liers caused by garbage collection and thread switching events. To
do this, we seeded a variable number (20, 50, 100, and 200) of ar-
tiﬁcial events along paths of the subject applications by inserting
calls to garbage collection (System.gc()) and thread switching
instructions (Thread.start() and Thread.join()). The
target thread contained only a single instruction so that its actual
execution time would be low and the most prominent cost would be
the context-switch overhead. We then applied the RLR techniques
and checked to see if the paths containing the seeded events were
determined to be outliers. For each of the applications, the RLR
techniques were able to detect all of the seeded high-energy events.
From this result, we conclude that the use of statistical outlier de-
tection to identify paths affected by garbage collection and thread
switching overhead is both an effective and practical approach.
4.4.4 Threats to Validity
In this section we discuss the threats to the validity of our empir-

ical evaluation and explain how we addressed these issues.

External Validity: The subjects in this study are real world mar-
ketplace apps downloaded from the Google Play Market. They rep-
resent different app domains and, in terms of size, are representa-
tive of many apps we saw in the marketplace.

Internal Validity: In general, to help ensure internal validity,
the accuracy and timing experiments were repeated multiple times
and averaged. To ensure that the outlier detection was a result of
our technique, we tracked the seeding of the garbage collection and
thread switching, so we could determine easily in which paths they
occurred. Furthermore, we compared actual and seeded garbage
collection events, to verify that they had similar energy characteris-
tics. For threads, we used a minimal sized thread (one instruction)
to ensure that the thread’s energy was not inﬂated and therefore
made easier to detect.

Construct Validity: For accuracy, we were unable to use the
most straightforward comparison, bytecode ground truth, due to
the difﬁculty of measuring the ground truth for such short events.
Instead, we used invocation ground truth and well-known statistical
tests to show the degree to which our models ﬁt the measured data.
Overall, it seems likely that if the calculated values for invocation
were close to ground truth and the R2 values were consistently
high across all apps, then the calculated source line level energy
would also be accurate. Nonetheless, this is a validity threat that
our experimental design could not completely address.

5. RELATED WORK

There are two areas of related work for our approach, energy es-
timation and power measurement. The ﬁrst area, energy estimation,
assumes that developers do not have access to power measurement
hardware and uses software based techniques to predict how much
energy an application will consume at runtime. The second group
of techniques, power measurement, makes use of power measure-
ment hardware to obtain power samples and then uses software
based techniques to attribute the power to implementation struc-
tures.

The general process of energy estimation techniques is to build
a parameter-based model of energy consumption, capture values
for the model’s parameters from the application, and then calculate

Calculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36

an approach that combines hardware-based energy measurements
with program analysis and statistical modeling techniques. At a
high-level, the basic intuition is as follows: While measuring the
energy consumption of a smartphone, the approach uses efﬁcient
path proﬁling to identify which parts of the application are exe-
cuting and correlates these paths with the measured energy. Then,
the approach statically analyzes the paths to identify and adjust for
high-energy events, such as thread switching, before applying ro-
bust regression analysis to calculate each source line’s energy con-
sumption. Finally, the approach presents developers with a graph-
ical representation of the energy consumption by overlaying the
calculated energy with the source code of the application.

We also performed an empirical evaluation of our approach to
measure its accuracy and the time needed to perform the analysis.
Our approach was able to accurately calculate energy. For a set of
API invocations, we found that the calculated energy values were
within 10% of the ground truth measurements. The statistical mod-
els also matched the measured data very closely with a high R2
average of 0.93 and a low accumulated error rate. Importantly, in
our experiments, the approach was also able to detect the inﬂuence
of high-energy events, such as thread switching and garbage col-
lection, with 100% accuracy. The approach was also fast, it could
calculate source line level energy measurements for each of our
subject applications in less than three minutes. Overall, the results
of the evaluation were positive and indicate that our approach is an
effective and practical way to provide developers with source line
level energy information.

The remainder of this paper is organized as follows: In Section 2
we discuss several of the signiﬁcant challenges that shaped the de-
sign of our approach. We present the approach itself in Section 3.
The evaluation of the approach is described in Section 4. Finally,
we discuss related work and conclude in Sections 5 and 6.

2. BACKGROUND AND MOTIVATION

In this section we discuss several challenges to measuring and
calculating source line energy consumption. We break the chal-
lenges into three broad categories, hardware, runtime system, and
software level, and explain how they preclude a straightforward
solution for calculating source level energy consumption. To il-
lustrate these challenges, we make use of the code shown as Pro-
grams 1 and 2, which are excerpts from the open-source Google
Authenticator project that handles synchronizing a system clock.
In the example, method getNetworkTime (Program 1, line 1)
retrieves the time by sending an HTTP request to a timeserver
(line 7) and then parsing the response packet (lines 16, 20, 23,
26). Method runBackgroundSync (Program 2, line 2) calls the
getNetworkTime (line 6) and then starts a background thread
to handle errors (line 10).
2.1 Hardware Limitations

The primary hardware obstacle to directly measuring the energy
consumption of source lines is the difference in the speed at which
instructions execute and hardware devices can perform energy mea-
surements. On modern processors, individual instructions will ex-
ecute at a rate of several million per second. At best, power me-
ters can sample electrical power draw at several tens of KHz [16],
which means that each sample will include the power consumption
of hundreds, perhaps thousands, of instructions. For example, it
is possible for Program 2 to execute completely in the time that
transpires between two consecutive power samples by a relatively
fast power meter. There are reasons to believe that this order of
magnitude disparity will likely persist, since the bottleneck in high-
frequency power sampling is the storage system, which cannot save

p u b l i c long getNetworkTime ( )

throws

I O E x c e p t i o n {

HttpHead r e q u e s t = new HttpHead (URL ) ;
Log . i (LOG_TAG, "Sending request to "

+ r e q u e s t . getURI ( ) ) ;
H t t p R e s p o n s e h t t p R e s p o n s e ;
t r y {

h t t p R e s p o n s e = m H t t p C l i e n t . e x e c u t e ( r e q u e s t ) ;

} catch ( C l i e n t P r o t o c o l E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( S t r i n g . v a l u e O f ( e ) ) ;

} catch ( I O E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( "Failed due " +

"to connectivity issues: " + e ) ;

}

t r y {

Header d a t e H e a d e r =

h t t p R e s p o n s e . g e t L a s t H e a d e r ( "Date" ) ;

Log . i (LOG_TAG, "Received response with "

+"Date header: " + d a t e H e a d e r ) ;

i f

( d a t e H e a d e r == n u l l ) {

throw new I O E x c e p t i o n ( "No Date header" ) ;

}
S t r i n g d a t e H e a d e r V a l u e =

t ry {

Date networkDate =

d a t e H e a d e r . g e t V a l u e ( ) ;

D a t e U t i l s . p a r s e D a t e ( d a t e H e a d e r V a l u e ) ;

return networkDate . getTime ( ) ;

} catch ( D a t e P a r s e E x c e p t i o n e ) {

throw new I O E x c e p t i o n (

"Invalid Date header format " ) ;

}

} f i n a l l y {

. . . . . .

}

}

Program 1: Google Authenticator Method 1

power samples at the same frequency as the power meter can gen-
erate them [14, 15, 20], and there is no evidence to show that this
gap will be closed in the near future. Therefore, a challenge for our
approach is to reconcile power measurements samples and instruc-
tion execution, even though there is a several orders of magnitude
difference in their frequency.
2.2 Runtime System Challenges

The runtime system of an Android smartphone includes both the
Android operating system and the Dalvik Virtual Machine, the plat-
form on which marketplace apps are run. The runtime system im-
plements several types of behaviors that affect energy consumption
of an app, thread switching, garbage collection, and tail energy.
However, the details of the duration, frequency, and timing of these
events is, by design, hidden from the app. This makes it difﬁcult
to correctly attribute energy at the source level. Although it would
be straightforward to modify the runtime systems to track these
events, this would introduce considerable overhead and reduce the
portability of the approach, as it would be necessary to provide
custom runtime systems for each smartphone platform. Therefore,
one challenge for our approach is to account for these events with
information that is available at the app layer.

Thread switching causes several problems for calculating source
line level energy. The ﬁrst problem is that any energy measure-
ments for a given time period may also include energy for threads
that are not related to the application (i.e.,, operating system pro-
cesses). For example, at any point in the execution of the thread
in runBackgroundSync or getNetworkTime, the OS could
swap in a thread from another app or the OS. Any power samples
during this time would likely include instructions from both the
original and swapped-in thread. The second problem is that thread

p r i v a t e void

runBackgroundSync ( E x e c u t o r
long n e t w o r k T i m e M i l l i s ;
t r y {

n e t w o r k T i m e M i l l i s =

c a l l b a c k E x e c u t o r ) {

mNetworkTimeProvider . getNetworkTime ( ) ;

} catch ( I O E x c e p t i o n e ) {

Log .w(LOG_TAG, "Failed to obtain network " +
"time due to connectivity issues" ) ;

c a l l b a c k E x e c u t o r . e x e c u t e ( new Runnable ( ) {

@Override
p u b l i c void run ( ) {

f i n i s h ( R e s u l t . ERROR_CONNECTIVITY_ISSUE ) ;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

}
} ) ;
return ;

}

Program 2: Google Authenticator Method 2

switching itself introduces an energy overhead. For example, Line
10 of Program 2 will incur a signiﬁcant energy overhead for the
context switch that occurs when a new thread is started.

Periodically, the Android operating system will perform garbage
collection during the execution of an application. Typically, ap-
plications do not have control over garbage collection, it is man-
aged by the operating system and can occur anytime and within
any method. Although the Dalvik virtual machine logs garbage
collection, it timestamps the events via a millisecond based clock,
which does not provide enough precision to determine in which
path they occur (paths are tracked with nanosecond timestamps.)
As we note in Section 3.2.2, garbage collection incurs a signiﬁ-
cant energy cost and has the potential to signiﬁcantly distort en-
ergy measurements for an application. For example, consider if
garbage collection were to occur at line 20 of Program 1, which is
compiled as a simple jump on equality (ifeq), or line 6 of Pro-
gram 2, which is a relatively expensive method invocation. The
extremely high cost of the garbage collection would dwarf the cost
of both instructions making them appear to have a nearly identical
high energy cost. Therefore, an approach must be able to identify
and properly account for garbage collection while calculating the
source line level energy consumption of an application.

Smartphones exhibit tail energy usage, where certain hardware
components are optimistically kept active by the operating system,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. Tail energy manifests itself in two differ-
ent ways. The ﬁrst way is when an invocation to an API accesses a
hardware component and then returns. Even when no other invoca-
tions access the component, the component will remain active for
a time period Ttail and consume energy Etail. An example of this
kind of invocation is at line 7 of Program 1. The call to the network
will cause the radio to remain on for a period of time, even after
the request is ﬁnished, and consume energy during this time. The
second way is when two invocations access the component in se-
quence and the time interval between them is less than Ttail. Here,
only a portion of Etail will be consumed. The Etail for certain de-
vices can be quite high and a naive approach to measurement might
attribute the tail energy cost to subsequently executed instructions.
Referring back to the example invocation, the naive approach could
mistakenly attribute part of the invocation’s tail energy to its suc-
cessors, lines 16, 18, and 20, (depending on the length of its Ttail)
instead of to line 7. To be accurate, an approach must recognize
when tail energy occurs and attribute it to the source invocations
that started the component and kept it at a non-idle state.

2.3 Software-Level Challenges

Source level calculations require precise information about an
app’s execution. In particular, for each time period represented by
a power sample, it is necessary to know which instructions were
executed, their frequency, and their ordering — essentially, path
information. The primary challenge is that obtaining this type of
information at the software level is generally expensive and intru-
sive. For example, inserting instrumentation into an app to iso-
late and measure individual instructions can lead to high overhead.
Even optimizations, such as only instrumenting each basic block,
would still produce a high amount of instrumentation. Other ap-
proaches, such as instruction counting, do not allow developers to
know which instances of the instructions were executed.

It is also necessary to have precise information about API invoca-
tions. During execution, smartphone applications generally invoke
library functions and APIs to access hardware components, such
as GPS, network, and WiFi. For example, at line 7 of Program 1,
getNetworkTime() sends an HTTP request to Google by in-
voking HttpClient.execute(). This invocation consumes
a relatively large amount of energy due to its use of the network.
In contrast, a call to dataheader.getValue at line 24 of Pro-
gram 1, incurs a relatively small constant cost, since it is simply
returning the value of an HTTP header. This wide range of invo-
cation behavior causes problems for techniques that naively apply
statistical sampling or averaging-based approaches because, unlike
normal instructions, an invocation’s energy cost can vary based on
its target and the data provided for its arguments. Furthermore, it is
not feasible to precompute the cost of API calls, since that requires
sampling every point in each API calls input space to determine its
energy consumption.
3. APPROACH

The goal of our approach is to provide source line level energy
information for smartphone applications. An overview of our ap-
proach is shown in Figure 1. From a high-level, our approach has
two phases, Runtime Measurement and Ofﬂine Analysis. The in-
puts to the Runtime Measurement phase are the application under
analysis (AUA) and a set of use cases for which the tester wants
to obtain energy measurements. The App Instrumenter uses an
efﬁcient path proﬁling technique to guide the insertion of probes
into the AUA that will capture timestamps and path traversal infor-
mation. The tester executes the instrumented AUA on the Power
Measurement Platform. This causes the instrumentation to record
path information while the Power Measurement Platform records
power samples. The path and power samples are the inputs for the
Ofﬂine Analysis phase. The Path Adjuster performs a static anal-
ysis of the paths and makes modiﬁcations to the power samples to
account for the high-energy events. Then the Analyzer performs
the regression analysis in order to calculate each source line’s en-
ergy consumption. If the Analyzer ﬁnds there are not enough data
points to solve the regression analysis, then the process returns to
the Runtime Measurement phase so the developer can further exe-
cute the application. If this is not possible, then the Analyzer per-
forms approximations that we discuss in Section 3.2.2. Finally, the
Annotator uses the calculations to create graphical overlays of the
measurements on the source code for display in an integrated de-
velopment environment. We explain the approach in more detail in
the remainder of this section.
3.1 Runtime Measurement Phase

During the Runtime Measurement phase, information about the
paths executed in the AUA and power measurements are generated
by the approach. To do this, the App Instrumenter inserts probes

Figure 1: Overview of the approach

into the AUA to record the information, and then the instrumented
AUA is executed by the developer while power samples are col-
lected by the Power Measurement Platform. The output of the Run-
time Measurement phase is set of timestamped paths executed by
the AUA and power measurements.

Instrumentation of the AUA: The instrumentation collects in-
formation about the paths executed by the developer. Namely, which
paths are traversed, their frequency, and timestamps of the path
traversals and invocation of certain APIs. To record the path infor-
mation, the App Instrumenter adapts a techniques for efﬁcient path
proﬁling proposed by Ball and Larus [5]. The approach ﬁrst builds
a control-ﬂow graph (CFG) of each method in the AUA. Then each
edge in the CFG is assigned a label so that each unique path in the
CFG has a unique path ID. The approach then calculates a maxi-
mal spanning tree over the CFG and uses this to guide the minimal
placement of instrumentation that will increment a path ID counter.
By design, the approach can use a single counter to identify the path
traversed in the method. We extended the Ball-Larus approach to
handle nested method calls, concurrency, and exceptions. The App
Instrumenter also inserts a probe at the method entry to initialize
the method’s path counter, record a timestamp of when the path
traversal began, and the current thread ID. At each exit point of
the method, another probe records the value of the path ID counter,
and another timestamp. After execution is ﬁnished, this informa-
tion allows the approach to generate a set of path tuples of the form
(cid:104)thread_id, path_id, enter_time, exit_time(cid:105) where thread_id
identiﬁes current thread, path_id is the traversed ID for paths, and
enter_time and exit_time are the time stamps that indicate when
a path starts and ends.

The App Instrumenter also inserts probes to obtain timestamps
before and after the invocation of certain APIs. As we explain
in Section 3.2.1, this information is used to allocate tail energy
and isolate the energy cost of certain APIs for which it is not
possible to model using linear regression (i.e., methods that have
non constant energy consumption.) For each of the invocations,
the instrumentation generates an invocation tuple of the form
(cid:104)method_id, enter_time, exit_time(cid:105), where method_id iden-
tiﬁes the invoking method, and enter_time and exit_time are
timestamps before invoking the method and after the method has
returned.

Execution of the Instrumented AUA: To generate the path and
invocation tuples, the instrumented AUA is executed on the Power
Measurement Platform. The Power Measurement Platform is based
on the LEAP node [25]. The LEAP is an x86 platform based on an

ATOM N550 processor that runs Android 3.2. Each component
in the LEAP (e.g., WiFi, GPS, memory, and CPU) is connected
to an analog to digital converter (DAQ) that samples current draw
at 10KHz. The LEAP also provides Android applications with the
ability to trigger a synchronization signal. This allows the approach
to synchronize the samples with the paths’ timestamps and avoid
inaccuracy due to clock skew. Each of the uses cases is executed
by the developer on the AUA while it is running on the LEAP. Note
that all of the measurements are recorded in hardware external to
the Android smartphone components, so the measurement process
does not introduce any interference or execution overhead.
3.2 Ofﬂine Analysis Phase

In the Ofﬂine Analysis phase, our approach analyzes the tuples
and power samples generated in the Runtime Measurement phase
to produce a mapping of energy to source lines. There are three
parts to this phase.
In the ﬁrst part, the Path Adjuster statically
examines each traversed path in the CFG and adjusts the corre-
sponding energy measurements to account for special API invoca-
tions, tail energy, and interleaving threads. The adjusted energy
measurements and paths are the inputs to the second part, the Ana-
lyzer, which uses robust regression techniques to calculate the cost
of each source line and identify paths along which garbage col-
lection and thread context switches occurred. The Analyzer also
determines if the testing process created enough data points to per-
form the linear regression and either reduces the grouping of vari-
ables to be solved in the regression or directs the tester to repeat
the test cases to provide more data points. Finally, in the third part,
the Annotator creates a graphic representation of the energy mea-
surements and overlays this with the source code. Note that in the
rest of the paper, we describe our approach in terms of bytecode
instructions, but it is straightforward to convert the bytecode-level
information to source-level using compiler provided debugging in-
formation.
3.2.1 Adjustment to Path Energy Samples
Before beginning the analysis, the Path Adjuster ﬁrst reconstructs
the paths traversed during execution of the AUA. The instructions
executed in a path can be identiﬁed using the path ID and the
CFG of the method containing the path, as described by Ball and
Larus [5]. Once the paths have been reconstructed, the Path Ad-
juster calculates the energy total for the path by summing the mea-
surements reported during the path’s time of execution. The Path
Adjuster can identify the corresponding path and power samples
due to the synchronized timestamps. Then, the Path Adjuster per-

App Instrumenter Path Adjuster Analyzer Annotator Runtime Measurement Phase  Offline Analysis Phase Application (AUA) Use  cases Energy Report Power Measurement Platform Visualization {<paths>} {<power>} Insufficient data? AUA´ forms a static analysis of each path in order to adjust certain API
invocations due to non-constant and too-short API invocations, tail
energy, and thread interleaving. The Path Adjuster generates a
set of paths with the adjusted invocations removed from the paths
and their corresponding energy removed from the power measure-
ments.

API Invocations: Certain API invocations have a non-constant
energy cost associated with their execution. Therefore, it is not
possible to calculate their energy cost using the robust linear re-
gression techniques described in Section 3.2.2. To address this
problem, our approach uses the invocation tuples to identify the
time periods when these invocations are executing and calculates
the invocations’ energy cost by summing the power measurements
taken during that time.

Figure 2: Using longer execution windows for calculating the
energy of invocations with a short execution time.

In most cases, the execution time of an invocation is long enough
that the approach is able to get accurate energy measurements (i.e.,
the execution time is longer than several sampling periods.) How-
ever, in some cases the execution time of the invocation is too brief
(e.g., the execution time is shorter than a sampling period.) For
these invocations, the approach identiﬁes an execution time period
that includes the too short execution and for which the approach
does have enough power samples to accurately the energy con-
sumption. Then it calculates the ratio of the original execution time
versus the larger execution time and multiples that against the en-
ergy total for the larger execution time. To illustrate, consider the
example shown in Figure 2. In this ﬁgure, the horizontal bars in-
dicate the energy sampling interval. For example, the LEAP will
sample the power at t3 and then again at t4. If an invocation I exe-
cutes from time t1 until time t2, then there are no power samples to
be summed in order to ﬁnd the energy consumed by I (EI). When
this occurs, the Path Adjuster ﬁnds the next largest execution win-
dow for which it has sufﬁcient energy samples and uses this win-
dow to calculate EI. In the case of the example, the Path Adjuster
calculates EI as shown in Equation 1, where Ea,b denotes the en-
ergy consumption measured by the Power Measurement Platform
during interval [a, b].

t2 − t1
t4 − t3

Et3,t4

(1)

Note that this only approximates EI. We have found that for
functions whose execution time is so short, this is a reasonable ap-
proximation. These functions consume a very small portion of the
overall energy expended at runtime, on average about 6% of the
total API energy cost. For the general case, where the execution
time is of sufﬁcient length, our evaluation shows that we are able to
accurately measure most functions to within 9% of their measured
ground truth cost.

Figure 3: API invocations with tail energy

Tail Energy: As explained in Section 2, tail energy occurs when
the operating system keeps certain hardware components active,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. The result of this behavior is that the en-
ergy measurements for the time period following the component
access will be higher. Our approach adjusts the path energy total so
that the tail energy is attributed to the invocations that interact with
the hardware component. We assume the availability of tail energy
models, which are generally provided by either component manu-
facturers or power researchers [24]. The model speciﬁes the energy
consumption of the component after an invocation (Etail) and for
how long the device driver maintains this state (Ttail). To calcu-
late the adjustment, the Path Adjuster examines the reconstructed
paths to identify the sequence AD of invocations to methods that
cause tail energy for each device D of the smartphone. For each
such invocation ai ∈ AD, the adjuster compares the timestamp of
ai against the timestamp of ai+1. If the difference is greater than
Ttail then all of Etail is attributed to ai. If the difference is less
than Ttail then only a fraction of Etail is expended before ai+1
occurs and should be attributed to ai. The fraction is calculated as
shown in Equation 2, where TS returns the starting timestamp of an
invocation and TE returns the ending timestamp of an invocation.
Note that the invocation timestamps are known due to the invoca-
tion tuples collected during the Runtime Measurement phase.

TS(ai+1) − TE(ai)

Ttail

Etail

(2)

To illustrate these two scenarios, consider the two invocations
shown in Figure 3. Both of these, AP I_1 and AP I_2, access
the same device in sequence. Their tail energy consumptions are
shown as curved lines extending after the end of the invocations.
To calculate the tail energy associated with AP I_1, note that t2,
the start of the invocation to AP I_2, occurs before the Ttail time
has transpired. Therefore the tail energy assigned to AP I_1 is
t3−t1 ∗ Etail. When the invocation to AP I_2 returns
calculated as t2−t1
at t4, there is no other API accessing the same external device, so
we assign all of Etail, to AP I_2.

Thread Context-Switching During Invocations: A potential
problem that arises with the way the approach attributes energy to
API invocations is that it is possible for the thread containing the
invocation be switched out for another thread from the same appli-
cation. For example, this can happen because the invocation must
wait for a shared resource or another thread has higher priority.
The problem is that energy consumption by the other threads will
then also be measured in the corresponding power samples. As we
discussed earlier, this situation can be detected by modifying the
operating system to accurately track thread scheduling. However,
this would make the approach less portable, so we have devised a
software-level technique to address this problem.

ticular, the Analyzer uses RLR based on M-estimation [13], which
does iterative regression analysis. It begins by solving a normal
linear regression on the set of data points. Then at each iteration,
it calculates the residuals and gives each data point a weight based
on the standard deviations of the residuals. The regression analysis
is repeated on the weighted data to generate a new model and the
process repeats until the standard deviation of residuals does not
change between iterations. For the power samples, RLR is prefer-
able over the well-known ordinary least squares approach because
it is more robust in the presence of outliers. In this case, our data
sample has outliers, which are the paths whose energy measure-
ments are inﬂuenced by garbage collection and thread switching.

More speciﬁcally, at each iteration, given the linear function (cid:126)y =
X(cid:126)θ + (cid:126)u, the Analyzer solves Equation 3 and updates the standard
deviation of residuals. For the weighting function (ψ), we use
the well-known Tukey’s Bisquare function [37], which is shown
in Equation 4. The σ is the standard deviation of residuals in the
last iteration. The value of k is constant and is set according to
different use cases. In our experiments, we found that the average
energy cost of garbage collection and thread switching is about 10
to 70 times the average standard deviation of the residuals in the
ﬁrst iteration; therefore, we select the median 40 of this range as k.

(cid:88)
ψ(yi −(cid:88)
(cid:40)

k

i

ψk(x) =

xikθk)xij = 0

x(kσ − x2)2 −kσ < x < kσ
0

otherwise

(3)

(4)

The solution represents the energy cost of each instruction in the
path. Taken together with the measured energy cost of the invoca-
tions, the Analyzer now has the energy cost for the entire path. The
values for all of the paths are provided as input to the Annotator.
Two special cases are discussed below.

The ﬁrst special case is when it is not possible to solve for a
path’s instruction energy (i.e., m). This happens when the number
of unique bytecodes in a path is higher than the number of indepen-
dent data points. Solving linear system of equations requires that
there be at least as many independent data points as unknown vari-
ables. In this situation, the Analyzer recognizes that there are not
enough data points and can take two actions, which are repeated
until the equation is solvable. The ﬁrst is that the tester is notiﬁed
that the application should be executed more to generate additional
data points. The additional executions do not need to exactly repro-
duce the initial executions, but should represent similar use cases
to ensure a signiﬁcant amount of path overlap. Since this is not
always possible, the second possible action for the Analyzer is to
group counts of similar bytecodes. For example, all variations of
the iconst instruction. This gives fewer unknown variables for
the system of equations. Note that in our experience, even moder-
ate size marketplace apps were sufﬁciently complex that neither of
these actions were required in our evaluation.

The second special case are paths identiﬁed as outliers, which
contain external thread switching or garbage collection. The de-
tection of these outliers is discussed more below. Currently, the
Analyzer excludes these paths, which comprise about 1% of the
total path count. Although it is desirable to include these paths,
since excessive high-energy events could be a symptom of energy
inefﬁcient coding, there are two obstacles to this that we hope to
address in future work. First, the path must be adjusted to remove
the energy cost of the high-energy event. However, because the
measured energy of these events is so high compared to the path
energy, it is not clear how to accurately estimate and separate the

Figure 4: Concurrent threads during an API invocation.

The Path Adjuster determines the number of threads that were
executing while the invocation was executing. This is done by ex-
amining the starting and ending timestamps of each path tuple to
see which ones were active between the invocation’s timestamps.
Then, the Path Adjuster evenly allocates the energy among the con-
N , where N is the
current threads, assigning each the energy of 1
number of concurrent threads. To illustrate, consider the example
shown in Figure 4. T 1 is the original thread and contains an API
invocation at time t1. Threads T 2 and T 3 run while T 1 is per-
forming the invocation. T 1 and T 2 are concurrent in time interval
[t2, t3] and all three are concurrent in [t3, t4]. Therefore, the en-
ergy of T 1 will be Et1,t2 + 1
3 Et3,t4. This is similar to the
way prior approaches have handled concurrent thread energy [24].

2 Et2,t3 + 1

3.2.2 Calculating Source Line Energy Values
The second part of the Ofﬂine Analysis phase calculates the en-
ergy consumption of each source line. The input to the Analyzer
is the set of adjusted paths and energy samples produced by the
the Path Adjuster. At this point, adjustments for all of the API in-
vocations have been made, but the paths could still be inﬂuenced
by the occurrence of garbage collection and thread switching dur-
ing times when there is no API invocation. As we discussed in
Section 2, the energy costs associated with events, such as garbage
collection and thread switching, can skew the regression analysis,
but it is difﬁcult to identify when they occur. Our insight is that
characteristics of these events allow us to deﬁne them as statisti-
cal outliers and therefore the Analyzer can employ Robust Linear
Regression techniques to calculate each source lines’ energy con-
sumption and mitigate the inﬂuence of these high-energy events. In
the rest of this section, we ﬁrst explain the regression technique and
then discuss the insight that allows us to deﬁne garbage collection
and thread switching as statistical outliers.
Robust Linear Regression Analysis

The Analyzer uses linear regression analysis to calculate each
instruction’s energy consumption. We expect linear regression to
work well in this situation because prior work has found that the
cost of bytecodes will be constant given a particular hardware envi-
ronment [12, 29] and the Path Adjuster has removed the non-linear
cost invocations.

To perform the analysis, the Analyzer sets up the equations E =
mX, where E is the adjusted power measurements, X represents
the path traversals with each row representing a frequency vector of
bytecodes present in the measured path. (Note that the bytecodes
associated with the inserted instrumentation are included in this
matrix. Since the approach knows which paths were instrumented,
the associated results are simply removed before visualizing or re-
porting the ﬁnal source line level calculations.) Then the Analyzer
solves for the coefﬁcients m to determine the energy consumed by
the instructions in the path segment. To solve the equations, the An-
alyzer employs Robust Linear Regression (RLR) analysis. In par-

Table 1: Subject applications

App
BBC Reader
Bubble Blaster II
Classic Alchemy
Skyﬁre
Textgram

C
590
932
751
684
632

M

4,923
6,060
4,434
3,976
5,315

BC

Application Information
Description
RSS reader for BBC news
Game to blast bubbles
Educational game

293,910
398,437
467,099
274,196 Web-browser
244,940

Text editor

Figure 5: Visualization of the energy measurements.

event energy versus the path energy. Second, although the energy
associated with these events is signiﬁcant and of interest to devel-
opers, its not clear which instructions should be attributed with the
cost. Currently, this number is tracked and reported as a separate
total.
High-energy Events as Statistical Outliers

The energy overhead of switching to external threads and garbage
collection is quite high. Our experiments show that these events
range from 20,000 to 150,000 times the cost of a normal instruc-
tion. Yet they occur rarely during execution. Our insight is that
the high energy cost and relative infrequency of these high energy
events allows them to be detected as statistical outliers. In small
scale experiments, we found that the energy cost of a path ranges
from 0.007mJ to 0.631mJ; garbage collection from 20mJ to 81mJ;
and thread switching overhead from 6.44mJ to 11.3mJ. This means
that the energy cost of paths with garbage collection and thread
switching will be signiﬁcantly larger than normal paths — 10 to
over 10,000 times larger. This difference in the range of values al-
lows us to identify the events by deﬁning them as outliers based on
their energy consumption (i.e., by setting an appropriate value of k
in Tukey’s Bisquare function.) Note that our approach detects out-
liers for a speciﬁc path and does not simply cluster all of the energy
measurements. A per-path outlier detection is necessary since it is
possible for a path to be long enough that it consumes more energy
than garbage collection or thread switching. In the evaluation, we
validate this approach to detecting garbage collection and thread
switching by showing that our approach is able to detect all known
occurrences of these types of events.

3.2.3 Visualizing the Energy Consumption
The Annotator presents a graphical representation of the source
line level information. Developers can use this visualization to
more readily understand the distribution of energy consumption
across the different parts of their application. The Annotator was
developed as part of our prior work [12], so it is not a research
contribution of this paper. Nonetheless, we consider it an integral
aspect of our approach that increases its usability, so we brieﬂy
summarize its function.

The Annotator is an Eclipse plugin that overlays power informa-
tion onto an application’s source code. A screenshot is shown in
Figure 5. The visualization uses a SeeSoft [9] like graphical rep-
resentation where different colors indicate the amount of energy
consumed by source lines. The color for each source code line is
obtained by ranking each source line according to the sum of its
associated bytecode energy costs. The ranking is then mapped to a
color within the spectrum. In our example, blue shows low energy

consumption and red indicates a high level of energy consumption.
In between values are different levels of red and blue (purple.)

4. EVALUATION

We evaluated two aspects of our approach, analysis time and ac-
curacy. For the evaluation, we implemented our approach as a pro-
totype tool, vLens, and designed several experiments to evaluate
these two aspects. We considered two broad research questions:

RQ1: What amount of analysis time is incurred by vLens?
RQ2: How accurately does vLens calculate the energy consump-

tion of the application?
4.1 Subject Applications

In the evaluation, we used a set of ﬁve application from the
Google Play Market. Table 1 shows the number of classes (C),
methods (M), and bytecodes (BC) for each application. All of the
applications are written for the Dalvik Virtual Machine, do not use
any native libraries, and can be translated to and from Java Virtual
Machine bytecodes by the dex2jar tool. These applications rep-
resent real-world marketplace applications and implement a diverse
range of functionality. For all of the experiments, we ran the appli-
cations using canonical usage scenarios for each application. For
example, we played a game several times (Bubble Blaster II and
Classic Alchemy), created and edited a text document (Textgram),
read a news article via the reader (BBC Reader), and opened a web
page (Skyﬁre).
4.2

Implementation

The vLens prototype is written in Java and works for Android ap-
plications written to run on the Dalvik Virtual Machine. We chose
to implement for Android because its open nature made it easier
to understand the OS inner workings. However, our approach is
applicable for other platforms, such as Windows Phone and iOS,
since it relies on energy measurements provided by external hard-
ware, statistical techniques, and instrumentation, which is available
on many platforms.

There are four main modules in the implementation: the Power
Measurement Platform, App Instrumenter, Analyzer, and Annota-
tor. For the Power Measurement Platform we utilized the LEAP
power measurement device [25] described in Section 3.1. The App
Instrumenter uses BCEL [4] to build intra-procedural control ﬂow
graphs for the efﬁcient path proﬁling and insert the required instru-
mentation. We use dex2jar [1] to convert Dalvik bytecodes to
Java bytecodes; then after instrumentation, we compile the classes
back to Dalvik with the dx tool provided by the Android SDK. The
Analyzer uses R [3] for the robust linear regression functions and
Java code to perform the path adjustments. Finally, the Annotator
is based on an Eclipse visualization plugin we built for prior work
in energy estimation [12].

4.3 RQ1: Analysis Overhead

For the ﬁrst research question, we consider three aspects of the

Table 2: Time and Accuracy

Timing Measurements

Accuracy

App
BBC Reader
Bubble Blaster II
Classic Alchemy
Skyﬁre
Textgram

TI (s)
353
460
873
277
298

TA(s)

TR(%)

158
145
128
97
63

0.51
3.24
8.77
1.12
6.33

R2

0.94
0.90
0.93
0.99
0.92

AEE (%)

6.5
8.6
3.4
4.8
6.3

approach’s analysis time. These are: (1) time to instrument each
application (TI), (2) time to perform the ofﬂine analysis (TA), and
(3) runtime overhead introduced by the instrumentation (TR). Ex-
periments to measure the ﬁrst two were performed on a desktop
platform containing an Intel i3@2.1Ghz with 2GB RAM and run-
ning Ubuntu 12.04. Overhead was measured on the LEAP plat-
form.

To determine TI, we measured the time to instrument each ap-
plication with vLens. After running the application and collecting
the path and invocation tuples, we determined TA by measuring the
time to analyze the tuples, perform path adjustments, and calculate
each source line’s energy using the regression analysis. The results
of these measurements are shown, in seconds, in Table 2. The time
to instrument ranged from ﬁve to twelve minutes, and the time to
analyze ranged from one to just under three minutes. Most of the
instrumentation time was due to the computational cost of building
and analyzing the control ﬂow graphs for each of the methods. The
majority of the ofﬂine analysis cost was due to the IO overhead of
reading all of the path tuples into memory so they could be con-
verted to the path matrices. Further optimizations, such as caching
path information during the ofﬂine analysis, could reduce this cost
further. However, since vLens is intended to be an experimental
prototype, we did not implement these improvements.

To determine the runtime overhead of the instrumentation (TR)
we could not take the straightforward approach of comparing an in-
strumented version of each application against the uninstrumented
version. The reason for this is that a signiﬁcant amount of appli-
cation time is actually spent idle, waiting for user input or data.
The normal user variation in entering this data masks the instru-
mentation overhead variation. Therefore we calculate the non-idle
execution time of the instrumented application and then determine
the percentage of that time that is caused by the instrumentation. A
key insight to measuring non-idle time is that the Android operat-
ing system is event driven, so it idles waiting for user input after a
method exits, and then when it receives input, comes out of the idle
state and executes the event handler method. Therefore, we can
calculate the non-idle time of the application by summing up all of
the time during which an application path was being traversed. For
example if path p1 executed from time 1 to 3 and path p2 executed
from time 2 to 4, then we can calculate the non-idle time as 3 units.
Note that this properly counts a time unit once regardless of how
many threads are executing. Next, we proﬁled the instrumentation
code that was inserted into the application and determined its exe-
cution time TInst. By examining the path tuples, we also know the
execution frequency n of the instrumentation. The resulting calcu-
lation for TR is shown in Equation 5. Here the denominator is the
special time summation described above.
n ∗ TInst

TR =

∪Ti

(5)

The results of this calculation are shown in Table 2 as TR. The
overhead costs range from 0.51% to 8.77% with an average just
under 4%. Overall, this is a low runtime overhead, representing

about 0.15 seconds. Anecdotally, this amount of overhead did not
cause a noticeable delay to the testers during execution.
4.4 RQ2: Measurement Accuracy

For the second research question, we consider the accuracy of
the measurements calculated by vLens. The primary challenge in
this evaluation is that there is no source line ground truth against
which we can compare for accuracy. As discussed in Section 2,
power samplers cannot measure at a frequency high enough to cap-
ture individual source lines. Therefore, we show accuracy of the
approach in several other ways. First we examine the accuracy of
the energy attributed to the APIs. Second, we use statistical tests
to show that the regression analysis results can describe the over-
all energy consumption relationship accurately and that each path
also accurately accounts for its energy. Lastly, we show that our
technique for identifying high-energy events via statistical outlier
analysis correctly identiﬁes paths that contain these events.

Figure 6: Comparison of API energy cost

4.4.1 Accuracy of the API Energy Measurements
To measure the accuracy of the API energy measurements, we
compared their measured cost against a proﬁled cost. To obtain
the measured cost, we ran the apps using vLens and extracted the
cost of each invocation that was executed during the test runs. Al-
together, there were invocations to over 3,722 unique APIs. From
this group we focused on a group of twenty-four APIs whose in-
vocations together comprised more than 70% of the total invoca-
tion related energy consumed by the ﬁve applications. For these
twenty-four, we recorded the arguments and execution context of
the invocations and then proﬁled their energy cost. The proﬁling
was performed on the LEAP platform by executing each invoca-
tion 100 times and then measuring the energy consumed during the
execution. We repeated this proﬁling ﬁve times and calculated the
mean and standard deviation of the experiment. The proﬁled cost
was then compared against the cost calculated by vLens. The re-
sult of this comparison are shown in Figure 6. Each of the APIs
are listed along the X-axis and the two different costs are shown on
the Y-axis, the values on the Y-axis are normalized to the cost of
proﬁled cost. One standard deviation off of the proﬁling mean is
shown with the additional horizontal lines.

Figure 6 shows that for nineteen of the twenty-four APIs, the
vLens measured cost was within an average of 9% of the proﬁled
costs and the gap was within one standard deviation in almost all
cases. For the remaining ﬁve, the measured cost was off signiﬁ-
cantly. We investigated these APIs to determine what caused this
high error rate. The ﬁrst four APIs are synchronized, which means
that they invoke monitor_enter and monitor_exit. This

  0.00  0.50  1.00  1.50  2.00123456789101112131415161718192021222324Normalized EnergyvLensProfilingmade the execution time and energy consumption of their invoca-
tion vary widely as the acquisition and release of the synchroniza-
tion lock was non-deterministic. The ﬁfth API accessed an HTTP
response code, and we found that the code was cached after the
ﬁrst call to the method, which meant signiﬁcantly less computa-
tions had to be performed in subsequent invocations. Because the
proﬁling results for these ﬁve were skewed by these types of be-
haviors, we consider the nineteen to be a more accurate reﬂection
of the accuracy achieved by the vLens calculations.
4.4.2 Accuracy of Bytecode Energy Distribution
We evaluate the accuracy of the bytecode regression model in
two ways. First, we determine the accuracy of the regression model
at an application level by comparing the amount of application en-
ergy calculated using the regression model versus the amount of
application energy actually measured during the experiments. Sec-
ond, we look at the accuracy of the regression model at a path level
by determining the multiple correlation coefﬁcient of the calculated
paths values. The results of these experiments are reported in Ta-
ble 2. Note that we cannot perform this experiment at the bytecode
level because we do not have a way to establish the bytecodes’
ground truth measurements.

To determine the accuracy of the regression model at the applica-
tion level, we calculate the Accumulated Estimating Error (AEE).
This value represents the normalized difference between the amount
of energy that the regression model would calculate for the appli-
cation versus the amount of actually measured energy. Intuitively,
the AEE can be thought of as the amount of total energy not accu-
rately accounted for by the regression model and a lower ratio is a
stronger result. The AEE is shown in Equation 6. The ˆyi represents
the energy calculated for the ith path based on the regression model
and yi is the measured energy of the ith path produced by the Path
Adjuster (i.e., with the invocation energy removed.)

AEE =

|Σˆyi − Σyi|

Σyi

(6)

To determine the accuracy of the regression model at a path level,
we calculate the multiple correlation coefﬁcient (R2). The R2 is a
well-known statistical measure that shows how well a variable can
be predicted based on a linear function of multiple variables. In
our case the value to be predicted is the energy of the ith path (ˆyi)
calculated with the regression model, and the multiple variables
are the individual bytecodes solved for during the regression. The
value of R2 is obtained by calculating the solution to Equation 7.
As with the AEE in Equation 6, yi is the adjusted measured value
of the ith path, ˆyi is the path’s value calculated using the regression
model, and ¯y is the mean of the measured paths. The R2 value is
measured on the interval [0, 1] with a value close to 1 representing
a strong ﬁt of the data to the model and 0 representing a weak ﬁt.

R2 = 1 − Σ(yi − ˆyi)2
Σ(yi − ¯y)2

(7)

For the AEE, the numbers range from 3.4% to 8.6% with an av-
erage of just under 6%. This means that, on average, 6% of the
actual measured energy is not accounted for by the model. In gen-
eral, since linear regression is an approximation, a certain amount
of variance in the energy totals is to be expected. In this context,
we believe that 6% represents a low enough number that the overall
results of the analysis would still be informative and help to guide
the developer in making changes to the code. The R2 values range
from 0.9 to 0.99 with an average of 0.936. The high average R2
value shows that our model is able to ﬁt the measured data very

closely. Overall, these numbers show that our regression model
exhibits high accuracy with respect to its calculations at both the
application and path level.

4.4.3 Accuracy of Outlier Detection
We evaluated the accuracy of the RLR techniques to detect out-
liers caused by garbage collection and thread switching events. To
do this, we seeded a variable number (20, 50, 100, and 200) of ar-
tiﬁcial events along paths of the subject applications by inserting
calls to garbage collection (System.gc()) and thread switching
instructions (Thread.start() and Thread.join()). The
target thread contained only a single instruction so that its actual
execution time would be low and the most prominent cost would be
the context-switch overhead. We then applied the RLR techniques
and checked to see if the paths containing the seeded events were
determined to be outliers. For each of the applications, the RLR
techniques were able to detect all of the seeded high-energy events.
From this result, we conclude that the use of statistical outlier de-
tection to identify paths affected by garbage collection and thread
switching overhead is both an effective and practical approach.
4.4.4 Threats to Validity
In this section we discuss the threats to the validity of our empir-

ical evaluation and explain how we addressed these issues.

External Validity: The subjects in this study are real world mar-
ketplace apps downloaded from the Google Play Market. They rep-
resent different app domains and, in terms of size, are representa-
tive of many apps we saw in the marketplace.

Internal Validity: In general, to help ensure internal validity,
the accuracy and timing experiments were repeated multiple times
and averaged. To ensure that the outlier detection was a result of
our technique, we tracked the seeding of the garbage collection and
thread switching, so we could determine easily in which paths they
occurred. Furthermore, we compared actual and seeded garbage
collection events, to verify that they had similar energy characteris-
tics. For threads, we used a minimal sized thread (one instruction)
to ensure that the thread’s energy was not inﬂated and therefore
made easier to detect.

Construct Validity: For accuracy, we were unable to use the
most straightforward comparison, bytecode ground truth, due to
the difﬁculty of measuring the ground truth for such short events.
Instead, we used invocation ground truth and well-known statistical
tests to show the degree to which our models ﬁt the measured data.
Overall, it seems likely that if the calculated values for invocation
were close to ground truth and the R2 values were consistently
high across all apps, then the calculated source line level energy
would also be accurate. Nonetheless, this is a validity threat that
our experimental design could not completely address.

5. RELATED WORK

There are two areas of related work for our approach, energy es-
timation and power measurement. The ﬁrst area, energy estimation,
assumes that developers do not have access to power measurement
hardware and uses software based techniques to predict how much
energy an application will consume at runtime. The second group
of techniques, power measurement, makes use of power measure-
ment hardware to obtain power samples and then uses software
based techniques to attribute the power to implementation struc-
tures.

The general process of energy estimation techniques is to build
a parameter-based model of energy consumption, capture values
for the model’s parameters from the application, and then calculate

the values produced by the model. As compared to our approach,
the primary difference is that estimation techniques assume that
developers do not have access to power measurement devices, the
target hardware platforms, or are unable to use these techniques for
various reasons. These scenarios can occur frequently in practice
and make estimation techniques a complementary approach to ours.
Our prior work developed an approach, eLens, for predicting
the energy consumption of smartphone applications based on an
expected workload [12]. The eLens technique is based on per-
instruction cost functions, which are provided by a Software En-
ergy Environment Proﬁle (SEEP) and driven by parameters ob-
tained via program analysis. Developing the SEEP is labor in-
tensive and may not always be feasible, as there are thousands of
APIs in the Android SDK, many of which require complex energy
In contrast, vLens takes live energy measurements and
models.
attributes them to source lines using regression and statistical tech-
niques. The vLens technique does not require a SEEP, but does
require a Power Measurement Platform, which may be easier to
obtain for some developers. Because vLens is based on runtime
measurements, it must also deal with the inﬂuence of garbage col-
lection, thread switching, tail energy, and sampling intervals.

Seo and colleagues [27, 28, 29] have proposed several software
energy estimation techniques. They model the energy consump-
tion of each Java bytecode and the network utilization, and capture
these two types of information by modifying the JVM. Compared
to vLens, their estimation requires modiﬁcations to the runtime sys-
tems, the construction of energy models, and provides information
at a component level instead of the source level.

Other approaches estimate software energy using models based
on operating system (OS) level features. These features include
calls to OS-level APIs [18, 33] or state metrics internal to the op-
erating system [23, 24, 39], such as CPU frequency and network
usage. Similar to this work are approaches to estimate the energy
consumption in virtual machines [10, 17, 32, 38]. Compared with
our approach, this body of work requires signiﬁcant integration and
modiﬁcation to the runtime systems and is not as portable. Further-
more, the workload of building models can be high.

Another group of approaches for software energy estimation is
based on low-level hardware modeling. Works of this type build
models based on the assembly instructions [35, 36] or micro-
instructions of each assembly instruction [19, 31]. The drawback
of these approaches is that they cannot estimate the energy of ex-
ternal devices (e.g.,, GPS, WIFI, etc.), which also consume a large
portion of energy in modern mobile systems. Moreover, Sinha and
colleagues [30] have shown that, at this level, the energy consump-
tion of instructions or micro-instructions are roughly the same. Un-
like this body of work, vLens can measure the energy consumption
of the entire mobile system, including external devices.

The last type of work to estimate software energy is to build sim-
ulators. The main drawback of simulators is their speed. Cycle-
level simulators [7, 22] can require thousands of instructions to
simulate one instruction, which is too slow to use for simulating
modern interactive applications. Even functional simulators [21],
which are comparatively faster than cycle accurate simulators, run
too slowly to be useful for capturing realistic user interactions.

The most closely related techniques to our approach are based on
power measurement. The general approach for these techniques is
to use a power measurement device, such as the LEAP [25] or Mon-
soon [2] power meters, that can sample energy measurements at a
certain frequency. These measurements are then combined with
software based techniques to provide useful information to soft-
ware developers. Sahin and colleagues [26] map energy consump-
tion to different component level design patterns. Their work ex-

plored the correlations between energy consumption and the use of
different design patterns. At a higher level, Flinn and colleagues [6,
11] measured the energy consumption of applications and mapped
the energy to individual OS processes. This was done, in part, by
instrumenting the operating systems.

Sesame [8] measures the energy by reading the battery inter-
face of laptops and uses regression analysis to automatically gen-
erate energy consumption information based on system level met-
rics, such as CPU workload and network utilization measurements.
However, Sesame does not provide information at the level of source
code lines. Tan and colleagues [34] also use regression analysis to
map energy to paths in the control ﬂow graph, but are not able to
provide any ﬁner level of granularity with their measurements.

Compared with these measurement approaches, vLens is able to
provide energy measurements at a much ﬁner level of granular-
ity. vLens calculates energy measurements at the source line level,
whereas the above mentioned approaches compute their informa-
tion at the level of entire application, architecture level components,
design patters, or methods.

6. CONCLUSION AND FUTURE WORK

In this paper, we presented our approach for calculating the source
line level energy consumption of Android applications. Our ap-
proach employs a combination of hardware-based energy measure-
ments and efﬁcient path proﬁling to correlate energy measurements
with the application’s execution. Then the approach analyzes each
of the executed paths to handle high energy events, such as garbage
collection and thread switching. The adjusted measurements are
then used to perform a regression analysis that maps the energy to
the individual source lines.

For the evaluation, we implemented our approach in a prototype
tool, vLens, and ran it against ﬁve real-world marketplace apps. Our
evaluation showed that vLens was fast, it was able to calculate en-
ergy information for each app in under three minutes. The approach
was also accurate. It was able to attribute invocation information
to within 10% of the ground truth, the statistical models ﬁt the data
closely with an R2 average of 0.93, and it could detect the high
energy events with 100% accuracy. Overall, the results are promis-
ing and indicate our approach has the potential to help developers
understand the energy related behavior of their applications.

In future work we will focus on improving several aspects of
our approach. The ﬁrst aspect is to design new experiments to im-
prove the construct validity of our experiments. Ideally, we would
do this via faster power sampling techniques; however, it is un-
likely that power samplers will show the same increase in speed
as CPUs. Therefore, we will investigate new statistical and ex-
perimental methods that will allow us to more precisely quantify
source line level accuracy of our approach. Second, we would like
to improve techniques for solving the linear systems of equations
when there are insufﬁcient data points and attaching “conﬁdence”
metrics to our approximations. Third, we would like to explore al-
ternative ways of handling paths that are identiﬁed as outliers by
the statistical analysis. For example, by identifying ways to at-
tribute high-energy events to source lines in a way that is meaning-
ful for developers. Lastly, we would like to use vLens in developer
studies to determine its usefulness for making energy consumption
improvements.

7. ACKNOWLEDGEMENTS

This work was supported by the National Science Foundation
under Grant No. CNS-905596 and a Zumberge Research Award
from the University of Southern California.

Calculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36

an approach that combines hardware-based energy measurements
with program analysis and statistical modeling techniques. At a
high-level, the basic intuition is as follows: While measuring the
energy consumption of a smartphone, the approach uses efﬁcient
path proﬁling to identify which parts of the application are exe-
cuting and correlates these paths with the measured energy. Then,
the approach statically analyzes the paths to identify and adjust for
high-energy events, such as thread switching, before applying ro-
bust regression analysis to calculate each source line’s energy con-
sumption. Finally, the approach presents developers with a graph-
ical representation of the energy consumption by overlaying the
calculated energy with the source code of the application.

We also performed an empirical evaluation of our approach to
measure its accuracy and the time needed to perform the analysis.
Our approach was able to accurately calculate energy. For a set of
API invocations, we found that the calculated energy values were
within 10% of the ground truth measurements. The statistical mod-
els also matched the measured data very closely with a high R2
average of 0.93 and a low accumulated error rate. Importantly, in
our experiments, the approach was also able to detect the inﬂuence
of high-energy events, such as thread switching and garbage col-
lection, with 100% accuracy. The approach was also fast, it could
calculate source line level energy measurements for each of our
subject applications in less than three minutes. Overall, the results
of the evaluation were positive and indicate that our approach is an
effective and practical way to provide developers with source line
level energy information.

The remainder of this paper is organized as follows: In Section 2
we discuss several of the signiﬁcant challenges that shaped the de-
sign of our approach. We present the approach itself in Section 3.
The evaluation of the approach is described in Section 4. Finally,
we discuss related work and conclude in Sections 5 and 6.

2. BACKGROUND AND MOTIVATION

In this section we discuss several challenges to measuring and
calculating source line energy consumption. We break the chal-
lenges into three broad categories, hardware, runtime system, and
software level, and explain how they preclude a straightforward
solution for calculating source level energy consumption. To il-
lustrate these challenges, we make use of the code shown as Pro-
grams 1 and 2, which are excerpts from the open-source Google
Authenticator project that handles synchronizing a system clock.
In the example, method getNetworkTime (Program 1, line 1)
retrieves the time by sending an HTTP request to a timeserver
(line 7) and then parsing the response packet (lines 16, 20, 23,
26). Method runBackgroundSync (Program 2, line 2) calls the
getNetworkTime (line 6) and then starts a background thread
to handle errors (line 10).
2.1 Hardware Limitations

The primary hardware obstacle to directly measuring the energy
consumption of source lines is the difference in the speed at which
instructions execute and hardware devices can perform energy mea-
surements. On modern processors, individual instructions will ex-
ecute at a rate of several million per second. At best, power me-
ters can sample electrical power draw at several tens of KHz [16],
which means that each sample will include the power consumption
of hundreds, perhaps thousands, of instructions. For example, it
is possible for Program 2 to execute completely in the time that
transpires between two consecutive power samples by a relatively
fast power meter. There are reasons to believe that this order of
magnitude disparity will likely persist, since the bottleneck in high-
frequency power sampling is the storage system, which cannot save

p u b l i c long getNetworkTime ( )

throws

I O E x c e p t i o n {

HttpHead r e q u e s t = new HttpHead (URL ) ;
Log . i (LOG_TAG, "Sending request to "

+ r e q u e s t . getURI ( ) ) ;
H t t p R e s p o n s e h t t p R e s p o n s e ;
t r y {

h t t p R e s p o n s e = m H t t p C l i e n t . e x e c u t e ( r e q u e s t ) ;

} catch ( C l i e n t P r o t o c o l E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( S t r i n g . v a l u e O f ( e ) ) ;

} catch ( I O E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( "Failed due " +

"to connectivity issues: " + e ) ;

}

t r y {

Header d a t e H e a d e r =

h t t p R e s p o n s e . g e t L a s t H e a d e r ( "Date" ) ;

Log . i (LOG_TAG, "Received response with "

+"Date header: " + d a t e H e a d e r ) ;

i f

( d a t e H e a d e r == n u l l ) {

throw new I O E x c e p t i o n ( "No Date header" ) ;

}
S t r i n g d a t e H e a d e r V a l u e =

t ry {

Date networkDate =

d a t e H e a d e r . g e t V a l u e ( ) ;

D a t e U t i l s . p a r s e D a t e ( d a t e H e a d e r V a l u e ) ;

return networkDate . getTime ( ) ;

} catch ( D a t e P a r s e E x c e p t i o n e ) {

throw new I O E x c e p t i o n (

"Invalid Date header format " ) ;

}

} f i n a l l y {

. . . . . .

}

}

Program 1: Google Authenticator Method 1

power samples at the same frequency as the power meter can gen-
erate them [14, 15, 20], and there is no evidence to show that this
gap will be closed in the near future. Therefore, a challenge for our
approach is to reconcile power measurements samples and instruc-
tion execution, even though there is a several orders of magnitude
difference in their frequency.
2.2 Runtime System Challenges

The runtime system of an Android smartphone includes both the
Android operating system and the Dalvik Virtual Machine, the plat-
form on which marketplace apps are run. The runtime system im-
plements several types of behaviors that affect energy consumption
of an app, thread switching, garbage collection, and tail energy.
However, the details of the duration, frequency, and timing of these
events is, by design, hidden from the app. This makes it difﬁcult
to correctly attribute energy at the source level. Although it would
be straightforward to modify the runtime systems to track these
events, this would introduce considerable overhead and reduce the
portability of the approach, as it would be necessary to provide
custom runtime systems for each smartphone platform. Therefore,
one challenge for our approach is to account for these events with
information that is available at the app layer.

Thread switching causes several problems for calculating source
line level energy. The ﬁrst problem is that any energy measure-
ments for a given time period may also include energy for threads
that are not related to the application (i.e.,, operating system pro-
cesses). For example, at any point in the execution of the thread
in runBackgroundSync or getNetworkTime, the OS could
swap in a thread from another app or the OS. Any power samples
during this time would likely include instructions from both the
original and swapped-in thread. The second problem is that thread

p r i v a t e void

runBackgroundSync ( E x e c u t o r
long n e t w o r k T i m e M i l l i s ;
t r y {

n e t w o r k T i m e M i l l i s =

c a l l b a c k E x e c u t o r ) {

mNetworkTimeProvider . getNetworkTime ( ) ;

} catch ( I O E x c e p t i o n e ) {

Log .w(LOG_TAG, "Failed to obtain network " +
"time due to connectivity issues" ) ;

c a l l b a c k E x e c u t o r . e x e c u t e ( new Runnable ( ) {

@Override
p u b l i c void run ( ) {

f i n i s h ( R e s u l t . ERROR_CONNECTIVITY_ISSUE ) ;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

}
} ) ;
return ;

}

Program 2: Google Authenticator Method 2

switching itself introduces an energy overhead. For example, Line
10 of Program 2 will incur a signiﬁcant energy overhead for the
context switch that occurs when a new thread is started.

Periodically, the Android operating system will perform garbage
collection during the execution of an application. Typically, ap-
plications do not have control over garbage collection, it is man-
aged by the operating system and can occur anytime and within
any method. Although the Dalvik virtual machine logs garbage
collection, it timestamps the events via a millisecond based clock,
which does not provide enough precision to determine in which
path they occur (paths are tracked with nanosecond timestamps.)
As we note in Section 3.2.2, garbage collection incurs a signiﬁ-
cant energy cost and has the potential to signiﬁcantly distort en-
ergy measurements for an application. For example, consider if
garbage collection were to occur at line 20 of Program 1, which is
compiled as a simple jump on equality (ifeq), or line 6 of Pro-
gram 2, which is a relatively expensive method invocation. The
extremely high cost of the garbage collection would dwarf the cost
of both instructions making them appear to have a nearly identical
high energy cost. Therefore, an approach must be able to identify
and properly account for garbage collection while calculating the
source line level energy consumption of an application.

Smartphones exhibit tail energy usage, where certain hardware
components are optimistically kept active by the operating system,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. Tail energy manifests itself in two differ-
ent ways. The ﬁrst way is when an invocation to an API accesses a
hardware component and then returns. Even when no other invoca-
tions access the component, the component will remain active for
a time period Ttail and consume energy Etail. An example of this
kind of invocation is at line 7 of Program 1. The call to the network
will cause the radio to remain on for a period of time, even after
the request is ﬁnished, and consume energy during this time. The
second way is when two invocations access the component in se-
quence and the time interval between them is less than Ttail. Here,
only a portion of Etail will be consumed. The Etail for certain de-
vices can be quite high and a naive approach to measurement might
attribute the tail energy cost to subsequently executed instructions.
Referring back to the example invocation, the naive approach could
mistakenly attribute part of the invocation’s tail energy to its suc-
cessors, lines 16, 18, and 20, (depending on the length of its Ttail)
instead of to line 7. To be accurate, an approach must recognize
when tail energy occurs and attribute it to the source invocations
that started the component and kept it at a non-idle state.

2.3 Software-Level Challenges

Source level calculations require precise information about an
app’s execution. In particular, for each time period represented by
a power sample, it is necessary to know which instructions were
executed, their frequency, and their ordering — essentially, path
information. The primary challenge is that obtaining this type of
information at the software level is generally expensive and intru-
sive. For example, inserting instrumentation into an app to iso-
late and measure individual instructions can lead to high overhead.
Even optimizations, such as only instrumenting each basic block,
would still produce a high amount of instrumentation. Other ap-
proaches, such as instruction counting, do not allow developers to
know which instances of the instructions were executed.

It is also necessary to have precise information about API invoca-
tions. During execution, smartphone applications generally invoke
library functions and APIs to access hardware components, such
as GPS, network, and WiFi. For example, at line 7 of Program 1,
getNetworkTime() sends an HTTP request to Google by in-
voking HttpClient.execute(). This invocation consumes
a relatively large amount of energy due to its use of the network.
In contrast, a call to dataheader.getValue at line 24 of Pro-
gram 1, incurs a relatively small constant cost, since it is simply
returning the value of an HTTP header. This wide range of invo-
cation behavior causes problems for techniques that naively apply
statistical sampling or averaging-based approaches because, unlike
normal instructions, an invocation’s energy cost can vary based on
its target and the data provided for its arguments. Furthermore, it is
not feasible to precompute the cost of API calls, since that requires
sampling every point in each API calls input space to determine its
energy consumption.
3. APPROACH

The goal of our approach is to provide source line level energy
information for smartphone applications. An overview of our ap-
proach is shown in Figure 1. From a high-level, our approach has
two phases, Runtime Measurement and Ofﬂine Analysis. The in-
puts to the Runtime Measurement phase are the application under
analysis (AUA) and a set of use cases for which the tester wants
to obtain energy measurements. The App Instrumenter uses an
efﬁcient path proﬁling technique to guide the insertion of probes
into the AUA that will capture timestamps and path traversal infor-
mation. The tester executes the instrumented AUA on the Power
Measurement Platform. This causes the instrumentation to record
path information while the Power Measurement Platform records
power samples. The path and power samples are the inputs for the
Ofﬂine Analysis phase. The Path Adjuster performs a static anal-
ysis of the paths and makes modiﬁcations to the power samples to
account for the high-energy events. Then the Analyzer performs
the regression analysis in order to calculate each source line’s en-
ergy consumption. If the Analyzer ﬁnds there are not enough data
points to solve the regression analysis, then the process returns to
the Runtime Measurement phase so the developer can further exe-
cute the application. If this is not possible, then the Analyzer per-
forms approximations that we discuss in Section 3.2.2. Finally, the
Annotator uses the calculations to create graphical overlays of the
measurements on the source code for display in an integrated de-
velopment environment. We explain the approach in more detail in
the remainder of this section.
3.1 Runtime Measurement Phase

During the Runtime Measurement phase, information about the
paths executed in the AUA and power measurements are generated
by the approach. To do this, the App Instrumenter inserts probes

Figure 1: Overview of the approach

into the AUA to record the information, and then the instrumented
AUA is executed by the developer while power samples are col-
lected by the Power Measurement Platform. The output of the Run-
time Measurement phase is set of timestamped paths executed by
the AUA and power measurements.

Instrumentation of the AUA: The instrumentation collects in-
formation about the paths executed by the developer. Namely, which
paths are traversed, their frequency, and timestamps of the path
traversals and invocation of certain APIs. To record the path infor-
mation, the App Instrumenter adapts a techniques for efﬁcient path
proﬁling proposed by Ball and Larus [5]. The approach ﬁrst builds
a control-ﬂow graph (CFG) of each method in the AUA. Then each
edge in the CFG is assigned a label so that each unique path in the
CFG has a unique path ID. The approach then calculates a maxi-
mal spanning tree over the CFG and uses this to guide the minimal
placement of instrumentation that will increment a path ID counter.
By design, the approach can use a single counter to identify the path
traversed in the method. We extended the Ball-Larus approach to
handle nested method calls, concurrency, and exceptions. The App
Instrumenter also inserts a probe at the method entry to initialize
the method’s path counter, record a timestamp of when the path
traversal began, and the current thread ID. At each exit point of
the method, another probe records the value of the path ID counter,
and another timestamp. After execution is ﬁnished, this informa-
tion allows the approach to generate a set of path tuples of the form
(cid:104)thread_id, path_id, enter_time, exit_time(cid:105) where thread_id
identiﬁes current thread, path_id is the traversed ID for paths, and
enter_time and exit_time are the time stamps that indicate when
a path starts and ends.

The App Instrumenter also inserts probes to obtain timestamps
before and after the invocation of certain APIs. As we explain
in Section 3.2.1, this information is used to allocate tail energy
and isolate the energy cost of certain APIs for which it is not
possible to model using linear regression (i.e., methods that have
non constant energy consumption.) For each of the invocations,
the instrumentation generates an invocation tuple of the form
(cid:104)method_id, enter_time, exit_time(cid:105), where method_id iden-
tiﬁes the invoking method, and enter_time and exit_time are
timestamps before invoking the method and after the method has
returned.

Execution of the Instrumented AUA: To generate the path and
invocation tuples, the instrumented AUA is executed on the Power
Measurement Platform. The Power Measurement Platform is based
on the LEAP node [25]. The LEAP is an x86 platform based on an

ATOM N550 processor that runs Android 3.2. Each component
in the LEAP (e.g., WiFi, GPS, memory, and CPU) is connected
to an analog to digital converter (DAQ) that samples current draw
at 10KHz. The LEAP also provides Android applications with the
ability to trigger a synchronization signal. This allows the approach
to synchronize the samples with the paths’ timestamps and avoid
inaccuracy due to clock skew. Each of the uses cases is executed
by the developer on the AUA while it is running on the LEAP. Note
that all of the measurements are recorded in hardware external to
the Android smartphone components, so the measurement process
does not introduce any interference or execution overhead.
3.2 Ofﬂine Analysis Phase

In the Ofﬂine Analysis phase, our approach analyzes the tuples
and power samples generated in the Runtime Measurement phase
to produce a mapping of energy to source lines. There are three
parts to this phase.
In the ﬁrst part, the Path Adjuster statically
examines each traversed path in the CFG and adjusts the corre-
sponding energy measurements to account for special API invoca-
tions, tail energy, and interleaving threads. The adjusted energy
measurements and paths are the inputs to the second part, the Ana-
lyzer, which uses robust regression techniques to calculate the cost
of each source line and identify paths along which garbage col-
lection and thread context switches occurred. The Analyzer also
determines if the testing process created enough data points to per-
form the linear regression and either reduces the grouping of vari-
ables to be solved in the regression or directs the tester to repeat
the test cases to provide more data points. Finally, in the third part,
the Annotator creates a graphic representation of the energy mea-
surements and overlays this with the source code. Note that in the
rest of the paper, we describe our approach in terms of bytecode
instructions, but it is straightforward to convert the bytecode-level
information to source-level using compiler provided debugging in-
formation.
3.2.1 Adjustment to Path Energy Samples
Before beginning the analysis, the Path Adjuster ﬁrst reconstructs
the paths traversed during execution of the AUA. The instructions
executed in a path can be identiﬁed using the path ID and the
CFG of the method containing the path, as described by Ball and
Larus [5]. Once the paths have been reconstructed, the Path Ad-
juster calculates the energy total for the path by summing the mea-
surements reported during the path’s time of execution. The Path
Adjuster can identify the corresponding path and power samples
due to the synchronized timestamps. Then, the Path Adjuster per-

App Instrumenter Path Adjuster Analyzer Annotator Runtime Measurement Phase  Offline Analysis Phase Application (AUA) Use  cases Energy Report Power Measurement Platform Visualization {<paths>} {<power>} Insufficient data? AUA´ forms a static analysis of each path in order to adjust certain API
invocations due to non-constant and too-short API invocations, tail
energy, and thread interleaving. The Path Adjuster generates a
set of paths with the adjusted invocations removed from the paths
and their corresponding energy removed from the power measure-
ments.

API Invocations: Certain API invocations have a non-constant
energy cost associated with their execution. Therefore, it is not
possible to calculate their energy cost using the robust linear re-
gression techniques described in Section 3.2.2. To address this
problem, our approach uses the invocation tuples to identify the
time periods when these invocations are executing and calculates
the invocations’ energy cost by summing the power measurements
taken during that time.

Figure 2: Using longer execution windows for calculating the
energy of invocations with a short execution time.

In most cases, the execution time of an invocation is long enough
that the approach is able to get accurate energy measurements (i.e.,
the execution time is longer than several sampling periods.) How-
ever, in some cases the execution time of the invocation is too brief
(e.g., the execution time is shorter than a sampling period.) For
these invocations, the approach identiﬁes an execution time period
that includes the too short execution and for which the approach
does have enough power samples to accurately the energy con-
sumption. Then it calculates the ratio of the original execution time
versus the larger execution time and multiples that against the en-
ergy total for the larger execution time. To illustrate, consider the
example shown in Figure 2. In this ﬁgure, the horizontal bars in-
dicate the energy sampling interval. For example, the LEAP will
sample the power at t3 and then again at t4. If an invocation I exe-
cutes from time t1 until time t2, then there are no power samples to
be summed in order to ﬁnd the energy consumed by I (EI). When
this occurs, the Path Adjuster ﬁnds the next largest execution win-
dow for which it has sufﬁcient energy samples and uses this win-
dow to calculate EI. In the case of the example, the Path Adjuster
calculates EI as shown in Equation 1, where Ea,b denotes the en-
ergy consumption measured by the Power Measurement Platform
during interval [a, b].

t2 − t1
t4 − t3

Et3,t4

(1)

Note that this only approximates EI. We have found that for
functions whose execution time is so short, this is a reasonable ap-
proximation. These functions consume a very small portion of the
overall energy expended at runtime, on average about 6% of the
total API energy cost. For the general case, where the execution
time is of sufﬁcient length, our evaluation shows that we are able to
accurately measure most functions to within 9% of their measured
ground truth cost.

Figure 3: API invocations with tail energy

Tail Energy: As explained in Section 2, tail energy occurs when
the operating system keeps certain hardware components active,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. The result of this behavior is that the en-
ergy measurements for the time period following the component
access will be higher. Our approach adjusts the path energy total so
that the tail energy is attributed to the invocations that interact with
the hardware component. We assume the availability of tail energy
models, which are generally provided by either component manu-
facturers or power researchers [24]. The model speciﬁes the energy
consumption of the component after an invocation (Etail) and for
how long the device driver maintains this state (Ttail). To calcu-
late the adjustment, the Path Adjuster examines the reconstructed
paths to identify the sequence AD of invocations to methods that
cause tail energy for each device D of the smartphone. For each
such invocation ai ∈ AD, the adjuster compares the timestamp of
ai against the timestamp of ai+1. If the difference is greater than
Ttail then all of Etail is attributed to ai. If the difference is less
than Ttail then only a fraction of Etail is expended before ai+1
occurs and should be attributed to ai. The fraction is calculated as
shown in Equation 2, where TS returns the starting timestamp of an
invocation and TE returns the ending timestamp of an invocation.
Note that the invocation timestamps are known due to the invoca-
tion tuples collected during the Runtime Measurement phase.

TS(ai+1) − TE(ai)

Ttail

Etail

(2)

To illustrate these two scenarios, consider the two invocations
shown in Figure 3. Both of these, AP I_1 and AP I_2, access
the same device in sequence. Their tail energy consumptions are
shown as curved lines extending after the end of the invocations.
To calculate the tail energy associated with AP I_1, note that t2,
the start of the invocation to AP I_2, occurs before the Ttail time
has transpired. Therefore the tail energy assigned to AP I_1 is
t3−t1 ∗ Etail. When the invocation to AP I_2 returns
calculated as t2−t1
at t4, there is no other API accessing the same external device, so
we assign all of Etail, to AP I_2.

Thread Context-Switching During Invocations: A potential
problem that arises with the way the approach attributes energy to
API invocations is that it is possible for the thread containing the
invocation be switched out for another thread from the same appli-
cation. For example, this can happen because the invocation must
wait for a shared resource or another thread has higher priority.
The problem is that energy consumption by the other threads will
then also be measured in the corresponding power samples. As we
discussed earlier, this situation can be detected by modifying the
operating system to accurately track thread scheduling. However,
this would make the approach less portable, so we have devised a
software-level technique to address this problem.

ticular, the Analyzer uses RLR based on M-estimation [13], which
does iterative regression analysis. It begins by solving a normal
linear regression on the set of data points. Then at each iteration,
it calculates the residuals and gives each data point a weight based
on the standard deviations of the residuals. The regression analysis
is repeated on the weighted data to generate a new model and the
process repeats until the standard deviation of residuals does not
change between iterations. For the power samples, RLR is prefer-
able over the well-known ordinary least squares approach because
it is more robust in the presence of outliers. In this case, our data
sample has outliers, which are the paths whose energy measure-
ments are inﬂuenced by garbage collection and thread switching.

More speciﬁcally, at each iteration, given the linear function (cid:126)y =
X(cid:126)θ + (cid:126)u, the Analyzer solves Equation 3 and updates the standard
deviation of residuals. For the weighting function (ψ), we use
the well-known Tukey’s Bisquare function [37], which is shown
in Equation 4. The σ is the standard deviation of residuals in the
last iteration. The value of k is constant and is set according to
different use cases. In our experiments, we found that the average
energy cost of garbage collection and thread switching is about 10
to 70 times the average standard deviation of the residuals in the
ﬁrst iteration; therefore, we select the median 40 of this range as k.

(cid:88)
ψ(yi −(cid:88)
(cid:40)

k

i

ψk(x) =

xikθk)xij = 0

x(kσ − x2)2 −kσ < x < kσ
0

otherwise

(3)

(4)

The solution represents the energy cost of each instruction in the
path. Taken together with the measured energy cost of the invoca-
tions, the Analyzer now has the energy cost for the entire path. The
values for all of the paths are provided as input to the Annotator.
Two special cases are discussed below.

The ﬁrst special case is when it is not possible to solve for a
path’s instruction energy (i.e., m). This happens when the number
of unique bytecodes in a path is higher than the number of indepen-
dent data points. Solving linear system of equations requires that
there be at least as many independent data points as unknown vari-
ables. In this situation, the Analyzer recognizes that there are not
enough data points and can take two actions, which are repeated
until the equation is solvable. The ﬁrst is that the tester is notiﬁed
that the application should be executed more to generate additional
data points. The additional executions do not need to exactly repro-
duce the initial executions, but should represent similar use cases
to ensure a signiﬁcant amount of path overlap. Since this is not
always possible, the second possible action for the Analyzer is to
group counts of similar bytecodes. For example, all variations of
the iconst instruction. This gives fewer unknown variables for
the system of equations. Note that in our experience, even moder-
ate size marketplace apps were sufﬁciently complex that neither of
these actions were required in our evaluation.

The second special case are paths identiﬁed as outliers, which
contain external thread switching or garbage collection. The de-
tection of these outliers is discussed more below. Currently, the
Analyzer excludes these paths, which comprise about 1% of the
total path count. Although it is desirable to include these paths,
since excessive high-energy events could be a symptom of energy
inefﬁcient coding, there are two obstacles to this that we hope to
address in future work. First, the path must be adjusted to remove
the energy cost of the high-energy event. However, because the
measured energy of these events is so high compared to the path
energy, it is not clear how to accurately estimate and separate the

Figure 4: Concurrent threads during an API invocation.

The Path Adjuster determines the number of threads that were
executing while the invocation was executing. This is done by ex-
amining the starting and ending timestamps of each path tuple to
see which ones were active between the invocation’s timestamps.
Then, the Path Adjuster evenly allocates the energy among the con-
N , where N is the
current threads, assigning each the energy of 1
number of concurrent threads. To illustrate, consider the example
shown in Figure 4. T 1 is the original thread and contains an API
invocation at time t1. Threads T 2 and T 3 run while T 1 is per-
forming the invocation. T 1 and T 2 are concurrent in time interval
[t2, t3] and all three are concurrent in [t3, t4]. Therefore, the en-
ergy of T 1 will be Et1,t2 + 1
3 Et3,t4. This is similar to the
way prior approaches have handled concurrent thread energy [24].

2 Et2,t3 + 1

3.2.2 Calculating Source Line Energy Values
The second part of the Ofﬂine Analysis phase calculates the en-
ergy consumption of each source line. The input to the Analyzer
is the set of adjusted paths and energy samples produced by the
the Path Adjuster. At this point, adjustments for all of the API in-
vocations have been made, but the paths could still be inﬂuenced
by the occurrence of garbage collection and thread switching dur-
ing times when there is no API invocation. As we discussed in
Section 2, the energy costs associated with events, such as garbage
collection and thread switching, can skew the regression analysis,
but it is difﬁcult to identify when they occur. Our insight is that
characteristics of these events allow us to deﬁne them as statisti-
cal outliers and therefore the Analyzer can employ Robust Linear
Regression techniques to calculate each source lines’ energy con-
sumption and mitigate the inﬂuence of these high-energy events. In
the rest of this section, we ﬁrst explain the regression technique and
then discuss the insight that allows us to deﬁne garbage collection
and thread switching as statistical outliers.
Robust Linear Regression Analysis

The Analyzer uses linear regression analysis to calculate each
instruction’s energy consumption. We expect linear regression to
work well in this situation because prior work has found that the
cost of bytecodes will be constant given a particular hardware envi-
ronment [12, 29] and the Path Adjuster has removed the non-linear
cost invocations.

To perform the analysis, the Analyzer sets up the equations E =
mX, where E is the adjusted power measurements, X represents
the path traversals with each row representing a frequency vector of
bytecodes present in the measured path. (Note that the bytecodes
associated with the inserted instrumentation are included in this
matrix. Since the approach knows which paths were instrumented,
the associated results are simply removed before visualizing or re-
porting the ﬁnal source line level calculations.) Then the Analyzer
solves for the coefﬁcients m to determine the energy consumed by
the instructions in the path segment. To solve the equations, the An-
alyzer employs Robust Linear Regression (RLR) analysis. In par-

Table 1: Subject applications

App
BBC Reader
Bubble Blaster II
Classic Alchemy
Skyﬁre
Textgram

C
590
932
751
684
632

M

4,923
6,060
4,434
3,976
5,315

BC

Application Information
Description
RSS reader for BBC news
Game to blast bubbles
Educational game

293,910
398,437
467,099
274,196 Web-browser
244,940

Text editor

Figure 5: Visualization of the energy measurements.

event energy versus the path energy. Second, although the energy
associated with these events is signiﬁcant and of interest to devel-
opers, its not clear which instructions should be attributed with the
cost. Currently, this number is tracked and reported as a separate
total.
High-energy Events as Statistical Outliers

The energy overhead of switching to external threads and garbage
collection is quite high. Our experiments show that these events
range from 20,000 to 150,000 times the cost of a normal instruc-
tion. Yet they occur rarely during execution. Our insight is that
the high energy cost and relative infrequency of these high energy
events allows them to be detected as statistical outliers. In small
scale experiments, we found that the energy cost of a path ranges
from 0.007mJ to 0.631mJ; garbage collection from 20mJ to 81mJ;
and thread switching overhead from 6.44mJ to 11.3mJ. This means
that the energy cost of paths with garbage collection and thread
switching will be signiﬁcantly larger than normal paths — 10 to
over 10,000 times larger. This difference in the range of values al-
lows us to identify the events by deﬁning them as outliers based on
their energy consumption (i.e., by setting an appropriate value of k
in Tukey’s Bisquare function.) Note that our approach detects out-
liers for a speciﬁc path and does not simply cluster all of the energy
measurements. A per-path outlier detection is necessary since it is
possible for a path to be long enough that it consumes more energy
than garbage collection or thread switching. In the evaluation, we
validate this approach to detecting garbage collection and thread
switching by showing that our approach is able to detect all known
occurrences of these types of events.

3.2.3 Visualizing the Energy Consumption
The Annotator presents a graphical representation of the source
line level information. Developers can use this visualization to
more readily understand the distribution of energy consumption
across the different parts of their application. The Annotator was
developed as part of our prior work [12], so it is not a research
contribution of this paper. Nonetheless, we consider it an integral
aspect of our approach that increases its usability, so we brieﬂy
summarize its function.

The Annotator is an Eclipse plugin that overlays power informa-
tion onto an application’s source code. A screenshot is shown in
Figure 5. The visualization uses a SeeSoft [9] like graphical rep-
resentation where different colors indicate the amount of energy
consumed by source lines. The color for each source code line is
obtained by ranking each source line according to the sum of its
associated bytecode energy costs. The ranking is then mapped to a
color within the spectrum. In our example, blue shows low energy

consumption and red indicates a high level of energy consumption.
In between values are different levels of red and blue (purple.)

4. EVALUATION

We evaluated two aspects of our approach, analysis time and ac-
curacy. For the evaluation, we implemented our approach as a pro-
totype tool, vLens, and designed several experiments to evaluate
these two aspects. We considered two broad research questions:

RQ1: What amount of analysis time is incurred by vLens?
RQ2: How accurately does vLens calculate the energy consump-

tion of the application?
4.1 Subject Applications

In the evaluation, we used a set of ﬁve application from the
Google Play Market. Table 1 shows the number of classes (C),
methods (M), and bytecodes (BC) for each application. All of the
applications are written for the Dalvik Virtual Machine, do not use
any native libraries, and can be translated to and from Java Virtual
Machine bytecodes by the dex2jar tool. These applications rep-
resent real-world marketplace applications and implement a diverse
range of functionality. For all of the experiments, we ran the appli-
cations using canonical usage scenarios for each application. For
example, we played a game several times (Bubble Blaster II and
Classic Alchemy), created and edited a text document (Textgram),
read a news article via the reader (BBC Reader), and opened a web
page (Skyﬁre).
4.2

Implementation

The vLens prototype is written in Java and works for Android ap-
plications written to run on the Dalvik Virtual Machine. We chose
to implement for Android because its open nature made it easier
to understand the OS inner workings. However, our approach is
applicable for other platforms, such as Windows Phone and iOS,
since it relies on energy measurements provided by external hard-
ware, statistical techniques, and instrumentation, which is available
on many platforms.

There are four main modules in the implementation: the Power
Measurement Platform, App Instrumenter, Analyzer, and Annota-
tor. For the Power Measurement Platform we utilized the LEAP
power measurement device [25] described in Section 3.1. The App
Instrumenter uses BCEL [4] to build intra-procedural control ﬂow
graphs for the efﬁcient path proﬁling and insert the required instru-
mentation. We use dex2jar [1] to convert Dalvik bytecodes to
Java bytecodes; then after instrumentation, we compile the classes
back to Dalvik with the dx tool provided by the Android SDK. The
Analyzer uses R [3] for the robust linear regression functions and
Java code to perform the path adjustments. Finally, the Annotator
is based on an Eclipse visualization plugin we built for prior work
in energy estimation [12].

4.3 RQ1: Analysis Overhead

For the ﬁrst research question, we consider three aspects of the

Table 2: Time and Accuracy

Timing Measurements

Accuracy

App
BBC Reader
Bubble Blaster II
Classic Alchemy
Skyﬁre
Textgram

TI (s)
353
460
873
277
298

TA(s)

TR(%)

158
145
128
97
63

0.51
3.24
8.77
1.12
6.33

R2

0.94
0.90
0.93
0.99
0.92

AEE (%)

6.5
8.6
3.4
4.8
6.3

approach’s analysis time. These are: (1) time to instrument each
application (TI), (2) time to perform the ofﬂine analysis (TA), and
(3) runtime overhead introduced by the instrumentation (TR). Ex-
periments to measure the ﬁrst two were performed on a desktop
platform containing an Intel i3@2.1Ghz with 2GB RAM and run-
ning Ubuntu 12.04. Overhead was measured on the LEAP plat-
form.

To determine TI, we measured the time to instrument each ap-
plication with vLens. After running the application and collecting
the path and invocation tuples, we determined TA by measuring the
time to analyze the tuples, perform path adjustments, and calculate
each source line’s energy using the regression analysis. The results
of these measurements are shown, in seconds, in Table 2. The time
to instrument ranged from ﬁve to twelve minutes, and the time to
analyze ranged from one to just under three minutes. Most of the
instrumentation time was due to the computational cost of building
and analyzing the control ﬂow graphs for each of the methods. The
majority of the ofﬂine analysis cost was due to the IO overhead of
reading all of the path tuples into memory so they could be con-
verted to the path matrices. Further optimizations, such as caching
path information during the ofﬂine analysis, could reduce this cost
further. However, since vLens is intended to be an experimental
prototype, we did not implement these improvements.

To determine the runtime overhead of the instrumentation (TR)
we could not take the straightforward approach of comparing an in-
strumented version of each application against the uninstrumented
version. The reason for this is that a signiﬁcant amount of appli-
cation time is actually spent idle, waiting for user input or data.
The normal user variation in entering this data masks the instru-
mentation overhead variation. Therefore we calculate the non-idle
execution time of the instrumented application and then determine
the percentage of that time that is caused by the instrumentation. A
key insight to measuring non-idle time is that the Android operat-
ing system is event driven, so it idles waiting for user input after a
method exits, and then when it receives input, comes out of the idle
state and executes the event handler method. Therefore, we can
calculate the non-idle time of the application by summing up all of
the time during which an application path was being traversed. For
example if path p1 executed from time 1 to 3 and path p2 executed
from time 2 to 4, then we can calculate the non-idle time as 3 units.
Note that this properly counts a time unit once regardless of how
many threads are executing. Next, we proﬁled the instrumentation
code that was inserted into the application and determined its exe-
cution time TInst. By examining the path tuples, we also know the
execution frequency n of the instrumentation. The resulting calcu-
lation for TR is shown in Equation 5. Here the denominator is the
special time summation described above.
n ∗ TInst

TR =

∪Ti

(5)

The results of this calculation are shown in Table 2 as TR. The
overhead costs range from 0.51% to 8.77% with an average just
under 4%. Overall, this is a low runtime overhead, representing

about 0.15 seconds. Anecdotally, this amount of overhead did not
cause a noticeable delay to the testers during execution.
4.4 RQ2: Measurement Accuracy

For the second research question, we consider the accuracy of
the measurements calculated by vLens. The primary challenge in
this evaluation is that there is no source line ground truth against
which we can compare for accuracy. As discussed in Section 2,
power samplers cannot measure at a frequency high enough to cap-
ture individual source lines. Therefore, we show accuracy of the
approach in several other ways. First we examine the accuracy of
the energy attributed to the APIs. Second, we use statistical tests
to show that the regression analysis results can describe the over-
all energy consumption relationship accurately and that each path
also accurately accounts for its energy. Lastly, we show that our
technique for identifying high-energy events via statistical outlier
analysis correctly identiﬁes paths that contain these events.

Figure 6: Comparison of API energy cost

4.4.1 Accuracy of the API Energy Measurements
To measure the accuracy of the API energy measurements, we
compared their measured cost against a proﬁled cost. To obtain
the measured cost, we ran the apps using vLens and extracted the
cost of each invocation that was executed during the test runs. Al-
together, there were invocations to over 3,722 unique APIs. From
this group we focused on a group of twenty-four APIs whose in-
vocations together comprised more than 70% of the total invoca-
tion related energy consumed by the ﬁve applications. For these
twenty-four, we recorded the arguments and execution context of
the invocations and then proﬁled their energy cost. The proﬁling
was performed on the LEAP platform by executing each invoca-
tion 100 times and then measuring the energy consumed during the
execution. We repeated this proﬁling ﬁve times and calculated the
mean and standard deviation of the experiment. The proﬁled cost
was then compared against the cost calculated by vLens. The re-
sult of this comparison are shown in Figure 6. Each of the APIs
are listed along the X-axis and the two different costs are shown on
the Y-axis, the values on the Y-axis are normalized to the cost of
proﬁled cost. One standard deviation off of the proﬁling mean is
shown with the additional horizontal lines.

Figure 6 shows that for nineteen of the twenty-four APIs, the
vLens measured cost was within an average of 9% of the proﬁled
costs and the gap was within one standard deviation in almost all
cases. For the remaining ﬁve, the measured cost was off signiﬁ-
cantly. We investigated these APIs to determine what caused this
high error rate. The ﬁrst four APIs are synchronized, which means
that they invoke monitor_enter and monitor_exit. This

  0.00  0.50  1.00  1.50  2.00123456789101112131415161718192021222324Normalized EnergyvLensProfilingmade the execution time and energy consumption of their invoca-
tion vary widely as the acquisition and release of the synchroniza-
tion lock was non-deterministic. The ﬁfth API accessed an HTTP
response code, and we found that the code was cached after the
ﬁrst call to the method, which meant signiﬁcantly less computa-
tions had to be performed in subsequent invocations. Because the
proﬁling results for these ﬁve were skewed by these types of be-
haviors, we consider the nineteen to be a more accurate reﬂection
of the accuracy achieved by the vLens calculations.
4.4.2 Accuracy of Bytecode Energy Distribution
We evaluate the accuracy of the bytecode regression model in
two ways. First, we determine the accuracy of the regression model
at an application level by comparing the amount of application en-
ergy calculated using the regression model versus the amount of
application energy actually measured during the experiments. Sec-
ond, we look at the accuracy of the regression model at a path level
by determining the multiple correlation coefﬁcient of the calculated
paths values. The results of these experiments are reported in Ta-
ble 2. Note that we cannot perform this experiment at the bytecode
level because we do not have a way to establish the bytecodes’
ground truth measurements.

To determine the accuracy of the regression model at the applica-
tion level, we calculate the Accumulated Estimating Error (AEE).
This value represents the normalized difference between the amount
of energy that the regression model would calculate for the appli-
cation versus the amount of actually measured energy. Intuitively,
the AEE can be thought of as the amount of total energy not accu-
rately accounted for by the regression model and a lower ratio is a
stronger result. The AEE is shown in Equation 6. The ˆyi represents
the energy calculated for the ith path based on the regression model
and yi is the measured energy of the ith path produced by the Path
Adjuster (i.e., with the invocation energy removed.)

AEE =

|Σˆyi − Σyi|

Σyi

(6)

To determine the accuracy of the regression model at a path level,
we calculate the multiple correlation coefﬁcient (R2). The R2 is a
well-known statistical measure that shows how well a variable can
be predicted based on a linear function of multiple variables. In
our case the value to be predicted is the energy of the ith path (ˆyi)
calculated with the regression model, and the multiple variables
are the individual bytecodes solved for during the regression. The
value of R2 is obtained by calculating the solution to Equation 7.
As with the AEE in Equation 6, yi is the adjusted measured value
of the ith path, ˆyi is the path’s value calculated using the regression
model, and ¯y is the mean of the measured paths. The R2 value is
measured on the interval [0, 1] with a value close to 1 representing
a strong ﬁt of the data to the model and 0 representing a weak ﬁt.

R2 = 1 − Σ(yi − ˆyi)2
Σ(yi − ¯y)2

(7)

For the AEE, the numbers range from 3.4% to 8.6% with an av-
erage of just under 6%. This means that, on average, 6% of the
actual measured energy is not accounted for by the model. In gen-
eral, since linear regression is an approximation, a certain amount
of variance in the energy totals is to be expected. In this context,
we believe that 6% represents a low enough number that the overall
results of the analysis would still be informative and help to guide
the developer in making changes to the code. The R2 values range
from 0.9 to 0.99 with an average of 0.936. The high average R2
value shows that our model is able to ﬁt the measured data very

closely. Overall, these numbers show that our regression model
exhibits high accuracy with respect to its calculations at both the
application and path level.

4.4.3 Accuracy of Outlier Detection
We evaluated the accuracy of the RLR techniques to detect out-
liers caused by garbage collection and thread switching events. To
do this, we seeded a variable number (20, 50, 100, and 200) of ar-
tiﬁcial events along paths of the subject applications by inserting
calls to garbage collection (System.gc()) and thread switching
instructions (Thread.start() and Thread.join()). The
target thread contained only a single instruction so that its actual
execution time would be low and the most prominent cost would be
the context-switch overhead. We then applied the RLR techniques
and checked to see if the paths containing the seeded events were
determined to be outliers. For each of the applications, the RLR
techniques were able to detect all of the seeded high-energy events.
From this result, we conclude that the use of statistical outlier de-
tection to identify paths affected by garbage collection and thread
switching overhead is both an effective and practical approach.
4.4.4 Threats to Validity
In this section we discuss the threats to the validity of our empir-

ical evaluation and explain how we addressed these issues.

External Validity: The subjects in this study are real world mar-
ketplace apps downloaded from the Google Play Market. They rep-
resent different app domains and, in terms of size, are representa-
tive of many apps we saw in the marketplace.

Internal Validity: In general, to help ensure internal validity,
the accuracy and timing experiments were repeated multiple times
and averaged. To ensure that the outlier detection was a result of
our technique, we tracked the seeding of the garbage collection and
thread switching, so we could determine easily in which paths they
occurred. Furthermore, we compared actual and seeded garbage
collection events, to verify that they had similar energy characteris-
tics. For threads, we used a minimal sized thread (one instruction)
to ensure that the thread’s energy was not inﬂated and therefore
made easier to detect.

Construct Validity: For accuracy, we were unable to use the
most straightforward comparison, bytecode ground truth, due to
the difﬁculty of measuring the ground truth for such short events.
Instead, we used invocation ground truth and well-known statistical
tests to show the degree to which our models ﬁt the measured data.
Overall, it seems likely that if the calculated values for invocation
were close to ground truth and the R2 values were consistently
high across all apps, then the calculated source line level energy
would also be accurate. Nonetheless, this is a validity threat that
our experimental design could not completely address.

5. RELATED WORK

There are two areas of related work for our approach, energy es-
timation and power measurement. The ﬁrst area, energy estimation,
assumes that developers do not have access to power measurement
hardware and uses software based techniques to predict how much
energy an application will consume at runtime. The second group
of techniques, power measurement, makes use of power measure-
ment hardware to obtain power samples and then uses software
based techniques to attribute the power to implementation struc-
tures.

The general process of energy estimation techniques is to build
a parameter-based model of energy consumption, capture values
for the model’s parameters from the application, and then calculate

the values produced by the model. As compared to our approach,
the primary difference is that estimation techniques assume that
developers do not have access to power measurement devices, the
target hardware platforms, or are unable to use these techniques for
various reasons. These scenarios can occur frequently in practice
and make estimation techniques a complementary approach to ours.
Our prior work developed an approach, eLens, for predicting
the energy consumption of smartphone applications based on an
expected workload [12]. The eLens technique is based on per-
instruction cost functions, which are provided by a Software En-
ergy Environment Proﬁle (SEEP) and driven by parameters ob-
tained via program analysis. Developing the SEEP is labor in-
tensive and may not always be feasible, as there are thousands of
APIs in the Android SDK, many of which require complex energy
In contrast, vLens takes live energy measurements and
models.
attributes them to source lines using regression and statistical tech-
niques. The vLens technique does not require a SEEP, but does
require a Power Measurement Platform, which may be easier to
obtain for some developers. Because vLens is based on runtime
measurements, it must also deal with the inﬂuence of garbage col-
lection, thread switching, tail energy, and sampling intervals.

Seo and colleagues [27, 28, 29] have proposed several software
energy estimation techniques. They model the energy consump-
tion of each Java bytecode and the network utilization, and capture
these two types of information by modifying the JVM. Compared
to vLens, their estimation requires modiﬁcations to the runtime sys-
tems, the construction of energy models, and provides information
at a component level instead of the source level.

Other approaches estimate software energy using models based
on operating system (OS) level features. These features include
calls to OS-level APIs [18, 33] or state metrics internal to the op-
erating system [23, 24, 39], such as CPU frequency and network
usage. Similar to this work are approaches to estimate the energy
consumption in virtual machines [10, 17, 32, 38]. Compared with
our approach, this body of work requires signiﬁcant integration and
modiﬁcation to the runtime systems and is not as portable. Further-
more, the workload of building models can be high.

Another group of approaches for software energy estimation is
based on low-level hardware modeling. Works of this type build
models based on the assembly instructions [35, 36] or micro-
instructions of each assembly instruction [19, 31]. The drawback
of these approaches is that they cannot estimate the energy of ex-
ternal devices (e.g.,, GPS, WIFI, etc.), which also consume a large
portion of energy in modern mobile systems. Moreover, Sinha and
colleagues [30] have shown that, at this level, the energy consump-
tion of instructions or micro-instructions are roughly the same. Un-
like this body of work, vLens can measure the energy consumption
of the entire mobile system, including external devices.

The last type of work to estimate software energy is to build sim-
ulators. The main drawback of simulators is their speed. Cycle-
level simulators [7, 22] can require thousands of instructions to
simulate one instruction, which is too slow to use for simulating
modern interactive applications. Even functional simulators [21],
which are comparatively faster than cycle accurate simulators, run
too slowly to be useful for capturing realistic user interactions.

The most closely related techniques to our approach are based on
power measurement. The general approach for these techniques is
to use a power measurement device, such as the LEAP [25] or Mon-
soon [2] power meters, that can sample energy measurements at a
certain frequency. These measurements are then combined with
software based techniques to provide useful information to soft-
ware developers. Sahin and colleagues [26] map energy consump-
tion to different component level design patterns. Their work ex-

plored the correlations between energy consumption and the use of
different design patterns. At a higher level, Flinn and colleagues [6,
11] measured the energy consumption of applications and mapped
the energy to individual OS processes. This was done, in part, by
instrumenting the operating systems.

Sesame [8] measures the energy by reading the battery inter-
face of laptops and uses regression analysis to automatically gen-
erate energy consumption information based on system level met-
rics, such as CPU workload and network utilization measurements.
However, Sesame does not provide information at the level of source
code lines. Tan and colleagues [34] also use regression analysis to
map energy to paths in the control ﬂow graph, but are not able to
provide any ﬁner level of granularity with their measurements.

Compared with these measurement approaches, vLens is able to
provide energy measurements at a much ﬁner level of granular-
ity. vLens calculates energy measurements at the source line level,
whereas the above mentioned approaches compute their informa-
tion at the level of entire application, architecture level components,
design patters, or methods.

6. CONCLUSION AND FUTURE WORK

In this paper, we presented our approach for calculating the source
line level energy consumption of Android applications. Our ap-
proach employs a combination of hardware-based energy measure-
ments and efﬁcient path proﬁling to correlate energy measurements
with the application’s execution. Then the approach analyzes each
of the executed paths to handle high energy events, such as garbage
collection and thread switching. The adjusted measurements are
then used to perform a regression analysis that maps the energy to
the individual source lines.

For the evaluation, we implemented our approach in a prototype
tool, vLens, and ran it against ﬁve real-world marketplace apps. Our
evaluation showed that vLens was fast, it was able to calculate en-
ergy information for each app in under three minutes. The approach
was also accurate. It was able to attribute invocation information
to within 10% of the ground truth, the statistical models ﬁt the data
closely with an R2 average of 0.93, and it could detect the high
energy events with 100% accuracy. Overall, the results are promis-
ing and indicate our approach has the potential to help developers
understand the energy related behavior of their applications.

In future work we will focus on improving several aspects of
our approach. The ﬁrst aspect is to design new experiments to im-
prove the construct validity of our experiments. Ideally, we would
do this via faster power sampling techniques; however, it is un-
likely that power samplers will show the same increase in speed
as CPUs. Therefore, we will investigate new statistical and ex-
perimental methods that will allow us to more precisely quantify
source line level accuracy of our approach. Second, we would like
to improve techniques for solving the linear systems of equations
when there are insufﬁcient data points and attaching “conﬁdence”
metrics to our approximations. Third, we would like to explore al-
ternative ways of handling paths that are identiﬁed as outliers by
the statistical analysis. For example, by identifying ways to at-
tribute high-energy events to source lines in a way that is meaning-
ful for developers. Lastly, we would like to use vLens in developer
studies to determine its usefulness for making energy consumption
improvements.

7. ACKNOWLEDGEMENTS

This work was supported by the National Science Foundation
under Grant No. CNS-905596 and a Zumberge Research Award
from the University of Southern California.

8. REFERENCES
[1] Dex2jar. http://code.google.com/p/dex2jar/.
[2] Monsoon. http://www.msoon.com/

LabEquipment/PowerMonitor/.
[3] The r project for statistical computing.
http://www.r-project.org/.

[4] Apache. Bcel library.

http://bcel.sourceforge.net/.

[5] T. Ball and J. Larus. Efﬁcient Path Proﬁling. In MICRO 29,

pages 46–57. IEEE Computer Society, 1996.

[6] F. Bellosa. The Beneﬁts of Event-Driven Energy Accounting

in Power-Sensitive Systems. In the 9th workshop on ACM
SIGOPS European Workshop, pages 37–42. ACM, 2000.

[7] D. Brooks, V. Tiwari, and M. Martonosi. Wattch: a

framework for architectural-level power analysis and
optimizations. In ACM SIGARCH Computer Architecture
News, volume 28, pages 83–94. ACM, 2000.

[8] M. Dong and L. Zhong. Sesame: Self-Constructive System
Energy Modeling for Battery-Powered Mobile Systems. In
Proc. of MobiSys, pages 335–348, 2011.

[9] S. G. Eick, J. L. Steffen, and E. E. Sumner, Jr. Seesoft-a tool
for visualizing line oriented software statistics. IEEE Trans.
Softw. Eng., 18(11):957–968, Nov. 1992.

[10] K. Farkas, J. Flinn, G. Back, D. Grunwald, and J. Anderson.
Quantifying the Energy Consumption of a Pocket Computer
and a Java Virtual Machine. ACM SIGMETRICS
Performance Evaluation Review, 28(1):252–263, 2000.

[11] J. Flinn and M. Satyanarayanan. PowerScope: A Tool for

Proﬁling the Energy Usage of Mobile Applications. In
Second IEEE Workshop on Mobile Computing Systems and
Applications, pages 2–10. IEEE, 1999.

[12] S. Hao, D. Li, W. G. Halfond, and R. Govindan. Estimating

mobile application energy consumption using program
analysis. In Proc. of 35th International Conference on
Software Engineering, 2013.

[13] P. Huber. Robust statistics. 1981.
[14] Intel. Atom N550 Datasheet.

http://www.intel.com/content/dam/www/
public/us/en/documents/datasheets/
atom-n400-vol-1-datasheet-.pdf.

[15] Intel. X18-M/25-M SATA SSD Datasheet.

http://download.intel.com/design/flash/
nand/mainstream/
mainstream-sata-ssd-datasheet.pdf.

[16] X. Jiang, P. Dutta, D. Culler, and I. Stoica. Micro power

meter for energy monitoring of wireless sensor networks at
scale. In Information Processing in Sensor Networks, 2007.
IPSN 2007. 6th International Symposium on, pages 186–195.
IEEE, 2007.

[17] A. Kansal, F. Zhao, J. Liu, N. Kothari, and A. Bhattacharya.

Virtual Machine Power Metering and Provisioning. In
Proceedings of the 1st ACM symposium on Cloud computing,
pages 39–50. ACM, 2010.

[18] T. Li and L. John. Run-time Modeling and Estimation of

Operating System Power Consumption. ACM SIGMETRICS
Performance Evaluation Review, 31(1):160–171, 2003.

[19] H. Mehta, R. Owens, and M. Irwin. INSTRUCTION LEVEL

POWER PROFILING. In Acoustics, Speech, and Signal
Processing, 1996. ICASSP-96. Conference Proceedings.,
1996 IEEE International Conference on, volume 6, pages
3326–3329. IEEE, 1996.

[20] Micron. DDR3 SDRAM SODIMM Datasheet. http:

//download.micron.com/pdf/datasheets/
modules/ddr3/jsf16c256x64h.pdf.

[21] R. Mittal, A. Kansal, and R. Chandra. Empowering

developers to estimate app energy consumption. In Proc. of
MobiCom, 2012.

[22] T. Mudge, T. Austin, and D. Grunwald. The reference

manual for the sim-panalyzer version 2.0 [z].
http://www.eecs.umich.edu/~panalyzer.

[23] A. Pathak, Y. Hu, M. Zhang, P. Bahl, and Y. Wang.

Fine-Grained Power Modeling for Smartphones Using
System Call Tracing. In Proc. of EuroSys, pages 153–168.
ACM, 2011.

[24] A. Pathak, Y. C. Hu, M. Zhang, P. Bahl, and Y.-M. Wang.

Where is the energy spent inside my app? Fine Grained
Energy Accounting on Smartphones with Eprof. In Proc. of
EuroSys, 2012.

[25] P. Peterson, D. Singh, W. Kaiser, and P. Reiher. Investigating
energy and security trade-offs in the classroom with the atom
leap testbed. In 4th Workshop on Cyber Security
Experimentation and Test (CSET), pages 11–11. USENIX
Association, 2011.

[26] C. Sahin, F. Cayci, I. L. M. Gutierrez, J. Clause, F. Kiamilev,

L. Pollock, and K. Winbladh. Initial explorations on design
pattern energy usage. In First International Workshop on
Green and Sustainable Software (GREENS), pages 55–61,
2012.

[27] C. Seo, S. Malek, and N. Medvidovic. An Energy

Consumption Framework for Distributed Java-Based
Systems. In Proc. of 22nd IEEE/ACM International
Conference on Automated Software Engineering, pages
421–424. ACM, 2007.

[28] C. Seo, S. Malek, and N. Medvidovic. Component-Level

Energy Consumption Estimation for Distributed Java-Based
Software Systems. In Proc. of 11th International Symposium
on Component-Based Software Engineering, pages 97–113.
Springer, 2008.

[29] C. Seo, S. Malek, and N. Medvidovic. Estimating the Energy

Consumption in Pervasive Java-Based Systems. In Sixth
Annual IEEE International Conference on Pervasive
Computing and Communications, pages 243–247. IEEE,
2008.

[30] A. Sinha and A. Chandrakasan. Jouletrack-A Web Based
Tool for Software Energy Proﬁling. In Design Automation
Conference, 2001. Proceedings, pages 220–225. IEEE, 2001.

[31] S. Steinke, M. Knauer, L. Wehmeyer, and P. Marwedel. An

Accurate and Fine Grain Instruction-Level Energy Model
Supporting Software Optimizations. In Proc. of PATMOS.
Citeseer, 2001.

[32] J. Stoess, C. Lang, and F. Bellosa. Energy Management for

Hypervisor-Based Virtual Machines. In 2007 USENIX
Annual Technical Conference on Proceedings of the USENIX
Annual Technical Conference, page 1. USENIX Association,
2007.

[33] T. Tan, A. Raghunathan, and N. Jha. Energy Macromodeling

of Embedded Operating Systems. ACM Transactions on
Embedded Computing Systems (TECS), 4(1):231–254, 2005.

[34] T. Tan, A. Raghunathan, G. Lakshminarayana, and N. Jha.
High-level Software Energy Macro-modeling. In Proc. of
Design Automation Conference (DAC), pages 605–610.
IEEE, 2001.

[35] V. Tiwari, S. Malik, and A. Wolfe. Power Analysis of

Embedded Software: A First Step Towards Software Power

Calculating Source Line Level Energy Information for

Android Applications

Ding Li, Shuai Hao, William G.J. Halfond, Ramesh Govindan

Department of Computer Science
University of Southern California

Los Angeles, California, USA

{dingli, shuaihao, halfond, ramesh}@usc.edu

ABSTRACT
The popularity of mobile apps continues to grow as developers
take advantage of the sensors and data available on mobile de-
vices. However, the increased functionality comes with a higher
energy cost, which can cause a problem for users on battery con-
strained mobile devices. To improve the energy consumption of
mobile apps, developers need detailed information about the en-
ergy consumption of their applications. Existing techniques have
drawbacks that limit their usefulness or provide information at too
high of a level of granularity, such as components or methods. Our
approach is able to calculate source line level energy consumption
information. It does this by combining hardware-based power mea-
surements with program analysis and statistical modeling. Our em-
pirical evaluation of the approach shows that it is fast and accu-
rate.

Categories and Subject Descriptors
D.2.8 [Software Engineering]: Metrics—performance measures

General Terms
Measurement, Performance

Keywords
Energy measurement, Android app, Source line level

1.

INTRODUCTION

The popularity of mobile apps continues to increase. This pop-
ularity is driven, in part, by the innovative ways in which app de-
velopers combine sensors and data to provide users with useful and
novel functionality. However, a problem for developers and users
alike is that these apps require a large amount of energy and the mo-
bile devices on which the apps run are constrained by limited bat-
tery power. This has led to a tension between adding new features
that will attract users, but consume more energy, and minimizing
energy costs at the risk of reducing functionality. The balance has
proven hard to attain and it is quite common to see many complaints
related to energy consumption in app marketplace reviews.

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
ISSTA ’13, July 15-20, 2013, Lugano, Switzerland
Copyright 2013 ACM 978-1-4503-2159-4/13/07 ...$15.00.

Research advances in battery, hardware, and operating system
design have, to some extent, improved the energy consumption of
mobile devices. However, in spite of these optimizations, a poorly-
coded app can be inefﬁcient and perform numerous unnecessary
and costly operations. It is difﬁcult for developers to determine if
their app is coded inefﬁciently with respect to energy consumption.
Although developers can consult well-known best practices, these
do not represent an objective way to improve an app’s implementa-
tion. An additional problem is that these guidelines do not provide
application speciﬁc guidance, therefore developers lack insight into
how energy is consumed by their apps.

To assist developers, researchers have developed a range of tech-
niques to provide energy consumption information. Several tech-
niques use runtime monitoring to track key operating system pa-
rameters and provide estimates to developers [8, 24, 39]. However,
the level of granularity of these techniques is either at the compo-
nent or method level, which is helpful, but does not provide in-
formation at a low enough level of granularity to guide developer
changes. For example, method level information cannot help devel-
opers distinguish between two paths within a method that have dif-
ferent energy consumption. Developers have often used CPU time
as a proxy for energy. However, this is not an accurate approxi-
mation because mobile devices scale their voltage dynamically and
interact with multiple hardware components that have varied en-
ergy consumption patterns, such as GPS, WiFi, and cameras [12].
Techniques for estimating energy consumption (as opposed to mea-
suring) could also be used, but have drawbacks: Cycle-accurate
simulators [22] often run several thousand times slower than actual
hardware, and program analysis based estimation techniques [12,
27] require carefully ﬁne-tuned software environment proﬁles.

Current research has not been able to provide developers with
techniques that can use energy measurements to provide source
line level energy consumption information. As we discuss in more
detail in Section 2, there are numerous practical and conceptual
challenges in providing this information. The most straightforward
technique, using a power meter to take direct measurements of an
app while it is running, is not practical. Current power meters
are unable to measure and record fast enough to isolate individual
source lines. Even if this problem could be resolved, such mea-
surements would not be accurate unless they also dealt with issues,
such as thread switching and garbage collection, that can make it
difﬁcult to determine the implementation structures that should be
attributed with the measured energy cost. As we discuss in Sec-
tion 3.2.2, these types of events can consume a signiﬁcant amount
of energy that could distort the energy attributed to the application.
In this paper, we present a new approach that provides developers
with source line level energy information. To address the numer-
ous inherent challenges in achieving this result, we have devised

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36

an approach that combines hardware-based energy measurements
with program analysis and statistical modeling techniques. At a
high-level, the basic intuition is as follows: While measuring the
energy consumption of a smartphone, the approach uses efﬁcient
path proﬁling to identify which parts of the application are exe-
cuting and correlates these paths with the measured energy. Then,
the approach statically analyzes the paths to identify and adjust for
high-energy events, such as thread switching, before applying ro-
bust regression analysis to calculate each source line’s energy con-
sumption. Finally, the approach presents developers with a graph-
ical representation of the energy consumption by overlaying the
calculated energy with the source code of the application.

We also performed an empirical evaluation of our approach to
measure its accuracy and the time needed to perform the analysis.
Our approach was able to accurately calculate energy. For a set of
API invocations, we found that the calculated energy values were
within 10% of the ground truth measurements. The statistical mod-
els also matched the measured data very closely with a high R2
average of 0.93 and a low accumulated error rate. Importantly, in
our experiments, the approach was also able to detect the inﬂuence
of high-energy events, such as thread switching and garbage col-
lection, with 100% accuracy. The approach was also fast, it could
calculate source line level energy measurements for each of our
subject applications in less than three minutes. Overall, the results
of the evaluation were positive and indicate that our approach is an
effective and practical way to provide developers with source line
level energy information.

The remainder of this paper is organized as follows: In Section 2
we discuss several of the signiﬁcant challenges that shaped the de-
sign of our approach. We present the approach itself in Section 3.
The evaluation of the approach is described in Section 4. Finally,
we discuss related work and conclude in Sections 5 and 6.

2. BACKGROUND AND MOTIVATION

In this section we discuss several challenges to measuring and
calculating source line energy consumption. We break the chal-
lenges into three broad categories, hardware, runtime system, and
software level, and explain how they preclude a straightforward
solution for calculating source level energy consumption. To il-
lustrate these challenges, we make use of the code shown as Pro-
grams 1 and 2, which are excerpts from the open-source Google
Authenticator project that handles synchronizing a system clock.
In the example, method getNetworkTime (Program 1, line 1)
retrieves the time by sending an HTTP request to a timeserver
(line 7) and then parsing the response packet (lines 16, 20, 23,
26). Method runBackgroundSync (Program 2, line 2) calls the
getNetworkTime (line 6) and then starts a background thread
to handle errors (line 10).
2.1 Hardware Limitations

The primary hardware obstacle to directly measuring the energy
consumption of source lines is the difference in the speed at which
instructions execute and hardware devices can perform energy mea-
surements. On modern processors, individual instructions will ex-
ecute at a rate of several million per second. At best, power me-
ters can sample electrical power draw at several tens of KHz [16],
which means that each sample will include the power consumption
of hundreds, perhaps thousands, of instructions. For example, it
is possible for Program 2 to execute completely in the time that
transpires between two consecutive power samples by a relatively
fast power meter. There are reasons to believe that this order of
magnitude disparity will likely persist, since the bottleneck in high-
frequency power sampling is the storage system, which cannot save

p u b l i c long getNetworkTime ( )

throws

I O E x c e p t i o n {

HttpHead r e q u e s t = new HttpHead (URL ) ;
Log . i (LOG_TAG, "Sending request to "

+ r e q u e s t . getURI ( ) ) ;
H t t p R e s p o n s e h t t p R e s p o n s e ;
t r y {

h t t p R e s p o n s e = m H t t p C l i e n t . e x e c u t e ( r e q u e s t ) ;

} catch ( C l i e n t P r o t o c o l E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( S t r i n g . v a l u e O f ( e ) ) ;

} catch ( I O E x c e p t i o n e ) {

throw new I O E x c e p t i o n ( "Failed due " +

"to connectivity issues: " + e ) ;

}

t r y {

Header d a t e H e a d e r =

h t t p R e s p o n s e . g e t L a s t H e a d e r ( "Date" ) ;

Log . i (LOG_TAG, "Received response with "

+"Date header: " + d a t e H e a d e r ) ;

i f

( d a t e H e a d e r == n u l l ) {

throw new I O E x c e p t i o n ( "No Date header" ) ;

}
S t r i n g d a t e H e a d e r V a l u e =

t ry {

Date networkDate =

d a t e H e a d e r . g e t V a l u e ( ) ;

D a t e U t i l s . p a r s e D a t e ( d a t e H e a d e r V a l u e ) ;

return networkDate . getTime ( ) ;

} catch ( D a t e P a r s e E x c e p t i o n e ) {

throw new I O E x c e p t i o n (

"Invalid Date header format " ) ;

}

} f i n a l l y {

. . . . . .

}

}

Program 1: Google Authenticator Method 1

power samples at the same frequency as the power meter can gen-
erate them [14, 15, 20], and there is no evidence to show that this
gap will be closed in the near future. Therefore, a challenge for our
approach is to reconcile power measurements samples and instruc-
tion execution, even though there is a several orders of magnitude
difference in their frequency.
2.2 Runtime System Challenges

The runtime system of an Android smartphone includes both the
Android operating system and the Dalvik Virtual Machine, the plat-
form on which marketplace apps are run. The runtime system im-
plements several types of behaviors that affect energy consumption
of an app, thread switching, garbage collection, and tail energy.
However, the details of the duration, frequency, and timing of these
events is, by design, hidden from the app. This makes it difﬁcult
to correctly attribute energy at the source level. Although it would
be straightforward to modify the runtime systems to track these
events, this would introduce considerable overhead and reduce the
portability of the approach, as it would be necessary to provide
custom runtime systems for each smartphone platform. Therefore,
one challenge for our approach is to account for these events with
information that is available at the app layer.

Thread switching causes several problems for calculating source
line level energy. The ﬁrst problem is that any energy measure-
ments for a given time period may also include energy for threads
that are not related to the application (i.e.,, operating system pro-
cesses). For example, at any point in the execution of the thread
in runBackgroundSync or getNetworkTime, the OS could
swap in a thread from another app or the OS. Any power samples
during this time would likely include instructions from both the
original and swapped-in thread. The second problem is that thread

p r i v a t e void

runBackgroundSync ( E x e c u t o r
long n e t w o r k T i m e M i l l i s ;
t r y {

n e t w o r k T i m e M i l l i s =

c a l l b a c k E x e c u t o r ) {

mNetworkTimeProvider . getNetworkTime ( ) ;

} catch ( I O E x c e p t i o n e ) {

Log .w(LOG_TAG, "Failed to obtain network " +
"time due to connectivity issues" ) ;

c a l l b a c k E x e c u t o r . e x e c u t e ( new Runnable ( ) {

@Override
p u b l i c void run ( ) {

f i n i s h ( R e s u l t . ERROR_CONNECTIVITY_ISSUE ) ;

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

}
} ) ;
return ;

}

Program 2: Google Authenticator Method 2

switching itself introduces an energy overhead. For example, Line
10 of Program 2 will incur a signiﬁcant energy overhead for the
context switch that occurs when a new thread is started.

Periodically, the Android operating system will perform garbage
collection during the execution of an application. Typically, ap-
plications do not have control over garbage collection, it is man-
aged by the operating system and can occur anytime and within
any method. Although the Dalvik virtual machine logs garbage
collection, it timestamps the events via a millisecond based clock,
which does not provide enough precision to determine in which
path they occur (paths are tracked with nanosecond timestamps.)
As we note in Section 3.2.2, garbage collection incurs a signiﬁ-
cant energy cost and has the potential to signiﬁcantly distort en-
ergy measurements for an application. For example, consider if
garbage collection were to occur at line 20 of Program 1, which is
compiled as a simple jump on equality (ifeq), or line 6 of Pro-
gram 2, which is a relatively expensive method invocation. The
extremely high cost of the garbage collection would dwarf the cost
of both instructions making them appear to have a nearly identical
high energy cost. Therefore, an approach must be able to identify
and properly account for garbage collection while calculating the
source line level energy consumption of an application.

Smartphones exhibit tail energy usage, where certain hardware
components are optimistically kept active by the operating system,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. Tail energy manifests itself in two differ-
ent ways. The ﬁrst way is when an invocation to an API accesses a
hardware component and then returns. Even when no other invoca-
tions access the component, the component will remain active for
a time period Ttail and consume energy Etail. An example of this
kind of invocation is at line 7 of Program 1. The call to the network
will cause the radio to remain on for a period of time, even after
the request is ﬁnished, and consume energy during this time. The
second way is when two invocations access the component in se-
quence and the time interval between them is less than Ttail. Here,
only a portion of Etail will be consumed. The Etail for certain de-
vices can be quite high and a naive approach to measurement might
attribute the tail energy cost to subsequently executed instructions.
Referring back to the example invocation, the naive approach could
mistakenly attribute part of the invocation’s tail energy to its suc-
cessors, lines 16, 18, and 20, (depending on the length of its Ttail)
instead of to line 7. To be accurate, an approach must recognize
when tail energy occurs and attribute it to the source invocations
that started the component and kept it at a non-idle state.

2.3 Software-Level Challenges

Source level calculations require precise information about an
app’s execution. In particular, for each time period represented by
a power sample, it is necessary to know which instructions were
executed, their frequency, and their ordering — essentially, path
information. The primary challenge is that obtaining this type of
information at the software level is generally expensive and intru-
sive. For example, inserting instrumentation into an app to iso-
late and measure individual instructions can lead to high overhead.
Even optimizations, such as only instrumenting each basic block,
would still produce a high amount of instrumentation. Other ap-
proaches, such as instruction counting, do not allow developers to
know which instances of the instructions were executed.

It is also necessary to have precise information about API invoca-
tions. During execution, smartphone applications generally invoke
library functions and APIs to access hardware components, such
as GPS, network, and WiFi. For example, at line 7 of Program 1,
getNetworkTime() sends an HTTP request to Google by in-
voking HttpClient.execute(). This invocation consumes
a relatively large amount of energy due to its use of the network.
In contrast, a call to dataheader.getValue at line 24 of Pro-
gram 1, incurs a relatively small constant cost, since it is simply
returning the value of an HTTP header. This wide range of invo-
cation behavior causes problems for techniques that naively apply
statistical sampling or averaging-based approaches because, unlike
normal instructions, an invocation’s energy cost can vary based on
its target and the data provided for its arguments. Furthermore, it is
not feasible to precompute the cost of API calls, since that requires
sampling every point in each API calls input space to determine its
energy consumption.
3. APPROACH

The goal of our approach is to provide source line level energy
information for smartphone applications. An overview of our ap-
proach is shown in Figure 1. From a high-level, our approach has
two phases, Runtime Measurement and Ofﬂine Analysis. The in-
puts to the Runtime Measurement phase are the application under
analysis (AUA) and a set of use cases for which the tester wants
to obtain energy measurements. The App Instrumenter uses an
efﬁcient path proﬁling technique to guide the insertion of probes
into the AUA that will capture timestamps and path traversal infor-
mation. The tester executes the instrumented AUA on the Power
Measurement Platform. This causes the instrumentation to record
path information while the Power Measurement Platform records
power samples. The path and power samples are the inputs for the
Ofﬂine Analysis phase. The Path Adjuster performs a static anal-
ysis of the paths and makes modiﬁcations to the power samples to
account for the high-energy events. Then the Analyzer performs
the regression analysis in order to calculate each source line’s en-
ergy consumption. If the Analyzer ﬁnds there are not enough data
points to solve the regression analysis, then the process returns to
the Runtime Measurement phase so the developer can further exe-
cute the application. If this is not possible, then the Analyzer per-
forms approximations that we discuss in Section 3.2.2. Finally, the
Annotator uses the calculations to create graphical overlays of the
measurements on the source code for display in an integrated de-
velopment environment. We explain the approach in more detail in
the remainder of this section.
3.1 Runtime Measurement Phase

During the Runtime Measurement phase, information about the
paths executed in the AUA and power measurements are generated
by the approach. To do this, the App Instrumenter inserts probes

Figure 1: Overview of the approach

into the AUA to record the information, and then the instrumented
AUA is executed by the developer while power samples are col-
lected by the Power Measurement Platform. The output of the Run-
time Measurement phase is set of timestamped paths executed by
the AUA and power measurements.

Instrumentation of the AUA: The instrumentation collects in-
formation about the paths executed by the developer. Namely, which
paths are traversed, their frequency, and timestamps of the path
traversals and invocation of certain APIs. To record the path infor-
mation, the App Instrumenter adapts a techniques for efﬁcient path
proﬁling proposed by Ball and Larus [5]. The approach ﬁrst builds
a control-ﬂow graph (CFG) of each method in the AUA. Then each
edge in the CFG is assigned a label so that each unique path in the
CFG has a unique path ID. The approach then calculates a maxi-
mal spanning tree over the CFG and uses this to guide the minimal
placement of instrumentation that will increment a path ID counter.
By design, the approach can use a single counter to identify the path
traversed in the method. We extended the Ball-Larus approach to
handle nested method calls, concurrency, and exceptions. The App
Instrumenter also inserts a probe at the method entry to initialize
the method’s path counter, record a timestamp of when the path
traversal began, and the current thread ID. At each exit point of
the method, another probe records the value of the path ID counter,
and another timestamp. After execution is ﬁnished, this informa-
tion allows the approach to generate a set of path tuples of the form
(cid:104)thread_id, path_id, enter_time, exit_time(cid:105) where thread_id
identiﬁes current thread, path_id is the traversed ID for paths, and
enter_time and exit_time are the time stamps that indicate when
a path starts and ends.

The App Instrumenter also inserts probes to obtain timestamps
before and after the invocation of certain APIs. As we explain
in Section 3.2.1, this information is used to allocate tail energy
and isolate the energy cost of certain APIs for which it is not
possible to model using linear regression (i.e., methods that have
non constant energy consumption.) For each of the invocations,
the instrumentation generates an invocation tuple of the form
(cid:104)method_id, enter_time, exit_time(cid:105), where method_id iden-
tiﬁes the invoking method, and enter_time and exit_time are
timestamps before invoking the method and after the method has
returned.

Execution of the Instrumented AUA: To generate the path and
invocation tuples, the instrumented AUA is executed on the Power
Measurement Platform. The Power Measurement Platform is based
on the LEAP node [25]. The LEAP is an x86 platform based on an

ATOM N550 processor that runs Android 3.2. Each component
in the LEAP (e.g., WiFi, GPS, memory, and CPU) is connected
to an analog to digital converter (DAQ) that samples current draw
at 10KHz. The LEAP also provides Android applications with the
ability to trigger a synchronization signal. This allows the approach
to synchronize the samples with the paths’ timestamps and avoid
inaccuracy due to clock skew. Each of the uses cases is executed
by the developer on the AUA while it is running on the LEAP. Note
that all of the measurements are recorded in hardware external to
the Android smartphone components, so the measurement process
does not introduce any interference or execution overhead.
3.2 Ofﬂine Analysis Phase

In the Ofﬂine Analysis phase, our approach analyzes the tuples
and power samples generated in the Runtime Measurement phase
to produce a mapping of energy to source lines. There are three
parts to this phase.
In the ﬁrst part, the Path Adjuster statically
examines each traversed path in the CFG and adjusts the corre-
sponding energy measurements to account for special API invoca-
tions, tail energy, and interleaving threads. The adjusted energy
measurements and paths are the inputs to the second part, the Ana-
lyzer, which uses robust regression techniques to calculate the cost
of each source line and identify paths along which garbage col-
lection and thread context switches occurred. The Analyzer also
determines if the testing process created enough data points to per-
form the linear regression and either reduces the grouping of vari-
ables to be solved in the regression or directs the tester to repeat
the test cases to provide more data points. Finally, in the third part,
the Annotator creates a graphic representation of the energy mea-
surements and overlays this with the source code. Note that in the
rest of the paper, we describe our approach in terms of bytecode
instructions, but it is straightforward to convert the bytecode-level
information to source-level using compiler provided debugging in-
formation.
3.2.1 Adjustment to Path Energy Samples
Before beginning the analysis, the Path Adjuster ﬁrst reconstructs
the paths traversed during execution of the AUA. The instructions
executed in a path can be identiﬁed using the path ID and the
CFG of the method containing the path, as described by Ball and
Larus [5]. Once the paths have been reconstructed, the Path Ad-
juster calculates the energy total for the path by summing the mea-
surements reported during the path’s time of execution. The Path
Adjuster can identify the corresponding path and power samples
due to the synchronized timestamps. Then, the Path Adjuster per-

App Instrumenter Path Adjuster Analyzer Annotator Runtime Measurement Phase  Offline Analysis Phase Application (AUA) Use  cases Energy Report Power Measurement Platform Visualization {<paths>} {<power>} Insufficient data? AUA´ forms a static analysis of each path in order to adjust certain API
invocations due to non-constant and too-short API invocations, tail
energy, and thread interleaving. The Path Adjuster generates a
set of paths with the adjusted invocations removed from the paths
and their corresponding energy removed from the power measure-
ments.

API Invocations: Certain API invocations have a non-constant
energy cost associated with their execution. Therefore, it is not
possible to calculate their energy cost using the robust linear re-
gression techniques described in Section 3.2.2. To address this
problem, our approach uses the invocation tuples to identify the
time periods when these invocations are executing and calculates
the invocations’ energy cost by summing the power measurements
taken during that time.

Figure 2: Using longer execution windows for calculating the
energy of invocations with a short execution time.

In most cases, the execution time of an invocation is long enough
that the approach is able to get accurate energy measurements (i.e.,
the execution time is longer than several sampling periods.) How-
ever, in some cases the execution time of the invocation is too brief
(e.g., the execution time is shorter than a sampling period.) For
these invocations, the approach identiﬁes an execution time period
that includes the too short execution and for which the approach
does have enough power samples to accurately the energy con-
sumption. Then it calculates the ratio of the original execution time
versus the larger execution time and multiples that against the en-
ergy total for the larger execution time. To illustrate, consider the
example shown in Figure 2. In this ﬁgure, the horizontal bars in-
dicate the energy sampling interval. For example, the LEAP will
sample the power at t3 and then again at t4. If an invocation I exe-
cutes from time t1 until time t2, then there are no power samples to
be summed in order to ﬁnd the energy consumed by I (EI). When
this occurs, the Path Adjuster ﬁnds the next largest execution win-
dow for which it has sufﬁcient energy samples and uses this win-
dow to calculate EI. In the case of the example, the Path Adjuster
calculates EI as shown in Equation 1, where Ea,b denotes the en-
ergy consumption measured by the Power Measurement Platform
during interval [a, b].

t2 − t1
t4 − t3

Et3,t4

(1)

Note that this only approximates EI. We have found that for
functions whose execution time is so short, this is a reasonable ap-
proximation. These functions consume a very small portion of the
overall energy expended at runtime, on average about 6% of the
total API energy cost. For the general case, where the execution
time is of sufﬁcient length, our evaluation shows that we are able to
accurately measure most functions to within 9% of their measured
ground truth cost.

Figure 3: API invocations with tail energy

Tail Energy: As explained in Section 2, tail energy occurs when
the operating system keeps certain hardware components active,
even during idle periods, to enable subsequent invocations to amor-
tize startup energy costs. The result of this behavior is that the en-
ergy measurements for the time period following the component
access will be higher. Our approach adjusts the path energy total so
that the tail energy is attributed to the invocations that interact with
the hardware component. We assume the availability of tail energy
models, which are generally provided by either component manu-
facturers or power researchers [24]. The model speciﬁes the energy
consumption of the component after an invocation (Etail) and for
how long the device driver maintains this state (Ttail). To calcu-
late the adjustment, the Path Adjuster examines the reconstructed
paths to identify the sequence AD of invocations to methods that
cause tail energy for each device D of the smartphone. For each
such invocation ai ∈ AD, the adjuster compares the timestamp of
ai against the timestamp of ai+1. If the difference is greater than
Ttail then all of Etail is attributed to ai. If the difference is less
than Ttail then only a fraction of Etail is expended before ai+1
occurs and should be attributed to ai. The fraction is calculated as
shown in Equation 2, where TS returns the starting timestamp of an
invocation and TE returns the ending timestamp of an invocation.
Note that the invocation timestamps are known due to the invoca-
tion tuples collected during the Runtime Measurement phase.

TS(ai+1) − TE(ai)

Ttail

Etail

(2)

To illustrate these two scenarios, consider the two invocations
shown in Figure 3. Both of these, AP I_1 and AP I_2, access
the same device in sequence. Their tail energy consumptions are
shown as curved lines extending after the end of the invocations.
To calculate the tail energy associated with AP I_1, note that t2,
the start of the invocation to AP I_2, occurs before the Ttail time
has transpired. Therefore the tail energy assigned to AP I_1 is
t3−t1 ∗ Etail. When the invocation to AP I_2 returns
calculated as t2−t1
at t4, there is no other API accessing the same external device, so
we assign all of Etail, to AP I_2.

Thread Context-Switching During Invocations: A potential
problem that arises with the way the approach attributes energy to
API invocations is that it is possible for the thread containing the
invocation be switched out for another thread from the same appli-
cation. For example, this can happen because the invocation must
wait for a shared resource or another thread has higher priority.
The problem is that energy consumption by the other threads will
then also be measured in the corresponding power samples. As we
discussed earlier, this situation can be detected by modifying the
operating system to accurately track thread scheduling. However,
this would make the approach less portable, so we have devised a
software-level technique to address this problem.

ticular, the Analyzer uses RLR based on M-estimation [13], which
does iterative regression analysis. It begins by solving a normal
linear regression on the set of data points. Then at each iteration,
it calculates the residuals and gives each data point a weight based
on the standard deviations of the residuals. The regression analysis
is repeated on the weighted data to generate a new model and the
process repeats until the standard deviation of residuals does not
change between iterations. For the power samples, RLR is prefer-
able over the well-known ordinary least squares approach because
it is more robust in the presence of outliers. In this case, our data
sample has outliers, which are the paths whose energy measure-
ments are inﬂuenced by garbage collection and thread switching.

More speciﬁcally, at each iteration, given the linear function (cid:126)y =
X(cid:126)θ + (cid:126)u, the Analyzer solves Equation 3 and updates the standard
deviation of residuals. For the weighting function (ψ), we use
the well-known Tukey’s Bisquare function [37], which is shown
in Equation 4. The σ is the standard deviation of residuals in the
last iteration. The value of k is constant and is set according to
different use cases. In our experiments, we found that the average
energy cost of garbage collection and thread switching is about 10
to 70 times the average standard deviation of the residuals in the
ﬁrst iteration; therefore, we select the median 40 of this range as k.

(cid:88)
ψ(yi −(cid:88)
(cid:40)

k

i

ψk(x) =

xikθk)xij = 0

x(kσ − x2)2 −kσ < x < kσ
0

otherwise

(3)

(4)

The solution represents the energy cost of each instruction in the
path. Taken together with the measured energy cost of the invoca-
tions, the Analyzer now has the energy cost for the entire path. The
values for all of the paths are provided as input to the Annotator.
Two special cases are discussed below.

The ﬁrst special case is when it is not possible to solve for a
path’s instruction energy (i.e., m). This happens when the number
of unique bytecodes in a path is higher than the number of indepen-
dent data points. Solving linear system of equations requires that
there be at least as many independent data points as unknown vari-
ables. In this situation, the Analyzer recognizes that there are not
enough data points and can take two actions, which are repeated
until the equation is solvable. The ﬁrst is that the tester is notiﬁed
that the application should be executed more to generate additional
data points. The additional executions do not need to exactly repro-
duce the initial executions, but should represent similar use cases
to ensure a signiﬁcant amount of path overlap. Since this is not
always possible, the second possible action for the Analyzer is to
group counts of similar bytecodes. For example, all variations of
the iconst instruction. This gives fewer unknown variables for
the system of equations. Note that in our experience, even moder-
ate size marketplace apps were sufﬁciently complex that neither of
these actions were required in our evaluation.

The second special case are paths identiﬁed as outliers, which
contain external thread switching or garbage collection. The de-
tection of these outliers is discussed more below. Currently, the
Analyzer excludes these paths, which comprise about 1% of the
total path count. Although it is desirable to include these paths,
since excessive high-energy events could be a symptom of energy
inefﬁcient coding, there are two obstacles to this that we hope to
address in future work. First, the path must be adjusted to remove
the energy cost of the high-energy event. However, because the
measured energy of these events is so high compared to the path
energy, it is not clear how to accurately estimate and separate the

Figure 4: Concurrent threads during an API invocation.

The Path Adjuster determines the number of threads that were
executing while the invocation was executing. This is done by ex-
amining the starting and ending timestamps of each path tuple to
see which ones were active between the invocation’s timestamps.
Then, the Path Adjuster evenly allocates the energy among the con-
N , where N is the
current threads, assigning each the energy of 1
number of concurrent threads. To illustrate, consider the example
shown in Figure 4. T 1 is the original thread and contains an API
invocation at time t1. Threads T 2 and T 3 run while T 1 is per-
forming the invocation. T 1 and T 2 are concurrent in time interval
[t2, t3] and all three are concurrent in [t3, t4]. Therefore, the en-
ergy of T 1 will be Et1,t2 + 1
3 Et3,t4. This is similar to the
way prior approaches have handled concurrent thread energy [24].

2 Et2,t3 + 1

3.2.2 Calculating Source Line Energy Values
The second part of the Ofﬂine Analysis phase calculates the en-
ergy consumption of each source line. The input to the Analyzer
is the set of adjusted paths and energy samples produced by the
the Path Adjuster. At this point, adjustments for all of the API in-
vocations have been made, but the paths could still be inﬂuenced
by the occurrence of garbage collection and thread switching dur-
ing times when there is no API invocation. As we discussed in
Section 2, the energy costs associated with events, such as garbage
collection and thread switching, can skew the regression analysis,
but it is difﬁcult to identify when they occur. Our insight is that
characteristics of these events allow us to deﬁne them as statisti-
cal outliers and therefore the Analyzer can employ Robust Linear
Regression techniques to calculate each source lines’ energy con-
sumption and mitigate the inﬂuence of these high-energy events. In
the rest of this section, we ﬁrst explain the regression technique and
then discuss the insight that allows us to deﬁne garbage collection
and thread switching as statistical outliers.
Robust Linear Regression Analysis

The Analyzer uses linear regression analysis to calculate each
instruction’s energy consumption. We expect linear regression to
work well in this situation because prior work has found that the
cost of bytecodes will be constant given a particular hardware envi-
ronment [12, 29] and the Path Adjuster has removed the non-linear
cost invocations.

To perform the analysis, the Analyzer sets up the equations E =
mX, where E is the adjusted power measurements, X represents
the path traversals with each row representing a frequency vector of
bytecodes present in the measured path. (Note that the bytecodes
associated with the inserted instrumentation are included in this
matrix. Since the approach knows which paths were instrumented,
the associated results are simply removed before visualizing or re-
porting the ﬁnal source line level calculations.) Then the Analyzer
solves for the coefﬁcients m to determine the energy consumed by
the instructions in the path segment. To solve the equations, the An-
alyzer employs Robust Linear Regression (RLR) analysis. In par-

Table 1: Subject applications

App
BBC Reader
Bubble Blaster II
Classic Alchemy
Skyﬁre
Textgram

C
590
932
751
684
632

M

4,923
6,060
4,434
3,976
5,315

BC

Application Information
Description
RSS reader for BBC news
Game to blast bubbles
Educational game

293,910
398,437
467,099
274,196 Web-browser
244,940

Text editor

Figure 5: Visualization of the energy measurements.

event energy versus the path energy. Second, although the energy
associated with these events is signiﬁcant and of interest to devel-
opers, its not clear which instructions should be attributed with the
cost. Currently, this number is tracked and reported as a separate
total.
High-energy Events as Statistical Outliers

The energy overhead of switching to external threads and garbage
collection is quite high. Our experiments show that these events
range from 20,000 to 150,000 times the cost of a normal instruc-
tion. Yet they occur rarely during execution. Our insight is that
the high energy cost and relative infrequency of these high energy
events allows them to be detected as statistical outliers. In small
scale experiments, we found that the energy cost of a path ranges
from 0.007mJ to 0.631mJ; garbage collection from 20mJ to 81mJ;
and thread switching overhead from 6.44mJ to 11.3mJ. This means
that the energy cost of paths with garbage collection and thread
switching will be signiﬁcantly larger than normal paths — 10 to
over 10,000 times larger. This difference in the range of values al-
lows us to identify the events by deﬁning them as outliers based on
their energy consumption (i.e., by setting an appropriate value of k
in Tukey’s Bisquare function.) Note that our approach detects out-
liers for a speciﬁc path and does not simply cluster all of the energy
measurements. A per-path outlier detection is necessary since it is
possible for a path to be long enough that it consumes more energy
than garbage collection or thread switching. In the evaluation, we
validate this approach to detecting garbage collection and thread
switching by showing that our approach is able to detect all known
occurrences of these types of events.

3.2.3 Visualizing the Energy Consumption
The Annotator presents a graphical representation of the source
line level information. Developers can use this visualization to
more readily understand the distribution of energy consumption
across the different parts of their application. The Annotator was
developed as part of our prior work [12], so it is not a research
contribution of this paper. Nonetheless, we consider it an integral
aspect of our approach that increases its usability, so we brieﬂy
summarize its function.

The Annotator is an Eclipse plugin that overlays power informa-
tion onto an application’s source code. A screenshot is shown in
Figure 5. The visualization uses a SeeSoft [9] like graphical rep-
resentation where different colors indicate the amount of energy
consumed by source lines. The color for each source code line is
obtained by ranking each source line according to the sum of its
associated bytecode energy costs. The ranking is then mapped to a
color within the spectrum. In our example, blue shows low energy

consumption and red indicates a high level of energy consumption.
In between values are different levels of red and blue (purple.)

4. EVALUATION

We evaluated two aspects of our approach, analysis time and ac-
curacy. For the evaluation, we implemented our approach as a pro-
totype tool, vLens, and designed several experiments to evaluate
these two aspects. We considered two broad research questions:

RQ1: What amount of analysis time is incurred by vLens?
RQ2: How accurately does vLens calculate the energy consump-

tion of the application?
4.1 Subject Applications

In the evaluation, we used a set of ﬁve application from the
Google Play Market. Table 1 shows the number of classes (C),
methods (M), and bytecodes (BC) for each application. All of the
applications are written for the Dalvik Virtual Machine, do not use
any native libraries, and can be translated to and from Java Virtual
Machine bytecodes by the dex2jar tool. These applications rep-
resent real-world marketplace applications and implement a diverse
range of functionality. For all of the experiments, we ran the appli-
cations using canonical usage scenarios for each application. For
example, we played a game several times (Bubble Blaster II and
Classic Alchemy), created and edited a text document (Textgram),
read a news article via the reader (BBC Reader), and opened a web
page (Skyﬁre).
4.2

Implementation

The vLens prototype is written in Java and works for Android ap-
plications written to run on the Dalvik Virtual Machine. We chose
to implement for Android because its open nature made it easier
to understand the OS inner workings. However, our approach is
applicable for other platforms, such as Windows Phone and iOS,
since it relies on energy measurements provided by external hard-
ware, statistical techniques, and instrumentation, which is available
on many platforms.

There are four main modules in the implementation: the Power
Measurement Platform, App Instrumenter, Analyzer, and Annota-
tor. For the Power Measurement Platform we utilized the LEAP
power measurement device [25] described in Section 3.1. The App
Instrumenter uses BCEL [4] to build intra-procedural control ﬂow
graphs for the efﬁcient path proﬁling and insert the required instru-
mentation. We use dex2jar [1] to convert Dalvik bytecodes to
Java bytecodes; then after instrumentation, we compile the classes
back to Dalvik with the dx tool provided by the Android SDK. The
Analyzer uses R [3] for the robust linear regression functions and
Java code to perform the path adjustments. Finally, the Annotator
is based on an Eclipse visualization plugin we built for prior work
in energy estimation [12].

4.3 RQ1: Analysis Overhead

For the ﬁrst research question, we consider three aspects of the

Table 2: Time and Accuracy

Timing Measurements

Accuracy

App
BBC Reader
Bubble Blaster II
Classic Alchemy
Skyﬁre
Textgram

TI (s)
353
460
873
277
298

TA(s)

TR(%)

158
145
128
97
63

0.51
3.24
8.77
1.12
6.33

R2

0.94
0.90
0.93
0.99
0.92

AEE (%)

6.5
8.6
3.4
4.8
6.3

approach’s analysis time. These are: (1) time to instrument each
application (TI), (2) time to perform the ofﬂine analysis (TA), and
(3) runtime overhead introduced by the instrumentation (TR). Ex-
periments to measure the ﬁrst two were performed on a desktop
platform containing an Intel i3@2.1Ghz with 2GB RAM and run-
ning Ubuntu 12.04. Overhead was measured on the LEAP plat-
form.

To determine TI, we measured the time to instrument each ap-
plication with vLens. After running the application and collecting
the path and invocation tuples, we determined TA by measuring the
time to analyze the tuples, perform path adjustments, and calculate
each source line’s energy using the regression analysis. The results
of these measurements are shown, in seconds, in Table 2. The time
to instrument ranged from ﬁve to twelve minutes, and the time to
analyze ranged from one to just under three minutes. Most of the
instrumentation time was due to the computational cost of building
and analyzing the control ﬂow graphs for each of the methods. The
majority of the ofﬂine analysis cost was due to the IO overhead of
reading all of the path tuples into memory so they could be con-
verted to the path matrices. Further optimizations, such as caching
path information during the ofﬂine analysis, could reduce this cost
further. However, since vLens is intended to be an experimental
prototype, we did not implement these improvements.

To determine the runtime overhead of the instrumentation (TR)
we could not take the straightforward approach of comparing an in-
strumented version of each application against the uninstrumented
version. The reason for this is that a signiﬁcant amount of appli-
cation time is actually spent idle, waiting for user input or data.
The normal user variation in entering this data masks the instru-
mentation overhead variation. Therefore we calculate the non-idle
execution time of the instrumented application and then determine
the percentage of that time that is caused by the instrumentation. A
key insight to measuring non-idle time is that the Android operat-
ing system is event driven, so it idles waiting for user input after a
method exits, and then when it receives input, comes out of the idle
state and executes the event handler method. Therefore, we can
calculate the non-idle time of the application by summing up all of
the time during which an application path was being traversed. For
example if path p1 executed from time 1 to 3 and path p2 executed
from time 2 to 4, then we can calculate the non-idle time as 3 units.
Note that this properly counts a time unit once regardless of how
many threads are executing. Next, we proﬁled the instrumentation
code that was inserted into the application and determined its exe-
cution time TInst. By examining the path tuples, we also know the
execution frequency n of the instrumentation. The resulting calcu-
lation for TR is shown in Equation 5. Here the denominator is the
special time summation described above.
n ∗ TInst

TR =

∪Ti

(5)

The results of this calculation are shown in Table 2 as TR. The
overhead costs range from 0.51% to 8.77% with an average just
under 4%. Overall, this is a low runtime overhead, representing

about 0.15 seconds. Anecdotally, this amount of overhead did not
cause a noticeable delay to the testers during execution.
4.4 RQ2: Measurement Accuracy

For the second research question, we consider the accuracy of
the measurements calculated by vLens. The primary challenge in
this evaluation is that there is no source line ground truth against
which we can compare for accuracy. As discussed in Section 2,
power samplers cannot measure at a frequency high enough to cap-
ture individual source lines. Therefore, we show accuracy of the
approach in several other ways. First we examine the accuracy of
the energy attributed to the APIs. Second, we use statistical tests
to show that the regression analysis results can describe the over-
all energy consumption relationship accurately and that each path
also accurately accounts for its energy. Lastly, we show that our
technique for identifying high-energy events via statistical outlier
analysis correctly identiﬁes paths that contain these events.

Figure 6: Comparison of API energy cost

4.4.1 Accuracy of the API Energy Measurements
To measure the accuracy of the API energy measurements, we
compared their measured cost against a proﬁled cost. To obtain
the measured cost, we ran the apps using vLens and extracted the
cost of each invocation that was executed during the test runs. Al-
together, there were invocations to over 3,722 unique APIs. From
this group we focused on a group of twenty-four APIs whose in-
vocations together comprised more than 70% of the total invoca-
tion related energy consumed by the ﬁve applications. For these
twenty-four, we recorded the arguments and execution context of
the invocations and then proﬁled their energy cost. The proﬁling
was performed on the LEAP platform by executing each invoca-
tion 100 times and then measuring the energy consumed during the
execution. We repeated this proﬁling ﬁve times and calculated the
mean and standard deviation of the experiment. The proﬁled cost
was then compared against the cost calculated by vLens. The re-
sult of this comparison are shown in Figure 6. Each of the APIs
are listed along the X-axis and the two different costs are shown on
the Y-axis, the values on the Y-axis are normalized to the cost of
proﬁled cost. One standard deviation off of the proﬁling mean is
shown with the additional horizontal lines.

Figure 6 shows that for nineteen of the twenty-four APIs, the
vLens measured cost was within an average of 9% of the proﬁled
costs and the gap was within one standard deviation in almost all
cases. For the remaining ﬁve, the measured cost was off signiﬁ-
cantly. We investigated these APIs to determine what caused this
high error rate. The ﬁrst four APIs are synchronized, which means
that they invoke monitor_enter and monitor_exit. This

  0.00  0.50  1.00  1.50  2.00123456789101112131415161718192021222324Normalized EnergyvLensProfilingmade the execution time and energy consumption of their invoca-
tion vary widely as the acquisition and release of the synchroniza-
tion lock was non-deterministic. The ﬁfth API accessed an HTTP
response code, and we found that the code was cached after the
ﬁrst call to the method, which meant signiﬁcantly less computa-
tions had to be performed in subsequent invocations. Because the
proﬁling results for these ﬁve were skewed by these types of be-
haviors, we consider the nineteen to be a more accurate reﬂection
of the accuracy achieved by the vLens calculations.
4.4.2 Accuracy of Bytecode Energy Distribution
We evaluate the accuracy of the bytecode regression model in
two ways. First, we determine the accuracy of the regression model
at an application level by comparing the amount of application en-
ergy calculated using the regression model versus the amount of
application energy actually measured during the experiments. Sec-
ond, we look at the accuracy of the regression model at a path level
by determining the multiple correlation coefﬁcient of the calculated
paths values. The results of these experiments are reported in Ta-
ble 2. Note that we cannot perform this experiment at the bytecode
level because we do not have a way to establish the bytecodes’
ground truth measurements.

To determine the accuracy of the regression model at the applica-
tion level, we calculate the Accumulated Estimating Error (AEE).
This value represents the normalized difference between the amount
of energy that the regression model would calculate for the appli-
cation versus the amount of actually measured energy. Intuitively,
the AEE can be thought of as the amount of total energy not accu-
rately accounted for by the regression model and a lower ratio is a
stronger result. The AEE is shown in Equation 6. The ˆyi represents
the energy calculated for the ith path based on the regression model
and yi is the measured energy of the ith path produced by the Path
Adjuster (i.e., with the invocation energy removed.)

AEE =

|Σˆyi − Σyi|

Σyi

(6)

To determine the accuracy of the regression model at a path level,
we calculate the multiple correlation coefﬁcient (R2). The R2 is a
well-known statistical measure that shows how well a variable can
be predicted based on a linear function of multiple variables. In
our case the value to be predicted is the energy of the ith path (ˆyi)
calculated with the regression model, and the multiple variables
are the individual bytecodes solved for during the regression. The
value of R2 is obtained by calculating the solution to Equation 7.
As with the AEE in Equation 6, yi is the adjusted measured value
of the ith path, ˆyi is the path’s value calculated using the regression
model, and ¯y is the mean of the measured paths. The R2 value is
measured on the interval [0, 1] with a value close to 1 representing
a strong ﬁt of the data to the model and 0 representing a weak ﬁt.

R2 = 1 − Σ(yi − ˆyi)2
Σ(yi − ¯y)2

(7)

For the AEE, the numbers range from 3.4% to 8.6% with an av-
erage of just under 6%. This means that, on average, 6% of the
actual measured energy is not accounted for by the model. In gen-
eral, since linear regression is an approximation, a certain amount
of variance in the energy totals is to be expected. In this context,
we believe that 6% represents a low enough number that the overall
results of the analysis would still be informative and help to guide
the developer in making changes to the code. The R2 values range
from 0.9 to 0.99 with an average of 0.936. The high average R2
value shows that our model is able to ﬁt the measured data very

closely. Overall, these numbers show that our regression model
exhibits high accuracy with respect to its calculations at both the
application and path level.

4.4.3 Accuracy of Outlier Detection
We evaluated the accuracy of the RLR techniques to detect out-
liers caused by garbage collection and thread switching events. To
do this, we seeded a variable number (20, 50, 100, and 200) of ar-
tiﬁcial events along paths of the subject applications by inserting
calls to garbage collection (System.gc()) and thread switching
instructions (Thread.start() and Thread.join()). The
target thread contained only a single instruction so that its actual
execution time would be low and the most prominent cost would be
the context-switch overhead. We then applied the RLR techniques
and checked to see if the paths containing the seeded events were
determined to be outliers. For each of the applications, the RLR
techniques were able to detect all of the seeded high-energy events.
From this result, we conclude that the use of statistical outlier de-
tection to identify paths affected by garbage collection and thread
switching overhead is both an effective and practical approach.
4.4.4 Threats to Validity
In this section we discuss the threats to the validity of our empir-

ical evaluation and explain how we addressed these issues.

External Validity: The subjects in this study are real world mar-
ketplace apps downloaded from the Google Play Market. They rep-
resent different app domains and, in terms of size, are representa-
tive of many apps we saw in the marketplace.

Internal Validity: In general, to help ensure internal validity,
the accuracy and timing experiments were repeated multiple times
and averaged. To ensure that the outlier detection was a result of
our technique, we tracked the seeding of the garbage collection and
thread switching, so we could determine easily in which paths they
occurred. Furthermore, we compared actual and seeded garbage
collection events, to verify that they had similar energy characteris-
tics. For threads, we used a minimal sized thread (one instruction)
to ensure that the thread’s energy was not inﬂated and therefore
made easier to detect.

Construct Validity: For accuracy, we were unable to use the
most straightforward comparison, bytecode ground truth, due to
the difﬁculty of measuring the ground truth for such short events.
Instead, we used invocation ground truth and well-known statistical
tests to show the degree to which our models ﬁt the measured data.
Overall, it seems likely that if the calculated values for invocation
were close to ground truth and the R2 values were consistently
high across all apps, then the calculated source line level energy
would also be accurate. Nonetheless, this is a validity threat that
our experimental design could not completely address.

5. RELATED WORK

There are two areas of related work for our approach, energy es-
timation and power measurement. The ﬁrst area, energy estimation,
assumes that developers do not have access to power measurement
hardware and uses software based techniques to predict how much
energy an application will consume at runtime. The second group
of techniques, power measurement, makes use of power measure-
ment hardware to obtain power samples and then uses software
based techniques to attribute the power to implementation struc-
tures.

The general process of energy estimation techniques is to build
a parameter-based model of energy consumption, capture values
for the model’s parameters from the application, and then calculate

the values produced by the model. As compared to our approach,
the primary difference is that estimation techniques assume that
developers do not have access to power measurement devices, the
target hardware platforms, or are unable to use these techniques for
various reasons. These scenarios can occur frequently in practice
and make estimation techniques a complementary approach to ours.
Our prior work developed an approach, eLens, for predicting
the energy consumption of smartphone applications based on an
expected workload [12]. The eLens technique is based on per-
instruction cost functions, which are provided by a Software En-
ergy Environment Proﬁle (SEEP) and driven by parameters ob-
tained via program analysis. Developing the SEEP is labor in-
tensive and may not always be feasible, as there are thousands of
APIs in the Android SDK, many of which require complex energy
In contrast, vLens takes live energy measurements and
models.
attributes them to source lines using regression and statistical tech-
niques. The vLens technique does not require a SEEP, but does
require a Power Measurement Platform, which may be easier to
obtain for some developers. Because vLens is based on runtime
measurements, it must also deal with the inﬂuence of garbage col-
lection, thread switching, tail energy, and sampling intervals.

Seo and colleagues [27, 28, 29] have proposed several software
energy estimation techniques. They model the energy consump-
tion of each Java bytecode and the network utilization, and capture
these two types of information by modifying the JVM. Compared
to vLens, their estimation requires modiﬁcations to the runtime sys-
tems, the construction of energy models, and provides information
at a component level instead of the source level.

Other approaches estimate software energy using models based
on operating system (OS) level features. These features include
calls to OS-level APIs [18, 33] or state metrics internal to the op-
erating system [23, 24, 39], such as CPU frequency and network
usage. Similar to this work are approaches to estimate the energy
consumption in virtual machines [10, 17, 32, 38]. Compared with
our approach, this body of work requires signiﬁcant integration and
modiﬁcation to the runtime systems and is not as portable. Further-
more, the workload of building models can be high.

Another group of approaches for software energy estimation is
based on low-level hardware modeling. Works of this type build
models based on the assembly instructions [35, 36] or micro-
instructions of each assembly instruction [19, 31]. The drawback
of these approaches is that they cannot estimate the energy of ex-
ternal devices (e.g.,, GPS, WIFI, etc.), which also consume a large
portion of energy in modern mobile systems. Moreover, Sinha and
colleagues [30] have shown that, at this level, the energy consump-
tion of instructions or micro-instructions are roughly the same. Un-
like this body of work, vLens can measure the energy consumption
of the entire mobile system, including external devices.

The last type of work to estimate software energy is to build sim-
ulators. The main drawback of simulators is their speed. Cycle-
level simulators [7, 22] can require thousands of instructions to
simulate one instruction, which is too slow to use for simulating
modern interactive applications. Even functional simulators [21],
which are comparatively faster than cycle accurate simulators, run
too slowly to be useful for capturing realistic user interactions.

The most closely related techniques to our approach are based on
power measurement. The general approach for these techniques is
to use a power measurement device, such as the LEAP [25] or Mon-
soon [2] power meters, that can sample energy measurements at a
certain frequency. These measurements are then combined with
software based techniques to provide useful information to soft-
ware developers. Sahin and colleagues [26] map energy consump-
tion to different component level design patterns. Their work ex-

plored the correlations between energy consumption and the use of
different design patterns. At a higher level, Flinn and colleagues [6,
11] measured the energy consumption of applications and mapped
the energy to individual OS processes. This was done, in part, by
instrumenting the operating systems.

Sesame [8] measures the energy by reading the battery inter-
face of laptops and uses regression analysis to automatically gen-
erate energy consumption information based on system level met-
rics, such as CPU workload and network utilization measurements.
However, Sesame does not provide information at the level of source
code lines. Tan and colleagues [34] also use regression analysis to
map energy to paths in the control ﬂow graph, but are not able to
provide any ﬁner level of granularity with their measurements.

Compared with these measurement approaches, vLens is able to
provide energy measurements at a much ﬁner level of granular-
ity. vLens calculates energy measurements at the source line level,
whereas the above mentioned approaches compute their informa-
tion at the level of entire application, architecture level components,
design patters, or methods.

6. CONCLUSION AND FUTURE WORK

In this paper, we presented our approach for calculating the source
line level energy consumption of Android applications. Our ap-
proach employs a combination of hardware-based energy measure-
ments and efﬁcient path proﬁling to correlate energy measurements
with the application’s execution. Then the approach analyzes each
of the executed paths to handle high energy events, such as garbage
collection and thread switching. The adjusted measurements are
then used to perform a regression analysis that maps the energy to
the individual source lines.

For the evaluation, we implemented our approach in a prototype
tool, vLens, and ran it against ﬁve real-world marketplace apps. Our
evaluation showed that vLens was fast, it was able to calculate en-
ergy information for each app in under three minutes. The approach
was also accurate. It was able to attribute invocation information
to within 10% of the ground truth, the statistical models ﬁt the data
closely with an R2 average of 0.93, and it could detect the high
energy events with 100% accuracy. Overall, the results are promis-
ing and indicate our approach has the potential to help developers
understand the energy related behavior of their applications.

In future work we will focus on improving several aspects of
our approach. The ﬁrst aspect is to design new experiments to im-
prove the construct validity of our experiments. Ideally, we would
do this via faster power sampling techniques; however, it is un-
likely that power samplers will show the same increase in speed
as CPUs. Therefore, we will investigate new statistical and ex-
perimental methods that will allow us to more precisely quantify
source line level accuracy of our approach. Second, we would like
to improve techniques for solving the linear systems of equations
when there are insufﬁcient data points and attaching “conﬁdence”
metrics to our approximations. Third, we would like to explore al-
ternative ways of handling paths that are identiﬁed as outliers by
the statistical analysis. For example, by identifying ways to at-
tribute high-energy events to source lines in a way that is meaning-
ful for developers. Lastly, we would like to use vLens in developer
studies to determine its usefulness for making energy consumption
improvements.

7. ACKNOWLEDGEMENTS

This work was supported by the National Science Foundation
under Grant No. CNS-905596 and a Zumberge Research Award
from the University of Southern California.

8. REFERENCES
[1] Dex2jar. http://code.google.com/p/dex2jar/.
[2] Monsoon. http://www.msoon.com/

LabEquipment/PowerMonitor/.
[3] The r project for statistical computing.
http://www.r-project.org/.

[4] Apache. Bcel library.

http://bcel.sourceforge.net/.

[5] T. Ball and J. Larus. Efﬁcient Path Proﬁling. In MICRO 29,

pages 46–57. IEEE Computer Society, 1996.

[6] F. Bellosa. The Beneﬁts of Event-Driven Energy Accounting

in Power-Sensitive Systems. In the 9th workshop on ACM
SIGOPS European Workshop, pages 37–42. ACM, 2000.

[7] D. Brooks, V. Tiwari, and M. Martonosi. Wattch: a

framework for architectural-level power analysis and
optimizations. In ACM SIGARCH Computer Architecture
News, volume 28, pages 83–94. ACM, 2000.

[8] M. Dong and L. Zhong. Sesame: Self-Constructive System
Energy Modeling for Battery-Powered Mobile Systems. In
Proc. of MobiSys, pages 335–348, 2011.

[9] S. G. Eick, J. L. Steffen, and E. E. Sumner, Jr. Seesoft-a tool
for visualizing line oriented software statistics. IEEE Trans.
Softw. Eng., 18(11):957–968, Nov. 1992.

[10] K. Farkas, J. Flinn, G. Back, D. Grunwald, and J. Anderson.
Quantifying the Energy Consumption of a Pocket Computer
and a Java Virtual Machine. ACM SIGMETRICS
Performance Evaluation Review, 28(1):252–263, 2000.

[11] J. Flinn and M. Satyanarayanan. PowerScope: A Tool for

Proﬁling the Energy Usage of Mobile Applications. In
Second IEEE Workshop on Mobile Computing Systems and
Applications, pages 2–10. IEEE, 1999.

[12] S. Hao, D. Li, W. G. Halfond, and R. Govindan. Estimating

mobile application energy consumption using program
analysis. In Proc. of 35th International Conference on
Software Engineering, 2013.

[13] P. Huber. Robust statistics. 1981.
[14] Intel. Atom N550 Datasheet.

http://www.intel.com/content/dam/www/
public/us/en/documents/datasheets/
atom-n400-vol-1-datasheet-.pdf.

[15] Intel. X18-M/25-M SATA SSD Datasheet.

http://download.intel.com/design/flash/
nand/mainstream/
mainstream-sata-ssd-datasheet.pdf.

[16] X. Jiang, P. Dutta, D. Culler, and I. Stoica. Micro power

meter for energy monitoring of wireless sensor networks at
scale. In Information Processing in Sensor Networks, 2007.
IPSN 2007. 6th International Symposium on, pages 186–195.
IEEE, 2007.

[17] A. Kansal, F. Zhao, J. Liu, N. Kothari, and A. Bhattacharya.

Virtual Machine Power Metering and Provisioning. In
Proceedings of the 1st ACM symposium on Cloud computing,
pages 39–50. ACM, 2010.

[18] T. Li and L. John. Run-time Modeling and Estimation of

Operating System Power Consumption. ACM SIGMETRICS
Performance Evaluation Review, 31(1):160–171, 2003.

[19] H. Mehta, R. Owens, and M. Irwin. INSTRUCTION LEVEL

POWER PROFILING. In Acoustics, Speech, and Signal
Processing, 1996. ICASSP-96. Conference Proceedings.,
1996 IEEE International Conference on, volume 6, pages
3326–3329. IEEE, 1996.

[20] Micron. DDR3 SDRAM SODIMM Datasheet. http:

//download.micron.com/pdf/datasheets/
modules/ddr3/jsf16c256x64h.pdf.

[21] R. Mittal, A. Kansal, and R. Chandra. Empowering

developers to estimate app energy consumption. In Proc. of
MobiCom, 2012.

[22] T. Mudge, T. Austin, and D. Grunwald. The reference

manual for the sim-panalyzer version 2.0 [z].
http://www.eecs.umich.edu/~panalyzer.

[23] A. Pathak, Y. Hu, M. Zhang, P. Bahl, and Y. Wang.

Fine-Grained Power Modeling for Smartphones Using
System Call Tracing. In Proc. of EuroSys, pages 153–168.
ACM, 2011.

[24] A. Pathak, Y. C. Hu, M. Zhang, P. Bahl, and Y.-M. Wang.

Where is the energy spent inside my app? Fine Grained
Energy Accounting on Smartphones with Eprof. In Proc. of
EuroSys, 2012.

[25] P. Peterson, D. Singh, W. Kaiser, and P. Reiher. Investigating
energy and security trade-offs in the classroom with the atom
leap testbed. In 4th Workshop on Cyber Security
Experimentation and Test (CSET), pages 11–11. USENIX
Association, 2011.

[26] C. Sahin, F. Cayci, I. L. M. Gutierrez, J. Clause, F. Kiamilev,

L. Pollock, and K. Winbladh. Initial explorations on design
pattern energy usage. In First International Workshop on
Green and Sustainable Software (GREENS), pages 55–61,
2012.

[27] C. Seo, S. Malek, and N. Medvidovic. An Energy

Consumption Framework for Distributed Java-Based
Systems. In Proc. of 22nd IEEE/ACM International
Conference on Automated Software Engineering, pages
421–424. ACM, 2007.

[28] C. Seo, S. Malek, and N. Medvidovic. Component-Level

Energy Consumption Estimation for Distributed Java-Based
Software Systems. In Proc. of 11th International Symposium
on Component-Based Software Engineering, pages 97–113.
Springer, 2008.

[29] C. Seo, S. Malek, and N. Medvidovic. Estimating the Energy

Consumption in Pervasive Java-Based Systems. In Sixth
Annual IEEE International Conference on Pervasive
Computing and Communications, pages 243–247. IEEE,
2008.

[30] A. Sinha and A. Chandrakasan. Jouletrack-A Web Based
Tool for Software Energy Proﬁling. In Design Automation
Conference, 2001. Proceedings, pages 220–225. IEEE, 2001.

[31] S. Steinke, M. Knauer, L. Wehmeyer, and P. Marwedel. An

Accurate and Fine Grain Instruction-Level Energy Model
Supporting Software Optimizations. In Proc. of PATMOS.
Citeseer, 2001.

[32] J. Stoess, C. Lang, and F. Bellosa. Energy Management for

Hypervisor-Based Virtual Machines. In 2007 USENIX
Annual Technical Conference on Proceedings of the USENIX
Annual Technical Conference, page 1. USENIX Association,
2007.

[33] T. Tan, A. Raghunathan, and N. Jha. Energy Macromodeling

of Embedded Operating Systems. ACM Transactions on
Embedded Computing Systems (TECS), 4(1):231–254, 2005.

[34] T. Tan, A. Raghunathan, G. Lakshminarayana, and N. Jha.
High-level Software Energy Macro-modeling. In Proc. of
Design Automation Conference (DAC), pages 605–610.
IEEE, 2001.

[35] V. Tiwari, S. Malik, and A. Wolfe. Power Analysis of

Embedded Software: A First Step Towards Software Power

Minimization. IEEE Transactions on Very Large Scale
Integration (VLSI) Systems, 2(4):437–445, 1994.

[36] V. Tiwari, S. Malik, A. Wolfe, and M. Tien-Chien Lee.
Instruction Level Power Analysis and Optimization of
Software. The Journal of VLSI Signal Processing,
13(2):223–238, 1996.

[37] J. Turkey and A. Beaton. The ﬁtting of power series,

meaning polynomials, illustrated on band-spectroscopic data.
Technometrics, 16:189–192, 1974.

[38] N. Vijaykrishnan, M. Kandemir, S. Kim, S. Tomar,

A. Sivasubramaniam, and M. Irwin. Energy Behavior of Java

Applications from the Memory Perspective. In Proceedings
of the 2001 Symposium on Java TM Virtual Machine
Research and Technology Symposium-Volume 1, pages
23–23. USENIX Association, 2001.

[39] L. Zhang, B. Tiwana, Z. Qian, Z. Wang, R. Dick, Z. Mao,

and L. Yang. Accurate Online Power Estimation and
Automatic Battery Behavior Based Power Model Generation
for Smartphones. In Proc. of IEEE/ACM/IFIP International
Conference on Hardware/Software Codesign and System
Synthesis, pages 105–114. ACM, 2010.

