DroidAnalytics: A Signature Based Analytic System to Collect, Extract, Analyze and

Associate Android Malware

Min Zheng, Mingshen Sun, John C.S. Lui

Computer Science & Engineering Department

The Chinese University of Hong Kong

Abstract—Smartphones and mobile devices are rapidly be-
coming indispensable devices for many users. Unfortunately,
they also become fertile grounds for hackers to deploy mal-
ware. There is an urgent need to have a “security analytic
& forensic system” which can facilitate analysts to examine,
dissect, associate and correlate large number of mobile ap-
plications. An effective analytic system needs to address the
following questions: How to automatically collect and manage
a high volume of mobile malware? How to analyze a zero-
day suspicious application, and compare or associate it with
existing malware families in the database? How to reveal similar
malicious logic in various malware, and to quickly identify the
new malicious code segment? In this paper, we present the
design and implementation of DroidAnalytics, a signature based
analytic system to automatically collect, manage, analyze and
extract android malware. The system facilitates analysts to
retrieve, associate and reveal malicious logics at the “opcode
level”. We demonstrate the efﬁcacy of DroidAnalytics using
150,368 Android applications, and successfully determine 2,494
Android malware from 102 different families, with 342 of them
being zero-day malware samples from six different families. To
the best of our knowledge, this is the ﬁrst reported case in
showing such a large Android malware analysis/detection. The
evaluation shows the DroidAnalytics is a valuable tool and is
effective in analyzing malware repackaging and mutations.

I. Introduction

Smartphones are becoming prevailing devices for many
people. Unfortunately, malware on smartphones is also in-
creasing at an unprecedented rate. Android OS-based sys-
tems, being the most popular platform for mobile devices,
have been a popular target for malware developers. As stated
in [1], the exponential growth of mobile malware is mainly
due to the ease of generating malware variants. Although
there are number of works which focus on Android malware
detection via permission leakage, it is equally important to
design a system that can perform comprehensive malware
analytics: analyze and dissect suspicious applications at the
opcode level (instead at the permission level), and correlate
the application with existing malware in the database to de-
termine whether it is mutated malware or zero-day malware,
as well as which legitimate applications are infected.
Challenges: To realize an effective analytic system for
Android mobile applications, we need to overcome several
technical hurdles. First, how to systematically collect mal-
ware from the wild. As indicated in [2], new malware vari-
ants are always hidden in many different third-party markets.

Due to the competition of anti-virus companies and their fear
of accidentally releasing malware to the public, companies
are usually reluctant to share their malware database to
researchers. Researchers can only obtain a handful of mobile
malware samples. Hence, how to automate a systematic
process to collect these malicious applications is the ﬁrst
hurdle we need to overcome.

The second hurdle is how to identify repackaged ap-
plications (or mutated malware) from the vast ocean of
applications and malware. As reported in [3], hackers can
easily transform legitimate applications by injecting mali-
cious logic or obfuscated program segments so that they have
the same structure as the original application but contain ma-
licious logic. Thus, how to determine whether an application
is a repackaged or obfuscated malware, and which legitimate
applications are infected is very challenging.

The third hurdle is how to associate a malware with
existing malware (or application) so as to facilitate security
analysis. The existing approach of using cryptographic hash
or package name as an identiﬁer is not effective because
hackers can easily change the hash value or package name.
Security analysts often need to go through a laborous process
of reverse engineering to discover malicious functions and
structure. There is an urgent need to have an efﬁcient method
to associate malware with other malware in the database, so
to examine their commonalities at the opcode level.
Contributions: We present the design and implementation
of DroidAnalytics, an Andorid malware analytic system
for malware collection, signature generation, information
retrieval, and malware association based on similarity score.
Furthermore, DroidAnalytic can efﬁciently detect zero-day
repackaged malware. The contributions of our system are:
(cid:15) DroidAnalytics automates the processes of malware
collection, analysis and management. We have suc-
cessfully collected 150,368 Android applications, and
determined 2,494 malware samples from 102 families.
Among those, there are 342 zero-day malware samples
from six different malware families. We plan to release
the malware database to the research community. (for
our malware database, please refer to http://ansrlab.cse.
cuhk.edu.hk/software/droidanalytics).

(cid:15) DroidAnalytics uses a multi-level signature algorithm
to extract the malware feature based on their semantic

DroidAnalytics: A Signature Based Analytic System to Collect, Extract, Analyze and

Associate Android Malware

Min Zheng, Mingshen Sun, John C.S. Lui

Computer Science & Engineering Department

The Chinese University of Hong Kong

Abstract—Smartphones and mobile devices are rapidly be-
coming indispensable devices for many users. Unfortunately,
they also become fertile grounds for hackers to deploy mal-
ware. There is an urgent need to have a “security analytic
& forensic system” which can facilitate analysts to examine,
dissect, associate and correlate large number of mobile ap-
plications. An effective analytic system needs to address the
following questions: How to automatically collect and manage
a high volume of mobile malware? How to analyze a zero-
day suspicious application, and compare or associate it with
existing malware families in the database? How to reveal similar
malicious logic in various malware, and to quickly identify the
new malicious code segment? In this paper, we present the
design and implementation of DroidAnalytics, a signature based
analytic system to automatically collect, manage, analyze and
extract android malware. The system facilitates analysts to
retrieve, associate and reveal malicious logics at the “opcode
level”. We demonstrate the efﬁcacy of DroidAnalytics using
150,368 Android applications, and successfully determine 2,494
Android malware from 102 different families, with 342 of them
being zero-day malware samples from six different families. To
the best of our knowledge, this is the ﬁrst reported case in
showing such a large Android malware analysis/detection. The
evaluation shows the DroidAnalytics is a valuable tool and is
effective in analyzing malware repackaging and mutations.

I. Introduction

Smartphones are becoming prevailing devices for many
people. Unfortunately, malware on smartphones is also in-
creasing at an unprecedented rate. Android OS-based sys-
tems, being the most popular platform for mobile devices,
have been a popular target for malware developers. As stated
in [1], the exponential growth of mobile malware is mainly
due to the ease of generating malware variants. Although
there are number of works which focus on Android malware
detection via permission leakage, it is equally important to
design a system that can perform comprehensive malware
analytics: analyze and dissect suspicious applications at the
opcode level (instead at the permission level), and correlate
the application with existing malware in the database to de-
termine whether it is mutated malware or zero-day malware,
as well as which legitimate applications are infected.
Challenges: To realize an effective analytic system for
Android mobile applications, we need to overcome several
technical hurdles. First, how to systematically collect mal-
ware from the wild. As indicated in [2], new malware vari-
ants are always hidden in many different third-party markets.

Due to the competition of anti-virus companies and their fear
of accidentally releasing malware to the public, companies
are usually reluctant to share their malware database to
researchers. Researchers can only obtain a handful of mobile
malware samples. Hence, how to automate a systematic
process to collect these malicious applications is the ﬁrst
hurdle we need to overcome.

The second hurdle is how to identify repackaged ap-
plications (or mutated malware) from the vast ocean of
applications and malware. As reported in [3], hackers can
easily transform legitimate applications by injecting mali-
cious logic or obfuscated program segments so that they have
the same structure as the original application but contain ma-
licious logic. Thus, how to determine whether an application
is a repackaged or obfuscated malware, and which legitimate
applications are infected is very challenging.

The third hurdle is how to associate a malware with
existing malware (or application) so as to facilitate security
analysis. The existing approach of using cryptographic hash
or package name as an identiﬁer is not effective because
hackers can easily change the hash value or package name.
Security analysts often need to go through a laborous process
of reverse engineering to discover malicious functions and
structure. There is an urgent need to have an efﬁcient method
to associate malware with other malware in the database, so
to examine their commonalities at the opcode level.
Contributions: We present the design and implementation
of DroidAnalytics, an Andorid malware analytic system
for malware collection, signature generation, information
retrieval, and malware association based on similarity score.
Furthermore, DroidAnalytic can efﬁciently detect zero-day
repackaged malware. The contributions of our system are:
(cid:15) DroidAnalytics automates the processes of malware
collection, analysis and management. We have suc-
cessfully collected 150,368 Android applications, and
determined 2,494 malware samples from 102 families.
Among those, there are 342 zero-day malware samples
from six different malware families. We plan to release
the malware database to the research community. (for
our malware database, please refer to http://ansrlab.cse.
cuhk.edu.hk/software/droidanalytics).

(cid:15) DroidAnalytics uses a multi-level signature algorithm
to extract the malware feature based on their semantic

meaning at the opcode level. This is far more robust
than a cryptographic hash of the entire application.
We show how to use DroidAnalytics to combat against
malware which uses repackaging or code obfuscation,
as well as how to analyze malware with dynamic
payloads (see Sec. III).

(cid:15) Unlike previous works which associate malware via
“permission”, DroidAnalytics associates malware and
generates signatures at
the app/class/method level.
Hence, we can easily track and analyze mutation,
derivatives, and new generation of a malware. Droid-
Analytics can reveal malicious behavior at the method
level to identify repackaged malware, and perform class
association among malware/applications (see Sec. IV).
(cid:15) One can use DroidAnalytics to detect zero-day repack-
aged malware. We have found 342 zero-day repackaged
malware in six different families (see Sec. V).
II. Design & Implementation of DroidAnalytics

AndroidAnalytics consists of modules for automatic mal-
ware collection, signature generation, information retrieval
and association, as well as similarity comparison between
malware. One can also use these functions to detect zero-
day repackaged malware.

Figure 1. The Architecture of the DroidAnalytics

A. Building Blocks of DroidAnalytics

Figure 1 depicts the architecture of DroidAnalytics and its
components. Let us explain the design of each component.
(cid:15) Extensible Crawler: In DroidAnalytics, we implement an
application crawler based on Scrapy [4]. Users can specify
ofﬁcial or third party market places, as well as blog sites
and the crawler will perform regular mobile application
download. The crawler enables us to systematically build
up the mobile applications database for malware analysis
and association. So far, we have collected 150,368 mobile
applications and carried out detailed security analysis.
(cid:15) Dynamic Payloads Detector: To deal with malware which
dynamically downloads malicious codes via the Internet or
attachment ﬁles, we have implemented the dynamic payloads
detector component, which determines malicious trigger
code within malware packages and tracks the downloaded

application and its behavior in virtual machine. Firstly, it
scans the package to ﬁnd suspicious ﬁles such as .elf or
.jar ﬁle. Hackers usually camouﬂage malicious ﬁles by
changing their ﬁle type. To overcome this, this component
scans all ﬁles and identiﬁes ﬁles using their magic numbers
instead of ﬁle extension. Secondly, if an application has any
Internet behavior (e.g., Internet permission or re-delegating
other applications to download ﬁles [5]), the dynamic pay-
loads detector will treat these ﬁles as the target, then runs the
application in the emulator. The system will use the forward
symbolic execution technique to trigger the download behav-
ior. For detail, please refer to [6]. Both the suspicious ﬁles
within the package and dynamically downloaded ﬁles from
the Internet will be sent to the signature generator (which
we will shortly describe) for further analysis.
(cid:15) Android App Information (AIS) Parser: AIS is a
data structure within DroidAnalytics and it is used to rep-
resent .apk information structure. Using the AIS parser,
analysts can reveal the cryptographic hash (or other ba-
sic signature) of an .apk ﬁle,
its package name, per-
mission information, broadcast receiver information and
disassembled code, : : :, etc. Our AIS parser decrypts the
AndroidManifest.xml within an application and dis-
assembles the .dex ﬁle into .smali code. Then it extracts
package information from source code and retains it in AIS
so analysts can easily retrieve this information.
(cid:15) Signature Generator: Anti-virus companies usually use
cryptographic hash, e.g., MD5,
to generate a signature
for an application. This has two major drawbacks. Firstly,
hackers can easily mutate an application and change its
cryptographic hash. Secondly, the cryptographic hash does
not provide sufﬁcient ﬂexibility for security analysis. In
DroidAnalytics, we use a three-level signature generation
scheme to identify each application. This signature scheme
is based on the mobile application, classes, methods, as
well as malware’s dynamic payloads (if any). Our signature
generation is based on the following observation: For any
functional application, it needs to invoke various Android
API calls, and Android API calls sequence within a method
is difﬁcult to modify (unless one drastically changes the
program’s logic, but we did not ﬁnd any from the 150,368
applications we collected that used this obfuscation tech-
nique). Hence, we generate a method’s signature using the
API call sequence, and given the signature of a method,
create the signature of a class which composes of different
methods. Finally, the signature of an application is composed
of all signatures of its classes. We like to emphasize that
our signature algorithm is not only for defense against mal-
ware obfuscation, but more importantly, facilitating malware
analysis via class/method association (we will show in later
sections). Let us present the detail of signature generation.
(a) Android API calls table: Our system uses the API
calls table of the Android SDK. The android.jar ﬁle is
the framework package provided by the Android SDK. We

3 Level SignaturesApplication RepositoryCloud Apk ScannerAppMalware ReportSignature GeneratorAnalyzerAnalysis EnginesAIS Parserwww.appsapk.comwww.souapp.com...CrawlerDynamic Payloads DetectorEmulatorsDroidAnalytics: A Signature Based Analytic System to Collect, Extract, Analyze and

Associate Android Malware

Min Zheng, Mingshen Sun, John C.S. Lui

Computer Science & Engineering Department

The Chinese University of Hong Kong

Abstract—Smartphones and mobile devices are rapidly be-
coming indispensable devices for many users. Unfortunately,
they also become fertile grounds for hackers to deploy mal-
ware. There is an urgent need to have a “security analytic
& forensic system” which can facilitate analysts to examine,
dissect, associate and correlate large number of mobile ap-
plications. An effective analytic system needs to address the
following questions: How to automatically collect and manage
a high volume of mobile malware? How to analyze a zero-
day suspicious application, and compare or associate it with
existing malware families in the database? How to reveal similar
malicious logic in various malware, and to quickly identify the
new malicious code segment? In this paper, we present the
design and implementation of DroidAnalytics, a signature based
analytic system to automatically collect, manage, analyze and
extract android malware. The system facilitates analysts to
retrieve, associate and reveal malicious logics at the “opcode
level”. We demonstrate the efﬁcacy of DroidAnalytics using
150,368 Android applications, and successfully determine 2,494
Android malware from 102 different families, with 342 of them
being zero-day malware samples from six different families. To
the best of our knowledge, this is the ﬁrst reported case in
showing such a large Android malware analysis/detection. The
evaluation shows the DroidAnalytics is a valuable tool and is
effective in analyzing malware repackaging and mutations.

I. Introduction

Smartphones are becoming prevailing devices for many
people. Unfortunately, malware on smartphones is also in-
creasing at an unprecedented rate. Android OS-based sys-
tems, being the most popular platform for mobile devices,
have been a popular target for malware developers. As stated
in [1], the exponential growth of mobile malware is mainly
due to the ease of generating malware variants. Although
there are number of works which focus on Android malware
detection via permission leakage, it is equally important to
design a system that can perform comprehensive malware
analytics: analyze and dissect suspicious applications at the
opcode level (instead at the permission level), and correlate
the application with existing malware in the database to de-
termine whether it is mutated malware or zero-day malware,
as well as which legitimate applications are infected.
Challenges: To realize an effective analytic system for
Android mobile applications, we need to overcome several
technical hurdles. First, how to systematically collect mal-
ware from the wild. As indicated in [2], new malware vari-
ants are always hidden in many different third-party markets.

Due to the competition of anti-virus companies and their fear
of accidentally releasing malware to the public, companies
are usually reluctant to share their malware database to
researchers. Researchers can only obtain a handful of mobile
malware samples. Hence, how to automate a systematic
process to collect these malicious applications is the ﬁrst
hurdle we need to overcome.

The second hurdle is how to identify repackaged ap-
plications (or mutated malware) from the vast ocean of
applications and malware. As reported in [3], hackers can
easily transform legitimate applications by injecting mali-
cious logic or obfuscated program segments so that they have
the same structure as the original application but contain ma-
licious logic. Thus, how to determine whether an application
is a repackaged or obfuscated malware, and which legitimate
applications are infected is very challenging.

The third hurdle is how to associate a malware with
existing malware (or application) so as to facilitate security
analysis. The existing approach of using cryptographic hash
or package name as an identiﬁer is not effective because
hackers can easily change the hash value or package name.
Security analysts often need to go through a laborous process
of reverse engineering to discover malicious functions and
structure. There is an urgent need to have an efﬁcient method
to associate malware with other malware in the database, so
to examine their commonalities at the opcode level.
Contributions: We present the design and implementation
of DroidAnalytics, an Andorid malware analytic system
for malware collection, signature generation, information
retrieval, and malware association based on similarity score.
Furthermore, DroidAnalytic can efﬁciently detect zero-day
repackaged malware. The contributions of our system are:
(cid:15) DroidAnalytics automates the processes of malware
collection, analysis and management. We have suc-
cessfully collected 150,368 Android applications, and
determined 2,494 malware samples from 102 families.
Among those, there are 342 zero-day malware samples
from six different malware families. We plan to release
the malware database to the research community. (for
our malware database, please refer to http://ansrlab.cse.
cuhk.edu.hk/software/droidanalytics).

(cid:15) DroidAnalytics uses a multi-level signature algorithm
to extract the malware feature based on their semantic

meaning at the opcode level. This is far more robust
than a cryptographic hash of the entire application.
We show how to use DroidAnalytics to combat against
malware which uses repackaging or code obfuscation,
as well as how to analyze malware with dynamic
payloads (see Sec. III).

(cid:15) Unlike previous works which associate malware via
“permission”, DroidAnalytics associates malware and
generates signatures at
the app/class/method level.
Hence, we can easily track and analyze mutation,
derivatives, and new generation of a malware. Droid-
Analytics can reveal malicious behavior at the method
level to identify repackaged malware, and perform class
association among malware/applications (see Sec. IV).
(cid:15) One can use DroidAnalytics to detect zero-day repack-
aged malware. We have found 342 zero-day repackaged
malware in six different families (see Sec. V).
II. Design & Implementation of DroidAnalytics

AndroidAnalytics consists of modules for automatic mal-
ware collection, signature generation, information retrieval
and association, as well as similarity comparison between
malware. One can also use these functions to detect zero-
day repackaged malware.

Figure 1. The Architecture of the DroidAnalytics

A. Building Blocks of DroidAnalytics

Figure 1 depicts the architecture of DroidAnalytics and its
components. Let us explain the design of each component.
(cid:15) Extensible Crawler: In DroidAnalytics, we implement an
application crawler based on Scrapy [4]. Users can specify
ofﬁcial or third party market places, as well as blog sites
and the crawler will perform regular mobile application
download. The crawler enables us to systematically build
up the mobile applications database for malware analysis
and association. So far, we have collected 150,368 mobile
applications and carried out detailed security analysis.
(cid:15) Dynamic Payloads Detector: To deal with malware which
dynamically downloads malicious codes via the Internet or
attachment ﬁles, we have implemented the dynamic payloads
detector component, which determines malicious trigger
code within malware packages and tracks the downloaded

application and its behavior in virtual machine. Firstly, it
scans the package to ﬁnd suspicious ﬁles such as .elf or
.jar ﬁle. Hackers usually camouﬂage malicious ﬁles by
changing their ﬁle type. To overcome this, this component
scans all ﬁles and identiﬁes ﬁles using their magic numbers
instead of ﬁle extension. Secondly, if an application has any
Internet behavior (e.g., Internet permission or re-delegating
other applications to download ﬁles [5]), the dynamic pay-
loads detector will treat these ﬁles as the target, then runs the
application in the emulator. The system will use the forward
symbolic execution technique to trigger the download behav-
ior. For detail, please refer to [6]. Both the suspicious ﬁles
within the package and dynamically downloaded ﬁles from
the Internet will be sent to the signature generator (which
we will shortly describe) for further analysis.
(cid:15) Android App Information (AIS) Parser: AIS is a
data structure within DroidAnalytics and it is used to rep-
resent .apk information structure. Using the AIS parser,
analysts can reveal the cryptographic hash (or other ba-
sic signature) of an .apk ﬁle,
its package name, per-
mission information, broadcast receiver information and
disassembled code, : : :, etc. Our AIS parser decrypts the
AndroidManifest.xml within an application and dis-
assembles the .dex ﬁle into .smali code. Then it extracts
package information from source code and retains it in AIS
so analysts can easily retrieve this information.
(cid:15) Signature Generator: Anti-virus companies usually use
cryptographic hash, e.g., MD5,
to generate a signature
for an application. This has two major drawbacks. Firstly,
hackers can easily mutate an application and change its
cryptographic hash. Secondly, the cryptographic hash does
not provide sufﬁcient ﬂexibility for security analysis. In
DroidAnalytics, we use a three-level signature generation
scheme to identify each application. This signature scheme
is based on the mobile application, classes, methods, as
well as malware’s dynamic payloads (if any). Our signature
generation is based on the following observation: For any
functional application, it needs to invoke various Android
API calls, and Android API calls sequence within a method
is difﬁcult to modify (unless one drastically changes the
program’s logic, but we did not ﬁnd any from the 150,368
applications we collected that used this obfuscation tech-
nique). Hence, we generate a method’s signature using the
API call sequence, and given the signature of a method,
create the signature of a class which composes of different
methods. Finally, the signature of an application is composed
of all signatures of its classes. We like to emphasize that
our signature algorithm is not only for defense against mal-
ware obfuscation, but more importantly, facilitating malware
analysis via class/method association (we will show in later
sections). Let us present the detail of signature generation.
(a) Android API calls table: Our system uses the API
calls table of the Android SDK. The android.jar ﬁle is
the framework package provided by the Android SDK. We

3 Level SignaturesApplication RepositoryCloud Apk ScannerAppMalware ReportSignature GeneratorAnalyzerAnalysis EnginesAIS Parserwww.appsapk.comwww.souapp.com...CrawlerDynamic Payloads DetectorEmulatorsuse the Java reﬂection [7] to obtain all descriptions of the
API calls. For each API, we extract both the class path
and the method name. We assign each full path method
a hex number as part of the ID. For the current version
of DroidAnalytics, we extract 47,126 full path methods
in the Android SDK 4.1 version as our API calls ta-
ble. Table I depicts a snapshot of API calls table, e.g.,
android/content/Intent;-><init> is assigned
an ID 0x30291.

Full Path Method

android/accounts/Account;-><init>

:

android/content/Intent;-><init>
android/content/Intent;->toUri
android/telephony/SmsManager;->getDefault
android/app/PendingIntent;->getBroadcast

Method ID
0x00001

:

0x30291
0x30292
0x39D53
0xF3E91

EXAMPLE OF THE ANDROID API CALLS TABLE AND ASSIGNED IDS

Table I

(b) Disassembling process: Each Android application is
composed of different classes and each class is composed
of different methods. To generate signatures for each class
or method, DroidAnalytics ﬁrst disassembles an .apk ﬁle,
then takes the Dalvik opcodes of the .dex ﬁle and trans-
forms them to methods and classes. Then DroidAnalytics
uses the Android API calls table to generate signatures.
(c) Generate Lev3 signature (or method signature): The
system ﬁrst generates a signature for each method and we
call this the Lev3 signature. Based on the Android API calls
table, the system extracts the API call ID sequence as a string
in each method, then hashes this string value to produce the
method’s signature. Figure 2 illustrates how to generate the
Lev3 signature of a method which sends messages to another
mobile phone. Figure 2 shows that the method contains
three API calls. Using the Android API calls table (as in
Table I), we determine their IDs. Signature of a method
is generated by cancatenation of all these IDs. Note that
DroidAnalytics will not extract the API calls which will not
be executed in run time because these codes are usually
generated via obfuscation. Furthermore, if a method (except
the main method) will not be invoked by any other methods,
signature generator will also ignore this method because this
may be a defunct method generated by malware writers.
(d) Generate Lev2 signature (either class signature or
dynamic payload signature): Next, DroidAnalytics pro-
ceeds to generate the Lev2 signature for each class, and it is
based on the Lev3 signatures of methods within that class.
Malware writers may use various obfuscation or repackaging
techniques to change the calling order of the methods table
in a .dex ﬁle. To overcome this problem, our signature
generation algorithm will ﬁrst sort the level 3 signatures
within that class, and then concatenate all these level 3
signatures to form the level 2 signature.

Some malicious codes are dynamically downloaded from

Figure 2. The Process of Lev3 Signature Generation

the Internet during execution. DroidAnalytics uses the dy-
namic payloads detector component to obtain the payload
ﬁles. For the dynamic payloads which are .dex ﬁle or
.jar ﬁle, DroidAnalytics treats them as classes within
the malware. Given these ﬁles,
the system checks their
API call sequence and generates a Lev2 signature for each
class within an application. For the dynamic payloads which
contain, say, .elf ﬁle or .so ﬁle, DroidAnalytics treats
them as a single class within that malware, then uses the
cryptographic hash value (e.g., MD5) of the payload as its
Lev2 signature. For the dynamic payloads which are .apk
ﬁles, DroidAnalytics treats each as a new application and
a class within the malware. DroidAnalytics ﬁrst uses the
cryptographic hash value (e.g., MD5) of the new .apk ﬁle
as one Lev2 signature of that malware. Because the payload
is a new application, DroidAnalytics will use the method we
discussed to carry out a new signature generation.
(e) Generate Lev1 signature (or application signature):
The Lev1 signature is based on the level 2 signatures, e.g.,
signatures of all qualiﬁed classes within an application. In
addition, the signature generator will ignore the class (except
the main class) which will not be invoked by any other
classes since these defunct classes may be generated via
obfuscation. Malware writers may use some repackaging or
obfuscation techniques to change the order of the classes
table of the .dex ﬁle, our signature algorithm will ﬁrst sort
all Lev2 signatures, then concatenate these Lev2 signatures
to generate the Lev1 signature.

Figure 3 summarizes the signature genration framework.
For example, the Lev3 signatures of AAAE1 and B23E8 are
the two method signatures within the same class. Based on
these two (sorted) signatures, we generate the Lev2 signature
of the corresponding class, which is 53EB3. Note that the
Lev2 signature of C3EB3 is generated from a .dex ﬁle
which is a dynamic payload used to execute the malicious
behavior. Based on all sorted Lev2 signatures of all classes,
we generate the Lev1 signature, F32DE, of the application.

const/4v2,0x0new-instancev3,Landroid/content/Intent;const-stringv5,"SENT"invoke-direct{v3,v5},Landroid/content/Intent;-><init>(Ljava/lang/String;)Vconst/4v5,0x0invoke-static{v1,v2,v3,v5},Landroid/app/PendingIntent;->getBroadcast\(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;move-result-objectv4.localv4,pi:Landroid/app/PendingIntent;invoke-static{},Landroid/telephony/SmsManager;->getDefault()\Landroid/telephony/SmsManager;move-result-objectv0android/content/Intent;-><init>()android/app/PendingIntent;->getBroadcast()android/telephony/SmsManager;->getDefault()->0x30291->0xF3E91->0x39D530x302910xF3E910x39D53MethodSign:AAAE1APICallsTableAPICallsIDSequenceStringDroidAnalytics: A Signature Based Analytic System to Collect, Extract, Analyze and

Associate Android Malware

Min Zheng, Mingshen Sun, John C.S. Lui

Computer Science & Engineering Department

The Chinese University of Hong Kong

Abstract—Smartphones and mobile devices are rapidly be-
coming indispensable devices for many users. Unfortunately,
they also become fertile grounds for hackers to deploy mal-
ware. There is an urgent need to have a “security analytic
& forensic system” which can facilitate analysts to examine,
dissect, associate and correlate large number of mobile ap-
plications. An effective analytic system needs to address the
following questions: How to automatically collect and manage
a high volume of mobile malware? How to analyze a zero-
day suspicious application, and compare or associate it with
existing malware families in the database? How to reveal similar
malicious logic in various malware, and to quickly identify the
new malicious code segment? In this paper, we present the
design and implementation of DroidAnalytics, a signature based
analytic system to automatically collect, manage, analyze and
extract android malware. The system facilitates analysts to
retrieve, associate and reveal malicious logics at the “opcode
level”. We demonstrate the efﬁcacy of DroidAnalytics using
150,368 Android applications, and successfully determine 2,494
Android malware from 102 different families, with 342 of them
being zero-day malware samples from six different families. To
the best of our knowledge, this is the ﬁrst reported case in
showing such a large Android malware analysis/detection. The
evaluation shows the DroidAnalytics is a valuable tool and is
effective in analyzing malware repackaging and mutations.

I. Introduction

Smartphones are becoming prevailing devices for many
people. Unfortunately, malware on smartphones is also in-
creasing at an unprecedented rate. Android OS-based sys-
tems, being the most popular platform for mobile devices,
have been a popular target for malware developers. As stated
in [1], the exponential growth of mobile malware is mainly
due to the ease of generating malware variants. Although
there are number of works which focus on Android malware
detection via permission leakage, it is equally important to
design a system that can perform comprehensive malware
analytics: analyze and dissect suspicious applications at the
opcode level (instead at the permission level), and correlate
the application with existing malware in the database to de-
termine whether it is mutated malware or zero-day malware,
as well as which legitimate applications are infected.
Challenges: To realize an effective analytic system for
Android mobile applications, we need to overcome several
technical hurdles. First, how to systematically collect mal-
ware from the wild. As indicated in [2], new malware vari-
ants are always hidden in many different third-party markets.

Due to the competition of anti-virus companies and their fear
of accidentally releasing malware to the public, companies
are usually reluctant to share their malware database to
researchers. Researchers can only obtain a handful of mobile
malware samples. Hence, how to automate a systematic
process to collect these malicious applications is the ﬁrst
hurdle we need to overcome.

The second hurdle is how to identify repackaged ap-
plications (or mutated malware) from the vast ocean of
applications and malware. As reported in [3], hackers can
easily transform legitimate applications by injecting mali-
cious logic or obfuscated program segments so that they have
the same structure as the original application but contain ma-
licious logic. Thus, how to determine whether an application
is a repackaged or obfuscated malware, and which legitimate
applications are infected is very challenging.

The third hurdle is how to associate a malware with
existing malware (or application) so as to facilitate security
analysis. The existing approach of using cryptographic hash
or package name as an identiﬁer is not effective because
hackers can easily change the hash value or package name.
Security analysts often need to go through a laborous process
of reverse engineering to discover malicious functions and
structure. There is an urgent need to have an efﬁcient method
to associate malware with other malware in the database, so
to examine their commonalities at the opcode level.
Contributions: We present the design and implementation
of DroidAnalytics, an Andorid malware analytic system
for malware collection, signature generation, information
retrieval, and malware association based on similarity score.
Furthermore, DroidAnalytic can efﬁciently detect zero-day
repackaged malware. The contributions of our system are:
(cid:15) DroidAnalytics automates the processes of malware
collection, analysis and management. We have suc-
cessfully collected 150,368 Android applications, and
determined 2,494 malware samples from 102 families.
Among those, there are 342 zero-day malware samples
from six different malware families. We plan to release
the malware database to the research community. (for
our malware database, please refer to http://ansrlab.cse.
cuhk.edu.hk/software/droidanalytics).

(cid:15) DroidAnalytics uses a multi-level signature algorithm
to extract the malware feature based on their semantic

meaning at the opcode level. This is far more robust
than a cryptographic hash of the entire application.
We show how to use DroidAnalytics to combat against
malware which uses repackaging or code obfuscation,
as well as how to analyze malware with dynamic
payloads (see Sec. III).

(cid:15) Unlike previous works which associate malware via
“permission”, DroidAnalytics associates malware and
generates signatures at
the app/class/method level.
Hence, we can easily track and analyze mutation,
derivatives, and new generation of a malware. Droid-
Analytics can reveal malicious behavior at the method
level to identify repackaged malware, and perform class
association among malware/applications (see Sec. IV).
(cid:15) One can use DroidAnalytics to detect zero-day repack-
aged malware. We have found 342 zero-day repackaged
malware in six different families (see Sec. V).
II. Design & Implementation of DroidAnalytics

AndroidAnalytics consists of modules for automatic mal-
ware collection, signature generation, information retrieval
and association, as well as similarity comparison between
malware. One can also use these functions to detect zero-
day repackaged malware.

Figure 1. The Architecture of the DroidAnalytics

A. Building Blocks of DroidAnalytics

Figure 1 depicts the architecture of DroidAnalytics and its
components. Let us explain the design of each component.
(cid:15) Extensible Crawler: In DroidAnalytics, we implement an
application crawler based on Scrapy [4]. Users can specify
ofﬁcial or third party market places, as well as blog sites
and the crawler will perform regular mobile application
download. The crawler enables us to systematically build
up the mobile applications database for malware analysis
and association. So far, we have collected 150,368 mobile
applications and carried out detailed security analysis.
(cid:15) Dynamic Payloads Detector: To deal with malware which
dynamically downloads malicious codes via the Internet or
attachment ﬁles, we have implemented the dynamic payloads
detector component, which determines malicious trigger
code within malware packages and tracks the downloaded

application and its behavior in virtual machine. Firstly, it
scans the package to ﬁnd suspicious ﬁles such as .elf or
.jar ﬁle. Hackers usually camouﬂage malicious ﬁles by
changing their ﬁle type. To overcome this, this component
scans all ﬁles and identiﬁes ﬁles using their magic numbers
instead of ﬁle extension. Secondly, if an application has any
Internet behavior (e.g., Internet permission or re-delegating
other applications to download ﬁles [5]), the dynamic pay-
loads detector will treat these ﬁles as the target, then runs the
application in the emulator. The system will use the forward
symbolic execution technique to trigger the download behav-
ior. For detail, please refer to [6]. Both the suspicious ﬁles
within the package and dynamically downloaded ﬁles from
the Internet will be sent to the signature generator (which
we will shortly describe) for further analysis.
(cid:15) Android App Information (AIS) Parser: AIS is a
data structure within DroidAnalytics and it is used to rep-
resent .apk information structure. Using the AIS parser,
analysts can reveal the cryptographic hash (or other ba-
sic signature) of an .apk ﬁle,
its package name, per-
mission information, broadcast receiver information and
disassembled code, : : :, etc. Our AIS parser decrypts the
AndroidManifest.xml within an application and dis-
assembles the .dex ﬁle into .smali code. Then it extracts
package information from source code and retains it in AIS
so analysts can easily retrieve this information.
(cid:15) Signature Generator: Anti-virus companies usually use
cryptographic hash, e.g., MD5,
to generate a signature
for an application. This has two major drawbacks. Firstly,
hackers can easily mutate an application and change its
cryptographic hash. Secondly, the cryptographic hash does
not provide sufﬁcient ﬂexibility for security analysis. In
DroidAnalytics, we use a three-level signature generation
scheme to identify each application. This signature scheme
is based on the mobile application, classes, methods, as
well as malware’s dynamic payloads (if any). Our signature
generation is based on the following observation: For any
functional application, it needs to invoke various Android
API calls, and Android API calls sequence within a method
is difﬁcult to modify (unless one drastically changes the
program’s logic, but we did not ﬁnd any from the 150,368
applications we collected that used this obfuscation tech-
nique). Hence, we generate a method’s signature using the
API call sequence, and given the signature of a method,
create the signature of a class which composes of different
methods. Finally, the signature of an application is composed
of all signatures of its classes. We like to emphasize that
our signature algorithm is not only for defense against mal-
ware obfuscation, but more importantly, facilitating malware
analysis via class/method association (we will show in later
sections). Let us present the detail of signature generation.
(a) Android API calls table: Our system uses the API
calls table of the Android SDK. The android.jar ﬁle is
the framework package provided by the Android SDK. We

3 Level SignaturesApplication RepositoryCloud Apk ScannerAppMalware ReportSignature GeneratorAnalyzerAnalysis EnginesAIS Parserwww.appsapk.comwww.souapp.com...CrawlerDynamic Payloads DetectorEmulatorsuse the Java reﬂection [7] to obtain all descriptions of the
API calls. For each API, we extract both the class path
and the method name. We assign each full path method
a hex number as part of the ID. For the current version
of DroidAnalytics, we extract 47,126 full path methods
in the Android SDK 4.1 version as our API calls ta-
ble. Table I depicts a snapshot of API calls table, e.g.,
android/content/Intent;-><init> is assigned
an ID 0x30291.

Full Path Method

android/accounts/Account;-><init>

:

android/content/Intent;-><init>
android/content/Intent;->toUri
android/telephony/SmsManager;->getDefault
android/app/PendingIntent;->getBroadcast

Method ID
0x00001

:

0x30291
0x30292
0x39D53
0xF3E91

EXAMPLE OF THE ANDROID API CALLS TABLE AND ASSIGNED IDS

Table I

(b) Disassembling process: Each Android application is
composed of different classes and each class is composed
of different methods. To generate signatures for each class
or method, DroidAnalytics ﬁrst disassembles an .apk ﬁle,
then takes the Dalvik opcodes of the .dex ﬁle and trans-
forms them to methods and classes. Then DroidAnalytics
uses the Android API calls table to generate signatures.
(c) Generate Lev3 signature (or method signature): The
system ﬁrst generates a signature for each method and we
call this the Lev3 signature. Based on the Android API calls
table, the system extracts the API call ID sequence as a string
in each method, then hashes this string value to produce the
method’s signature. Figure 2 illustrates how to generate the
Lev3 signature of a method which sends messages to another
mobile phone. Figure 2 shows that the method contains
three API calls. Using the Android API calls table (as in
Table I), we determine their IDs. Signature of a method
is generated by cancatenation of all these IDs. Note that
DroidAnalytics will not extract the API calls which will not
be executed in run time because these codes are usually
generated via obfuscation. Furthermore, if a method (except
the main method) will not be invoked by any other methods,
signature generator will also ignore this method because this
may be a defunct method generated by malware writers.
(d) Generate Lev2 signature (either class signature or
dynamic payload signature): Next, DroidAnalytics pro-
ceeds to generate the Lev2 signature for each class, and it is
based on the Lev3 signatures of methods within that class.
Malware writers may use various obfuscation or repackaging
techniques to change the calling order of the methods table
in a .dex ﬁle. To overcome this problem, our signature
generation algorithm will ﬁrst sort the level 3 signatures
within that class, and then concatenate all these level 3
signatures to form the level 2 signature.

Some malicious codes are dynamically downloaded from

Figure 2. The Process of Lev3 Signature Generation

the Internet during execution. DroidAnalytics uses the dy-
namic payloads detector component to obtain the payload
ﬁles. For the dynamic payloads which are .dex ﬁle or
.jar ﬁle, DroidAnalytics treats them as classes within
the malware. Given these ﬁles,
the system checks their
API call sequence and generates a Lev2 signature for each
class within an application. For the dynamic payloads which
contain, say, .elf ﬁle or .so ﬁle, DroidAnalytics treats
them as a single class within that malware, then uses the
cryptographic hash value (e.g., MD5) of the payload as its
Lev2 signature. For the dynamic payloads which are .apk
ﬁles, DroidAnalytics treats each as a new application and
a class within the malware. DroidAnalytics ﬁrst uses the
cryptographic hash value (e.g., MD5) of the new .apk ﬁle
as one Lev2 signature of that malware. Because the payload
is a new application, DroidAnalytics will use the method we
discussed to carry out a new signature generation.
(e) Generate Lev1 signature (or application signature):
The Lev1 signature is based on the level 2 signatures, e.g.,
signatures of all qualiﬁed classes within an application. In
addition, the signature generator will ignore the class (except
the main class) which will not be invoked by any other
classes since these defunct classes may be generated via
obfuscation. Malware writers may use some repackaging or
obfuscation techniques to change the order of the classes
table of the .dex ﬁle, our signature algorithm will ﬁrst sort
all Lev2 signatures, then concatenate these Lev2 signatures
to generate the Lev1 signature.

Figure 3 summarizes the signature genration framework.
For example, the Lev3 signatures of AAAE1 and B23E8 are
the two method signatures within the same class. Based on
these two (sorted) signatures, we generate the Lev2 signature
of the corresponding class, which is 53EB3. Note that the
Lev2 signature of C3EB3 is generated from a .dex ﬁle
which is a dynamic payload used to execute the malicious
behavior. Based on all sorted Lev2 signatures of all classes,
we generate the Lev1 signature, F32DE, of the application.

const/4v2,0x0new-instancev3,Landroid/content/Intent;const-stringv5,"SENT"invoke-direct{v3,v5},Landroid/content/Intent;-><init>(Ljava/lang/String;)Vconst/4v5,0x0invoke-static{v1,v2,v3,v5},Landroid/app/PendingIntent;->getBroadcast\(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;move-result-objectv4.localv4,pi:Landroid/app/PendingIntent;invoke-static{},Landroid/telephony/SmsManager;->getDefault()\Landroid/telephony/SmsManager;move-result-objectv0android/content/Intent;-><init>()android/app/PendingIntent;->getBroadcast()android/telephony/SmsManager;->getDefault()->0x30291->0xF3E91->0x39D530x302910xF3E910x39D53MethodSign:AAAE1APICallsTableAPICallsIDSequenceStringmalware from three different families (10 samples in each
family) and Table II illustrates our results. The malware
families in our study are: Basebrid (or Basebridge), Gold-
Dream, and Kungfu. We use ADAM [16], a system which
can automatically transform an original malware sample
to different variants by various repackaging and obfusca-
tion techniques (e.g. inserting defunct methods, modifying
methods name, ...etc). We generate seven different variants
for each malware. Then we put these 240 new malware
samples into the DroidAnalytics system and check their
signatures. After our signature calculations, the result shows
that for each malware, the original sample and seven mutated
variants have distinct MD5 hash values (3 repackaging, 4
code obfuscation), but all of them have the same level 1
signature. This shows that DroidAnalytics’ signature system
is effective in defending against code obfuscation.
B. Analyzing Malware with Attachement Files or Dy-
namic Payloads: Some malware will dynamically download
ﬁle which contains the malicious code. Also, some attach-
ment ﬁles within a package may contain malicious logic
but they can be concealed as other valid documents (e.g.,
.png ﬁle, .wma ﬁle). DroidAnalytics will treat these ﬁles
as dynamic payloads. By using static and dynamic analysis
techniques described in Section II, DroidAnalytics accesses
these payloads and generates different signatures.
Experiment. We carried out the following experiment. From
our malware database, we used our signature system and
detected some malware contain the same ﬁle with a .png
ﬁlename extension. But when we check the magic number of
this ﬁle, it is actually an .elf ﬁle. Upon further analysis,
we found that this ﬁle is a root exploit and this malware
belongs to the GinMaster (or GingerMaster) family. An-
other example is the Plankton family. By using dynamic
analysis, DroidAnalytics discovered that all malware in
this family will download a plankton_v0.0.4.jar (or
similar .jar) when the main activity of the application
starts. Further analysis revealed the .jar ﬁle contains ma-
licious behavior, i.e., stealing browser’s history information,
making screen shortcuts and botnet logic. Table III depicts
DroidAnalytics system detects some representative malware
using dynamic payloads.

MD5
34cb03276e426f8d61e782b8435d3147
a24d2ae57c3cee1cf3298c856a917100

9e847c9a27dc9898825f466ea00dac81

dcbe11e5f3b82ce891b793ea40e4975e

Dynamic Payload
/assets/runme.png
/assets/gbfm.png
/assets/install.png
/assets/installsoft.png
/assets/runme.png
/assets/gbfa.png
/assets/install.png
plankton v0.0.4.jar

Description
ELF ﬁle to expoit root
ELF ﬁle to expoit root

Malware Family
GinMaster
GinMaster

ELF ﬁle to expoit root

GinMaster

download in runtime

Plankton

Table III

EXAMPLES OF DYNAMIC PAYLOADS

We also carried out experiment to analyze repackaged

malware. For detail, please refer to [6].

Figure 3.
Illustration of signature generation: the application (Lev1)
signature, class level (Lev2) signatures and method level (Lev3) signatures.

For the current DroidAnalytics platform, we use a server
which is of 2.80 GHz Duo CPU processor, 4GB memory and
2 TB hard disk, with two virtual machines in the server to
implement the anti-virus engine. We carried out experiment
to study the processing time to scanning and generating
signatures. On average, it takes around 60 seconds to scan
one application (includes the dynamic analysis), and around
three seconds to generate all three level signatures, ﬁve
seconds to generate AIS information, and one second to
insert information into the database. As of November 2012,
our system have downloaded 150,368 mobile applications
from the following places: Google Play [8], nine Android
third party markets (e.g., [9]–[11]), two malware forums
[12], [13] and one mobile malware share blog [2]. The size
of all downloaded application is 468GB.
III. Utility & Effectiveness of Signature Based System
Here, we illustrate how DroidAnalytics’ signatures can
be used to analyze (and detect) malware repackaging, code
obfuscation and malware with dynamic payloads.
A. Analyzing Malware which uses Code Obfuscation: A
malware writer can use a disassembler (e.g., Apktool [14])
to convert a .dex ﬁle into .smali ﬁles, then injects new
malware logic into the .smali code, rebuilds it back to a
.dex ﬁle. Based on this, malware writers can apply various
code obfuscation techniques while preserve the behavior as
the original one in order to bypass the anti-virus detection.
As shown in [3], [15], many mobile anti-virus products are
not effective to detect code obfuscated variants.

DroidAnalytics will not extract the API calls in methods
and classes which will not be executed in run time (refer to
Sec. II) because they are defunct and can be generated by
obfuscators. In addition, our signature generation does not
depend on the name of methods or classes and so name
obfuscation has no effect on our signature. Furthermore,
the signature generation of DroidAnalytics is based on the
analyst-deﬁned API calls table. So one can ﬂexibly update
the table to defend against various code obfuscation.
Experiment. To illustrate the effectiveness of DroidAn-
alytics against code obfuscation, we chose 30 different

F32DE53EB393DE1B103CAAAE1B23E83A4EBAABEFADA13Lev1Lev2Lev3......C3EB3dex, jar, elfmethods, classes signaturesdynamic payload signatures......sortedsortedsortedsortedDroidAnalytics: A Signature Based Analytic System to Collect, Extract, Analyze and

Associate Android Malware

Min Zheng, Mingshen Sun, John C.S. Lui

Computer Science & Engineering Department

The Chinese University of Hong Kong

Abstract—Smartphones and mobile devices are rapidly be-
coming indispensable devices for many users. Unfortunately,
they also become fertile grounds for hackers to deploy mal-
ware. There is an urgent need to have a “security analytic
& forensic system” which can facilitate analysts to examine,
dissect, associate and correlate large number of mobile ap-
plications. An effective analytic system needs to address the
following questions: How to automatically collect and manage
a high volume of mobile malware? How to analyze a zero-
day suspicious application, and compare or associate it with
existing malware families in the database? How to reveal similar
malicious logic in various malware, and to quickly identify the
new malicious code segment? In this paper, we present the
design and implementation of DroidAnalytics, a signature based
analytic system to automatically collect, manage, analyze and
extract android malware. The system facilitates analysts to
retrieve, associate and reveal malicious logics at the “opcode
level”. We demonstrate the efﬁcacy of DroidAnalytics using
150,368 Android applications, and successfully determine 2,494
Android malware from 102 different families, with 342 of them
being zero-day malware samples from six different families. To
the best of our knowledge, this is the ﬁrst reported case in
showing such a large Android malware analysis/detection. The
evaluation shows the DroidAnalytics is a valuable tool and is
effective in analyzing malware repackaging and mutations.

I. Introduction

Smartphones are becoming prevailing devices for many
people. Unfortunately, malware on smartphones is also in-
creasing at an unprecedented rate. Android OS-based sys-
tems, being the most popular platform for mobile devices,
have been a popular target for malware developers. As stated
in [1], the exponential growth of mobile malware is mainly
due to the ease of generating malware variants. Although
there are number of works which focus on Android malware
detection via permission leakage, it is equally important to
design a system that can perform comprehensive malware
analytics: analyze and dissect suspicious applications at the
opcode level (instead at the permission level), and correlate
the application with existing malware in the database to de-
termine whether it is mutated malware or zero-day malware,
as well as which legitimate applications are infected.
Challenges: To realize an effective analytic system for
Android mobile applications, we need to overcome several
technical hurdles. First, how to systematically collect mal-
ware from the wild. As indicated in [2], new malware vari-
ants are always hidden in many different third-party markets.

Due to the competition of anti-virus companies and their fear
of accidentally releasing malware to the public, companies
are usually reluctant to share their malware database to
researchers. Researchers can only obtain a handful of mobile
malware samples. Hence, how to automate a systematic
process to collect these malicious applications is the ﬁrst
hurdle we need to overcome.

The second hurdle is how to identify repackaged ap-
plications (or mutated malware) from the vast ocean of
applications and malware. As reported in [3], hackers can
easily transform legitimate applications by injecting mali-
cious logic or obfuscated program segments so that they have
the same structure as the original application but contain ma-
licious logic. Thus, how to determine whether an application
is a repackaged or obfuscated malware, and which legitimate
applications are infected is very challenging.

The third hurdle is how to associate a malware with
existing malware (or application) so as to facilitate security
analysis. The existing approach of using cryptographic hash
or package name as an identiﬁer is not effective because
hackers can easily change the hash value or package name.
Security analysts often need to go through a laborous process
of reverse engineering to discover malicious functions and
structure. There is an urgent need to have an efﬁcient method
to associate malware with other malware in the database, so
to examine their commonalities at the opcode level.
Contributions: We present the design and implementation
of DroidAnalytics, an Andorid malware analytic system
for malware collection, signature generation, information
retrieval, and malware association based on similarity score.
Furthermore, DroidAnalytic can efﬁciently detect zero-day
repackaged malware. The contributions of our system are:
(cid:15) DroidAnalytics automates the processes of malware
collection, analysis and management. We have suc-
cessfully collected 150,368 Android applications, and
determined 2,494 malware samples from 102 families.
Among those, there are 342 zero-day malware samples
from six different malware families. We plan to release
the malware database to the research community. (for
our malware database, please refer to http://ansrlab.cse.
cuhk.edu.hk/software/droidanalytics).

(cid:15) DroidAnalytics uses a multi-level signature algorithm
to extract the malware feature based on their semantic

meaning at the opcode level. This is far more robust
than a cryptographic hash of the entire application.
We show how to use DroidAnalytics to combat against
malware which uses repackaging or code obfuscation,
as well as how to analyze malware with dynamic
payloads (see Sec. III).

(cid:15) Unlike previous works which associate malware via
“permission”, DroidAnalytics associates malware and
generates signatures at
the app/class/method level.
Hence, we can easily track and analyze mutation,
derivatives, and new generation of a malware. Droid-
Analytics can reveal malicious behavior at the method
level to identify repackaged malware, and perform class
association among malware/applications (see Sec. IV).
(cid:15) One can use DroidAnalytics to detect zero-day repack-
aged malware. We have found 342 zero-day repackaged
malware in six different families (see Sec. V).
II. Design & Implementation of DroidAnalytics

AndroidAnalytics consists of modules for automatic mal-
ware collection, signature generation, information retrieval
and association, as well as similarity comparison between
malware. One can also use these functions to detect zero-
day repackaged malware.

Figure 1. The Architecture of the DroidAnalytics

A. Building Blocks of DroidAnalytics

Figure 1 depicts the architecture of DroidAnalytics and its
components. Let us explain the design of each component.
(cid:15) Extensible Crawler: In DroidAnalytics, we implement an
application crawler based on Scrapy [4]. Users can specify
ofﬁcial or third party market places, as well as blog sites
and the crawler will perform regular mobile application
download. The crawler enables us to systematically build
up the mobile applications database for malware analysis
and association. So far, we have collected 150,368 mobile
applications and carried out detailed security analysis.
(cid:15) Dynamic Payloads Detector: To deal with malware which
dynamically downloads malicious codes via the Internet or
attachment ﬁles, we have implemented the dynamic payloads
detector component, which determines malicious trigger
code within malware packages and tracks the downloaded

application and its behavior in virtual machine. Firstly, it
scans the package to ﬁnd suspicious ﬁles such as .elf or
.jar ﬁle. Hackers usually camouﬂage malicious ﬁles by
changing their ﬁle type. To overcome this, this component
scans all ﬁles and identiﬁes ﬁles using their magic numbers
instead of ﬁle extension. Secondly, if an application has any
Internet behavior (e.g., Internet permission or re-delegating
other applications to download ﬁles [5]), the dynamic pay-
loads detector will treat these ﬁles as the target, then runs the
application in the emulator. The system will use the forward
symbolic execution technique to trigger the download behav-
ior. For detail, please refer to [6]. Both the suspicious ﬁles
within the package and dynamically downloaded ﬁles from
the Internet will be sent to the signature generator (which
we will shortly describe) for further analysis.
(cid:15) Android App Information (AIS) Parser: AIS is a
data structure within DroidAnalytics and it is used to rep-
resent .apk information structure. Using the AIS parser,
analysts can reveal the cryptographic hash (or other ba-
sic signature) of an .apk ﬁle,
its package name, per-
mission information, broadcast receiver information and
disassembled code, : : :, etc. Our AIS parser decrypts the
AndroidManifest.xml within an application and dis-
assembles the .dex ﬁle into .smali code. Then it extracts
package information from source code and retains it in AIS
so analysts can easily retrieve this information.
(cid:15) Signature Generator: Anti-virus companies usually use
cryptographic hash, e.g., MD5,
to generate a signature
for an application. This has two major drawbacks. Firstly,
hackers can easily mutate an application and change its
cryptographic hash. Secondly, the cryptographic hash does
not provide sufﬁcient ﬂexibility for security analysis. In
DroidAnalytics, we use a three-level signature generation
scheme to identify each application. This signature scheme
is based on the mobile application, classes, methods, as
well as malware’s dynamic payloads (if any). Our signature
generation is based on the following observation: For any
functional application, it needs to invoke various Android
API calls, and Android API calls sequence within a method
is difﬁcult to modify (unless one drastically changes the
program’s logic, but we did not ﬁnd any from the 150,368
applications we collected that used this obfuscation tech-
nique). Hence, we generate a method’s signature using the
API call sequence, and given the signature of a method,
create the signature of a class which composes of different
methods. Finally, the signature of an application is composed
of all signatures of its classes. We like to emphasize that
our signature algorithm is not only for defense against mal-
ware obfuscation, but more importantly, facilitating malware
analysis via class/method association (we will show in later
sections). Let us present the detail of signature generation.
(a) Android API calls table: Our system uses the API
calls table of the Android SDK. The android.jar ﬁle is
the framework package provided by the Android SDK. We

3 Level SignaturesApplication RepositoryCloud Apk ScannerAppMalware ReportSignature GeneratorAnalyzerAnalysis EnginesAIS Parserwww.appsapk.comwww.souapp.com...CrawlerDynamic Payloads DetectorEmulatorsuse the Java reﬂection [7] to obtain all descriptions of the
API calls. For each API, we extract both the class path
and the method name. We assign each full path method
a hex number as part of the ID. For the current version
of DroidAnalytics, we extract 47,126 full path methods
in the Android SDK 4.1 version as our API calls ta-
ble. Table I depicts a snapshot of API calls table, e.g.,
android/content/Intent;-><init> is assigned
an ID 0x30291.

Full Path Method

android/accounts/Account;-><init>

:

android/content/Intent;-><init>
android/content/Intent;->toUri
android/telephony/SmsManager;->getDefault
android/app/PendingIntent;->getBroadcast

Method ID
0x00001

:

0x30291
0x30292
0x39D53
0xF3E91

EXAMPLE OF THE ANDROID API CALLS TABLE AND ASSIGNED IDS

Table I

(b) Disassembling process: Each Android application is
composed of different classes and each class is composed
of different methods. To generate signatures for each class
or method, DroidAnalytics ﬁrst disassembles an .apk ﬁle,
then takes the Dalvik opcodes of the .dex ﬁle and trans-
forms them to methods and classes. Then DroidAnalytics
uses the Android API calls table to generate signatures.
(c) Generate Lev3 signature (or method signature): The
system ﬁrst generates a signature for each method and we
call this the Lev3 signature. Based on the Android API calls
table, the system extracts the API call ID sequence as a string
in each method, then hashes this string value to produce the
method’s signature. Figure 2 illustrates how to generate the
Lev3 signature of a method which sends messages to another
mobile phone. Figure 2 shows that the method contains
three API calls. Using the Android API calls table (as in
Table I), we determine their IDs. Signature of a method
is generated by cancatenation of all these IDs. Note that
DroidAnalytics will not extract the API calls which will not
be executed in run time because these codes are usually
generated via obfuscation. Furthermore, if a method (except
the main method) will not be invoked by any other methods,
signature generator will also ignore this method because this
may be a defunct method generated by malware writers.
(d) Generate Lev2 signature (either class signature or
dynamic payload signature): Next, DroidAnalytics pro-
ceeds to generate the Lev2 signature for each class, and it is
based on the Lev3 signatures of methods within that class.
Malware writers may use various obfuscation or repackaging
techniques to change the calling order of the methods table
in a .dex ﬁle. To overcome this problem, our signature
generation algorithm will ﬁrst sort the level 3 signatures
within that class, and then concatenate all these level 3
signatures to form the level 2 signature.

Some malicious codes are dynamically downloaded from

Figure 2. The Process of Lev3 Signature Generation

the Internet during execution. DroidAnalytics uses the dy-
namic payloads detector component to obtain the payload
ﬁles. For the dynamic payloads which are .dex ﬁle or
.jar ﬁle, DroidAnalytics treats them as classes within
the malware. Given these ﬁles,
the system checks their
API call sequence and generates a Lev2 signature for each
class within an application. For the dynamic payloads which
contain, say, .elf ﬁle or .so ﬁle, DroidAnalytics treats
them as a single class within that malware, then uses the
cryptographic hash value (e.g., MD5) of the payload as its
Lev2 signature. For the dynamic payloads which are .apk
ﬁles, DroidAnalytics treats each as a new application and
a class within the malware. DroidAnalytics ﬁrst uses the
cryptographic hash value (e.g., MD5) of the new .apk ﬁle
as one Lev2 signature of that malware. Because the payload
is a new application, DroidAnalytics will use the method we
discussed to carry out a new signature generation.
(e) Generate Lev1 signature (or application signature):
The Lev1 signature is based on the level 2 signatures, e.g.,
signatures of all qualiﬁed classes within an application. In
addition, the signature generator will ignore the class (except
the main class) which will not be invoked by any other
classes since these defunct classes may be generated via
obfuscation. Malware writers may use some repackaging or
obfuscation techniques to change the order of the classes
table of the .dex ﬁle, our signature algorithm will ﬁrst sort
all Lev2 signatures, then concatenate these Lev2 signatures
to generate the Lev1 signature.

Figure 3 summarizes the signature genration framework.
For example, the Lev3 signatures of AAAE1 and B23E8 are
the two method signatures within the same class. Based on
these two (sorted) signatures, we generate the Lev2 signature
of the corresponding class, which is 53EB3. Note that the
Lev2 signature of C3EB3 is generated from a .dex ﬁle
which is a dynamic payload used to execute the malicious
behavior. Based on all sorted Lev2 signatures of all classes,
we generate the Lev1 signature, F32DE, of the application.

const/4v2,0x0new-instancev3,Landroid/content/Intent;const-stringv5,"SENT"invoke-direct{v3,v5},Landroid/content/Intent;-><init>(Ljava/lang/String;)Vconst/4v5,0x0invoke-static{v1,v2,v3,v5},Landroid/app/PendingIntent;->getBroadcast\(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;move-result-objectv4.localv4,pi:Landroid/app/PendingIntent;invoke-static{},Landroid/telephony/SmsManager;->getDefault()\Landroid/telephony/SmsManager;move-result-objectv0android/content/Intent;-><init>()android/app/PendingIntent;->getBroadcast()android/telephony/SmsManager;->getDefault()->0x30291->0xF3E91->0x39D530x302910xF3E910x39D53MethodSign:AAAE1APICallsTableAPICallsIDSequenceStringmalware from three different families (10 samples in each
family) and Table II illustrates our results. The malware
families in our study are: Basebrid (or Basebridge), Gold-
Dream, and Kungfu. We use ADAM [16], a system which
can automatically transform an original malware sample
to different variants by various repackaging and obfusca-
tion techniques (e.g. inserting defunct methods, modifying
methods name, ...etc). We generate seven different variants
for each malware. Then we put these 240 new malware
samples into the DroidAnalytics system and check their
signatures. After our signature calculations, the result shows
that for each malware, the original sample and seven mutated
variants have distinct MD5 hash values (3 repackaging, 4
code obfuscation), but all of them have the same level 1
signature. This shows that DroidAnalytics’ signature system
is effective in defending against code obfuscation.
B. Analyzing Malware with Attachement Files or Dy-
namic Payloads: Some malware will dynamically download
ﬁle which contains the malicious code. Also, some attach-
ment ﬁles within a package may contain malicious logic
but they can be concealed as other valid documents (e.g.,
.png ﬁle, .wma ﬁle). DroidAnalytics will treat these ﬁles
as dynamic payloads. By using static and dynamic analysis
techniques described in Section II, DroidAnalytics accesses
these payloads and generates different signatures.
Experiment. We carried out the following experiment. From
our malware database, we used our signature system and
detected some malware contain the same ﬁle with a .png
ﬁlename extension. But when we check the magic number of
this ﬁle, it is actually an .elf ﬁle. Upon further analysis,
we found that this ﬁle is a root exploit and this malware
belongs to the GinMaster (or GingerMaster) family. An-
other example is the Plankton family. By using dynamic
analysis, DroidAnalytics discovered that all malware in
this family will download a plankton_v0.0.4.jar (or
similar .jar) when the main activity of the application
starts. Further analysis revealed the .jar ﬁle contains ma-
licious behavior, i.e., stealing browser’s history information,
making screen shortcuts and botnet logic. Table III depicts
DroidAnalytics system detects some representative malware
using dynamic payloads.

MD5
34cb03276e426f8d61e782b8435d3147
a24d2ae57c3cee1cf3298c856a917100

9e847c9a27dc9898825f466ea00dac81

dcbe11e5f3b82ce891b793ea40e4975e

Dynamic Payload
/assets/runme.png
/assets/gbfm.png
/assets/install.png
/assets/installsoft.png
/assets/runme.png
/assets/gbfa.png
/assets/install.png
plankton v0.0.4.jar

Description
ELF ﬁle to expoit root
ELF ﬁle to expoit root

Malware Family
GinMaster
GinMaster

ELF ﬁle to expoit root

GinMaster

download in runtime

Plankton

Table III

EXAMPLES OF DYNAMIC PAYLOADS

We also carried out experiment to analyze repackaged

malware. For detail, please refer to [6].

Figure 3.
Illustration of signature generation: the application (Lev1)
signature, class level (Lev2) signatures and method level (Lev3) signatures.

For the current DroidAnalytics platform, we use a server
which is of 2.80 GHz Duo CPU processor, 4GB memory and
2 TB hard disk, with two virtual machines in the server to
implement the anti-virus engine. We carried out experiment
to study the processing time to scanning and generating
signatures. On average, it takes around 60 seconds to scan
one application (includes the dynamic analysis), and around
three seconds to generate all three level signatures, ﬁve
seconds to generate AIS information, and one second to
insert information into the database. As of November 2012,
our system have downloaded 150,368 mobile applications
from the following places: Google Play [8], nine Android
third party markets (e.g., [9]–[11]), two malware forums
[12], [13] and one mobile malware share blog [2]. The size
of all downloaded application is 468GB.
III. Utility & Effectiveness of Signature Based System
Here, we illustrate how DroidAnalytics’ signatures can
be used to analyze (and detect) malware repackaging, code
obfuscation and malware with dynamic payloads.
A. Analyzing Malware which uses Code Obfuscation: A
malware writer can use a disassembler (e.g., Apktool [14])
to convert a .dex ﬁle into .smali ﬁles, then injects new
malware logic into the .smali code, rebuilds it back to a
.dex ﬁle. Based on this, malware writers can apply various
code obfuscation techniques while preserve the behavior as
the original one in order to bypass the anti-virus detection.
As shown in [3], [15], many mobile anti-virus products are
not effective to detect code obfuscated variants.

DroidAnalytics will not extract the API calls in methods
and classes which will not be executed in run time (refer to
Sec. II) because they are defunct and can be generated by
obfuscators. In addition, our signature generation does not
depend on the name of methods or classes and so name
obfuscation has no effect on our signature. Furthermore,
the signature generation of DroidAnalytics is based on the
analyst-deﬁned API calls table. So one can ﬂexibly update
the table to defend against various code obfuscation.
Experiment. To illustrate the effectiveness of DroidAn-
alytics against code obfuscation, we chose 30 different

F32DE53EB393DE1B103CAAAE1B23E83A4EBAABEFADA13Lev1Lev2Lev3......C3EB3dex, jar, elfmethods, classes signaturesdynamic payload signatures......sortedsortedsortedsortedMD5
f7967f71b2f32287660ae9a3fa366022
f2e2d727f95fa868fd7ff54459e766e3
e01f573cca83fdf2737be6ecee35fe33
d383ceeb9c6ffcff8c0dd12b73ec43e3
cd040541693693faca9fec646e12e7e6
401952d745cd7ca5281a7f08d3e2eede
271c3965c7822ebf944feb8bbd1cfe7f
8b12ccdc8a69cf2d6a7e6c00f698aaaa

Pakage Name
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup

Lev1 Signature
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd

Malware Family
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu

Description
Original malware
Repackaging
Repackaging
Repackaging
Obfuscation
Obfuscation
Obfuscation
Obfuscation

Table II

EXAMPLES OF CODE OBFUSCATION

IV. Analytic Capability of DroidAnalytics

We conduct three experiments and show how analysts can
study malware, carry out similarity measurement between
applications, as well as perform class association among
150,368 mobile applications in the database.
A. Detailed Analysis on Malware: Using DroidAnalytics,
analysts can also discover which class or method uses
suspicious API calls via the permission recursion technique.
(cid:15) Common Analytics on Malware. First, using the AIS
parser, DroidAnalytics can reveal basic information of an
application like the cryptographic hash (i.e., MD5 value),
package name, broadcast receiver, : : :, etc. This is illustrated
in Figure 4. In addition, DroidAnalytics has a built-in cloud-
based APK scanner that supports diverse anti-virus scan
results (e.g., Kaspersky and Antiy) to help analysts for
reference. Our cloud-based APK scanner is extensible to
accommodate other anti-virus scan engines. Last but not
least, DroidAnalytics can disassemble the .dex ﬁle and
extract class number, method number, and API calls number
in each application, class or method. These functionalities
are useful so analysts can zoom in to the meta-information of
a suspicious malware. Figure 5 shows these functionalities.

Figure 4. Screen Capture of Common Analytics on Malware

(cid:15) Permission Recursion. Current state-of-the-art systems
examine the AndroidManifest.xml to discover per-
missions of an application. This is not informative enough

Figure 5. Screen Capture of Detailed Lev2 Signature

since analysts do not know which class or which method
uses these permissions for suspicious activities. In Droid-
Analytics, we can discover the permission within a class
or a method. Since each permission is related to some API
calls [17]. In DroidAnalytics, we tag permission to API calls
in each method. We combine the method permissions within
the same class as class permission, and combine all class
permissions as application permission. This helps analysts
to quickly discover suspicious methods or classes.
(cid:0) Experiment. In this experiment, we choose a popular
malware family Kungfu and examine the permissions at
the application/class/method levels. Malware in the Kungfu
family can obtain user’s information such as IMEI number,
phone model,..., etc. It can also exploit
the device and
gain root privilege access. Once the malware obtained the
root level access, it installs malicious application in the
background as a back-door service.

We use DroidAnalytics to generate all three-level sig-
natures. Figure 6 shows the partial structure of the sig-
natures with permission recursion of two Kungfu mal-
ware: A4E39D and D2EF8A, and together with a le-
gitimate application BEDIE3 (Lev1 signature). Firstly,
based on the malware reports by our cloud APK scan-
ner, we identify A4E39D and D2EF8A are malware
which come from the Kungfu family with different
package names, net.atools.android.cmwrap and
com.atools.netTrafficStats respectively. By an-
alyzing the Lev2 signature, we discover that BCEED is the
common class which is within the two Kungfu applications.
Secondly, from the Lev3 signature of BCEED, we use the
permission recursion method to expose the method 6F100

(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:1)(cid:2)(cid:3)(cid:4)(cid:3)(cid:4)(cid:6)(cid:7)(cid:6)(cid:8)(cid:9)(cid:8)(cid:8)(cid:6)(cid:10)(cid:11)(cid:12)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:3)(cid:4)(cid:5)(cid:6)(cid:5)(cid:7)(cid:6)(cid:8)(cid:9)(cid:6)(cid:10)(cid:11)(cid:12)(cid:8)(cid:5)(cid:6)(cid:2)(cid:9)(cid:10)(cid:4)(cid:11)(cid:2)(cid:13)(cid:5)(cid:14)(cid:6)(cid:15)(cid:16)(cid:17)(cid:18)(cid:19)(cid:15)(cid:20)(cid:20)(cid:14)(cid:21)(cid:15)(cid:22)(cid:17)(cid:23)(cid:11)(cid:24)(cid:25)(cid:22)(cid:14)(cid:22)(cid:26)(cid:26)(cid:11)(cid:26)(cid:19)(cid:18)(cid:20)(cid:27)(cid:22)(cid:22)(cid:28)(cid:6)(cid:29)(cid:30)(cid:12)(cid:4)(cid:13)(cid:14)(cid:4)(cid:15)(cid:2)(cid:13)(cid:5)(cid:14)(cid:31)(cid:7)(cid:28)(cid:7)(cid:32)(cid:15)(cid:31)(cid:31)(cid:22)(cid:33)(cid:28)(cid:7)(cid:32)(cid:14)(cid:8)(cid:3)(cid:29)(cid:4)(cid:16)(cid:5)(cid:17)(cid:9)(cid:18)(cid:19)(cid:14)(cid:9)(cid:20)(cid:2)(cid:21)(cid:7)(cid:5)(cid:22)(cid:17)(cid:13)(cid:5)(cid:19)(cid:28)(cid:26)(cid:18)(cid:23)(cid:24)(cid:11)(cid:5)(cid:3)(cid:9)(cid:25)(cid:5)(cid:11)(cid:2)(cid:13)(cid:5)(cid:19)(cid:25)(cid:24)(cid:19)(cid:34)(cid:25)(cid:23)(cid:34)(cid:19)(cid:19)(cid:5)(cid:19)(cid:24)(cid:13)(cid:21)(cid:25)(cid:13)(cid:24)(cid:23)(cid:12)(cid:2)(cid:21)(cid:11)(cid:5)(cid:7)(cid:7)(cid:5)(cid:22)(cid:17)(cid:7)(cid:26)(cid:27)(cid:28)(cid:29)(cid:30)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:41)(cid:42)(cid:43)(cid:43)(cid:1)(cid:41)(cid:38)(cid:43)(cid:44)(cid:45)(cid:46)(cid:37)(cid:1)(cid:37)(cid:47)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:1)(cid:37)(cid:36)(cid:48)(cid:37)(cid:1)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:49)(cid:47)(cid:41)(cid:45)(cid:50)(cid:43)(cid:48)(cid:37)(cid:41)(cid:51)(cid:1)(cid:49)(cid:1)(cid:37)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:49)(cid:38)(cid:38)(cid:37)(cid:51)(cid:51)(cid:41)(cid:38)(cid:43)(cid:49)(cid:36)(cid:51)(cid:37)(cid:41)(cid:46)(cid:43)(cid:38)(cid:49)(cid:1)(cid:39)(cid:43)(cid:48)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:49)(cid:38)(cid:38)(cid:37)(cid:51)(cid:51)(cid:41)(cid:52)(cid:39)(cid:48)(cid:37)(cid:41)(cid:46)(cid:43)(cid:38)(cid:49)(cid:1)(cid:39)(cid:43)(cid:48)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:1)(cid:37)(cid:36)(cid:48)(cid:37)(cid:1)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:41)(cid:51)(cid:44)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:51)(cid:37)(cid:48)(cid:47)(cid:41)(cid:51)(cid:44)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:51)(cid:1)(cid:49)(cid:46)(cid:46)(cid:41)(cid:45)(cid:49)(cid:38)(cid:53)(cid:49)(cid:54)(cid:37)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:55)(cid:36)(cid:39)(cid:1)(cid:37)(cid:41)(cid:37)(cid:56)(cid:1)(cid:37)(cid:36)(cid:48)(cid:49)(cid:46)(cid:41)(cid:51)(cid:1)(cid:43)(cid:36)(cid:49)(cid:54)(cid:37)(cid:31)(cid:2)(cid:13)(cid:2)(cid:5)(cid:32)(cid:2)(cid:21)(cid:9)(cid:33)(cid:17)(cid:3)(cid:2)(cid:17)(cid:3)(cid:26)(cid:34)(cid:29)(cid:30)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:3)(cid:35)(cid:33)(cid:11)(cid:35)(cid:33)(cid:28)(cid:6)(cid:14)(cid:33)(cid:3)(cid:31)(cid:35)(cid:28)(cid:42)(cid:43)(cid:43)(cid:1)(cid:41)(cid:38)(cid:43)(cid:44)(cid:45)(cid:46)(cid:37)(cid:1)(cid:37)(cid:47)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:3)(cid:35)(cid:33)(cid:11)(cid:35)(cid:33)(cid:28)(cid:6)(cid:14)(cid:33)(cid:3)(cid:31)(cid:35)(cid:28)(cid:51)(cid:39)(cid:54)(cid:41)(cid:51)(cid:1)(cid:36)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:10)(cid:31)(cid:57)(cid:3)(cid:20)(cid:11)(cid:10)(cid:28)(cid:1)(cid:11)(cid:8)(cid:11)(cid:29)(cid:2)(cid:31)(cid:35)(cid:32)(cid:28)(cid:51)(cid:44)(cid:51)(cid:41)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:47)(cid:18)(cid:13)(cid:4)(cid:17)(cid:9)(cid:31)(cid:2)(cid:7)(cid:23)(cid:6)(cid:3)(cid:7)(cid:30)(cid:5)(cid:5)(cid:5)(cid:53)(cid:6)(cid:29)(cid:11)(cid:10)(cid:4)(cid:30)(cid:32)(cid:13)(cid:5)(cid:1)(cid:2)(cid:3)(cid:2)(cid:13)(cid:3)(cid:2)(cid:19)(cid:1)(cid:2)(cid:3)(cid:2)(cid:13)(cid:3)(cid:2)(cid:19)(cid:5)(cid:5)(cid:5)(cid:35)(cid:36)(cid:37)(cid:31)(cid:38)(cid:25)(cid:21)(cid:22)(cid:39)(cid:4)(cid:17)(cid:40)(cid:18)(cid:41)(cid:42)(cid:43)(cid:44)(cid:17)(cid:19)(cid:21)(cid:22)(cid:5)(cid:19)(cid:45)(cid:18)(cid:43)(cid:44)(cid:19)(cid:21)(cid:19)(cid:43)(cid:4)(cid:5)(cid:5)(cid:5)(cid:49)(cid:35)(cid:33)(cid:3)(cid:32)(cid:13)(cid:5)(cid:12)(cid:4)(cid:7)(cid:7)(cid:12)(cid:4)(cid:7)(cid:7)(cid:5)(cid:5)(cid:47)(cid:10)(cid:31)(cid:3)(cid:20)(cid:49)(cid:35)(cid:6)(cid:8)(cid:32)(cid:33)(cid:3)(cid:14)(cid:4)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)(cid:8)(cid:9)(cid:10)(cid:11)(cid:9)(cid:12)(cid:5)(cid:10)(cid:13)(cid:14)(cid:15)(cid:16)(cid:17)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:18)(cid:1)(cid:2)(cid:19)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:2)(cid:5)(cid:14)(cid:2)(cid:11)(cid:10)(cid:7)(cid:15)(cid:16)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:2)(cid:14)(cid:15)(cid:10)(cid:16)(cid:16)(cid:5)(cid:17)(cid:10)(cid:11)(cid:18)(cid:6)(cid:19)(cid:16)(cid:11)(cid:2)(cid:20)(cid:14)(cid:10)(cid:15)(cid:15)(cid:5)(cid:21)(cid:17)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:23)(cid:23)(cid:23)(cid:24)(cid:4)(cid:10)(cid:10)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)(cid:30)(cid:31)(cid:23)(cid:27)(cid:26)(cid:23)(cid:27)(cid:30)(cid:2)(cid:32)(cid:32)(cid:25)(cid:2)(cid:25)(cid:27)(cid:27)(cid:33)(cid:33)(cid:34)(cid:31)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:10)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:37)(cid:34)(cid:33)(cid:32)(cid:23)(cid:34)(cid:30)(cid:24)(cid:25)(cid:24)(cid:4)(cid:4)(cid:34)(cid:29)(cid:32)(cid:28)(cid:33)(cid:28)(cid:32)(cid:34)(cid:4)(cid:30)(cid:31)(cid:33)(cid:37)(cid:25)(cid:37)(cid:32)(cid:10)(cid:28)(cid:37)(cid:33)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:29)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:31)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:39)(cid:40)(cid:41)(cid:42)(cid:43)(cid:40)(cid:42)(cid:41)(cid:30)(cid:33)(cid:31)(cid:31)(cid:32)(cid:31)(cid:26)(cid:29)(cid:25)(cid:10)(cid:25)(cid:30)(cid:30)(cid:23)(cid:25)(cid:26)(cid:24)(cid:34)(cid:31)(cid:33)(cid:28)(cid:25)(cid:31)(cid:2)(cid:34)(cid:37)(cid:4)(cid:37)(cid:2)(cid:29)(cid:29)(cid:37)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:32)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:4)(cid:23)(cid:24)(cid:37)(cid:27)(cid:28)(cid:26)(cid:2)(cid:34)(cid:28)(cid:31)(cid:33)(cid:37)(cid:25)(cid:34)(cid:24)(cid:2)(cid:10)(cid:27)(cid:28)(cid:34)(cid:37)(cid:37)(cid:30)(cid:24)(cid:37)(cid:37)(cid:27)(cid:27)(cid:34)(cid:4)(cid:29)(cid:25)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:6)(cid:20)(cid:16)(cid:43)(cid:2)(cid:32)(cid:2)(cid:7)(cid:3)(cid:2)(cid:13)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:4)(cid:34)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:44)(cid:39)(cid:45)(cid:43)(cid:46)(cid:41)(cid:42)(cid:34)(cid:26)(cid:33)(cid:4)(cid:2)(cid:4)(cid:33)(cid:25)(cid:25)(cid:24)(cid:31)(cid:37)(cid:28)(cid:31)(cid:24)(cid:25)(cid:29)(cid:37)(cid:31)(cid:25)(cid:10)(cid:2)(cid:10)(cid:30)(cid:27)(cid:2)(cid:31)(cid:27)(cid:25)(cid:2)(cid:2)(cid:10)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:41)(cid:46)(cid:40)(cid:14)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:27)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:46)(cid:14)(cid:14)(cid:42)(cid:6)(cid:6)(cid:47)(cid:40)(cid:42)(cid:41)(cid:48)(cid:49)(cid:43)(cid:50)(cid:47)(cid:6)(cid:41)(cid:46)(cid:41)(cid:42)(cid:25)(cid:2)(cid:10)(cid:24)(cid:37)(cid:30)(cid:28)(cid:23)(cid:31)(cid:30)(cid:28)(cid:37)(cid:24)(cid:30)(cid:4)(cid:29)(cid:30)(cid:32)(cid:10)(cid:34)(cid:27)(cid:31)(cid:25)(cid:30)(cid:24)(cid:27)(cid:28)(cid:34)(cid:2)(cid:37)(cid:29)(cid:28)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:23)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:25)(cid:24)(cid:27)(cid:32)(cid:28)(cid:37)(cid:24)(cid:26)(cid:29)(cid:26)(cid:4)(cid:31)(cid:24)(cid:33)(cid:23)(cid:23)(cid:25)(cid:26)(cid:23)(cid:4)(cid:30)(cid:31)(cid:28)(cid:2)(cid:28)(cid:2)(cid:29)(cid:24)(cid:4)(cid:28)(cid:2)(cid:33)(cid:10)(cid:2)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:2)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:31)(cid:26)(cid:37)(cid:23)(cid:10)(cid:37)(cid:25)(cid:32)(cid:32)(cid:32)(cid:24)(cid:33)(cid:2)(cid:29)(cid:2)(cid:27)(cid:4)(cid:25)(cid:29)(cid:37)(cid:29)(cid:34)(cid:10)(cid:33)(cid:24)(cid:2)(cid:27)(cid:26)(cid:32)(cid:34)(cid:27)(cid:31)(cid:4)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:28)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:4)(cid:29)(cid:24)(cid:24)(cid:29)(cid:2)(cid:30)(cid:10)(cid:27)(cid:28)(cid:27)(cid:29)(cid:28)(cid:31)(cid:26)(cid:26)(cid:28)(cid:23)(cid:25)(cid:28)(cid:33)(cid:28)(cid:28)(cid:25)(cid:28)(cid:4)(cid:37)(cid:24)(cid:27)(cid:37)(cid:25)(cid:29)(cid:28)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:8)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:46)(cid:14)(cid:14)(cid:42)(cid:6)(cid:6)(cid:47)(cid:40)(cid:42)(cid:41)(cid:48)(cid:49)(cid:43)(cid:50)(cid:47)(cid:6)(cid:41)(cid:46)(cid:41)(cid:42)(cid:24)(cid:32)(cid:33)(cid:33)(cid:30)(cid:28)(cid:10)(cid:23)(cid:4)(cid:2)(cid:34)(cid:34)(cid:29)(cid:37)(cid:37)(cid:23)(cid:2)(cid:25)(cid:28)(cid:25)(cid:10)(cid:24)(cid:30)(cid:30)(cid:4)(cid:25)(cid:37)(cid:31)(cid:24)(cid:27)(cid:29)(cid:24)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:14)(cid:15)(cid:2)(cid:10)(cid:13)(cid:17)(cid:13)(cid:2)(cid:28)(cid:2)(cid:13)(cid:2)(cid:9)(cid:32)(cid:2)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:26)(cid:33)(cid:23)(cid:27)(cid:24)(cid:24)(cid:4)(cid:29)(cid:32)(cid:24)(cid:23)(cid:34)(cid:26)(cid:26)(cid:31)(cid:27)(cid:31)(cid:31)(cid:32)(cid:33)(cid:26)(cid:25)(cid:28)(cid:29)(cid:24)(cid:37)(cid:4)(cid:4)(cid:32)(cid:32)(cid:2)(cid:32)(cid:30)(cid:26)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:53)(cid:2)(cid:11)(cid:10)(cid:7)(cid:15)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:26)(cid:4)(cid:31)(cid:28)(cid:26)(cid:25)(cid:30)(cid:2)(cid:24)(cid:29)(cid:26)(cid:27)(cid:25)(cid:4)(cid:37)(cid:10)(cid:25)(cid:34)(cid:27)(cid:30)(cid:29)(cid:37)(cid:31)(cid:24)(cid:37)(cid:26)(cid:24)(cid:2)(cid:34)(cid:32)(cid:31)(cid:34)(cid:10)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:14)(cid:22)(cid:9)(cid:9)(cid:2)(cid:32)(cid:11)(cid:7)(cid:22)(cid:9)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:24)(cid:53)(cid:13)(cid:22)(cid:7)(cid:23)(cid:46)(cid:9)(cid:10)(cid:15)(cid:19)(cid:11)(cid:7)(cid:32)(cid:16)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)(cid:8)(cid:9)(cid:10)(cid:11)(cid:9)(cid:12)(cid:5)(cid:10)(cid:13)(cid:14)(cid:15)(cid:16)(cid:17)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:18)(cid:1)(cid:2)(cid:19)DroidAnalytics: A Signature Based Analytic System to Collect, Extract, Analyze and

Associate Android Malware

Min Zheng, Mingshen Sun, John C.S. Lui

Computer Science & Engineering Department

The Chinese University of Hong Kong

Abstract—Smartphones and mobile devices are rapidly be-
coming indispensable devices for many users. Unfortunately,
they also become fertile grounds for hackers to deploy mal-
ware. There is an urgent need to have a “security analytic
& forensic system” which can facilitate analysts to examine,
dissect, associate and correlate large number of mobile ap-
plications. An effective analytic system needs to address the
following questions: How to automatically collect and manage
a high volume of mobile malware? How to analyze a zero-
day suspicious application, and compare or associate it with
existing malware families in the database? How to reveal similar
malicious logic in various malware, and to quickly identify the
new malicious code segment? In this paper, we present the
design and implementation of DroidAnalytics, a signature based
analytic system to automatically collect, manage, analyze and
extract android malware. The system facilitates analysts to
retrieve, associate and reveal malicious logics at the “opcode
level”. We demonstrate the efﬁcacy of DroidAnalytics using
150,368 Android applications, and successfully determine 2,494
Android malware from 102 different families, with 342 of them
being zero-day malware samples from six different families. To
the best of our knowledge, this is the ﬁrst reported case in
showing such a large Android malware analysis/detection. The
evaluation shows the DroidAnalytics is a valuable tool and is
effective in analyzing malware repackaging and mutations.

I. Introduction

Smartphones are becoming prevailing devices for many
people. Unfortunately, malware on smartphones is also in-
creasing at an unprecedented rate. Android OS-based sys-
tems, being the most popular platform for mobile devices,
have been a popular target for malware developers. As stated
in [1], the exponential growth of mobile malware is mainly
due to the ease of generating malware variants. Although
there are number of works which focus on Android malware
detection via permission leakage, it is equally important to
design a system that can perform comprehensive malware
analytics: analyze and dissect suspicious applications at the
opcode level (instead at the permission level), and correlate
the application with existing malware in the database to de-
termine whether it is mutated malware or zero-day malware,
as well as which legitimate applications are infected.
Challenges: To realize an effective analytic system for
Android mobile applications, we need to overcome several
technical hurdles. First, how to systematically collect mal-
ware from the wild. As indicated in [2], new malware vari-
ants are always hidden in many different third-party markets.

Due to the competition of anti-virus companies and their fear
of accidentally releasing malware to the public, companies
are usually reluctant to share their malware database to
researchers. Researchers can only obtain a handful of mobile
malware samples. Hence, how to automate a systematic
process to collect these malicious applications is the ﬁrst
hurdle we need to overcome.

The second hurdle is how to identify repackaged ap-
plications (or mutated malware) from the vast ocean of
applications and malware. As reported in [3], hackers can
easily transform legitimate applications by injecting mali-
cious logic or obfuscated program segments so that they have
the same structure as the original application but contain ma-
licious logic. Thus, how to determine whether an application
is a repackaged or obfuscated malware, and which legitimate
applications are infected is very challenging.

The third hurdle is how to associate a malware with
existing malware (or application) so as to facilitate security
analysis. The existing approach of using cryptographic hash
or package name as an identiﬁer is not effective because
hackers can easily change the hash value or package name.
Security analysts often need to go through a laborous process
of reverse engineering to discover malicious functions and
structure. There is an urgent need to have an efﬁcient method
to associate malware with other malware in the database, so
to examine their commonalities at the opcode level.
Contributions: We present the design and implementation
of DroidAnalytics, an Andorid malware analytic system
for malware collection, signature generation, information
retrieval, and malware association based on similarity score.
Furthermore, DroidAnalytic can efﬁciently detect zero-day
repackaged malware. The contributions of our system are:
(cid:15) DroidAnalytics automates the processes of malware
collection, analysis and management. We have suc-
cessfully collected 150,368 Android applications, and
determined 2,494 malware samples from 102 families.
Among those, there are 342 zero-day malware samples
from six different malware families. We plan to release
the malware database to the research community. (for
our malware database, please refer to http://ansrlab.cse.
cuhk.edu.hk/software/droidanalytics).

(cid:15) DroidAnalytics uses a multi-level signature algorithm
to extract the malware feature based on their semantic

meaning at the opcode level. This is far more robust
than a cryptographic hash of the entire application.
We show how to use DroidAnalytics to combat against
malware which uses repackaging or code obfuscation,
as well as how to analyze malware with dynamic
payloads (see Sec. III).

(cid:15) Unlike previous works which associate malware via
“permission”, DroidAnalytics associates malware and
generates signatures at
the app/class/method level.
Hence, we can easily track and analyze mutation,
derivatives, and new generation of a malware. Droid-
Analytics can reveal malicious behavior at the method
level to identify repackaged malware, and perform class
association among malware/applications (see Sec. IV).
(cid:15) One can use DroidAnalytics to detect zero-day repack-
aged malware. We have found 342 zero-day repackaged
malware in six different families (see Sec. V).
II. Design & Implementation of DroidAnalytics

AndroidAnalytics consists of modules for automatic mal-
ware collection, signature generation, information retrieval
and association, as well as similarity comparison between
malware. One can also use these functions to detect zero-
day repackaged malware.

Figure 1. The Architecture of the DroidAnalytics

A. Building Blocks of DroidAnalytics

Figure 1 depicts the architecture of DroidAnalytics and its
components. Let us explain the design of each component.
(cid:15) Extensible Crawler: In DroidAnalytics, we implement an
application crawler based on Scrapy [4]. Users can specify
ofﬁcial or third party market places, as well as blog sites
and the crawler will perform regular mobile application
download. The crawler enables us to systematically build
up the mobile applications database for malware analysis
and association. So far, we have collected 150,368 mobile
applications and carried out detailed security analysis.
(cid:15) Dynamic Payloads Detector: To deal with malware which
dynamically downloads malicious codes via the Internet or
attachment ﬁles, we have implemented the dynamic payloads
detector component, which determines malicious trigger
code within malware packages and tracks the downloaded

application and its behavior in virtual machine. Firstly, it
scans the package to ﬁnd suspicious ﬁles such as .elf or
.jar ﬁle. Hackers usually camouﬂage malicious ﬁles by
changing their ﬁle type. To overcome this, this component
scans all ﬁles and identiﬁes ﬁles using their magic numbers
instead of ﬁle extension. Secondly, if an application has any
Internet behavior (e.g., Internet permission or re-delegating
other applications to download ﬁles [5]), the dynamic pay-
loads detector will treat these ﬁles as the target, then runs the
application in the emulator. The system will use the forward
symbolic execution technique to trigger the download behav-
ior. For detail, please refer to [6]. Both the suspicious ﬁles
within the package and dynamically downloaded ﬁles from
the Internet will be sent to the signature generator (which
we will shortly describe) for further analysis.
(cid:15) Android App Information (AIS) Parser: AIS is a
data structure within DroidAnalytics and it is used to rep-
resent .apk information structure. Using the AIS parser,
analysts can reveal the cryptographic hash (or other ba-
sic signature) of an .apk ﬁle,
its package name, per-
mission information, broadcast receiver information and
disassembled code, : : :, etc. Our AIS parser decrypts the
AndroidManifest.xml within an application and dis-
assembles the .dex ﬁle into .smali code. Then it extracts
package information from source code and retains it in AIS
so analysts can easily retrieve this information.
(cid:15) Signature Generator: Anti-virus companies usually use
cryptographic hash, e.g., MD5,
to generate a signature
for an application. This has two major drawbacks. Firstly,
hackers can easily mutate an application and change its
cryptographic hash. Secondly, the cryptographic hash does
not provide sufﬁcient ﬂexibility for security analysis. In
DroidAnalytics, we use a three-level signature generation
scheme to identify each application. This signature scheme
is based on the mobile application, classes, methods, as
well as malware’s dynamic payloads (if any). Our signature
generation is based on the following observation: For any
functional application, it needs to invoke various Android
API calls, and Android API calls sequence within a method
is difﬁcult to modify (unless one drastically changes the
program’s logic, but we did not ﬁnd any from the 150,368
applications we collected that used this obfuscation tech-
nique). Hence, we generate a method’s signature using the
API call sequence, and given the signature of a method,
create the signature of a class which composes of different
methods. Finally, the signature of an application is composed
of all signatures of its classes. We like to emphasize that
our signature algorithm is not only for defense against mal-
ware obfuscation, but more importantly, facilitating malware
analysis via class/method association (we will show in later
sections). Let us present the detail of signature generation.
(a) Android API calls table: Our system uses the API
calls table of the Android SDK. The android.jar ﬁle is
the framework package provided by the Android SDK. We

3 Level SignaturesApplication RepositoryCloud Apk ScannerAppMalware ReportSignature GeneratorAnalyzerAnalysis EnginesAIS Parserwww.appsapk.comwww.souapp.com...CrawlerDynamic Payloads DetectorEmulatorsuse the Java reﬂection [7] to obtain all descriptions of the
API calls. For each API, we extract both the class path
and the method name. We assign each full path method
a hex number as part of the ID. For the current version
of DroidAnalytics, we extract 47,126 full path methods
in the Android SDK 4.1 version as our API calls ta-
ble. Table I depicts a snapshot of API calls table, e.g.,
android/content/Intent;-><init> is assigned
an ID 0x30291.

Full Path Method

android/accounts/Account;-><init>

:

android/content/Intent;-><init>
android/content/Intent;->toUri
android/telephony/SmsManager;->getDefault
android/app/PendingIntent;->getBroadcast

Method ID
0x00001

:

0x30291
0x30292
0x39D53
0xF3E91

EXAMPLE OF THE ANDROID API CALLS TABLE AND ASSIGNED IDS

Table I

(b) Disassembling process: Each Android application is
composed of different classes and each class is composed
of different methods. To generate signatures for each class
or method, DroidAnalytics ﬁrst disassembles an .apk ﬁle,
then takes the Dalvik opcodes of the .dex ﬁle and trans-
forms them to methods and classes. Then DroidAnalytics
uses the Android API calls table to generate signatures.
(c) Generate Lev3 signature (or method signature): The
system ﬁrst generates a signature for each method and we
call this the Lev3 signature. Based on the Android API calls
table, the system extracts the API call ID sequence as a string
in each method, then hashes this string value to produce the
method’s signature. Figure 2 illustrates how to generate the
Lev3 signature of a method which sends messages to another
mobile phone. Figure 2 shows that the method contains
three API calls. Using the Android API calls table (as in
Table I), we determine their IDs. Signature of a method
is generated by cancatenation of all these IDs. Note that
DroidAnalytics will not extract the API calls which will not
be executed in run time because these codes are usually
generated via obfuscation. Furthermore, if a method (except
the main method) will not be invoked by any other methods,
signature generator will also ignore this method because this
may be a defunct method generated by malware writers.
(d) Generate Lev2 signature (either class signature or
dynamic payload signature): Next, DroidAnalytics pro-
ceeds to generate the Lev2 signature for each class, and it is
based on the Lev3 signatures of methods within that class.
Malware writers may use various obfuscation or repackaging
techniques to change the calling order of the methods table
in a .dex ﬁle. To overcome this problem, our signature
generation algorithm will ﬁrst sort the level 3 signatures
within that class, and then concatenate all these level 3
signatures to form the level 2 signature.

Some malicious codes are dynamically downloaded from

Figure 2. The Process of Lev3 Signature Generation

the Internet during execution. DroidAnalytics uses the dy-
namic payloads detector component to obtain the payload
ﬁles. For the dynamic payloads which are .dex ﬁle or
.jar ﬁle, DroidAnalytics treats them as classes within
the malware. Given these ﬁles,
the system checks their
API call sequence and generates a Lev2 signature for each
class within an application. For the dynamic payloads which
contain, say, .elf ﬁle or .so ﬁle, DroidAnalytics treats
them as a single class within that malware, then uses the
cryptographic hash value (e.g., MD5) of the payload as its
Lev2 signature. For the dynamic payloads which are .apk
ﬁles, DroidAnalytics treats each as a new application and
a class within the malware. DroidAnalytics ﬁrst uses the
cryptographic hash value (e.g., MD5) of the new .apk ﬁle
as one Lev2 signature of that malware. Because the payload
is a new application, DroidAnalytics will use the method we
discussed to carry out a new signature generation.
(e) Generate Lev1 signature (or application signature):
The Lev1 signature is based on the level 2 signatures, e.g.,
signatures of all qualiﬁed classes within an application. In
addition, the signature generator will ignore the class (except
the main class) which will not be invoked by any other
classes since these defunct classes may be generated via
obfuscation. Malware writers may use some repackaging or
obfuscation techniques to change the order of the classes
table of the .dex ﬁle, our signature algorithm will ﬁrst sort
all Lev2 signatures, then concatenate these Lev2 signatures
to generate the Lev1 signature.

Figure 3 summarizes the signature genration framework.
For example, the Lev3 signatures of AAAE1 and B23E8 are
the two method signatures within the same class. Based on
these two (sorted) signatures, we generate the Lev2 signature
of the corresponding class, which is 53EB3. Note that the
Lev2 signature of C3EB3 is generated from a .dex ﬁle
which is a dynamic payload used to execute the malicious
behavior. Based on all sorted Lev2 signatures of all classes,
we generate the Lev1 signature, F32DE, of the application.

const/4v2,0x0new-instancev3,Landroid/content/Intent;const-stringv5,"SENT"invoke-direct{v3,v5},Landroid/content/Intent;-><init>(Ljava/lang/String;)Vconst/4v5,0x0invoke-static{v1,v2,v3,v5},Landroid/app/PendingIntent;->getBroadcast\(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;move-result-objectv4.localv4,pi:Landroid/app/PendingIntent;invoke-static{},Landroid/telephony/SmsManager;->getDefault()\Landroid/telephony/SmsManager;move-result-objectv0android/content/Intent;-><init>()android/app/PendingIntent;->getBroadcast()android/telephony/SmsManager;->getDefault()->0x30291->0xF3E91->0x39D530x302910xF3E910x39D53MethodSign:AAAE1APICallsTableAPICallsIDSequenceStringmalware from three different families (10 samples in each
family) and Table II illustrates our results. The malware
families in our study are: Basebrid (or Basebridge), Gold-
Dream, and Kungfu. We use ADAM [16], a system which
can automatically transform an original malware sample
to different variants by various repackaging and obfusca-
tion techniques (e.g. inserting defunct methods, modifying
methods name, ...etc). We generate seven different variants
for each malware. Then we put these 240 new malware
samples into the DroidAnalytics system and check their
signatures. After our signature calculations, the result shows
that for each malware, the original sample and seven mutated
variants have distinct MD5 hash values (3 repackaging, 4
code obfuscation), but all of them have the same level 1
signature. This shows that DroidAnalytics’ signature system
is effective in defending against code obfuscation.
B. Analyzing Malware with Attachement Files or Dy-
namic Payloads: Some malware will dynamically download
ﬁle which contains the malicious code. Also, some attach-
ment ﬁles within a package may contain malicious logic
but they can be concealed as other valid documents (e.g.,
.png ﬁle, .wma ﬁle). DroidAnalytics will treat these ﬁles
as dynamic payloads. By using static and dynamic analysis
techniques described in Section II, DroidAnalytics accesses
these payloads and generates different signatures.
Experiment. We carried out the following experiment. From
our malware database, we used our signature system and
detected some malware contain the same ﬁle with a .png
ﬁlename extension. But when we check the magic number of
this ﬁle, it is actually an .elf ﬁle. Upon further analysis,
we found that this ﬁle is a root exploit and this malware
belongs to the GinMaster (or GingerMaster) family. An-
other example is the Plankton family. By using dynamic
analysis, DroidAnalytics discovered that all malware in
this family will download a plankton_v0.0.4.jar (or
similar .jar) when the main activity of the application
starts. Further analysis revealed the .jar ﬁle contains ma-
licious behavior, i.e., stealing browser’s history information,
making screen shortcuts and botnet logic. Table III depicts
DroidAnalytics system detects some representative malware
using dynamic payloads.

MD5
34cb03276e426f8d61e782b8435d3147
a24d2ae57c3cee1cf3298c856a917100

9e847c9a27dc9898825f466ea00dac81

dcbe11e5f3b82ce891b793ea40e4975e

Dynamic Payload
/assets/runme.png
/assets/gbfm.png
/assets/install.png
/assets/installsoft.png
/assets/runme.png
/assets/gbfa.png
/assets/install.png
plankton v0.0.4.jar

Description
ELF ﬁle to expoit root
ELF ﬁle to expoit root

Malware Family
GinMaster
GinMaster

ELF ﬁle to expoit root

GinMaster

download in runtime

Plankton

Table III

EXAMPLES OF DYNAMIC PAYLOADS

We also carried out experiment to analyze repackaged

malware. For detail, please refer to [6].

Figure 3.
Illustration of signature generation: the application (Lev1)
signature, class level (Lev2) signatures and method level (Lev3) signatures.

For the current DroidAnalytics platform, we use a server
which is of 2.80 GHz Duo CPU processor, 4GB memory and
2 TB hard disk, with two virtual machines in the server to
implement the anti-virus engine. We carried out experiment
to study the processing time to scanning and generating
signatures. On average, it takes around 60 seconds to scan
one application (includes the dynamic analysis), and around
three seconds to generate all three level signatures, ﬁve
seconds to generate AIS information, and one second to
insert information into the database. As of November 2012,
our system have downloaded 150,368 mobile applications
from the following places: Google Play [8], nine Android
third party markets (e.g., [9]–[11]), two malware forums
[12], [13] and one mobile malware share blog [2]. The size
of all downloaded application is 468GB.
III. Utility & Effectiveness of Signature Based System
Here, we illustrate how DroidAnalytics’ signatures can
be used to analyze (and detect) malware repackaging, code
obfuscation and malware with dynamic payloads.
A. Analyzing Malware which uses Code Obfuscation: A
malware writer can use a disassembler (e.g., Apktool [14])
to convert a .dex ﬁle into .smali ﬁles, then injects new
malware logic into the .smali code, rebuilds it back to a
.dex ﬁle. Based on this, malware writers can apply various
code obfuscation techniques while preserve the behavior as
the original one in order to bypass the anti-virus detection.
As shown in [3], [15], many mobile anti-virus products are
not effective to detect code obfuscated variants.

DroidAnalytics will not extract the API calls in methods
and classes which will not be executed in run time (refer to
Sec. II) because they are defunct and can be generated by
obfuscators. In addition, our signature generation does not
depend on the name of methods or classes and so name
obfuscation has no effect on our signature. Furthermore,
the signature generation of DroidAnalytics is based on the
analyst-deﬁned API calls table. So one can ﬂexibly update
the table to defend against various code obfuscation.
Experiment. To illustrate the effectiveness of DroidAn-
alytics against code obfuscation, we chose 30 different

F32DE53EB393DE1B103CAAAE1B23E83A4EBAABEFADA13Lev1Lev2Lev3......C3EB3dex, jar, elfmethods, classes signaturesdynamic payload signatures......sortedsortedsortedsortedMD5
f7967f71b2f32287660ae9a3fa366022
f2e2d727f95fa868fd7ff54459e766e3
e01f573cca83fdf2737be6ecee35fe33
d383ceeb9c6ffcff8c0dd12b73ec43e3
cd040541693693faca9fec646e12e7e6
401952d745cd7ca5281a7f08d3e2eede
271c3965c7822ebf944feb8bbd1cfe7f
8b12ccdc8a69cf2d6a7e6c00f698aaaa

Pakage Name
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup

Lev1 Signature
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd

Malware Family
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu

Description
Original malware
Repackaging
Repackaging
Repackaging
Obfuscation
Obfuscation
Obfuscation
Obfuscation

Table II

EXAMPLES OF CODE OBFUSCATION

IV. Analytic Capability of DroidAnalytics

We conduct three experiments and show how analysts can
study malware, carry out similarity measurement between
applications, as well as perform class association among
150,368 mobile applications in the database.
A. Detailed Analysis on Malware: Using DroidAnalytics,
analysts can also discover which class or method uses
suspicious API calls via the permission recursion technique.
(cid:15) Common Analytics on Malware. First, using the AIS
parser, DroidAnalytics can reveal basic information of an
application like the cryptographic hash (i.e., MD5 value),
package name, broadcast receiver, : : :, etc. This is illustrated
in Figure 4. In addition, DroidAnalytics has a built-in cloud-
based APK scanner that supports diverse anti-virus scan
results (e.g., Kaspersky and Antiy) to help analysts for
reference. Our cloud-based APK scanner is extensible to
accommodate other anti-virus scan engines. Last but not
least, DroidAnalytics can disassemble the .dex ﬁle and
extract class number, method number, and API calls number
in each application, class or method. These functionalities
are useful so analysts can zoom in to the meta-information of
a suspicious malware. Figure 5 shows these functionalities.

Figure 4. Screen Capture of Common Analytics on Malware

(cid:15) Permission Recursion. Current state-of-the-art systems
examine the AndroidManifest.xml to discover per-
missions of an application. This is not informative enough

Figure 5. Screen Capture of Detailed Lev2 Signature

since analysts do not know which class or which method
uses these permissions for suspicious activities. In Droid-
Analytics, we can discover the permission within a class
or a method. Since each permission is related to some API
calls [17]. In DroidAnalytics, we tag permission to API calls
in each method. We combine the method permissions within
the same class as class permission, and combine all class
permissions as application permission. This helps analysts
to quickly discover suspicious methods or classes.
(cid:0) Experiment. In this experiment, we choose a popular
malware family Kungfu and examine the permissions at
the application/class/method levels. Malware in the Kungfu
family can obtain user’s information such as IMEI number,
phone model,..., etc. It can also exploit
the device and
gain root privilege access. Once the malware obtained the
root level access, it installs malicious application in the
background as a back-door service.

We use DroidAnalytics to generate all three-level sig-
natures. Figure 6 shows the partial structure of the sig-
natures with permission recursion of two Kungfu mal-
ware: A4E39D and D2EF8A, and together with a le-
gitimate application BEDIE3 (Lev1 signature). Firstly,
based on the malware reports by our cloud APK scan-
ner, we identify A4E39D and D2EF8A are malware
which come from the Kungfu family with different
package names, net.atools.android.cmwrap and
com.atools.netTrafficStats respectively. By an-
alyzing the Lev2 signature, we discover that BCEED is the
common class which is within the two Kungfu applications.
Secondly, from the Lev3 signature of BCEED, we use the
permission recursion method to expose the method 6F100

(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:1)(cid:2)(cid:3)(cid:4)(cid:3)(cid:4)(cid:6)(cid:7)(cid:6)(cid:8)(cid:9)(cid:8)(cid:8)(cid:6)(cid:10)(cid:11)(cid:12)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:3)(cid:4)(cid:5)(cid:6)(cid:5)(cid:7)(cid:6)(cid:8)(cid:9)(cid:6)(cid:10)(cid:11)(cid:12)(cid:8)(cid:5)(cid:6)(cid:2)(cid:9)(cid:10)(cid:4)(cid:11)(cid:2)(cid:13)(cid:5)(cid:14)(cid:6)(cid:15)(cid:16)(cid:17)(cid:18)(cid:19)(cid:15)(cid:20)(cid:20)(cid:14)(cid:21)(cid:15)(cid:22)(cid:17)(cid:23)(cid:11)(cid:24)(cid:25)(cid:22)(cid:14)(cid:22)(cid:26)(cid:26)(cid:11)(cid:26)(cid:19)(cid:18)(cid:20)(cid:27)(cid:22)(cid:22)(cid:28)(cid:6)(cid:29)(cid:30)(cid:12)(cid:4)(cid:13)(cid:14)(cid:4)(cid:15)(cid:2)(cid:13)(cid:5)(cid:14)(cid:31)(cid:7)(cid:28)(cid:7)(cid:32)(cid:15)(cid:31)(cid:31)(cid:22)(cid:33)(cid:28)(cid:7)(cid:32)(cid:14)(cid:8)(cid:3)(cid:29)(cid:4)(cid:16)(cid:5)(cid:17)(cid:9)(cid:18)(cid:19)(cid:14)(cid:9)(cid:20)(cid:2)(cid:21)(cid:7)(cid:5)(cid:22)(cid:17)(cid:13)(cid:5)(cid:19)(cid:28)(cid:26)(cid:18)(cid:23)(cid:24)(cid:11)(cid:5)(cid:3)(cid:9)(cid:25)(cid:5)(cid:11)(cid:2)(cid:13)(cid:5)(cid:19)(cid:25)(cid:24)(cid:19)(cid:34)(cid:25)(cid:23)(cid:34)(cid:19)(cid:19)(cid:5)(cid:19)(cid:24)(cid:13)(cid:21)(cid:25)(cid:13)(cid:24)(cid:23)(cid:12)(cid:2)(cid:21)(cid:11)(cid:5)(cid:7)(cid:7)(cid:5)(cid:22)(cid:17)(cid:7)(cid:26)(cid:27)(cid:28)(cid:29)(cid:30)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:41)(cid:42)(cid:43)(cid:43)(cid:1)(cid:41)(cid:38)(cid:43)(cid:44)(cid:45)(cid:46)(cid:37)(cid:1)(cid:37)(cid:47)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:1)(cid:37)(cid:36)(cid:48)(cid:37)(cid:1)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:49)(cid:47)(cid:41)(cid:45)(cid:50)(cid:43)(cid:48)(cid:37)(cid:41)(cid:51)(cid:1)(cid:49)(cid:1)(cid:37)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:49)(cid:38)(cid:38)(cid:37)(cid:51)(cid:51)(cid:41)(cid:38)(cid:43)(cid:49)(cid:36)(cid:51)(cid:37)(cid:41)(cid:46)(cid:43)(cid:38)(cid:49)(cid:1)(cid:39)(cid:43)(cid:48)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:49)(cid:38)(cid:38)(cid:37)(cid:51)(cid:51)(cid:41)(cid:52)(cid:39)(cid:48)(cid:37)(cid:41)(cid:46)(cid:43)(cid:38)(cid:49)(cid:1)(cid:39)(cid:43)(cid:48)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:1)(cid:37)(cid:36)(cid:48)(cid:37)(cid:1)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:41)(cid:51)(cid:44)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:51)(cid:37)(cid:48)(cid:47)(cid:41)(cid:51)(cid:44)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:51)(cid:1)(cid:49)(cid:46)(cid:46)(cid:41)(cid:45)(cid:49)(cid:38)(cid:53)(cid:49)(cid:54)(cid:37)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:55)(cid:36)(cid:39)(cid:1)(cid:37)(cid:41)(cid:37)(cid:56)(cid:1)(cid:37)(cid:36)(cid:48)(cid:49)(cid:46)(cid:41)(cid:51)(cid:1)(cid:43)(cid:36)(cid:49)(cid:54)(cid:37)(cid:31)(cid:2)(cid:13)(cid:2)(cid:5)(cid:32)(cid:2)(cid:21)(cid:9)(cid:33)(cid:17)(cid:3)(cid:2)(cid:17)(cid:3)(cid:26)(cid:34)(cid:29)(cid:30)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:3)(cid:35)(cid:33)(cid:11)(cid:35)(cid:33)(cid:28)(cid:6)(cid:14)(cid:33)(cid:3)(cid:31)(cid:35)(cid:28)(cid:42)(cid:43)(cid:43)(cid:1)(cid:41)(cid:38)(cid:43)(cid:44)(cid:45)(cid:46)(cid:37)(cid:1)(cid:37)(cid:47)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:3)(cid:35)(cid:33)(cid:11)(cid:35)(cid:33)(cid:28)(cid:6)(cid:14)(cid:33)(cid:3)(cid:31)(cid:35)(cid:28)(cid:51)(cid:39)(cid:54)(cid:41)(cid:51)(cid:1)(cid:36)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:10)(cid:31)(cid:57)(cid:3)(cid:20)(cid:11)(cid:10)(cid:28)(cid:1)(cid:11)(cid:8)(cid:11)(cid:29)(cid:2)(cid:31)(cid:35)(cid:32)(cid:28)(cid:51)(cid:44)(cid:51)(cid:41)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:47)(cid:18)(cid:13)(cid:4)(cid:17)(cid:9)(cid:31)(cid:2)(cid:7)(cid:23)(cid:6)(cid:3)(cid:7)(cid:30)(cid:5)(cid:5)(cid:5)(cid:53)(cid:6)(cid:29)(cid:11)(cid:10)(cid:4)(cid:30)(cid:32)(cid:13)(cid:5)(cid:1)(cid:2)(cid:3)(cid:2)(cid:13)(cid:3)(cid:2)(cid:19)(cid:1)(cid:2)(cid:3)(cid:2)(cid:13)(cid:3)(cid:2)(cid:19)(cid:5)(cid:5)(cid:5)(cid:35)(cid:36)(cid:37)(cid:31)(cid:38)(cid:25)(cid:21)(cid:22)(cid:39)(cid:4)(cid:17)(cid:40)(cid:18)(cid:41)(cid:42)(cid:43)(cid:44)(cid:17)(cid:19)(cid:21)(cid:22)(cid:5)(cid:19)(cid:45)(cid:18)(cid:43)(cid:44)(cid:19)(cid:21)(cid:19)(cid:43)(cid:4)(cid:5)(cid:5)(cid:5)(cid:49)(cid:35)(cid:33)(cid:3)(cid:32)(cid:13)(cid:5)(cid:12)(cid:4)(cid:7)(cid:7)(cid:12)(cid:4)(cid:7)(cid:7)(cid:5)(cid:5)(cid:47)(cid:10)(cid:31)(cid:3)(cid:20)(cid:49)(cid:35)(cid:6)(cid:8)(cid:32)(cid:33)(cid:3)(cid:14)(cid:4)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)(cid:8)(cid:9)(cid:10)(cid:11)(cid:9)(cid:12)(cid:5)(cid:10)(cid:13)(cid:14)(cid:15)(cid:16)(cid:17)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:18)(cid:1)(cid:2)(cid:19)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:2)(cid:5)(cid:14)(cid:2)(cid:11)(cid:10)(cid:7)(cid:15)(cid:16)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:2)(cid:14)(cid:15)(cid:10)(cid:16)(cid:16)(cid:5)(cid:17)(cid:10)(cid:11)(cid:18)(cid:6)(cid:19)(cid:16)(cid:11)(cid:2)(cid:20)(cid:14)(cid:10)(cid:15)(cid:15)(cid:5)(cid:21)(cid:17)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:23)(cid:23)(cid:23)(cid:24)(cid:4)(cid:10)(cid:10)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)(cid:30)(cid:31)(cid:23)(cid:27)(cid:26)(cid:23)(cid:27)(cid:30)(cid:2)(cid:32)(cid:32)(cid:25)(cid:2)(cid:25)(cid:27)(cid:27)(cid:33)(cid:33)(cid:34)(cid:31)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:10)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:37)(cid:34)(cid:33)(cid:32)(cid:23)(cid:34)(cid:30)(cid:24)(cid:25)(cid:24)(cid:4)(cid:4)(cid:34)(cid:29)(cid:32)(cid:28)(cid:33)(cid:28)(cid:32)(cid:34)(cid:4)(cid:30)(cid:31)(cid:33)(cid:37)(cid:25)(cid:37)(cid:32)(cid:10)(cid:28)(cid:37)(cid:33)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:29)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:31)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:39)(cid:40)(cid:41)(cid:42)(cid:43)(cid:40)(cid:42)(cid:41)(cid:30)(cid:33)(cid:31)(cid:31)(cid:32)(cid:31)(cid:26)(cid:29)(cid:25)(cid:10)(cid:25)(cid:30)(cid:30)(cid:23)(cid:25)(cid:26)(cid:24)(cid:34)(cid:31)(cid:33)(cid:28)(cid:25)(cid:31)(cid:2)(cid:34)(cid:37)(cid:4)(cid:37)(cid:2)(cid:29)(cid:29)(cid:37)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:32)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:4)(cid:23)(cid:24)(cid:37)(cid:27)(cid:28)(cid:26)(cid:2)(cid:34)(cid:28)(cid:31)(cid:33)(cid:37)(cid:25)(cid:34)(cid:24)(cid:2)(cid:10)(cid:27)(cid:28)(cid:34)(cid:37)(cid:37)(cid:30)(cid:24)(cid:37)(cid:37)(cid:27)(cid:27)(cid:34)(cid:4)(cid:29)(cid:25)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:6)(cid:20)(cid:16)(cid:43)(cid:2)(cid:32)(cid:2)(cid:7)(cid:3)(cid:2)(cid:13)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:4)(cid:34)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:44)(cid:39)(cid:45)(cid:43)(cid:46)(cid:41)(cid:42)(cid:34)(cid:26)(cid:33)(cid:4)(cid:2)(cid:4)(cid:33)(cid:25)(cid:25)(cid:24)(cid:31)(cid:37)(cid:28)(cid:31)(cid:24)(cid:25)(cid:29)(cid:37)(cid:31)(cid:25)(cid:10)(cid:2)(cid:10)(cid:30)(cid:27)(cid:2)(cid:31)(cid:27)(cid:25)(cid:2)(cid:2)(cid:10)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:41)(cid:46)(cid:40)(cid:14)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:27)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:46)(cid:14)(cid:14)(cid:42)(cid:6)(cid:6)(cid:47)(cid:40)(cid:42)(cid:41)(cid:48)(cid:49)(cid:43)(cid:50)(cid:47)(cid:6)(cid:41)(cid:46)(cid:41)(cid:42)(cid:25)(cid:2)(cid:10)(cid:24)(cid:37)(cid:30)(cid:28)(cid:23)(cid:31)(cid:30)(cid:28)(cid:37)(cid:24)(cid:30)(cid:4)(cid:29)(cid:30)(cid:32)(cid:10)(cid:34)(cid:27)(cid:31)(cid:25)(cid:30)(cid:24)(cid:27)(cid:28)(cid:34)(cid:2)(cid:37)(cid:29)(cid:28)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:23)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:25)(cid:24)(cid:27)(cid:32)(cid:28)(cid:37)(cid:24)(cid:26)(cid:29)(cid:26)(cid:4)(cid:31)(cid:24)(cid:33)(cid:23)(cid:23)(cid:25)(cid:26)(cid:23)(cid:4)(cid:30)(cid:31)(cid:28)(cid:2)(cid:28)(cid:2)(cid:29)(cid:24)(cid:4)(cid:28)(cid:2)(cid:33)(cid:10)(cid:2)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:2)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:31)(cid:26)(cid:37)(cid:23)(cid:10)(cid:37)(cid:25)(cid:32)(cid:32)(cid:32)(cid:24)(cid:33)(cid:2)(cid:29)(cid:2)(cid:27)(cid:4)(cid:25)(cid:29)(cid:37)(cid:29)(cid:34)(cid:10)(cid:33)(cid:24)(cid:2)(cid:27)(cid:26)(cid:32)(cid:34)(cid:27)(cid:31)(cid:4)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:28)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:4)(cid:29)(cid:24)(cid:24)(cid:29)(cid:2)(cid:30)(cid:10)(cid:27)(cid:28)(cid:27)(cid:29)(cid:28)(cid:31)(cid:26)(cid:26)(cid:28)(cid:23)(cid:25)(cid:28)(cid:33)(cid:28)(cid:28)(cid:25)(cid:28)(cid:4)(cid:37)(cid:24)(cid:27)(cid:37)(cid:25)(cid:29)(cid:28)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:8)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:46)(cid:14)(cid:14)(cid:42)(cid:6)(cid:6)(cid:47)(cid:40)(cid:42)(cid:41)(cid:48)(cid:49)(cid:43)(cid:50)(cid:47)(cid:6)(cid:41)(cid:46)(cid:41)(cid:42)(cid:24)(cid:32)(cid:33)(cid:33)(cid:30)(cid:28)(cid:10)(cid:23)(cid:4)(cid:2)(cid:34)(cid:34)(cid:29)(cid:37)(cid:37)(cid:23)(cid:2)(cid:25)(cid:28)(cid:25)(cid:10)(cid:24)(cid:30)(cid:30)(cid:4)(cid:25)(cid:37)(cid:31)(cid:24)(cid:27)(cid:29)(cid:24)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:14)(cid:15)(cid:2)(cid:10)(cid:13)(cid:17)(cid:13)(cid:2)(cid:28)(cid:2)(cid:13)(cid:2)(cid:9)(cid:32)(cid:2)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:26)(cid:33)(cid:23)(cid:27)(cid:24)(cid:24)(cid:4)(cid:29)(cid:32)(cid:24)(cid:23)(cid:34)(cid:26)(cid:26)(cid:31)(cid:27)(cid:31)(cid:31)(cid:32)(cid:33)(cid:26)(cid:25)(cid:28)(cid:29)(cid:24)(cid:37)(cid:4)(cid:4)(cid:32)(cid:32)(cid:2)(cid:32)(cid:30)(cid:26)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:53)(cid:2)(cid:11)(cid:10)(cid:7)(cid:15)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:26)(cid:4)(cid:31)(cid:28)(cid:26)(cid:25)(cid:30)(cid:2)(cid:24)(cid:29)(cid:26)(cid:27)(cid:25)(cid:4)(cid:37)(cid:10)(cid:25)(cid:34)(cid:27)(cid:30)(cid:29)(cid:37)(cid:31)(cid:24)(cid:37)(cid:26)(cid:24)(cid:2)(cid:34)(cid:32)(cid:31)(cid:34)(cid:10)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:14)(cid:22)(cid:9)(cid:9)(cid:2)(cid:32)(cid:11)(cid:7)(cid:22)(cid:9)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:24)(cid:53)(cid:13)(cid:22)(cid:7)(cid:23)(cid:46)(cid:9)(cid:10)(cid:15)(cid:19)(cid:11)(cid:7)(cid:32)(cid:16)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)(cid:8)(cid:9)(cid:10)(cid:11)(cid:9)(cid:12)(cid:5)(cid:10)(cid:13)(cid:14)(cid:15)(cid:16)(cid:17)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:18)(cid:1)(cid:2)(cid:19)Figure 6.

Illustration of Detail Analytics on Malware

with the INSTALL_PACKAGES permission. Note that the
INSTALL_PACKAGES permission is a system permission
which the application can install other unrelated applica-
tions. This shows how DroidAnalytics helps analysts to
quickly discover the malicious code of methods and classes
of the Kungfu family.
(cid:15) Class Association. Traditional analysis on malware only
focuses on one malware but can not associate malware
with other malware or applications. DroidAnalytics can
associate legitimate applications and other malware in the
class level and/or method level. Given a class signature (or
Lev2 signature), DroidAnalytics keeps track of how many
legitimate applications or malware using this particular class.
Also, with the methodology of permission recursion, Droid-
Analytics can indicate the permission usage of this class
signature. By using class association, we can easily deter-
mine which class or method may possess malicious behavior,
and which class is used for common task, say for pushing
advertisement. Lastly, for class signatures which are used
by many known malware but zero legitimate application,
these are classes that analysts need to pay special attention
to because it is very likely that they contain malicious code
and are used in many repackaged or obfuscated malware.
(cid:0) Experiment. Using DroidAnalytics, we carry out the
class association experiment using 1,000 legitimate appliac-
tions and 1,000 malware as reported by Kaspersky. After
the class association, we discover a class (Lev2) signa-
ture 2bcb4f8940f00fb7f50731ee341003df which
is used by 143 malware and zero legitimate application.
the 143 malware are all from the Geinimi
In addition,
family. Furthermore, this class has 47 API calls and uses
READ_CONTACTS and SEND_SMS permissions. Therefore,
we quickly identify this class contains malicious codes. In
the signature database, we also ﬁnd a class (Lev2) signa-
ture 9067f7292650ba0b5c725165111ef04e which
is used by 80 legitimate applications and 42 mal-
ware. Further analysis shows that
this class is used

and this

class uses

an advertisement

by similar number of legitimate applications and mal-
library
ware,
called DOMOB [18]. Another class
signature
a007d9e3754daef90ded300190903451 is used by
105 legitimate applications and 80 malware. Further exami-
nation shows that it is a class from the Google ofﬁcial library
called AdMob [19].

(Lev2)

For detail, all experimented malware samples are pre-
sented in [6], and they represent the known malware in
our database. Readers who are interested in these malware
samples can refer to [6]. The detection results is based on
the cloud anti-virus engine using various detection engines
(i.e., Kaspersky and Antiy(linux version)). Note that in the
last column, R (G) represents repackaged (generic) malware
family. For those malware families with less than ﬁve
samples, we lump them as “others” in the table. Antiy (linux
version) [20] is a commercial anti-virus product that we
obtained from the company, and the product is known to run
the same engine for detecting malware in smartphones. The
rows are sorted in alphabetical order. Highlighted rows show
the common malware families detected by both Kasper-
sky and Antiy. Others are uniquely detected by one anti-
virus product. The penultimate row shows there are 1,295
common malware samples detected by these two anti-virus
products. Hence, the number of unique malware samples is
2,148.

V. Zero-day Malware Detection

Here, we show a novel methodology in using Droid-
Analytics to detect the zero-day repackaged malware. We
analyze three zero-day malware families to illustrate the
effectiveness of our system.

A. Zero-day Malware

Zero-day malware is a new malware that current com-
mercial anti-virus systems cannot detect. Anti-virus software
usually relies on signatures to identify malware. However,

BCEEFCCEEDCCEEF...112BF123AB823ABA12BF...READ_SMS(P1)SEND_SMS(P2)INTERNET(P3)SET_WALLPAPER(P4)READ_CONTACTS(P6)READ_SMS(P1)P1, P2, P5P3, P4P1, P6P1P1, P2, P3, P4, P5P1, P6P1, P2, P5, P6P1, P2P3, P4P6P16F100INSTALL_PACKAGES(P5)P57DCF1No permissionNo permissionA4E39DBEDIE3D2EF8ABCEEDLev1 signature(Applications)Lev2 signature(Classes)Lev3 signature(Methods)PermissionREAD_SMS(P1)SEND_SMS(P2)INTERNET(P3)SET_WALLPAPER(P4)INSTALL_PACKAGES(P5)DroidAnalytics: A Signature Based Analytic System to Collect, Extract, Analyze and

Associate Android Malware

Min Zheng, Mingshen Sun, John C.S. Lui

Computer Science & Engineering Department

The Chinese University of Hong Kong

Abstract—Smartphones and mobile devices are rapidly be-
coming indispensable devices for many users. Unfortunately,
they also become fertile grounds for hackers to deploy mal-
ware. There is an urgent need to have a “security analytic
& forensic system” which can facilitate analysts to examine,
dissect, associate and correlate large number of mobile ap-
plications. An effective analytic system needs to address the
following questions: How to automatically collect and manage
a high volume of mobile malware? How to analyze a zero-
day suspicious application, and compare or associate it with
existing malware families in the database? How to reveal similar
malicious logic in various malware, and to quickly identify the
new malicious code segment? In this paper, we present the
design and implementation of DroidAnalytics, a signature based
analytic system to automatically collect, manage, analyze and
extract android malware. The system facilitates analysts to
retrieve, associate and reveal malicious logics at the “opcode
level”. We demonstrate the efﬁcacy of DroidAnalytics using
150,368 Android applications, and successfully determine 2,494
Android malware from 102 different families, with 342 of them
being zero-day malware samples from six different families. To
the best of our knowledge, this is the ﬁrst reported case in
showing such a large Android malware analysis/detection. The
evaluation shows the DroidAnalytics is a valuable tool and is
effective in analyzing malware repackaging and mutations.

I. Introduction

Smartphones are becoming prevailing devices for many
people. Unfortunately, malware on smartphones is also in-
creasing at an unprecedented rate. Android OS-based sys-
tems, being the most popular platform for mobile devices,
have been a popular target for malware developers. As stated
in [1], the exponential growth of mobile malware is mainly
due to the ease of generating malware variants. Although
there are number of works which focus on Android malware
detection via permission leakage, it is equally important to
design a system that can perform comprehensive malware
analytics: analyze and dissect suspicious applications at the
opcode level (instead at the permission level), and correlate
the application with existing malware in the database to de-
termine whether it is mutated malware or zero-day malware,
as well as which legitimate applications are infected.
Challenges: To realize an effective analytic system for
Android mobile applications, we need to overcome several
technical hurdles. First, how to systematically collect mal-
ware from the wild. As indicated in [2], new malware vari-
ants are always hidden in many different third-party markets.

Due to the competition of anti-virus companies and their fear
of accidentally releasing malware to the public, companies
are usually reluctant to share their malware database to
researchers. Researchers can only obtain a handful of mobile
malware samples. Hence, how to automate a systematic
process to collect these malicious applications is the ﬁrst
hurdle we need to overcome.

The second hurdle is how to identify repackaged ap-
plications (or mutated malware) from the vast ocean of
applications and malware. As reported in [3], hackers can
easily transform legitimate applications by injecting mali-
cious logic or obfuscated program segments so that they have
the same structure as the original application but contain ma-
licious logic. Thus, how to determine whether an application
is a repackaged or obfuscated malware, and which legitimate
applications are infected is very challenging.

The third hurdle is how to associate a malware with
existing malware (or application) so as to facilitate security
analysis. The existing approach of using cryptographic hash
or package name as an identiﬁer is not effective because
hackers can easily change the hash value or package name.
Security analysts often need to go through a laborous process
of reverse engineering to discover malicious functions and
structure. There is an urgent need to have an efﬁcient method
to associate malware with other malware in the database, so
to examine their commonalities at the opcode level.
Contributions: We present the design and implementation
of DroidAnalytics, an Andorid malware analytic system
for malware collection, signature generation, information
retrieval, and malware association based on similarity score.
Furthermore, DroidAnalytic can efﬁciently detect zero-day
repackaged malware. The contributions of our system are:
(cid:15) DroidAnalytics automates the processes of malware
collection, analysis and management. We have suc-
cessfully collected 150,368 Android applications, and
determined 2,494 malware samples from 102 families.
Among those, there are 342 zero-day malware samples
from six different malware families. We plan to release
the malware database to the research community. (for
our malware database, please refer to http://ansrlab.cse.
cuhk.edu.hk/software/droidanalytics).

(cid:15) DroidAnalytics uses a multi-level signature algorithm
to extract the malware feature based on their semantic

meaning at the opcode level. This is far more robust
than a cryptographic hash of the entire application.
We show how to use DroidAnalytics to combat against
malware which uses repackaging or code obfuscation,
as well as how to analyze malware with dynamic
payloads (see Sec. III).

(cid:15) Unlike previous works which associate malware via
“permission”, DroidAnalytics associates malware and
generates signatures at
the app/class/method level.
Hence, we can easily track and analyze mutation,
derivatives, and new generation of a malware. Droid-
Analytics can reveal malicious behavior at the method
level to identify repackaged malware, and perform class
association among malware/applications (see Sec. IV).
(cid:15) One can use DroidAnalytics to detect zero-day repack-
aged malware. We have found 342 zero-day repackaged
malware in six different families (see Sec. V).
II. Design & Implementation of DroidAnalytics

AndroidAnalytics consists of modules for automatic mal-
ware collection, signature generation, information retrieval
and association, as well as similarity comparison between
malware. One can also use these functions to detect zero-
day repackaged malware.

Figure 1. The Architecture of the DroidAnalytics

A. Building Blocks of DroidAnalytics

Figure 1 depicts the architecture of DroidAnalytics and its
components. Let us explain the design of each component.
(cid:15) Extensible Crawler: In DroidAnalytics, we implement an
application crawler based on Scrapy [4]. Users can specify
ofﬁcial or third party market places, as well as blog sites
and the crawler will perform regular mobile application
download. The crawler enables us to systematically build
up the mobile applications database for malware analysis
and association. So far, we have collected 150,368 mobile
applications and carried out detailed security analysis.
(cid:15) Dynamic Payloads Detector: To deal with malware which
dynamically downloads malicious codes via the Internet or
attachment ﬁles, we have implemented the dynamic payloads
detector component, which determines malicious trigger
code within malware packages and tracks the downloaded

application and its behavior in virtual machine. Firstly, it
scans the package to ﬁnd suspicious ﬁles such as .elf or
.jar ﬁle. Hackers usually camouﬂage malicious ﬁles by
changing their ﬁle type. To overcome this, this component
scans all ﬁles and identiﬁes ﬁles using their magic numbers
instead of ﬁle extension. Secondly, if an application has any
Internet behavior (e.g., Internet permission or re-delegating
other applications to download ﬁles [5]), the dynamic pay-
loads detector will treat these ﬁles as the target, then runs the
application in the emulator. The system will use the forward
symbolic execution technique to trigger the download behav-
ior. For detail, please refer to [6]. Both the suspicious ﬁles
within the package and dynamically downloaded ﬁles from
the Internet will be sent to the signature generator (which
we will shortly describe) for further analysis.
(cid:15) Android App Information (AIS) Parser: AIS is a
data structure within DroidAnalytics and it is used to rep-
resent .apk information structure. Using the AIS parser,
analysts can reveal the cryptographic hash (or other ba-
sic signature) of an .apk ﬁle,
its package name, per-
mission information, broadcast receiver information and
disassembled code, : : :, etc. Our AIS parser decrypts the
AndroidManifest.xml within an application and dis-
assembles the .dex ﬁle into .smali code. Then it extracts
package information from source code and retains it in AIS
so analysts can easily retrieve this information.
(cid:15) Signature Generator: Anti-virus companies usually use
cryptographic hash, e.g., MD5,
to generate a signature
for an application. This has two major drawbacks. Firstly,
hackers can easily mutate an application and change its
cryptographic hash. Secondly, the cryptographic hash does
not provide sufﬁcient ﬂexibility for security analysis. In
DroidAnalytics, we use a three-level signature generation
scheme to identify each application. This signature scheme
is based on the mobile application, classes, methods, as
well as malware’s dynamic payloads (if any). Our signature
generation is based on the following observation: For any
functional application, it needs to invoke various Android
API calls, and Android API calls sequence within a method
is difﬁcult to modify (unless one drastically changes the
program’s logic, but we did not ﬁnd any from the 150,368
applications we collected that used this obfuscation tech-
nique). Hence, we generate a method’s signature using the
API call sequence, and given the signature of a method,
create the signature of a class which composes of different
methods. Finally, the signature of an application is composed
of all signatures of its classes. We like to emphasize that
our signature algorithm is not only for defense against mal-
ware obfuscation, but more importantly, facilitating malware
analysis via class/method association (we will show in later
sections). Let us present the detail of signature generation.
(a) Android API calls table: Our system uses the API
calls table of the Android SDK. The android.jar ﬁle is
the framework package provided by the Android SDK. We

3 Level SignaturesApplication RepositoryCloud Apk ScannerAppMalware ReportSignature GeneratorAnalyzerAnalysis EnginesAIS Parserwww.appsapk.comwww.souapp.com...CrawlerDynamic Payloads DetectorEmulatorsuse the Java reﬂection [7] to obtain all descriptions of the
API calls. For each API, we extract both the class path
and the method name. We assign each full path method
a hex number as part of the ID. For the current version
of DroidAnalytics, we extract 47,126 full path methods
in the Android SDK 4.1 version as our API calls ta-
ble. Table I depicts a snapshot of API calls table, e.g.,
android/content/Intent;-><init> is assigned
an ID 0x30291.

Full Path Method

android/accounts/Account;-><init>

:

android/content/Intent;-><init>
android/content/Intent;->toUri
android/telephony/SmsManager;->getDefault
android/app/PendingIntent;->getBroadcast

Method ID
0x00001

:

0x30291
0x30292
0x39D53
0xF3E91

EXAMPLE OF THE ANDROID API CALLS TABLE AND ASSIGNED IDS

Table I

(b) Disassembling process: Each Android application is
composed of different classes and each class is composed
of different methods. To generate signatures for each class
or method, DroidAnalytics ﬁrst disassembles an .apk ﬁle,
then takes the Dalvik opcodes of the .dex ﬁle and trans-
forms them to methods and classes. Then DroidAnalytics
uses the Android API calls table to generate signatures.
(c) Generate Lev3 signature (or method signature): The
system ﬁrst generates a signature for each method and we
call this the Lev3 signature. Based on the Android API calls
table, the system extracts the API call ID sequence as a string
in each method, then hashes this string value to produce the
method’s signature. Figure 2 illustrates how to generate the
Lev3 signature of a method which sends messages to another
mobile phone. Figure 2 shows that the method contains
three API calls. Using the Android API calls table (as in
Table I), we determine their IDs. Signature of a method
is generated by cancatenation of all these IDs. Note that
DroidAnalytics will not extract the API calls which will not
be executed in run time because these codes are usually
generated via obfuscation. Furthermore, if a method (except
the main method) will not be invoked by any other methods,
signature generator will also ignore this method because this
may be a defunct method generated by malware writers.
(d) Generate Lev2 signature (either class signature or
dynamic payload signature): Next, DroidAnalytics pro-
ceeds to generate the Lev2 signature for each class, and it is
based on the Lev3 signatures of methods within that class.
Malware writers may use various obfuscation or repackaging
techniques to change the calling order of the methods table
in a .dex ﬁle. To overcome this problem, our signature
generation algorithm will ﬁrst sort the level 3 signatures
within that class, and then concatenate all these level 3
signatures to form the level 2 signature.

Some malicious codes are dynamically downloaded from

Figure 2. The Process of Lev3 Signature Generation

the Internet during execution. DroidAnalytics uses the dy-
namic payloads detector component to obtain the payload
ﬁles. For the dynamic payloads which are .dex ﬁle or
.jar ﬁle, DroidAnalytics treats them as classes within
the malware. Given these ﬁles,
the system checks their
API call sequence and generates a Lev2 signature for each
class within an application. For the dynamic payloads which
contain, say, .elf ﬁle or .so ﬁle, DroidAnalytics treats
them as a single class within that malware, then uses the
cryptographic hash value (e.g., MD5) of the payload as its
Lev2 signature. For the dynamic payloads which are .apk
ﬁles, DroidAnalytics treats each as a new application and
a class within the malware. DroidAnalytics ﬁrst uses the
cryptographic hash value (e.g., MD5) of the new .apk ﬁle
as one Lev2 signature of that malware. Because the payload
is a new application, DroidAnalytics will use the method we
discussed to carry out a new signature generation.
(e) Generate Lev1 signature (or application signature):
The Lev1 signature is based on the level 2 signatures, e.g.,
signatures of all qualiﬁed classes within an application. In
addition, the signature generator will ignore the class (except
the main class) which will not be invoked by any other
classes since these defunct classes may be generated via
obfuscation. Malware writers may use some repackaging or
obfuscation techniques to change the order of the classes
table of the .dex ﬁle, our signature algorithm will ﬁrst sort
all Lev2 signatures, then concatenate these Lev2 signatures
to generate the Lev1 signature.

Figure 3 summarizes the signature genration framework.
For example, the Lev3 signatures of AAAE1 and B23E8 are
the two method signatures within the same class. Based on
these two (sorted) signatures, we generate the Lev2 signature
of the corresponding class, which is 53EB3. Note that the
Lev2 signature of C3EB3 is generated from a .dex ﬁle
which is a dynamic payload used to execute the malicious
behavior. Based on all sorted Lev2 signatures of all classes,
we generate the Lev1 signature, F32DE, of the application.

const/4v2,0x0new-instancev3,Landroid/content/Intent;const-stringv5,"SENT"invoke-direct{v3,v5},Landroid/content/Intent;-><init>(Ljava/lang/String;)Vconst/4v5,0x0invoke-static{v1,v2,v3,v5},Landroid/app/PendingIntent;->getBroadcast\(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;move-result-objectv4.localv4,pi:Landroid/app/PendingIntent;invoke-static{},Landroid/telephony/SmsManager;->getDefault()\Landroid/telephony/SmsManager;move-result-objectv0android/content/Intent;-><init>()android/app/PendingIntent;->getBroadcast()android/telephony/SmsManager;->getDefault()->0x30291->0xF3E91->0x39D530x302910xF3E910x39D53MethodSign:AAAE1APICallsTableAPICallsIDSequenceStringmalware from three different families (10 samples in each
family) and Table II illustrates our results. The malware
families in our study are: Basebrid (or Basebridge), Gold-
Dream, and Kungfu. We use ADAM [16], a system which
can automatically transform an original malware sample
to different variants by various repackaging and obfusca-
tion techniques (e.g. inserting defunct methods, modifying
methods name, ...etc). We generate seven different variants
for each malware. Then we put these 240 new malware
samples into the DroidAnalytics system and check their
signatures. After our signature calculations, the result shows
that for each malware, the original sample and seven mutated
variants have distinct MD5 hash values (3 repackaging, 4
code obfuscation), but all of them have the same level 1
signature. This shows that DroidAnalytics’ signature system
is effective in defending against code obfuscation.
B. Analyzing Malware with Attachement Files or Dy-
namic Payloads: Some malware will dynamically download
ﬁle which contains the malicious code. Also, some attach-
ment ﬁles within a package may contain malicious logic
but they can be concealed as other valid documents (e.g.,
.png ﬁle, .wma ﬁle). DroidAnalytics will treat these ﬁles
as dynamic payloads. By using static and dynamic analysis
techniques described in Section II, DroidAnalytics accesses
these payloads and generates different signatures.
Experiment. We carried out the following experiment. From
our malware database, we used our signature system and
detected some malware contain the same ﬁle with a .png
ﬁlename extension. But when we check the magic number of
this ﬁle, it is actually an .elf ﬁle. Upon further analysis,
we found that this ﬁle is a root exploit and this malware
belongs to the GinMaster (or GingerMaster) family. An-
other example is the Plankton family. By using dynamic
analysis, DroidAnalytics discovered that all malware in
this family will download a plankton_v0.0.4.jar (or
similar .jar) when the main activity of the application
starts. Further analysis revealed the .jar ﬁle contains ma-
licious behavior, i.e., stealing browser’s history information,
making screen shortcuts and botnet logic. Table III depicts
DroidAnalytics system detects some representative malware
using dynamic payloads.

MD5
34cb03276e426f8d61e782b8435d3147
a24d2ae57c3cee1cf3298c856a917100

9e847c9a27dc9898825f466ea00dac81

dcbe11e5f3b82ce891b793ea40e4975e

Dynamic Payload
/assets/runme.png
/assets/gbfm.png
/assets/install.png
/assets/installsoft.png
/assets/runme.png
/assets/gbfa.png
/assets/install.png
plankton v0.0.4.jar

Description
ELF ﬁle to expoit root
ELF ﬁle to expoit root

Malware Family
GinMaster
GinMaster

ELF ﬁle to expoit root

GinMaster

download in runtime

Plankton

Table III

EXAMPLES OF DYNAMIC PAYLOADS

We also carried out experiment to analyze repackaged

malware. For detail, please refer to [6].

Figure 3.
Illustration of signature generation: the application (Lev1)
signature, class level (Lev2) signatures and method level (Lev3) signatures.

For the current DroidAnalytics platform, we use a server
which is of 2.80 GHz Duo CPU processor, 4GB memory and
2 TB hard disk, with two virtual machines in the server to
implement the anti-virus engine. We carried out experiment
to study the processing time to scanning and generating
signatures. On average, it takes around 60 seconds to scan
one application (includes the dynamic analysis), and around
three seconds to generate all three level signatures, ﬁve
seconds to generate AIS information, and one second to
insert information into the database. As of November 2012,
our system have downloaded 150,368 mobile applications
from the following places: Google Play [8], nine Android
third party markets (e.g., [9]–[11]), two malware forums
[12], [13] and one mobile malware share blog [2]. The size
of all downloaded application is 468GB.
III. Utility & Effectiveness of Signature Based System
Here, we illustrate how DroidAnalytics’ signatures can
be used to analyze (and detect) malware repackaging, code
obfuscation and malware with dynamic payloads.
A. Analyzing Malware which uses Code Obfuscation: A
malware writer can use a disassembler (e.g., Apktool [14])
to convert a .dex ﬁle into .smali ﬁles, then injects new
malware logic into the .smali code, rebuilds it back to a
.dex ﬁle. Based on this, malware writers can apply various
code obfuscation techniques while preserve the behavior as
the original one in order to bypass the anti-virus detection.
As shown in [3], [15], many mobile anti-virus products are
not effective to detect code obfuscated variants.

DroidAnalytics will not extract the API calls in methods
and classes which will not be executed in run time (refer to
Sec. II) because they are defunct and can be generated by
obfuscators. In addition, our signature generation does not
depend on the name of methods or classes and so name
obfuscation has no effect on our signature. Furthermore,
the signature generation of DroidAnalytics is based on the
analyst-deﬁned API calls table. So one can ﬂexibly update
the table to defend against various code obfuscation.
Experiment. To illustrate the effectiveness of DroidAn-
alytics against code obfuscation, we chose 30 different

F32DE53EB393DE1B103CAAAE1B23E83A4EBAABEFADA13Lev1Lev2Lev3......C3EB3dex, jar, elfmethods, classes signaturesdynamic payload signatures......sortedsortedsortedsortedMD5
f7967f71b2f32287660ae9a3fa366022
f2e2d727f95fa868fd7ff54459e766e3
e01f573cca83fdf2737be6ecee35fe33
d383ceeb9c6ffcff8c0dd12b73ec43e3
cd040541693693faca9fec646e12e7e6
401952d745cd7ca5281a7f08d3e2eede
271c3965c7822ebf944feb8bbd1cfe7f
8b12ccdc8a69cf2d6a7e6c00f698aaaa

Pakage Name
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup

Lev1 Signature
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd

Malware Family
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu

Description
Original malware
Repackaging
Repackaging
Repackaging
Obfuscation
Obfuscation
Obfuscation
Obfuscation

Table II

EXAMPLES OF CODE OBFUSCATION

IV. Analytic Capability of DroidAnalytics

We conduct three experiments and show how analysts can
study malware, carry out similarity measurement between
applications, as well as perform class association among
150,368 mobile applications in the database.
A. Detailed Analysis on Malware: Using DroidAnalytics,
analysts can also discover which class or method uses
suspicious API calls via the permission recursion technique.
(cid:15) Common Analytics on Malware. First, using the AIS
parser, DroidAnalytics can reveal basic information of an
application like the cryptographic hash (i.e., MD5 value),
package name, broadcast receiver, : : :, etc. This is illustrated
in Figure 4. In addition, DroidAnalytics has a built-in cloud-
based APK scanner that supports diverse anti-virus scan
results (e.g., Kaspersky and Antiy) to help analysts for
reference. Our cloud-based APK scanner is extensible to
accommodate other anti-virus scan engines. Last but not
least, DroidAnalytics can disassemble the .dex ﬁle and
extract class number, method number, and API calls number
in each application, class or method. These functionalities
are useful so analysts can zoom in to the meta-information of
a suspicious malware. Figure 5 shows these functionalities.

Figure 4. Screen Capture of Common Analytics on Malware

(cid:15) Permission Recursion. Current state-of-the-art systems
examine the AndroidManifest.xml to discover per-
missions of an application. This is not informative enough

Figure 5. Screen Capture of Detailed Lev2 Signature

since analysts do not know which class or which method
uses these permissions for suspicious activities. In Droid-
Analytics, we can discover the permission within a class
or a method. Since each permission is related to some API
calls [17]. In DroidAnalytics, we tag permission to API calls
in each method. We combine the method permissions within
the same class as class permission, and combine all class
permissions as application permission. This helps analysts
to quickly discover suspicious methods or classes.
(cid:0) Experiment. In this experiment, we choose a popular
malware family Kungfu and examine the permissions at
the application/class/method levels. Malware in the Kungfu
family can obtain user’s information such as IMEI number,
phone model,..., etc. It can also exploit
the device and
gain root privilege access. Once the malware obtained the
root level access, it installs malicious application in the
background as a back-door service.

We use DroidAnalytics to generate all three-level sig-
natures. Figure 6 shows the partial structure of the sig-
natures with permission recursion of two Kungfu mal-
ware: A4E39D and D2EF8A, and together with a le-
gitimate application BEDIE3 (Lev1 signature). Firstly,
based on the malware reports by our cloud APK scan-
ner, we identify A4E39D and D2EF8A are malware
which come from the Kungfu family with different
package names, net.atools.android.cmwrap and
com.atools.netTrafficStats respectively. By an-
alyzing the Lev2 signature, we discover that BCEED is the
common class which is within the two Kungfu applications.
Secondly, from the Lev3 signature of BCEED, we use the
permission recursion method to expose the method 6F100

(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:1)(cid:2)(cid:3)(cid:4)(cid:3)(cid:4)(cid:6)(cid:7)(cid:6)(cid:8)(cid:9)(cid:8)(cid:8)(cid:6)(cid:10)(cid:11)(cid:12)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:3)(cid:4)(cid:5)(cid:6)(cid:5)(cid:7)(cid:6)(cid:8)(cid:9)(cid:6)(cid:10)(cid:11)(cid:12)(cid:8)(cid:5)(cid:6)(cid:2)(cid:9)(cid:10)(cid:4)(cid:11)(cid:2)(cid:13)(cid:5)(cid:14)(cid:6)(cid:15)(cid:16)(cid:17)(cid:18)(cid:19)(cid:15)(cid:20)(cid:20)(cid:14)(cid:21)(cid:15)(cid:22)(cid:17)(cid:23)(cid:11)(cid:24)(cid:25)(cid:22)(cid:14)(cid:22)(cid:26)(cid:26)(cid:11)(cid:26)(cid:19)(cid:18)(cid:20)(cid:27)(cid:22)(cid:22)(cid:28)(cid:6)(cid:29)(cid:30)(cid:12)(cid:4)(cid:13)(cid:14)(cid:4)(cid:15)(cid:2)(cid:13)(cid:5)(cid:14)(cid:31)(cid:7)(cid:28)(cid:7)(cid:32)(cid:15)(cid:31)(cid:31)(cid:22)(cid:33)(cid:28)(cid:7)(cid:32)(cid:14)(cid:8)(cid:3)(cid:29)(cid:4)(cid:16)(cid:5)(cid:17)(cid:9)(cid:18)(cid:19)(cid:14)(cid:9)(cid:20)(cid:2)(cid:21)(cid:7)(cid:5)(cid:22)(cid:17)(cid:13)(cid:5)(cid:19)(cid:28)(cid:26)(cid:18)(cid:23)(cid:24)(cid:11)(cid:5)(cid:3)(cid:9)(cid:25)(cid:5)(cid:11)(cid:2)(cid:13)(cid:5)(cid:19)(cid:25)(cid:24)(cid:19)(cid:34)(cid:25)(cid:23)(cid:34)(cid:19)(cid:19)(cid:5)(cid:19)(cid:24)(cid:13)(cid:21)(cid:25)(cid:13)(cid:24)(cid:23)(cid:12)(cid:2)(cid:21)(cid:11)(cid:5)(cid:7)(cid:7)(cid:5)(cid:22)(cid:17)(cid:7)(cid:26)(cid:27)(cid:28)(cid:29)(cid:30)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:41)(cid:42)(cid:43)(cid:43)(cid:1)(cid:41)(cid:38)(cid:43)(cid:44)(cid:45)(cid:46)(cid:37)(cid:1)(cid:37)(cid:47)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:1)(cid:37)(cid:36)(cid:48)(cid:37)(cid:1)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:49)(cid:47)(cid:41)(cid:45)(cid:50)(cid:43)(cid:48)(cid:37)(cid:41)(cid:51)(cid:1)(cid:49)(cid:1)(cid:37)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:49)(cid:38)(cid:38)(cid:37)(cid:51)(cid:51)(cid:41)(cid:38)(cid:43)(cid:49)(cid:36)(cid:51)(cid:37)(cid:41)(cid:46)(cid:43)(cid:38)(cid:49)(cid:1)(cid:39)(cid:43)(cid:48)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:49)(cid:38)(cid:38)(cid:37)(cid:51)(cid:51)(cid:41)(cid:52)(cid:39)(cid:48)(cid:37)(cid:41)(cid:46)(cid:43)(cid:38)(cid:49)(cid:1)(cid:39)(cid:43)(cid:48)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:1)(cid:37)(cid:36)(cid:48)(cid:37)(cid:1)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:41)(cid:51)(cid:44)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:51)(cid:37)(cid:48)(cid:47)(cid:41)(cid:51)(cid:44)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:51)(cid:1)(cid:49)(cid:46)(cid:46)(cid:41)(cid:45)(cid:49)(cid:38)(cid:53)(cid:49)(cid:54)(cid:37)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:55)(cid:36)(cid:39)(cid:1)(cid:37)(cid:41)(cid:37)(cid:56)(cid:1)(cid:37)(cid:36)(cid:48)(cid:49)(cid:46)(cid:41)(cid:51)(cid:1)(cid:43)(cid:36)(cid:49)(cid:54)(cid:37)(cid:31)(cid:2)(cid:13)(cid:2)(cid:5)(cid:32)(cid:2)(cid:21)(cid:9)(cid:33)(cid:17)(cid:3)(cid:2)(cid:17)(cid:3)(cid:26)(cid:34)(cid:29)(cid:30)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:3)(cid:35)(cid:33)(cid:11)(cid:35)(cid:33)(cid:28)(cid:6)(cid:14)(cid:33)(cid:3)(cid:31)(cid:35)(cid:28)(cid:42)(cid:43)(cid:43)(cid:1)(cid:41)(cid:38)(cid:43)(cid:44)(cid:45)(cid:46)(cid:37)(cid:1)(cid:37)(cid:47)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:3)(cid:35)(cid:33)(cid:11)(cid:35)(cid:33)(cid:28)(cid:6)(cid:14)(cid:33)(cid:3)(cid:31)(cid:35)(cid:28)(cid:51)(cid:39)(cid:54)(cid:41)(cid:51)(cid:1)(cid:36)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:10)(cid:31)(cid:57)(cid:3)(cid:20)(cid:11)(cid:10)(cid:28)(cid:1)(cid:11)(cid:8)(cid:11)(cid:29)(cid:2)(cid:31)(cid:35)(cid:32)(cid:28)(cid:51)(cid:44)(cid:51)(cid:41)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:47)(cid:18)(cid:13)(cid:4)(cid:17)(cid:9)(cid:31)(cid:2)(cid:7)(cid:23)(cid:6)(cid:3)(cid:7)(cid:30)(cid:5)(cid:5)(cid:5)(cid:53)(cid:6)(cid:29)(cid:11)(cid:10)(cid:4)(cid:30)(cid:32)(cid:13)(cid:5)(cid:1)(cid:2)(cid:3)(cid:2)(cid:13)(cid:3)(cid:2)(cid:19)(cid:1)(cid:2)(cid:3)(cid:2)(cid:13)(cid:3)(cid:2)(cid:19)(cid:5)(cid:5)(cid:5)(cid:35)(cid:36)(cid:37)(cid:31)(cid:38)(cid:25)(cid:21)(cid:22)(cid:39)(cid:4)(cid:17)(cid:40)(cid:18)(cid:41)(cid:42)(cid:43)(cid:44)(cid:17)(cid:19)(cid:21)(cid:22)(cid:5)(cid:19)(cid:45)(cid:18)(cid:43)(cid:44)(cid:19)(cid:21)(cid:19)(cid:43)(cid:4)(cid:5)(cid:5)(cid:5)(cid:49)(cid:35)(cid:33)(cid:3)(cid:32)(cid:13)(cid:5)(cid:12)(cid:4)(cid:7)(cid:7)(cid:12)(cid:4)(cid:7)(cid:7)(cid:5)(cid:5)(cid:47)(cid:10)(cid:31)(cid:3)(cid:20)(cid:49)(cid:35)(cid:6)(cid:8)(cid:32)(cid:33)(cid:3)(cid:14)(cid:4)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)(cid:8)(cid:9)(cid:10)(cid:11)(cid:9)(cid:12)(cid:5)(cid:10)(cid:13)(cid:14)(cid:15)(cid:16)(cid:17)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:18)(cid:1)(cid:2)(cid:19)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:2)(cid:5)(cid:14)(cid:2)(cid:11)(cid:10)(cid:7)(cid:15)(cid:16)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:2)(cid:14)(cid:15)(cid:10)(cid:16)(cid:16)(cid:5)(cid:17)(cid:10)(cid:11)(cid:18)(cid:6)(cid:19)(cid:16)(cid:11)(cid:2)(cid:20)(cid:14)(cid:10)(cid:15)(cid:15)(cid:5)(cid:21)(cid:17)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:23)(cid:23)(cid:23)(cid:24)(cid:4)(cid:10)(cid:10)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)(cid:30)(cid:31)(cid:23)(cid:27)(cid:26)(cid:23)(cid:27)(cid:30)(cid:2)(cid:32)(cid:32)(cid:25)(cid:2)(cid:25)(cid:27)(cid:27)(cid:33)(cid:33)(cid:34)(cid:31)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:10)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:37)(cid:34)(cid:33)(cid:32)(cid:23)(cid:34)(cid:30)(cid:24)(cid:25)(cid:24)(cid:4)(cid:4)(cid:34)(cid:29)(cid:32)(cid:28)(cid:33)(cid:28)(cid:32)(cid:34)(cid:4)(cid:30)(cid:31)(cid:33)(cid:37)(cid:25)(cid:37)(cid:32)(cid:10)(cid:28)(cid:37)(cid:33)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:29)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:31)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:39)(cid:40)(cid:41)(cid:42)(cid:43)(cid:40)(cid:42)(cid:41)(cid:30)(cid:33)(cid:31)(cid:31)(cid:32)(cid:31)(cid:26)(cid:29)(cid:25)(cid:10)(cid:25)(cid:30)(cid:30)(cid:23)(cid:25)(cid:26)(cid:24)(cid:34)(cid:31)(cid:33)(cid:28)(cid:25)(cid:31)(cid:2)(cid:34)(cid:37)(cid:4)(cid:37)(cid:2)(cid:29)(cid:29)(cid:37)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:32)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:4)(cid:23)(cid:24)(cid:37)(cid:27)(cid:28)(cid:26)(cid:2)(cid:34)(cid:28)(cid:31)(cid:33)(cid:37)(cid:25)(cid:34)(cid:24)(cid:2)(cid:10)(cid:27)(cid:28)(cid:34)(cid:37)(cid:37)(cid:30)(cid:24)(cid:37)(cid:37)(cid:27)(cid:27)(cid:34)(cid:4)(cid:29)(cid:25)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:6)(cid:20)(cid:16)(cid:43)(cid:2)(cid:32)(cid:2)(cid:7)(cid:3)(cid:2)(cid:13)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:4)(cid:34)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:44)(cid:39)(cid:45)(cid:43)(cid:46)(cid:41)(cid:42)(cid:34)(cid:26)(cid:33)(cid:4)(cid:2)(cid:4)(cid:33)(cid:25)(cid:25)(cid:24)(cid:31)(cid:37)(cid:28)(cid:31)(cid:24)(cid:25)(cid:29)(cid:37)(cid:31)(cid:25)(cid:10)(cid:2)(cid:10)(cid:30)(cid:27)(cid:2)(cid:31)(cid:27)(cid:25)(cid:2)(cid:2)(cid:10)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:41)(cid:46)(cid:40)(cid:14)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:27)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:46)(cid:14)(cid:14)(cid:42)(cid:6)(cid:6)(cid:47)(cid:40)(cid:42)(cid:41)(cid:48)(cid:49)(cid:43)(cid:50)(cid:47)(cid:6)(cid:41)(cid:46)(cid:41)(cid:42)(cid:25)(cid:2)(cid:10)(cid:24)(cid:37)(cid:30)(cid:28)(cid:23)(cid:31)(cid:30)(cid:28)(cid:37)(cid:24)(cid:30)(cid:4)(cid:29)(cid:30)(cid:32)(cid:10)(cid:34)(cid:27)(cid:31)(cid:25)(cid:30)(cid:24)(cid:27)(cid:28)(cid:34)(cid:2)(cid:37)(cid:29)(cid:28)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:23)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:25)(cid:24)(cid:27)(cid:32)(cid:28)(cid:37)(cid:24)(cid:26)(cid:29)(cid:26)(cid:4)(cid:31)(cid:24)(cid:33)(cid:23)(cid:23)(cid:25)(cid:26)(cid:23)(cid:4)(cid:30)(cid:31)(cid:28)(cid:2)(cid:28)(cid:2)(cid:29)(cid:24)(cid:4)(cid:28)(cid:2)(cid:33)(cid:10)(cid:2)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:2)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:31)(cid:26)(cid:37)(cid:23)(cid:10)(cid:37)(cid:25)(cid:32)(cid:32)(cid:32)(cid:24)(cid:33)(cid:2)(cid:29)(cid:2)(cid:27)(cid:4)(cid:25)(cid:29)(cid:37)(cid:29)(cid:34)(cid:10)(cid:33)(cid:24)(cid:2)(cid:27)(cid:26)(cid:32)(cid:34)(cid:27)(cid:31)(cid:4)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:28)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:4)(cid:29)(cid:24)(cid:24)(cid:29)(cid:2)(cid:30)(cid:10)(cid:27)(cid:28)(cid:27)(cid:29)(cid:28)(cid:31)(cid:26)(cid:26)(cid:28)(cid:23)(cid:25)(cid:28)(cid:33)(cid:28)(cid:28)(cid:25)(cid:28)(cid:4)(cid:37)(cid:24)(cid:27)(cid:37)(cid:25)(cid:29)(cid:28)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:8)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:46)(cid:14)(cid:14)(cid:42)(cid:6)(cid:6)(cid:47)(cid:40)(cid:42)(cid:41)(cid:48)(cid:49)(cid:43)(cid:50)(cid:47)(cid:6)(cid:41)(cid:46)(cid:41)(cid:42)(cid:24)(cid:32)(cid:33)(cid:33)(cid:30)(cid:28)(cid:10)(cid:23)(cid:4)(cid:2)(cid:34)(cid:34)(cid:29)(cid:37)(cid:37)(cid:23)(cid:2)(cid:25)(cid:28)(cid:25)(cid:10)(cid:24)(cid:30)(cid:30)(cid:4)(cid:25)(cid:37)(cid:31)(cid:24)(cid:27)(cid:29)(cid:24)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:14)(cid:15)(cid:2)(cid:10)(cid:13)(cid:17)(cid:13)(cid:2)(cid:28)(cid:2)(cid:13)(cid:2)(cid:9)(cid:32)(cid:2)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:26)(cid:33)(cid:23)(cid:27)(cid:24)(cid:24)(cid:4)(cid:29)(cid:32)(cid:24)(cid:23)(cid:34)(cid:26)(cid:26)(cid:31)(cid:27)(cid:31)(cid:31)(cid:32)(cid:33)(cid:26)(cid:25)(cid:28)(cid:29)(cid:24)(cid:37)(cid:4)(cid:4)(cid:32)(cid:32)(cid:2)(cid:32)(cid:30)(cid:26)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:53)(cid:2)(cid:11)(cid:10)(cid:7)(cid:15)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:26)(cid:4)(cid:31)(cid:28)(cid:26)(cid:25)(cid:30)(cid:2)(cid:24)(cid:29)(cid:26)(cid:27)(cid:25)(cid:4)(cid:37)(cid:10)(cid:25)(cid:34)(cid:27)(cid:30)(cid:29)(cid:37)(cid:31)(cid:24)(cid:37)(cid:26)(cid:24)(cid:2)(cid:34)(cid:32)(cid:31)(cid:34)(cid:10)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:14)(cid:22)(cid:9)(cid:9)(cid:2)(cid:32)(cid:11)(cid:7)(cid:22)(cid:9)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:24)(cid:53)(cid:13)(cid:22)(cid:7)(cid:23)(cid:46)(cid:9)(cid:10)(cid:15)(cid:19)(cid:11)(cid:7)(cid:32)(cid:16)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)(cid:8)(cid:9)(cid:10)(cid:11)(cid:9)(cid:12)(cid:5)(cid:10)(cid:13)(cid:14)(cid:15)(cid:16)(cid:17)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:18)(cid:1)(cid:2)(cid:19)Figure 6.

Illustration of Detail Analytics on Malware

with the INSTALL_PACKAGES permission. Note that the
INSTALL_PACKAGES permission is a system permission
which the application can install other unrelated applica-
tions. This shows how DroidAnalytics helps analysts to
quickly discover the malicious code of methods and classes
of the Kungfu family.
(cid:15) Class Association. Traditional analysis on malware only
focuses on one malware but can not associate malware
with other malware or applications. DroidAnalytics can
associate legitimate applications and other malware in the
class level and/or method level. Given a class signature (or
Lev2 signature), DroidAnalytics keeps track of how many
legitimate applications or malware using this particular class.
Also, with the methodology of permission recursion, Droid-
Analytics can indicate the permission usage of this class
signature. By using class association, we can easily deter-
mine which class or method may possess malicious behavior,
and which class is used for common task, say for pushing
advertisement. Lastly, for class signatures which are used
by many known malware but zero legitimate application,
these are classes that analysts need to pay special attention
to because it is very likely that they contain malicious code
and are used in many repackaged or obfuscated malware.
(cid:0) Experiment. Using DroidAnalytics, we carry out the
class association experiment using 1,000 legitimate appliac-
tions and 1,000 malware as reported by Kaspersky. After
the class association, we discover a class (Lev2) signa-
ture 2bcb4f8940f00fb7f50731ee341003df which
is used by 143 malware and zero legitimate application.
the 143 malware are all from the Geinimi
In addition,
family. Furthermore, this class has 47 API calls and uses
READ_CONTACTS and SEND_SMS permissions. Therefore,
we quickly identify this class contains malicious codes. In
the signature database, we also ﬁnd a class (Lev2) signa-
ture 9067f7292650ba0b5c725165111ef04e which
is used by 80 legitimate applications and 42 mal-
ware. Further analysis shows that
this class is used

and this

class uses

an advertisement

by similar number of legitimate applications and mal-
library
ware,
called DOMOB [18]. Another class
signature
a007d9e3754daef90ded300190903451 is used by
105 legitimate applications and 80 malware. Further exami-
nation shows that it is a class from the Google ofﬁcial library
called AdMob [19].

(Lev2)

For detail, all experimented malware samples are pre-
sented in [6], and they represent the known malware in
our database. Readers who are interested in these malware
samples can refer to [6]. The detection results is based on
the cloud anti-virus engine using various detection engines
(i.e., Kaspersky and Antiy(linux version)). Note that in the
last column, R (G) represents repackaged (generic) malware
family. For those malware families with less than ﬁve
samples, we lump them as “others” in the table. Antiy (linux
version) [20] is a commercial anti-virus product that we
obtained from the company, and the product is known to run
the same engine for detecting malware in smartphones. The
rows are sorted in alphabetical order. Highlighted rows show
the common malware families detected by both Kasper-
sky and Antiy. Others are uniquely detected by one anti-
virus product. The penultimate row shows there are 1,295
common malware samples detected by these two anti-virus
products. Hence, the number of unique malware samples is
2,148.

V. Zero-day Malware Detection

Here, we show a novel methodology in using Droid-
Analytics to detect the zero-day repackaged malware. We
analyze three zero-day malware families to illustrate the
effectiveness of our system.

A. Zero-day Malware

Zero-day malware is a new malware that current com-
mercial anti-virus systems cannot detect. Anti-virus software
usually relies on signatures to identify malware. However,

BCEEFCCEEDCCEEF...112BF123AB823ABA12BF...READ_SMS(P1)SEND_SMS(P2)INTERNET(P3)SET_WALLPAPER(P4)READ_CONTACTS(P6)READ_SMS(P1)P1, P2, P5P3, P4P1, P6P1P1, P2, P3, P4, P5P1, P6P1, P2, P5, P6P1, P2P3, P4P6P16F100INSTALL_PACKAGES(P5)P57DCF1No permissionNo permissionA4E39DBEDIE3D2EF8ABCEEDLev1 signature(Applications)Lev2 signature(Classes)Lev3 signature(Methods)PermissionREAD_SMS(P1)SEND_SMS(P2)INTERNET(P3)SET_WALLPAPER(P4)INSTALL_PACKAGES(P5)signature can only be generated when samples are obtained.
It is always a challenge for anti-virus companies to detect
the zero-day malware, then update their malware detection
engines as quickly as possible.

In this paper, we deﬁne an application as a zero-day
malware if it has malicious behavior and it cannot be
detected by popular anti-virus software (e.g., Kaspersky,
NOD32, Norton) using their latest signature database. As
of November, 2012, we use DroidAnalytics and have suc-
cessfully detected 342 zero-day repackaged malware in
six different families: AisRs, Aseiei, AIProvider, G3app,
GSmstracker and YFontmaster (please refer to Table IV
for reference). In this paper, we use the name of the injected
package (not the name of the repackaged applications) as
the name of its malware family. Furthermore, all samples
are scanned by Kaspersky, NOD32, Norton and Antiy using
their latest database in November, 2012. We also uploaded
these samples to the virustotal [21] for malware detection
analysis. Note that none of the submitted samples was
reported as a malware by these engines when we carried
out our experiments.

Family Name Number Malicious Package Name
AisRs
Aseiei
AIProvider
G3app
GSmstracker
YFontmaster
All

com.ais.rs
com.aseiei
com.android.internal.provider
com.g3app
com.gizmoquip.smstracker
com.yy.fontmaster

87
64
51
96
10
34
342

ZERO-DAY REPACKAGED MALWARE SAMPLES

Table IV

In [22], [23], authors reported that nearly 86.0% of all
Android malware are actually repackaged versions of some
legitimate applications. By camouﬂaging to some legitimate
applications, repackaged malware can easily deceive users.
Given the large percentage of repackaged malware, we
explore the effectiveness of using DroidAnalytics to detect
the zero-day repackaged malware.
B. Zero-Day Malware Detection Methodology

The process of detecting zero-day repackaged malware

can be summarized by the following steps.
Step 1: We ﬁrst construct a white list for common and
legitimate classes. For example, we add all legitimate level
2 signatures, such as those in utility libraries (e.g., Json
library) or advertisement libraries (e.g., Google Admob li-
brary, Airpush library) to the white list. All level 2 signatures
in the white list will not be used to calculate the similarity
score between two applications.
Step 2: We calculate the number of common API calls
between two given applications in the database. This can
be achieved by using the similarity score in Equation (1).

Sapp(fa; fb) = S(fa \ fb);

(1)

where fa and fb as two level 2 signature sets of two
applications a and b respectively, S(x) is a function to
indicate the total number of API calls in the set x. The
above similarity score between two repackaged malwares
focus on the common repackaged API calls that correspond
to the malicious logic, and ignore the effect of other API
calls in these two applications.
Step 3: Assume we have N applications in the database,
then we start with N clusters. The distance between two
clusters is the similarity score we mentioned in Step 2. We
select two applications which have the largest similarity
score and combine them into one cluster. For this new
cluster, we re-calculate the similarity score between this new
cluster with other N (cid:0) 2 clusters. The new similarity score
is computed by averaging all similarity scores between all
applications in two different clusters.
Step 4: Again, we combine two clusters which have the
largest similarity score. We continue this step until
the
similarity score between any two clusters is less than a pre-
deﬁned threshold T (say T is 100).
Step 5: After we ﬁnish the clustering process, we will use
anti-virus engines to scan all of these N applications. Each
application may be classiﬁed as legitimate or malicious.
Step 6: If a cluster has more than n applications (say n =
10) and a small fraction f (say f (cid:20) 0:2) is classiﬁed as
malicious. This should be a suspicious cluster since it is
very unlikely that more than n applications are similar (in
terms of class functionality) in the real-world, and most of
them are classiﬁed as benign. Hence, the similarity comes
when some of these applications are repackaged. We then
extract their common classes (using our level 2 signature)
and examine these classes. Once we ﬁnd any malicious logic
in these common classes, we discover a zero-day repackaged
malware family.
Experimental results in discovering zero-day repackaged
malware: Let us present the results of using DroidAnalytics
to discover three zero-day repackaged malware families.
- AisRs family: We discover 87 samples of AisRs fam-
ily in our database. All
the malware are repackaged
from legitimate applications (e.g., com.fengle.jumptiger,
com.mine.videoplayer) and all of them have a common
malicious package named “com.ais.rs”. This malware
contains a number of botnet commands that can be remotely
invoked. When the malware runs, it will ﬁrst communicate
with two remote servers. These two servers are camouﬂaged
as software download websites. If any of these two servers
is online, the malware will receive some commands like
downloading other .apk ﬁles. They are not necessary
malware, but they contain advertisement from the website,
“http://push.aandroid.net”. It is interesting to note that the
address is “aandroid.net”, not “android.net”. Also, one of

DroidAnalytics: A Signature Based Analytic System to Collect, Extract, Analyze and

Associate Android Malware

Min Zheng, Mingshen Sun, John C.S. Lui

Computer Science & Engineering Department

The Chinese University of Hong Kong

Abstract—Smartphones and mobile devices are rapidly be-
coming indispensable devices for many users. Unfortunately,
they also become fertile grounds for hackers to deploy mal-
ware. There is an urgent need to have a “security analytic
& forensic system” which can facilitate analysts to examine,
dissect, associate and correlate large number of mobile ap-
plications. An effective analytic system needs to address the
following questions: How to automatically collect and manage
a high volume of mobile malware? How to analyze a zero-
day suspicious application, and compare or associate it with
existing malware families in the database? How to reveal similar
malicious logic in various malware, and to quickly identify the
new malicious code segment? In this paper, we present the
design and implementation of DroidAnalytics, a signature based
analytic system to automatically collect, manage, analyze and
extract android malware. The system facilitates analysts to
retrieve, associate and reveal malicious logics at the “opcode
level”. We demonstrate the efﬁcacy of DroidAnalytics using
150,368 Android applications, and successfully determine 2,494
Android malware from 102 different families, with 342 of them
being zero-day malware samples from six different families. To
the best of our knowledge, this is the ﬁrst reported case in
showing such a large Android malware analysis/detection. The
evaluation shows the DroidAnalytics is a valuable tool and is
effective in analyzing malware repackaging and mutations.

I. Introduction

Smartphones are becoming prevailing devices for many
people. Unfortunately, malware on smartphones is also in-
creasing at an unprecedented rate. Android OS-based sys-
tems, being the most popular platform for mobile devices,
have been a popular target for malware developers. As stated
in [1], the exponential growth of mobile malware is mainly
due to the ease of generating malware variants. Although
there are number of works which focus on Android malware
detection via permission leakage, it is equally important to
design a system that can perform comprehensive malware
analytics: analyze and dissect suspicious applications at the
opcode level (instead at the permission level), and correlate
the application with existing malware in the database to de-
termine whether it is mutated malware or zero-day malware,
as well as which legitimate applications are infected.
Challenges: To realize an effective analytic system for
Android mobile applications, we need to overcome several
technical hurdles. First, how to systematically collect mal-
ware from the wild. As indicated in [2], new malware vari-
ants are always hidden in many different third-party markets.

Due to the competition of anti-virus companies and their fear
of accidentally releasing malware to the public, companies
are usually reluctant to share their malware database to
researchers. Researchers can only obtain a handful of mobile
malware samples. Hence, how to automate a systematic
process to collect these malicious applications is the ﬁrst
hurdle we need to overcome.

The second hurdle is how to identify repackaged ap-
plications (or mutated malware) from the vast ocean of
applications and malware. As reported in [3], hackers can
easily transform legitimate applications by injecting mali-
cious logic or obfuscated program segments so that they have
the same structure as the original application but contain ma-
licious logic. Thus, how to determine whether an application
is a repackaged or obfuscated malware, and which legitimate
applications are infected is very challenging.

The third hurdle is how to associate a malware with
existing malware (or application) so as to facilitate security
analysis. The existing approach of using cryptographic hash
or package name as an identiﬁer is not effective because
hackers can easily change the hash value or package name.
Security analysts often need to go through a laborous process
of reverse engineering to discover malicious functions and
structure. There is an urgent need to have an efﬁcient method
to associate malware with other malware in the database, so
to examine their commonalities at the opcode level.
Contributions: We present the design and implementation
of DroidAnalytics, an Andorid malware analytic system
for malware collection, signature generation, information
retrieval, and malware association based on similarity score.
Furthermore, DroidAnalytic can efﬁciently detect zero-day
repackaged malware. The contributions of our system are:
(cid:15) DroidAnalytics automates the processes of malware
collection, analysis and management. We have suc-
cessfully collected 150,368 Android applications, and
determined 2,494 malware samples from 102 families.
Among those, there are 342 zero-day malware samples
from six different malware families. We plan to release
the malware database to the research community. (for
our malware database, please refer to http://ansrlab.cse.
cuhk.edu.hk/software/droidanalytics).

(cid:15) DroidAnalytics uses a multi-level signature algorithm
to extract the malware feature based on their semantic

meaning at the opcode level. This is far more robust
than a cryptographic hash of the entire application.
We show how to use DroidAnalytics to combat against
malware which uses repackaging or code obfuscation,
as well as how to analyze malware with dynamic
payloads (see Sec. III).

(cid:15) Unlike previous works which associate malware via
“permission”, DroidAnalytics associates malware and
generates signatures at
the app/class/method level.
Hence, we can easily track and analyze mutation,
derivatives, and new generation of a malware. Droid-
Analytics can reveal malicious behavior at the method
level to identify repackaged malware, and perform class
association among malware/applications (see Sec. IV).
(cid:15) One can use DroidAnalytics to detect zero-day repack-
aged malware. We have found 342 zero-day repackaged
malware in six different families (see Sec. V).
II. Design & Implementation of DroidAnalytics

AndroidAnalytics consists of modules for automatic mal-
ware collection, signature generation, information retrieval
and association, as well as similarity comparison between
malware. One can also use these functions to detect zero-
day repackaged malware.

Figure 1. The Architecture of the DroidAnalytics

A. Building Blocks of DroidAnalytics

Figure 1 depicts the architecture of DroidAnalytics and its
components. Let us explain the design of each component.
(cid:15) Extensible Crawler: In DroidAnalytics, we implement an
application crawler based on Scrapy [4]. Users can specify
ofﬁcial or third party market places, as well as blog sites
and the crawler will perform regular mobile application
download. The crawler enables us to systematically build
up the mobile applications database for malware analysis
and association. So far, we have collected 150,368 mobile
applications and carried out detailed security analysis.
(cid:15) Dynamic Payloads Detector: To deal with malware which
dynamically downloads malicious codes via the Internet or
attachment ﬁles, we have implemented the dynamic payloads
detector component, which determines malicious trigger
code within malware packages and tracks the downloaded

application and its behavior in virtual machine. Firstly, it
scans the package to ﬁnd suspicious ﬁles such as .elf or
.jar ﬁle. Hackers usually camouﬂage malicious ﬁles by
changing their ﬁle type. To overcome this, this component
scans all ﬁles and identiﬁes ﬁles using their magic numbers
instead of ﬁle extension. Secondly, if an application has any
Internet behavior (e.g., Internet permission or re-delegating
other applications to download ﬁles [5]), the dynamic pay-
loads detector will treat these ﬁles as the target, then runs the
application in the emulator. The system will use the forward
symbolic execution technique to trigger the download behav-
ior. For detail, please refer to [6]. Both the suspicious ﬁles
within the package and dynamically downloaded ﬁles from
the Internet will be sent to the signature generator (which
we will shortly describe) for further analysis.
(cid:15) Android App Information (AIS) Parser: AIS is a
data structure within DroidAnalytics and it is used to rep-
resent .apk information structure. Using the AIS parser,
analysts can reveal the cryptographic hash (or other ba-
sic signature) of an .apk ﬁle,
its package name, per-
mission information, broadcast receiver information and
disassembled code, : : :, etc. Our AIS parser decrypts the
AndroidManifest.xml within an application and dis-
assembles the .dex ﬁle into .smali code. Then it extracts
package information from source code and retains it in AIS
so analysts can easily retrieve this information.
(cid:15) Signature Generator: Anti-virus companies usually use
cryptographic hash, e.g., MD5,
to generate a signature
for an application. This has two major drawbacks. Firstly,
hackers can easily mutate an application and change its
cryptographic hash. Secondly, the cryptographic hash does
not provide sufﬁcient ﬂexibility for security analysis. In
DroidAnalytics, we use a three-level signature generation
scheme to identify each application. This signature scheme
is based on the mobile application, classes, methods, as
well as malware’s dynamic payloads (if any). Our signature
generation is based on the following observation: For any
functional application, it needs to invoke various Android
API calls, and Android API calls sequence within a method
is difﬁcult to modify (unless one drastically changes the
program’s logic, but we did not ﬁnd any from the 150,368
applications we collected that used this obfuscation tech-
nique). Hence, we generate a method’s signature using the
API call sequence, and given the signature of a method,
create the signature of a class which composes of different
methods. Finally, the signature of an application is composed
of all signatures of its classes. We like to emphasize that
our signature algorithm is not only for defense against mal-
ware obfuscation, but more importantly, facilitating malware
analysis via class/method association (we will show in later
sections). Let us present the detail of signature generation.
(a) Android API calls table: Our system uses the API
calls table of the Android SDK. The android.jar ﬁle is
the framework package provided by the Android SDK. We

3 Level SignaturesApplication RepositoryCloud Apk ScannerAppMalware ReportSignature GeneratorAnalyzerAnalysis EnginesAIS Parserwww.appsapk.comwww.souapp.com...CrawlerDynamic Payloads DetectorEmulatorsuse the Java reﬂection [7] to obtain all descriptions of the
API calls. For each API, we extract both the class path
and the method name. We assign each full path method
a hex number as part of the ID. For the current version
of DroidAnalytics, we extract 47,126 full path methods
in the Android SDK 4.1 version as our API calls ta-
ble. Table I depicts a snapshot of API calls table, e.g.,
android/content/Intent;-><init> is assigned
an ID 0x30291.

Full Path Method

android/accounts/Account;-><init>

:

android/content/Intent;-><init>
android/content/Intent;->toUri
android/telephony/SmsManager;->getDefault
android/app/PendingIntent;->getBroadcast

Method ID
0x00001

:

0x30291
0x30292
0x39D53
0xF3E91

EXAMPLE OF THE ANDROID API CALLS TABLE AND ASSIGNED IDS

Table I

(b) Disassembling process: Each Android application is
composed of different classes and each class is composed
of different methods. To generate signatures for each class
or method, DroidAnalytics ﬁrst disassembles an .apk ﬁle,
then takes the Dalvik opcodes of the .dex ﬁle and trans-
forms them to methods and classes. Then DroidAnalytics
uses the Android API calls table to generate signatures.
(c) Generate Lev3 signature (or method signature): The
system ﬁrst generates a signature for each method and we
call this the Lev3 signature. Based on the Android API calls
table, the system extracts the API call ID sequence as a string
in each method, then hashes this string value to produce the
method’s signature. Figure 2 illustrates how to generate the
Lev3 signature of a method which sends messages to another
mobile phone. Figure 2 shows that the method contains
three API calls. Using the Android API calls table (as in
Table I), we determine their IDs. Signature of a method
is generated by cancatenation of all these IDs. Note that
DroidAnalytics will not extract the API calls which will not
be executed in run time because these codes are usually
generated via obfuscation. Furthermore, if a method (except
the main method) will not be invoked by any other methods,
signature generator will also ignore this method because this
may be a defunct method generated by malware writers.
(d) Generate Lev2 signature (either class signature or
dynamic payload signature): Next, DroidAnalytics pro-
ceeds to generate the Lev2 signature for each class, and it is
based on the Lev3 signatures of methods within that class.
Malware writers may use various obfuscation or repackaging
techniques to change the calling order of the methods table
in a .dex ﬁle. To overcome this problem, our signature
generation algorithm will ﬁrst sort the level 3 signatures
within that class, and then concatenate all these level 3
signatures to form the level 2 signature.

Some malicious codes are dynamically downloaded from

Figure 2. The Process of Lev3 Signature Generation

the Internet during execution. DroidAnalytics uses the dy-
namic payloads detector component to obtain the payload
ﬁles. For the dynamic payloads which are .dex ﬁle or
.jar ﬁle, DroidAnalytics treats them as classes within
the malware. Given these ﬁles,
the system checks their
API call sequence and generates a Lev2 signature for each
class within an application. For the dynamic payloads which
contain, say, .elf ﬁle or .so ﬁle, DroidAnalytics treats
them as a single class within that malware, then uses the
cryptographic hash value (e.g., MD5) of the payload as its
Lev2 signature. For the dynamic payloads which are .apk
ﬁles, DroidAnalytics treats each as a new application and
a class within the malware. DroidAnalytics ﬁrst uses the
cryptographic hash value (e.g., MD5) of the new .apk ﬁle
as one Lev2 signature of that malware. Because the payload
is a new application, DroidAnalytics will use the method we
discussed to carry out a new signature generation.
(e) Generate Lev1 signature (or application signature):
The Lev1 signature is based on the level 2 signatures, e.g.,
signatures of all qualiﬁed classes within an application. In
addition, the signature generator will ignore the class (except
the main class) which will not be invoked by any other
classes since these defunct classes may be generated via
obfuscation. Malware writers may use some repackaging or
obfuscation techniques to change the order of the classes
table of the .dex ﬁle, our signature algorithm will ﬁrst sort
all Lev2 signatures, then concatenate these Lev2 signatures
to generate the Lev1 signature.

Figure 3 summarizes the signature genration framework.
For example, the Lev3 signatures of AAAE1 and B23E8 are
the two method signatures within the same class. Based on
these two (sorted) signatures, we generate the Lev2 signature
of the corresponding class, which is 53EB3. Note that the
Lev2 signature of C3EB3 is generated from a .dex ﬁle
which is a dynamic payload used to execute the malicious
behavior. Based on all sorted Lev2 signatures of all classes,
we generate the Lev1 signature, F32DE, of the application.

const/4v2,0x0new-instancev3,Landroid/content/Intent;const-stringv5,"SENT"invoke-direct{v3,v5},Landroid/content/Intent;-><init>(Ljava/lang/String;)Vconst/4v5,0x0invoke-static{v1,v2,v3,v5},Landroid/app/PendingIntent;->getBroadcast\(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;move-result-objectv4.localv4,pi:Landroid/app/PendingIntent;invoke-static{},Landroid/telephony/SmsManager;->getDefault()\Landroid/telephony/SmsManager;move-result-objectv0android/content/Intent;-><init>()android/app/PendingIntent;->getBroadcast()android/telephony/SmsManager;->getDefault()->0x30291->0xF3E91->0x39D530x302910xF3E910x39D53MethodSign:AAAE1APICallsTableAPICallsIDSequenceStringmalware from three different families (10 samples in each
family) and Table II illustrates our results. The malware
families in our study are: Basebrid (or Basebridge), Gold-
Dream, and Kungfu. We use ADAM [16], a system which
can automatically transform an original malware sample
to different variants by various repackaging and obfusca-
tion techniques (e.g. inserting defunct methods, modifying
methods name, ...etc). We generate seven different variants
for each malware. Then we put these 240 new malware
samples into the DroidAnalytics system and check their
signatures. After our signature calculations, the result shows
that for each malware, the original sample and seven mutated
variants have distinct MD5 hash values (3 repackaging, 4
code obfuscation), but all of them have the same level 1
signature. This shows that DroidAnalytics’ signature system
is effective in defending against code obfuscation.
B. Analyzing Malware with Attachement Files or Dy-
namic Payloads: Some malware will dynamically download
ﬁle which contains the malicious code. Also, some attach-
ment ﬁles within a package may contain malicious logic
but they can be concealed as other valid documents (e.g.,
.png ﬁle, .wma ﬁle). DroidAnalytics will treat these ﬁles
as dynamic payloads. By using static and dynamic analysis
techniques described in Section II, DroidAnalytics accesses
these payloads and generates different signatures.
Experiment. We carried out the following experiment. From
our malware database, we used our signature system and
detected some malware contain the same ﬁle with a .png
ﬁlename extension. But when we check the magic number of
this ﬁle, it is actually an .elf ﬁle. Upon further analysis,
we found that this ﬁle is a root exploit and this malware
belongs to the GinMaster (or GingerMaster) family. An-
other example is the Plankton family. By using dynamic
analysis, DroidAnalytics discovered that all malware in
this family will download a plankton_v0.0.4.jar (or
similar .jar) when the main activity of the application
starts. Further analysis revealed the .jar ﬁle contains ma-
licious behavior, i.e., stealing browser’s history information,
making screen shortcuts and botnet logic. Table III depicts
DroidAnalytics system detects some representative malware
using dynamic payloads.

MD5
34cb03276e426f8d61e782b8435d3147
a24d2ae57c3cee1cf3298c856a917100

9e847c9a27dc9898825f466ea00dac81

dcbe11e5f3b82ce891b793ea40e4975e

Dynamic Payload
/assets/runme.png
/assets/gbfm.png
/assets/install.png
/assets/installsoft.png
/assets/runme.png
/assets/gbfa.png
/assets/install.png
plankton v0.0.4.jar

Description
ELF ﬁle to expoit root
ELF ﬁle to expoit root

Malware Family
GinMaster
GinMaster

ELF ﬁle to expoit root

GinMaster

download in runtime

Plankton

Table III

EXAMPLES OF DYNAMIC PAYLOADS

We also carried out experiment to analyze repackaged

malware. For detail, please refer to [6].

Figure 3.
Illustration of signature generation: the application (Lev1)
signature, class level (Lev2) signatures and method level (Lev3) signatures.

For the current DroidAnalytics platform, we use a server
which is of 2.80 GHz Duo CPU processor, 4GB memory and
2 TB hard disk, with two virtual machines in the server to
implement the anti-virus engine. We carried out experiment
to study the processing time to scanning and generating
signatures. On average, it takes around 60 seconds to scan
one application (includes the dynamic analysis), and around
three seconds to generate all three level signatures, ﬁve
seconds to generate AIS information, and one second to
insert information into the database. As of November 2012,
our system have downloaded 150,368 mobile applications
from the following places: Google Play [8], nine Android
third party markets (e.g., [9]–[11]), two malware forums
[12], [13] and one mobile malware share blog [2]. The size
of all downloaded application is 468GB.
III. Utility & Effectiveness of Signature Based System
Here, we illustrate how DroidAnalytics’ signatures can
be used to analyze (and detect) malware repackaging, code
obfuscation and malware with dynamic payloads.
A. Analyzing Malware which uses Code Obfuscation: A
malware writer can use a disassembler (e.g., Apktool [14])
to convert a .dex ﬁle into .smali ﬁles, then injects new
malware logic into the .smali code, rebuilds it back to a
.dex ﬁle. Based on this, malware writers can apply various
code obfuscation techniques while preserve the behavior as
the original one in order to bypass the anti-virus detection.
As shown in [3], [15], many mobile anti-virus products are
not effective to detect code obfuscated variants.

DroidAnalytics will not extract the API calls in methods
and classes which will not be executed in run time (refer to
Sec. II) because they are defunct and can be generated by
obfuscators. In addition, our signature generation does not
depend on the name of methods or classes and so name
obfuscation has no effect on our signature. Furthermore,
the signature generation of DroidAnalytics is based on the
analyst-deﬁned API calls table. So one can ﬂexibly update
the table to defend against various code obfuscation.
Experiment. To illustrate the effectiveness of DroidAn-
alytics against code obfuscation, we chose 30 different

F32DE53EB393DE1B103CAAAE1B23E83A4EBAABEFADA13Lev1Lev2Lev3......C3EB3dex, jar, elfmethods, classes signaturesdynamic payload signatures......sortedsortedsortedsortedMD5
f7967f71b2f32287660ae9a3fa366022
f2e2d727f95fa868fd7ff54459e766e3
e01f573cca83fdf2737be6ecee35fe33
d383ceeb9c6ffcff8c0dd12b73ec43e3
cd040541693693faca9fec646e12e7e6
401952d745cd7ca5281a7f08d3e2eede
271c3965c7822ebf944feb8bbd1cfe7f
8b12ccdc8a69cf2d6a7e6c00f698aaaa

Pakage Name
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup

Lev1 Signature
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd

Malware Family
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu

Description
Original malware
Repackaging
Repackaging
Repackaging
Obfuscation
Obfuscation
Obfuscation
Obfuscation

Table II

EXAMPLES OF CODE OBFUSCATION

IV. Analytic Capability of DroidAnalytics

We conduct three experiments and show how analysts can
study malware, carry out similarity measurement between
applications, as well as perform class association among
150,368 mobile applications in the database.
A. Detailed Analysis on Malware: Using DroidAnalytics,
analysts can also discover which class or method uses
suspicious API calls via the permission recursion technique.
(cid:15) Common Analytics on Malware. First, using the AIS
parser, DroidAnalytics can reveal basic information of an
application like the cryptographic hash (i.e., MD5 value),
package name, broadcast receiver, : : :, etc. This is illustrated
in Figure 4. In addition, DroidAnalytics has a built-in cloud-
based APK scanner that supports diverse anti-virus scan
results (e.g., Kaspersky and Antiy) to help analysts for
reference. Our cloud-based APK scanner is extensible to
accommodate other anti-virus scan engines. Last but not
least, DroidAnalytics can disassemble the .dex ﬁle and
extract class number, method number, and API calls number
in each application, class or method. These functionalities
are useful so analysts can zoom in to the meta-information of
a suspicious malware. Figure 5 shows these functionalities.

Figure 4. Screen Capture of Common Analytics on Malware

(cid:15) Permission Recursion. Current state-of-the-art systems
examine the AndroidManifest.xml to discover per-
missions of an application. This is not informative enough

Figure 5. Screen Capture of Detailed Lev2 Signature

since analysts do not know which class or which method
uses these permissions for suspicious activities. In Droid-
Analytics, we can discover the permission within a class
or a method. Since each permission is related to some API
calls [17]. In DroidAnalytics, we tag permission to API calls
in each method. We combine the method permissions within
the same class as class permission, and combine all class
permissions as application permission. This helps analysts
to quickly discover suspicious methods or classes.
(cid:0) Experiment. In this experiment, we choose a popular
malware family Kungfu and examine the permissions at
the application/class/method levels. Malware in the Kungfu
family can obtain user’s information such as IMEI number,
phone model,..., etc. It can also exploit
the device and
gain root privilege access. Once the malware obtained the
root level access, it installs malicious application in the
background as a back-door service.

We use DroidAnalytics to generate all three-level sig-
natures. Figure 6 shows the partial structure of the sig-
natures with permission recursion of two Kungfu mal-
ware: A4E39D and D2EF8A, and together with a le-
gitimate application BEDIE3 (Lev1 signature). Firstly,
based on the malware reports by our cloud APK scan-
ner, we identify A4E39D and D2EF8A are malware
which come from the Kungfu family with different
package names, net.atools.android.cmwrap and
com.atools.netTrafficStats respectively. By an-
alyzing the Lev2 signature, we discover that BCEED is the
common class which is within the two Kungfu applications.
Secondly, from the Lev3 signature of BCEED, we use the
permission recursion method to expose the method 6F100

(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:1)(cid:2)(cid:3)(cid:4)(cid:3)(cid:4)(cid:6)(cid:7)(cid:6)(cid:8)(cid:9)(cid:8)(cid:8)(cid:6)(cid:10)(cid:11)(cid:12)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:3)(cid:4)(cid:5)(cid:6)(cid:5)(cid:7)(cid:6)(cid:8)(cid:9)(cid:6)(cid:10)(cid:11)(cid:12)(cid:8)(cid:5)(cid:6)(cid:2)(cid:9)(cid:10)(cid:4)(cid:11)(cid:2)(cid:13)(cid:5)(cid:14)(cid:6)(cid:15)(cid:16)(cid:17)(cid:18)(cid:19)(cid:15)(cid:20)(cid:20)(cid:14)(cid:21)(cid:15)(cid:22)(cid:17)(cid:23)(cid:11)(cid:24)(cid:25)(cid:22)(cid:14)(cid:22)(cid:26)(cid:26)(cid:11)(cid:26)(cid:19)(cid:18)(cid:20)(cid:27)(cid:22)(cid:22)(cid:28)(cid:6)(cid:29)(cid:30)(cid:12)(cid:4)(cid:13)(cid:14)(cid:4)(cid:15)(cid:2)(cid:13)(cid:5)(cid:14)(cid:31)(cid:7)(cid:28)(cid:7)(cid:32)(cid:15)(cid:31)(cid:31)(cid:22)(cid:33)(cid:28)(cid:7)(cid:32)(cid:14)(cid:8)(cid:3)(cid:29)(cid:4)(cid:16)(cid:5)(cid:17)(cid:9)(cid:18)(cid:19)(cid:14)(cid:9)(cid:20)(cid:2)(cid:21)(cid:7)(cid:5)(cid:22)(cid:17)(cid:13)(cid:5)(cid:19)(cid:28)(cid:26)(cid:18)(cid:23)(cid:24)(cid:11)(cid:5)(cid:3)(cid:9)(cid:25)(cid:5)(cid:11)(cid:2)(cid:13)(cid:5)(cid:19)(cid:25)(cid:24)(cid:19)(cid:34)(cid:25)(cid:23)(cid:34)(cid:19)(cid:19)(cid:5)(cid:19)(cid:24)(cid:13)(cid:21)(cid:25)(cid:13)(cid:24)(cid:23)(cid:12)(cid:2)(cid:21)(cid:11)(cid:5)(cid:7)(cid:7)(cid:5)(cid:22)(cid:17)(cid:7)(cid:26)(cid:27)(cid:28)(cid:29)(cid:30)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:41)(cid:42)(cid:43)(cid:43)(cid:1)(cid:41)(cid:38)(cid:43)(cid:44)(cid:45)(cid:46)(cid:37)(cid:1)(cid:37)(cid:47)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:1)(cid:37)(cid:36)(cid:48)(cid:37)(cid:1)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:49)(cid:47)(cid:41)(cid:45)(cid:50)(cid:43)(cid:48)(cid:37)(cid:41)(cid:51)(cid:1)(cid:49)(cid:1)(cid:37)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:49)(cid:38)(cid:38)(cid:37)(cid:51)(cid:51)(cid:41)(cid:38)(cid:43)(cid:49)(cid:36)(cid:51)(cid:37)(cid:41)(cid:46)(cid:43)(cid:38)(cid:49)(cid:1)(cid:39)(cid:43)(cid:48)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:49)(cid:38)(cid:38)(cid:37)(cid:51)(cid:51)(cid:41)(cid:52)(cid:39)(cid:48)(cid:37)(cid:41)(cid:46)(cid:43)(cid:38)(cid:49)(cid:1)(cid:39)(cid:43)(cid:48)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:1)(cid:37)(cid:36)(cid:48)(cid:37)(cid:1)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:41)(cid:51)(cid:44)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:51)(cid:37)(cid:48)(cid:47)(cid:41)(cid:51)(cid:44)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:51)(cid:1)(cid:49)(cid:46)(cid:46)(cid:41)(cid:45)(cid:49)(cid:38)(cid:53)(cid:49)(cid:54)(cid:37)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:55)(cid:36)(cid:39)(cid:1)(cid:37)(cid:41)(cid:37)(cid:56)(cid:1)(cid:37)(cid:36)(cid:48)(cid:49)(cid:46)(cid:41)(cid:51)(cid:1)(cid:43)(cid:36)(cid:49)(cid:54)(cid:37)(cid:31)(cid:2)(cid:13)(cid:2)(cid:5)(cid:32)(cid:2)(cid:21)(cid:9)(cid:33)(cid:17)(cid:3)(cid:2)(cid:17)(cid:3)(cid:26)(cid:34)(cid:29)(cid:30)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:3)(cid:35)(cid:33)(cid:11)(cid:35)(cid:33)(cid:28)(cid:6)(cid:14)(cid:33)(cid:3)(cid:31)(cid:35)(cid:28)(cid:42)(cid:43)(cid:43)(cid:1)(cid:41)(cid:38)(cid:43)(cid:44)(cid:45)(cid:46)(cid:37)(cid:1)(cid:37)(cid:47)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:3)(cid:35)(cid:33)(cid:11)(cid:35)(cid:33)(cid:28)(cid:6)(cid:14)(cid:33)(cid:3)(cid:31)(cid:35)(cid:28)(cid:51)(cid:39)(cid:54)(cid:41)(cid:51)(cid:1)(cid:36)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:10)(cid:31)(cid:57)(cid:3)(cid:20)(cid:11)(cid:10)(cid:28)(cid:1)(cid:11)(cid:8)(cid:11)(cid:29)(cid:2)(cid:31)(cid:35)(cid:32)(cid:28)(cid:51)(cid:44)(cid:51)(cid:41)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:47)(cid:18)(cid:13)(cid:4)(cid:17)(cid:9)(cid:31)(cid:2)(cid:7)(cid:23)(cid:6)(cid:3)(cid:7)(cid:30)(cid:5)(cid:5)(cid:5)(cid:53)(cid:6)(cid:29)(cid:11)(cid:10)(cid:4)(cid:30)(cid:32)(cid:13)(cid:5)(cid:1)(cid:2)(cid:3)(cid:2)(cid:13)(cid:3)(cid:2)(cid:19)(cid:1)(cid:2)(cid:3)(cid:2)(cid:13)(cid:3)(cid:2)(cid:19)(cid:5)(cid:5)(cid:5)(cid:35)(cid:36)(cid:37)(cid:31)(cid:38)(cid:25)(cid:21)(cid:22)(cid:39)(cid:4)(cid:17)(cid:40)(cid:18)(cid:41)(cid:42)(cid:43)(cid:44)(cid:17)(cid:19)(cid:21)(cid:22)(cid:5)(cid:19)(cid:45)(cid:18)(cid:43)(cid:44)(cid:19)(cid:21)(cid:19)(cid:43)(cid:4)(cid:5)(cid:5)(cid:5)(cid:49)(cid:35)(cid:33)(cid:3)(cid:32)(cid:13)(cid:5)(cid:12)(cid:4)(cid:7)(cid:7)(cid:12)(cid:4)(cid:7)(cid:7)(cid:5)(cid:5)(cid:47)(cid:10)(cid:31)(cid:3)(cid:20)(cid:49)(cid:35)(cid:6)(cid:8)(cid:32)(cid:33)(cid:3)(cid:14)(cid:4)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)(cid:8)(cid:9)(cid:10)(cid:11)(cid:9)(cid:12)(cid:5)(cid:10)(cid:13)(cid:14)(cid:15)(cid:16)(cid:17)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:18)(cid:1)(cid:2)(cid:19)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:2)(cid:5)(cid:14)(cid:2)(cid:11)(cid:10)(cid:7)(cid:15)(cid:16)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:2)(cid:14)(cid:15)(cid:10)(cid:16)(cid:16)(cid:5)(cid:17)(cid:10)(cid:11)(cid:18)(cid:6)(cid:19)(cid:16)(cid:11)(cid:2)(cid:20)(cid:14)(cid:10)(cid:15)(cid:15)(cid:5)(cid:21)(cid:17)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:23)(cid:23)(cid:23)(cid:24)(cid:4)(cid:10)(cid:10)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)(cid:30)(cid:31)(cid:23)(cid:27)(cid:26)(cid:23)(cid:27)(cid:30)(cid:2)(cid:32)(cid:32)(cid:25)(cid:2)(cid:25)(cid:27)(cid:27)(cid:33)(cid:33)(cid:34)(cid:31)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:10)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:37)(cid:34)(cid:33)(cid:32)(cid:23)(cid:34)(cid:30)(cid:24)(cid:25)(cid:24)(cid:4)(cid:4)(cid:34)(cid:29)(cid:32)(cid:28)(cid:33)(cid:28)(cid:32)(cid:34)(cid:4)(cid:30)(cid:31)(cid:33)(cid:37)(cid:25)(cid:37)(cid:32)(cid:10)(cid:28)(cid:37)(cid:33)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:29)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:31)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:39)(cid:40)(cid:41)(cid:42)(cid:43)(cid:40)(cid:42)(cid:41)(cid:30)(cid:33)(cid:31)(cid:31)(cid:32)(cid:31)(cid:26)(cid:29)(cid:25)(cid:10)(cid:25)(cid:30)(cid:30)(cid:23)(cid:25)(cid:26)(cid:24)(cid:34)(cid:31)(cid:33)(cid:28)(cid:25)(cid:31)(cid:2)(cid:34)(cid:37)(cid:4)(cid:37)(cid:2)(cid:29)(cid:29)(cid:37)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:32)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:4)(cid:23)(cid:24)(cid:37)(cid:27)(cid:28)(cid:26)(cid:2)(cid:34)(cid:28)(cid:31)(cid:33)(cid:37)(cid:25)(cid:34)(cid:24)(cid:2)(cid:10)(cid:27)(cid:28)(cid:34)(cid:37)(cid:37)(cid:30)(cid:24)(cid:37)(cid:37)(cid:27)(cid:27)(cid:34)(cid:4)(cid:29)(cid:25)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:6)(cid:20)(cid:16)(cid:43)(cid:2)(cid:32)(cid:2)(cid:7)(cid:3)(cid:2)(cid:13)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:4)(cid:34)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:44)(cid:39)(cid:45)(cid:43)(cid:46)(cid:41)(cid:42)(cid:34)(cid:26)(cid:33)(cid:4)(cid:2)(cid:4)(cid:33)(cid:25)(cid:25)(cid:24)(cid:31)(cid:37)(cid:28)(cid:31)(cid:24)(cid:25)(cid:29)(cid:37)(cid:31)(cid:25)(cid:10)(cid:2)(cid:10)(cid:30)(cid:27)(cid:2)(cid:31)(cid:27)(cid:25)(cid:2)(cid:2)(cid:10)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:41)(cid:46)(cid:40)(cid:14)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:27)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:46)(cid:14)(cid:14)(cid:42)(cid:6)(cid:6)(cid:47)(cid:40)(cid:42)(cid:41)(cid:48)(cid:49)(cid:43)(cid:50)(cid:47)(cid:6)(cid:41)(cid:46)(cid:41)(cid:42)(cid:25)(cid:2)(cid:10)(cid:24)(cid:37)(cid:30)(cid:28)(cid:23)(cid:31)(cid:30)(cid:28)(cid:37)(cid:24)(cid:30)(cid:4)(cid:29)(cid:30)(cid:32)(cid:10)(cid:34)(cid:27)(cid:31)(cid:25)(cid:30)(cid:24)(cid:27)(cid:28)(cid:34)(cid:2)(cid:37)(cid:29)(cid:28)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:23)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:25)(cid:24)(cid:27)(cid:32)(cid:28)(cid:37)(cid:24)(cid:26)(cid:29)(cid:26)(cid:4)(cid:31)(cid:24)(cid:33)(cid:23)(cid:23)(cid:25)(cid:26)(cid:23)(cid:4)(cid:30)(cid:31)(cid:28)(cid:2)(cid:28)(cid:2)(cid:29)(cid:24)(cid:4)(cid:28)(cid:2)(cid:33)(cid:10)(cid:2)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:2)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:31)(cid:26)(cid:37)(cid:23)(cid:10)(cid:37)(cid:25)(cid:32)(cid:32)(cid:32)(cid:24)(cid:33)(cid:2)(cid:29)(cid:2)(cid:27)(cid:4)(cid:25)(cid:29)(cid:37)(cid:29)(cid:34)(cid:10)(cid:33)(cid:24)(cid:2)(cid:27)(cid:26)(cid:32)(cid:34)(cid:27)(cid:31)(cid:4)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:28)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:4)(cid:29)(cid:24)(cid:24)(cid:29)(cid:2)(cid:30)(cid:10)(cid:27)(cid:28)(cid:27)(cid:29)(cid:28)(cid:31)(cid:26)(cid:26)(cid:28)(cid:23)(cid:25)(cid:28)(cid:33)(cid:28)(cid:28)(cid:25)(cid:28)(cid:4)(cid:37)(cid:24)(cid:27)(cid:37)(cid:25)(cid:29)(cid:28)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:8)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:46)(cid:14)(cid:14)(cid:42)(cid:6)(cid:6)(cid:47)(cid:40)(cid:42)(cid:41)(cid:48)(cid:49)(cid:43)(cid:50)(cid:47)(cid:6)(cid:41)(cid:46)(cid:41)(cid:42)(cid:24)(cid:32)(cid:33)(cid:33)(cid:30)(cid:28)(cid:10)(cid:23)(cid:4)(cid:2)(cid:34)(cid:34)(cid:29)(cid:37)(cid:37)(cid:23)(cid:2)(cid:25)(cid:28)(cid:25)(cid:10)(cid:24)(cid:30)(cid:30)(cid:4)(cid:25)(cid:37)(cid:31)(cid:24)(cid:27)(cid:29)(cid:24)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:14)(cid:15)(cid:2)(cid:10)(cid:13)(cid:17)(cid:13)(cid:2)(cid:28)(cid:2)(cid:13)(cid:2)(cid:9)(cid:32)(cid:2)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:26)(cid:33)(cid:23)(cid:27)(cid:24)(cid:24)(cid:4)(cid:29)(cid:32)(cid:24)(cid:23)(cid:34)(cid:26)(cid:26)(cid:31)(cid:27)(cid:31)(cid:31)(cid:32)(cid:33)(cid:26)(cid:25)(cid:28)(cid:29)(cid:24)(cid:37)(cid:4)(cid:4)(cid:32)(cid:32)(cid:2)(cid:32)(cid:30)(cid:26)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:53)(cid:2)(cid:11)(cid:10)(cid:7)(cid:15)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:26)(cid:4)(cid:31)(cid:28)(cid:26)(cid:25)(cid:30)(cid:2)(cid:24)(cid:29)(cid:26)(cid:27)(cid:25)(cid:4)(cid:37)(cid:10)(cid:25)(cid:34)(cid:27)(cid:30)(cid:29)(cid:37)(cid:31)(cid:24)(cid:37)(cid:26)(cid:24)(cid:2)(cid:34)(cid:32)(cid:31)(cid:34)(cid:10)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:14)(cid:22)(cid:9)(cid:9)(cid:2)(cid:32)(cid:11)(cid:7)(cid:22)(cid:9)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:24)(cid:53)(cid:13)(cid:22)(cid:7)(cid:23)(cid:46)(cid:9)(cid:10)(cid:15)(cid:19)(cid:11)(cid:7)(cid:32)(cid:16)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)(cid:8)(cid:9)(cid:10)(cid:11)(cid:9)(cid:12)(cid:5)(cid:10)(cid:13)(cid:14)(cid:15)(cid:16)(cid:17)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:18)(cid:1)(cid:2)(cid:19)Figure 6.

Illustration of Detail Analytics on Malware

with the INSTALL_PACKAGES permission. Note that the
INSTALL_PACKAGES permission is a system permission
which the application can install other unrelated applica-
tions. This shows how DroidAnalytics helps analysts to
quickly discover the malicious code of methods and classes
of the Kungfu family.
(cid:15) Class Association. Traditional analysis on malware only
focuses on one malware but can not associate malware
with other malware or applications. DroidAnalytics can
associate legitimate applications and other malware in the
class level and/or method level. Given a class signature (or
Lev2 signature), DroidAnalytics keeps track of how many
legitimate applications or malware using this particular class.
Also, with the methodology of permission recursion, Droid-
Analytics can indicate the permission usage of this class
signature. By using class association, we can easily deter-
mine which class or method may possess malicious behavior,
and which class is used for common task, say for pushing
advertisement. Lastly, for class signatures which are used
by many known malware but zero legitimate application,
these are classes that analysts need to pay special attention
to because it is very likely that they contain malicious code
and are used in many repackaged or obfuscated malware.
(cid:0) Experiment. Using DroidAnalytics, we carry out the
class association experiment using 1,000 legitimate appliac-
tions and 1,000 malware as reported by Kaspersky. After
the class association, we discover a class (Lev2) signa-
ture 2bcb4f8940f00fb7f50731ee341003df which
is used by 143 malware and zero legitimate application.
the 143 malware are all from the Geinimi
In addition,
family. Furthermore, this class has 47 API calls and uses
READ_CONTACTS and SEND_SMS permissions. Therefore,
we quickly identify this class contains malicious codes. In
the signature database, we also ﬁnd a class (Lev2) signa-
ture 9067f7292650ba0b5c725165111ef04e which
is used by 80 legitimate applications and 42 mal-
ware. Further analysis shows that
this class is used

and this

class uses

an advertisement

by similar number of legitimate applications and mal-
library
ware,
called DOMOB [18]. Another class
signature
a007d9e3754daef90ded300190903451 is used by
105 legitimate applications and 80 malware. Further exami-
nation shows that it is a class from the Google ofﬁcial library
called AdMob [19].

(Lev2)

For detail, all experimented malware samples are pre-
sented in [6], and they represent the known malware in
our database. Readers who are interested in these malware
samples can refer to [6]. The detection results is based on
the cloud anti-virus engine using various detection engines
(i.e., Kaspersky and Antiy(linux version)). Note that in the
last column, R (G) represents repackaged (generic) malware
family. For those malware families with less than ﬁve
samples, we lump them as “others” in the table. Antiy (linux
version) [20] is a commercial anti-virus product that we
obtained from the company, and the product is known to run
the same engine for detecting malware in smartphones. The
rows are sorted in alphabetical order. Highlighted rows show
the common malware families detected by both Kasper-
sky and Antiy. Others are uniquely detected by one anti-
virus product. The penultimate row shows there are 1,295
common malware samples detected by these two anti-virus
products. Hence, the number of unique malware samples is
2,148.

V. Zero-day Malware Detection

Here, we show a novel methodology in using Droid-
Analytics to detect the zero-day repackaged malware. We
analyze three zero-day malware families to illustrate the
effectiveness of our system.

A. Zero-day Malware

Zero-day malware is a new malware that current com-
mercial anti-virus systems cannot detect. Anti-virus software
usually relies on signatures to identify malware. However,

BCEEFCCEEDCCEEF...112BF123AB823ABA12BF...READ_SMS(P1)SEND_SMS(P2)INTERNET(P3)SET_WALLPAPER(P4)READ_CONTACTS(P6)READ_SMS(P1)P1, P2, P5P3, P4P1, P6P1P1, P2, P3, P4, P5P1, P6P1, P2, P5, P6P1, P2P3, P4P6P16F100INSTALL_PACKAGES(P5)P57DCF1No permissionNo permissionA4E39DBEDIE3D2EF8ABCEEDLev1 signature(Applications)Lev2 signature(Classes)Lev3 signature(Methods)PermissionREAD_SMS(P1)SEND_SMS(P2)INTERNET(P3)SET_WALLPAPER(P4)INSTALL_PACKAGES(P5)signature can only be generated when samples are obtained.
It is always a challenge for anti-virus companies to detect
the zero-day malware, then update their malware detection
engines as quickly as possible.

In this paper, we deﬁne an application as a zero-day
malware if it has malicious behavior and it cannot be
detected by popular anti-virus software (e.g., Kaspersky,
NOD32, Norton) using their latest signature database. As
of November, 2012, we use DroidAnalytics and have suc-
cessfully detected 342 zero-day repackaged malware in
six different families: AisRs, Aseiei, AIProvider, G3app,
GSmstracker and YFontmaster (please refer to Table IV
for reference). In this paper, we use the name of the injected
package (not the name of the repackaged applications) as
the name of its malware family. Furthermore, all samples
are scanned by Kaspersky, NOD32, Norton and Antiy using
their latest database in November, 2012. We also uploaded
these samples to the virustotal [21] for malware detection
analysis. Note that none of the submitted samples was
reported as a malware by these engines when we carried
out our experiments.

Family Name Number Malicious Package Name
AisRs
Aseiei
AIProvider
G3app
GSmstracker
YFontmaster
All

com.ais.rs
com.aseiei
com.android.internal.provider
com.g3app
com.gizmoquip.smstracker
com.yy.fontmaster

87
64
51
96
10
34
342

ZERO-DAY REPACKAGED MALWARE SAMPLES

Table IV

In [22], [23], authors reported that nearly 86.0% of all
Android malware are actually repackaged versions of some
legitimate applications. By camouﬂaging to some legitimate
applications, repackaged malware can easily deceive users.
Given the large percentage of repackaged malware, we
explore the effectiveness of using DroidAnalytics to detect
the zero-day repackaged malware.
B. Zero-Day Malware Detection Methodology

The process of detecting zero-day repackaged malware

can be summarized by the following steps.
Step 1: We ﬁrst construct a white list for common and
legitimate classes. For example, we add all legitimate level
2 signatures, such as those in utility libraries (e.g., Json
library) or advertisement libraries (e.g., Google Admob li-
brary, Airpush library) to the white list. All level 2 signatures
in the white list will not be used to calculate the similarity
score between two applications.
Step 2: We calculate the number of common API calls
between two given applications in the database. This can
be achieved by using the similarity score in Equation (1).

Sapp(fa; fb) = S(fa \ fb);

(1)

where fa and fb as two level 2 signature sets of two
applications a and b respectively, S(x) is a function to
indicate the total number of API calls in the set x. The
above similarity score between two repackaged malwares
focus on the common repackaged API calls that correspond
to the malicious logic, and ignore the effect of other API
calls in these two applications.
Step 3: Assume we have N applications in the database,
then we start with N clusters. The distance between two
clusters is the similarity score we mentioned in Step 2. We
select two applications which have the largest similarity
score and combine them into one cluster. For this new
cluster, we re-calculate the similarity score between this new
cluster with other N (cid:0) 2 clusters. The new similarity score
is computed by averaging all similarity scores between all
applications in two different clusters.
Step 4: Again, we combine two clusters which have the
largest similarity score. We continue this step until
the
similarity score between any two clusters is less than a pre-
deﬁned threshold T (say T is 100).
Step 5: After we ﬁnish the clustering process, we will use
anti-virus engines to scan all of these N applications. Each
application may be classiﬁed as legitimate or malicious.
Step 6: If a cluster has more than n applications (say n =
10) and a small fraction f (say f (cid:20) 0:2) is classiﬁed as
malicious. This should be a suspicious cluster since it is
very unlikely that more than n applications are similar (in
terms of class functionality) in the real-world, and most of
them are classiﬁed as benign. Hence, the similarity comes
when some of these applications are repackaged. We then
extract their common classes (using our level 2 signature)
and examine these classes. Once we ﬁnd any malicious logic
in these common classes, we discover a zero-day repackaged
malware family.
Experimental results in discovering zero-day repackaged
malware: Let us present the results of using DroidAnalytics
to discover three zero-day repackaged malware families.
- AisRs family: We discover 87 samples of AisRs fam-
ily in our database. All
the malware are repackaged
from legitimate applications (e.g., com.fengle.jumptiger,
com.mine.videoplayer) and all of them have a common
malicious package named “com.ais.rs”. This malware
contains a number of botnet commands that can be remotely
invoked. When the malware runs, it will ﬁrst communicate
with two remote servers. These two servers are camouﬂaged
as software download websites. If any of these two servers
is online, the malware will receive some commands like
downloading other .apk ﬁles. They are not necessary
malware, but they contain advertisement from the website,
“http://push.aandroid.net”. It is interesting to note that the
address is “aandroid.net”, not “android.net”. Also, one of

and

package

applications

family in our database. All

from legitimate
com.otiasj.androradio)
common malicious

the many botnet commands is to save the user’s application
installation lists and system information to the .SQLite
ﬁle, then upload this ﬁle to a remote server.
family: We discover 51 samples of
- AIProvider
AIProvider
the malware
(e.g.,
are
repackaged
jinho.eye check,
all
of
named
them have
a
are
“com.android.internal.provider”. There
several interesting characteristics of this malware. Firstly,
the malicious package name is disguised as a system
package name. Since DroidAnalytics does not detect
malware based on the package name, so our system can
easily discover this repackaged malware. Secondly,
this
malware uses DES to encrypt all SMS information (e.g.,
telephone numbers, SMS content) and store them in the
DESUtils class. Thirdly, the malware will start a service
called OperateService in the background when it
receives “BOOT_COMPLETED” broadcast. This service will
decrypt the SMS information in the DESUtils class and
use this information to send SMS messages without any
notiﬁcation.
- G3app family: We discover 96 samples of G3app family
in our database. All
the malware are repackaged from
legitimate applications (e.g., com.openg3.virtua lIncoming-
Call, com.cs.android.wc3) and all of them have a common
malicious package named “com.g3app”. There are several
malicious behaviors in the G3app malware family. Firstly,
the malware will frequently pop up notiﬁcation on the status
bar and entice users to select it. Secondly, the malware
will inject trigger codes to every button of the legitimate
application. If the user presses any button in the repackaged
application or the notiﬁcation in the status bar, the malware
will download other applications from the remote server.
We believe the hackers want to use repackaged malware to
publicize their applications and use these advertisements for
ﬁnancial gain.

VI. Related Work

Before the rapid increase of Android malware in 2011,
researchers focused on the permission and capability leaks
of Android applications. E.g., David Barrera et al. [24]
propose a methodology to explore and analyze permission-
based models in Android. Stowaway [17] is a tool for detect-
ing permission over privilege in Android, while ComDroid
[25] is a tool which detects communication vulnerabilities.
Woodpecker [26] analyzes each application on a smart-
phone to explore the reachability of a dangerous permission
from a public, unguarded interface. William Enck et al.
[27] propose a lightweight mobile phone application with
a certiﬁcation-based permission. In this paper, instead of
malware detection, we focus on designing an analytic system
that helps analysts to dissect, analyze and correlate Android
malware with other Android applications in the database.

We propose a novel signature system to identify malicious
code segments and associate with other malware in the
database. Our signature system is robust against obfuscation
techniques that hackers may use.

In August 2010, Kaspersky reported the ﬁrst SMS Trojan,
known as FakePlayer in Android systems [28]. Since then,
many malware and their variants have been discovered and
mobile malware rapidly became a serious threat. Felt et al.
study 18 Android malware in [29]. Enck et al. [30] carry
out a study with 1,100 android applications but no malware
was found. Zhou Yang et al. [31] study characterization and
evolution of Android malware with 1,260 samples. However,
they did not show how to systematically collect, analyze and
correlate these samples.

Yajin Zhou et al. [32] were the ﬁrst to present a systematic
study for the detection of malicious applications on Android
Markets. They successfully discover 211 malware. Their
system, DroidRanger, needs malware samples to extract the
footprint of each malware family before the known malware
detection. For zero day malware, DroidRanger serves as
a ﬁltering system. After the ﬁltering process, suspicious
malware needs to be manually analyzed. DroidMOSS [33]
is an Android system to detect repackaged applications
using fuzzy hashing. As stated in [33], the system is not
designed for general malware detection. Furthermore, the
similarity score provided by DoridMoss is not helpful in
malware analysis. In addition, obfuscation techniques can
change the order of classes and methods execution, and
this will
introduce large deviation in the measure used
in DroidMOSS. Michael Grace et al. develop RiskRanker
[34] to analyze whether a particular application exhibits
dangerous behavior. It uses class path as the malware family
feature to detect more mutations. However, obfuscation can
easily rearrange the opcode along an execution path. So
using class path for malware feature is not effective under
obfuscation attack. Our system overcomes these problems
by using a novel signature algorithm to extract the malware
feature at
the opcode level so it captures the semantic
meaning for signature generation.

For PC based malware, a lot of research work focus
on the signature based malware detection. For example,
authors in [15] discussed the limitation of using signature to
detect malware. In [35], authors described the obfuscation
techniques to hide malware. Authors in [36] presented an
automatic system to mine speciﬁcations of malicious behav-
ior in malware families. Paolo Milani Comparetti et al. [37]
proposed a solution to determine malicious functionalities of
malware. However, mobile malware has different features as
compared with PC based malware. It is difﬁcult to transform
a PC based malware detection solution for mobile devices.
For example, [3] reported that many anti-virus products have
poor performance in detecting Android malware mutations,
although these products performed reasonably well for PC
based malware. Repackaging is another characteristic of

DroidAnalytics: A Signature Based Analytic System to Collect, Extract, Analyze and

Associate Android Malware

Min Zheng, Mingshen Sun, John C.S. Lui

Computer Science & Engineering Department

The Chinese University of Hong Kong

Abstract—Smartphones and mobile devices are rapidly be-
coming indispensable devices for many users. Unfortunately,
they also become fertile grounds for hackers to deploy mal-
ware. There is an urgent need to have a “security analytic
& forensic system” which can facilitate analysts to examine,
dissect, associate and correlate large number of mobile ap-
plications. An effective analytic system needs to address the
following questions: How to automatically collect and manage
a high volume of mobile malware? How to analyze a zero-
day suspicious application, and compare or associate it with
existing malware families in the database? How to reveal similar
malicious logic in various malware, and to quickly identify the
new malicious code segment? In this paper, we present the
design and implementation of DroidAnalytics, a signature based
analytic system to automatically collect, manage, analyze and
extract android malware. The system facilitates analysts to
retrieve, associate and reveal malicious logics at the “opcode
level”. We demonstrate the efﬁcacy of DroidAnalytics using
150,368 Android applications, and successfully determine 2,494
Android malware from 102 different families, with 342 of them
being zero-day malware samples from six different families. To
the best of our knowledge, this is the ﬁrst reported case in
showing such a large Android malware analysis/detection. The
evaluation shows the DroidAnalytics is a valuable tool and is
effective in analyzing malware repackaging and mutations.

I. Introduction

Smartphones are becoming prevailing devices for many
people. Unfortunately, malware on smartphones is also in-
creasing at an unprecedented rate. Android OS-based sys-
tems, being the most popular platform for mobile devices,
have been a popular target for malware developers. As stated
in [1], the exponential growth of mobile malware is mainly
due to the ease of generating malware variants. Although
there are number of works which focus on Android malware
detection via permission leakage, it is equally important to
design a system that can perform comprehensive malware
analytics: analyze and dissect suspicious applications at the
opcode level (instead at the permission level), and correlate
the application with existing malware in the database to de-
termine whether it is mutated malware or zero-day malware,
as well as which legitimate applications are infected.
Challenges: To realize an effective analytic system for
Android mobile applications, we need to overcome several
technical hurdles. First, how to systematically collect mal-
ware from the wild. As indicated in [2], new malware vari-
ants are always hidden in many different third-party markets.

Due to the competition of anti-virus companies and their fear
of accidentally releasing malware to the public, companies
are usually reluctant to share their malware database to
researchers. Researchers can only obtain a handful of mobile
malware samples. Hence, how to automate a systematic
process to collect these malicious applications is the ﬁrst
hurdle we need to overcome.

The second hurdle is how to identify repackaged ap-
plications (or mutated malware) from the vast ocean of
applications and malware. As reported in [3], hackers can
easily transform legitimate applications by injecting mali-
cious logic or obfuscated program segments so that they have
the same structure as the original application but contain ma-
licious logic. Thus, how to determine whether an application
is a repackaged or obfuscated malware, and which legitimate
applications are infected is very challenging.

The third hurdle is how to associate a malware with
existing malware (or application) so as to facilitate security
analysis. The existing approach of using cryptographic hash
or package name as an identiﬁer is not effective because
hackers can easily change the hash value or package name.
Security analysts often need to go through a laborous process
of reverse engineering to discover malicious functions and
structure. There is an urgent need to have an efﬁcient method
to associate malware with other malware in the database, so
to examine their commonalities at the opcode level.
Contributions: We present the design and implementation
of DroidAnalytics, an Andorid malware analytic system
for malware collection, signature generation, information
retrieval, and malware association based on similarity score.
Furthermore, DroidAnalytic can efﬁciently detect zero-day
repackaged malware. The contributions of our system are:
(cid:15) DroidAnalytics automates the processes of malware
collection, analysis and management. We have suc-
cessfully collected 150,368 Android applications, and
determined 2,494 malware samples from 102 families.
Among those, there are 342 zero-day malware samples
from six different malware families. We plan to release
the malware database to the research community. (for
our malware database, please refer to http://ansrlab.cse.
cuhk.edu.hk/software/droidanalytics).

(cid:15) DroidAnalytics uses a multi-level signature algorithm
to extract the malware feature based on their semantic

meaning at the opcode level. This is far more robust
than a cryptographic hash of the entire application.
We show how to use DroidAnalytics to combat against
malware which uses repackaging or code obfuscation,
as well as how to analyze malware with dynamic
payloads (see Sec. III).

(cid:15) Unlike previous works which associate malware via
“permission”, DroidAnalytics associates malware and
generates signatures at
the app/class/method level.
Hence, we can easily track and analyze mutation,
derivatives, and new generation of a malware. Droid-
Analytics can reveal malicious behavior at the method
level to identify repackaged malware, and perform class
association among malware/applications (see Sec. IV).
(cid:15) One can use DroidAnalytics to detect zero-day repack-
aged malware. We have found 342 zero-day repackaged
malware in six different families (see Sec. V).
II. Design & Implementation of DroidAnalytics

AndroidAnalytics consists of modules for automatic mal-
ware collection, signature generation, information retrieval
and association, as well as similarity comparison between
malware. One can also use these functions to detect zero-
day repackaged malware.

Figure 1. The Architecture of the DroidAnalytics

A. Building Blocks of DroidAnalytics

Figure 1 depicts the architecture of DroidAnalytics and its
components. Let us explain the design of each component.
(cid:15) Extensible Crawler: In DroidAnalytics, we implement an
application crawler based on Scrapy [4]. Users can specify
ofﬁcial or third party market places, as well as blog sites
and the crawler will perform regular mobile application
download. The crawler enables us to systematically build
up the mobile applications database for malware analysis
and association. So far, we have collected 150,368 mobile
applications and carried out detailed security analysis.
(cid:15) Dynamic Payloads Detector: To deal with malware which
dynamically downloads malicious codes via the Internet or
attachment ﬁles, we have implemented the dynamic payloads
detector component, which determines malicious trigger
code within malware packages and tracks the downloaded

application and its behavior in virtual machine. Firstly, it
scans the package to ﬁnd suspicious ﬁles such as .elf or
.jar ﬁle. Hackers usually camouﬂage malicious ﬁles by
changing their ﬁle type. To overcome this, this component
scans all ﬁles and identiﬁes ﬁles using their magic numbers
instead of ﬁle extension. Secondly, if an application has any
Internet behavior (e.g., Internet permission or re-delegating
other applications to download ﬁles [5]), the dynamic pay-
loads detector will treat these ﬁles as the target, then runs the
application in the emulator. The system will use the forward
symbolic execution technique to trigger the download behav-
ior. For detail, please refer to [6]. Both the suspicious ﬁles
within the package and dynamically downloaded ﬁles from
the Internet will be sent to the signature generator (which
we will shortly describe) for further analysis.
(cid:15) Android App Information (AIS) Parser: AIS is a
data structure within DroidAnalytics and it is used to rep-
resent .apk information structure. Using the AIS parser,
analysts can reveal the cryptographic hash (or other ba-
sic signature) of an .apk ﬁle,
its package name, per-
mission information, broadcast receiver information and
disassembled code, : : :, etc. Our AIS parser decrypts the
AndroidManifest.xml within an application and dis-
assembles the .dex ﬁle into .smali code. Then it extracts
package information from source code and retains it in AIS
so analysts can easily retrieve this information.
(cid:15) Signature Generator: Anti-virus companies usually use
cryptographic hash, e.g., MD5,
to generate a signature
for an application. This has two major drawbacks. Firstly,
hackers can easily mutate an application and change its
cryptographic hash. Secondly, the cryptographic hash does
not provide sufﬁcient ﬂexibility for security analysis. In
DroidAnalytics, we use a three-level signature generation
scheme to identify each application. This signature scheme
is based on the mobile application, classes, methods, as
well as malware’s dynamic payloads (if any). Our signature
generation is based on the following observation: For any
functional application, it needs to invoke various Android
API calls, and Android API calls sequence within a method
is difﬁcult to modify (unless one drastically changes the
program’s logic, but we did not ﬁnd any from the 150,368
applications we collected that used this obfuscation tech-
nique). Hence, we generate a method’s signature using the
API call sequence, and given the signature of a method,
create the signature of a class which composes of different
methods. Finally, the signature of an application is composed
of all signatures of its classes. We like to emphasize that
our signature algorithm is not only for defense against mal-
ware obfuscation, but more importantly, facilitating malware
analysis via class/method association (we will show in later
sections). Let us present the detail of signature generation.
(a) Android API calls table: Our system uses the API
calls table of the Android SDK. The android.jar ﬁle is
the framework package provided by the Android SDK. We

3 Level SignaturesApplication RepositoryCloud Apk ScannerAppMalware ReportSignature GeneratorAnalyzerAnalysis EnginesAIS Parserwww.appsapk.comwww.souapp.com...CrawlerDynamic Payloads DetectorEmulatorsuse the Java reﬂection [7] to obtain all descriptions of the
API calls. For each API, we extract both the class path
and the method name. We assign each full path method
a hex number as part of the ID. For the current version
of DroidAnalytics, we extract 47,126 full path methods
in the Android SDK 4.1 version as our API calls ta-
ble. Table I depicts a snapshot of API calls table, e.g.,
android/content/Intent;-><init> is assigned
an ID 0x30291.

Full Path Method

android/accounts/Account;-><init>

:

android/content/Intent;-><init>
android/content/Intent;->toUri
android/telephony/SmsManager;->getDefault
android/app/PendingIntent;->getBroadcast

Method ID
0x00001

:

0x30291
0x30292
0x39D53
0xF3E91

EXAMPLE OF THE ANDROID API CALLS TABLE AND ASSIGNED IDS

Table I

(b) Disassembling process: Each Android application is
composed of different classes and each class is composed
of different methods. To generate signatures for each class
or method, DroidAnalytics ﬁrst disassembles an .apk ﬁle,
then takes the Dalvik opcodes of the .dex ﬁle and trans-
forms them to methods and classes. Then DroidAnalytics
uses the Android API calls table to generate signatures.
(c) Generate Lev3 signature (or method signature): The
system ﬁrst generates a signature for each method and we
call this the Lev3 signature. Based on the Android API calls
table, the system extracts the API call ID sequence as a string
in each method, then hashes this string value to produce the
method’s signature. Figure 2 illustrates how to generate the
Lev3 signature of a method which sends messages to another
mobile phone. Figure 2 shows that the method contains
three API calls. Using the Android API calls table (as in
Table I), we determine their IDs. Signature of a method
is generated by cancatenation of all these IDs. Note that
DroidAnalytics will not extract the API calls which will not
be executed in run time because these codes are usually
generated via obfuscation. Furthermore, if a method (except
the main method) will not be invoked by any other methods,
signature generator will also ignore this method because this
may be a defunct method generated by malware writers.
(d) Generate Lev2 signature (either class signature or
dynamic payload signature): Next, DroidAnalytics pro-
ceeds to generate the Lev2 signature for each class, and it is
based on the Lev3 signatures of methods within that class.
Malware writers may use various obfuscation or repackaging
techniques to change the calling order of the methods table
in a .dex ﬁle. To overcome this problem, our signature
generation algorithm will ﬁrst sort the level 3 signatures
within that class, and then concatenate all these level 3
signatures to form the level 2 signature.

Some malicious codes are dynamically downloaded from

Figure 2. The Process of Lev3 Signature Generation

the Internet during execution. DroidAnalytics uses the dy-
namic payloads detector component to obtain the payload
ﬁles. For the dynamic payloads which are .dex ﬁle or
.jar ﬁle, DroidAnalytics treats them as classes within
the malware. Given these ﬁles,
the system checks their
API call sequence and generates a Lev2 signature for each
class within an application. For the dynamic payloads which
contain, say, .elf ﬁle or .so ﬁle, DroidAnalytics treats
them as a single class within that malware, then uses the
cryptographic hash value (e.g., MD5) of the payload as its
Lev2 signature. For the dynamic payloads which are .apk
ﬁles, DroidAnalytics treats each as a new application and
a class within the malware. DroidAnalytics ﬁrst uses the
cryptographic hash value (e.g., MD5) of the new .apk ﬁle
as one Lev2 signature of that malware. Because the payload
is a new application, DroidAnalytics will use the method we
discussed to carry out a new signature generation.
(e) Generate Lev1 signature (or application signature):
The Lev1 signature is based on the level 2 signatures, e.g.,
signatures of all qualiﬁed classes within an application. In
addition, the signature generator will ignore the class (except
the main class) which will not be invoked by any other
classes since these defunct classes may be generated via
obfuscation. Malware writers may use some repackaging or
obfuscation techniques to change the order of the classes
table of the .dex ﬁle, our signature algorithm will ﬁrst sort
all Lev2 signatures, then concatenate these Lev2 signatures
to generate the Lev1 signature.

Figure 3 summarizes the signature genration framework.
For example, the Lev3 signatures of AAAE1 and B23E8 are
the two method signatures within the same class. Based on
these two (sorted) signatures, we generate the Lev2 signature
of the corresponding class, which is 53EB3. Note that the
Lev2 signature of C3EB3 is generated from a .dex ﬁle
which is a dynamic payload used to execute the malicious
behavior. Based on all sorted Lev2 signatures of all classes,
we generate the Lev1 signature, F32DE, of the application.

const/4v2,0x0new-instancev3,Landroid/content/Intent;const-stringv5,"SENT"invoke-direct{v3,v5},Landroid/content/Intent;-><init>(Ljava/lang/String;)Vconst/4v5,0x0invoke-static{v1,v2,v3,v5},Landroid/app/PendingIntent;->getBroadcast\(Landroid/content/Context;ILandroid/content/Intent;I)Landroid/app/PendingIntent;move-result-objectv4.localv4,pi:Landroid/app/PendingIntent;invoke-static{},Landroid/telephony/SmsManager;->getDefault()\Landroid/telephony/SmsManager;move-result-objectv0android/content/Intent;-><init>()android/app/PendingIntent;->getBroadcast()android/telephony/SmsManager;->getDefault()->0x30291->0xF3E91->0x39D530x302910xF3E910x39D53MethodSign:AAAE1APICallsTableAPICallsIDSequenceStringmalware from three different families (10 samples in each
family) and Table II illustrates our results. The malware
families in our study are: Basebrid (or Basebridge), Gold-
Dream, and Kungfu. We use ADAM [16], a system which
can automatically transform an original malware sample
to different variants by various repackaging and obfusca-
tion techniques (e.g. inserting defunct methods, modifying
methods name, ...etc). We generate seven different variants
for each malware. Then we put these 240 new malware
samples into the DroidAnalytics system and check their
signatures. After our signature calculations, the result shows
that for each malware, the original sample and seven mutated
variants have distinct MD5 hash values (3 repackaging, 4
code obfuscation), but all of them have the same level 1
signature. This shows that DroidAnalytics’ signature system
is effective in defending against code obfuscation.
B. Analyzing Malware with Attachement Files or Dy-
namic Payloads: Some malware will dynamically download
ﬁle which contains the malicious code. Also, some attach-
ment ﬁles within a package may contain malicious logic
but they can be concealed as other valid documents (e.g.,
.png ﬁle, .wma ﬁle). DroidAnalytics will treat these ﬁles
as dynamic payloads. By using static and dynamic analysis
techniques described in Section II, DroidAnalytics accesses
these payloads and generates different signatures.
Experiment. We carried out the following experiment. From
our malware database, we used our signature system and
detected some malware contain the same ﬁle with a .png
ﬁlename extension. But when we check the magic number of
this ﬁle, it is actually an .elf ﬁle. Upon further analysis,
we found that this ﬁle is a root exploit and this malware
belongs to the GinMaster (or GingerMaster) family. An-
other example is the Plankton family. By using dynamic
analysis, DroidAnalytics discovered that all malware in
this family will download a plankton_v0.0.4.jar (or
similar .jar) when the main activity of the application
starts. Further analysis revealed the .jar ﬁle contains ma-
licious behavior, i.e., stealing browser’s history information,
making screen shortcuts and botnet logic. Table III depicts
DroidAnalytics system detects some representative malware
using dynamic payloads.

MD5
34cb03276e426f8d61e782b8435d3147
a24d2ae57c3cee1cf3298c856a917100

9e847c9a27dc9898825f466ea00dac81

dcbe11e5f3b82ce891b793ea40e4975e

Dynamic Payload
/assets/runme.png
/assets/gbfm.png
/assets/install.png
/assets/installsoft.png
/assets/runme.png
/assets/gbfa.png
/assets/install.png
plankton v0.0.4.jar

Description
ELF ﬁle to expoit root
ELF ﬁle to expoit root

Malware Family
GinMaster
GinMaster

ELF ﬁle to expoit root

GinMaster

download in runtime

Plankton

Table III

EXAMPLES OF DYNAMIC PAYLOADS

We also carried out experiment to analyze repackaged

malware. For detail, please refer to [6].

Figure 3.
Illustration of signature generation: the application (Lev1)
signature, class level (Lev2) signatures and method level (Lev3) signatures.

For the current DroidAnalytics platform, we use a server
which is of 2.80 GHz Duo CPU processor, 4GB memory and
2 TB hard disk, with two virtual machines in the server to
implement the anti-virus engine. We carried out experiment
to study the processing time to scanning and generating
signatures. On average, it takes around 60 seconds to scan
one application (includes the dynamic analysis), and around
three seconds to generate all three level signatures, ﬁve
seconds to generate AIS information, and one second to
insert information into the database. As of November 2012,
our system have downloaded 150,368 mobile applications
from the following places: Google Play [8], nine Android
third party markets (e.g., [9]–[11]), two malware forums
[12], [13] and one mobile malware share blog [2]. The size
of all downloaded application is 468GB.
III. Utility & Effectiveness of Signature Based System
Here, we illustrate how DroidAnalytics’ signatures can
be used to analyze (and detect) malware repackaging, code
obfuscation and malware with dynamic payloads.
A. Analyzing Malware which uses Code Obfuscation: A
malware writer can use a disassembler (e.g., Apktool [14])
to convert a .dex ﬁle into .smali ﬁles, then injects new
malware logic into the .smali code, rebuilds it back to a
.dex ﬁle. Based on this, malware writers can apply various
code obfuscation techniques while preserve the behavior as
the original one in order to bypass the anti-virus detection.
As shown in [3], [15], many mobile anti-virus products are
not effective to detect code obfuscated variants.

DroidAnalytics will not extract the API calls in methods
and classes which will not be executed in run time (refer to
Sec. II) because they are defunct and can be generated by
obfuscators. In addition, our signature generation does not
depend on the name of methods or classes and so name
obfuscation has no effect on our signature. Furthermore,
the signature generation of DroidAnalytics is based on the
analyst-deﬁned API calls table. So one can ﬂexibly update
the table to defend against various code obfuscation.
Experiment. To illustrate the effectiveness of DroidAn-
alytics against code obfuscation, we chose 30 different

F32DE53EB393DE1B103CAAAE1B23E83A4EBAABEFADA13Lev1Lev2Lev3......C3EB3dex, jar, elfmethods, classes signaturesdynamic payload signatures......sortedsortedsortedsortedMD5
f7967f71b2f32287660ae9a3fa366022
f2e2d727f95fa868fd7ff54459e766e3
e01f573cca83fdf2737be6ecee35fe33
d383ceeb9c6ffcff8c0dd12b73ec43e3
cd040541693693faca9fec646e12e7e6
401952d745cd7ca5281a7f08d3e2eede
271c3965c7822ebf944feb8bbd1cfe7f
8b12ccdc8a69cf2d6a7e6c00f698aaaa

Pakage Name
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup
com.tutusw.phonespeedup

Lev1 Signature
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd
3c83ed0f80646c8ba112cb8535c293dd

Malware Family
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu
Kungfu

Description
Original malware
Repackaging
Repackaging
Repackaging
Obfuscation
Obfuscation
Obfuscation
Obfuscation

Table II

EXAMPLES OF CODE OBFUSCATION

IV. Analytic Capability of DroidAnalytics

We conduct three experiments and show how analysts can
study malware, carry out similarity measurement between
applications, as well as perform class association among
150,368 mobile applications in the database.
A. Detailed Analysis on Malware: Using DroidAnalytics,
analysts can also discover which class or method uses
suspicious API calls via the permission recursion technique.
(cid:15) Common Analytics on Malware. First, using the AIS
parser, DroidAnalytics can reveal basic information of an
application like the cryptographic hash (i.e., MD5 value),
package name, broadcast receiver, : : :, etc. This is illustrated
in Figure 4. In addition, DroidAnalytics has a built-in cloud-
based APK scanner that supports diverse anti-virus scan
results (e.g., Kaspersky and Antiy) to help analysts for
reference. Our cloud-based APK scanner is extensible to
accommodate other anti-virus scan engines. Last but not
least, DroidAnalytics can disassemble the .dex ﬁle and
extract class number, method number, and API calls number
in each application, class or method. These functionalities
are useful so analysts can zoom in to the meta-information of
a suspicious malware. Figure 5 shows these functionalities.

Figure 4. Screen Capture of Common Analytics on Malware

(cid:15) Permission Recursion. Current state-of-the-art systems
examine the AndroidManifest.xml to discover per-
missions of an application. This is not informative enough

Figure 5. Screen Capture of Detailed Lev2 Signature

since analysts do not know which class or which method
uses these permissions for suspicious activities. In Droid-
Analytics, we can discover the permission within a class
or a method. Since each permission is related to some API
calls [17]. In DroidAnalytics, we tag permission to API calls
in each method. We combine the method permissions within
the same class as class permission, and combine all class
permissions as application permission. This helps analysts
to quickly discover suspicious methods or classes.
(cid:0) Experiment. In this experiment, we choose a popular
malware family Kungfu and examine the permissions at
the application/class/method levels. Malware in the Kungfu
family can obtain user’s information such as IMEI number,
phone model,..., etc. It can also exploit
the device and
gain root privilege access. Once the malware obtained the
root level access, it installs malicious application in the
background as a back-door service.

We use DroidAnalytics to generate all three-level sig-
natures. Figure 6 shows the partial structure of the sig-
natures with permission recursion of two Kungfu mal-
ware: A4E39D and D2EF8A, and together with a le-
gitimate application BEDIE3 (Lev1 signature). Firstly,
based on the malware reports by our cloud APK scan-
ner, we identify A4E39D and D2EF8A are malware
which come from the Kungfu family with different
package names, net.atools.android.cmwrap and
com.atools.netTrafficStats respectively. By an-
alyzing the Lev2 signature, we discover that BCEED is the
common class which is within the two Kungfu applications.
Secondly, from the Lev3 signature of BCEED, we use the
permission recursion method to expose the method 6F100

(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:1)(cid:2)(cid:3)(cid:4)(cid:3)(cid:4)(cid:6)(cid:7)(cid:6)(cid:8)(cid:9)(cid:8)(cid:8)(cid:6)(cid:10)(cid:11)(cid:12)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:3)(cid:4)(cid:5)(cid:6)(cid:5)(cid:7)(cid:6)(cid:8)(cid:9)(cid:6)(cid:10)(cid:11)(cid:12)(cid:8)(cid:5)(cid:6)(cid:2)(cid:9)(cid:10)(cid:4)(cid:11)(cid:2)(cid:13)(cid:5)(cid:14)(cid:6)(cid:15)(cid:16)(cid:17)(cid:18)(cid:19)(cid:15)(cid:20)(cid:20)(cid:14)(cid:21)(cid:15)(cid:22)(cid:17)(cid:23)(cid:11)(cid:24)(cid:25)(cid:22)(cid:14)(cid:22)(cid:26)(cid:26)(cid:11)(cid:26)(cid:19)(cid:18)(cid:20)(cid:27)(cid:22)(cid:22)(cid:28)(cid:6)(cid:29)(cid:30)(cid:12)(cid:4)(cid:13)(cid:14)(cid:4)(cid:15)(cid:2)(cid:13)(cid:5)(cid:14)(cid:31)(cid:7)(cid:28)(cid:7)(cid:32)(cid:15)(cid:31)(cid:31)(cid:22)(cid:33)(cid:28)(cid:7)(cid:32)(cid:14)(cid:8)(cid:3)(cid:29)(cid:4)(cid:16)(cid:5)(cid:17)(cid:9)(cid:18)(cid:19)(cid:14)(cid:9)(cid:20)(cid:2)(cid:21)(cid:7)(cid:5)(cid:22)(cid:17)(cid:13)(cid:5)(cid:19)(cid:28)(cid:26)(cid:18)(cid:23)(cid:24)(cid:11)(cid:5)(cid:3)(cid:9)(cid:25)(cid:5)(cid:11)(cid:2)(cid:13)(cid:5)(cid:19)(cid:25)(cid:24)(cid:19)(cid:34)(cid:25)(cid:23)(cid:34)(cid:19)(cid:19)(cid:5)(cid:19)(cid:24)(cid:13)(cid:21)(cid:25)(cid:13)(cid:24)(cid:23)(cid:12)(cid:2)(cid:21)(cid:11)(cid:5)(cid:7)(cid:7)(cid:5)(cid:22)(cid:17)(cid:7)(cid:26)(cid:27)(cid:28)(cid:29)(cid:30)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:41)(cid:42)(cid:43)(cid:43)(cid:1)(cid:41)(cid:38)(cid:43)(cid:44)(cid:45)(cid:46)(cid:37)(cid:1)(cid:37)(cid:47)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:1)(cid:37)(cid:36)(cid:48)(cid:37)(cid:1)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:49)(cid:47)(cid:41)(cid:45)(cid:50)(cid:43)(cid:48)(cid:37)(cid:41)(cid:51)(cid:1)(cid:49)(cid:1)(cid:37)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:49)(cid:38)(cid:38)(cid:37)(cid:51)(cid:51)(cid:41)(cid:38)(cid:43)(cid:49)(cid:36)(cid:51)(cid:37)(cid:41)(cid:46)(cid:43)(cid:38)(cid:49)(cid:1)(cid:39)(cid:43)(cid:48)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:49)(cid:38)(cid:38)(cid:37)(cid:51)(cid:51)(cid:41)(cid:52)(cid:39)(cid:48)(cid:37)(cid:41)(cid:46)(cid:43)(cid:38)(cid:49)(cid:1)(cid:39)(cid:43)(cid:48)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:1)(cid:37)(cid:36)(cid:48)(cid:37)(cid:1)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:41)(cid:51)(cid:44)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:51)(cid:37)(cid:48)(cid:47)(cid:41)(cid:51)(cid:44)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:39)(cid:48)(cid:51)(cid:1)(cid:49)(cid:46)(cid:46)(cid:41)(cid:45)(cid:49)(cid:38)(cid:53)(cid:49)(cid:54)(cid:37)(cid:51)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:11)(cid:10)(cid:7)(cid:3)(cid:4)(cid:4)(cid:3)(cid:31)(cid:35)(cid:28)(cid:55)(cid:36)(cid:39)(cid:1)(cid:37)(cid:41)(cid:37)(cid:56)(cid:1)(cid:37)(cid:36)(cid:48)(cid:49)(cid:46)(cid:41)(cid:51)(cid:1)(cid:43)(cid:36)(cid:49)(cid:54)(cid:37)(cid:31)(cid:2)(cid:13)(cid:2)(cid:5)(cid:32)(cid:2)(cid:21)(cid:9)(cid:33)(cid:17)(cid:3)(cid:2)(cid:17)(cid:3)(cid:26)(cid:34)(cid:29)(cid:30)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:3)(cid:35)(cid:33)(cid:11)(cid:35)(cid:33)(cid:28)(cid:6)(cid:14)(cid:33)(cid:3)(cid:31)(cid:35)(cid:28)(cid:42)(cid:43)(cid:43)(cid:1)(cid:41)(cid:38)(cid:43)(cid:44)(cid:45)(cid:46)(cid:37)(cid:1)(cid:37)(cid:47)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:3)(cid:35)(cid:33)(cid:11)(cid:35)(cid:33)(cid:28)(cid:6)(cid:14)(cid:33)(cid:3)(cid:31)(cid:35)(cid:28)(cid:51)(cid:39)(cid:54)(cid:41)(cid:51)(cid:1)(cid:36)(cid:5)(cid:5)(cid:5)(cid:6)(cid:35)(cid:20)(cid:10)(cid:31)(cid:3)(cid:20)(cid:28)(cid:29)(cid:10)(cid:31)(cid:57)(cid:3)(cid:20)(cid:11)(cid:10)(cid:28)(cid:1)(cid:11)(cid:8)(cid:11)(cid:29)(cid:2)(cid:31)(cid:35)(cid:32)(cid:28)(cid:51)(cid:44)(cid:51)(cid:41)(cid:36)(cid:37)(cid:38)(cid:37)(cid:39)(cid:40)(cid:37)(cid:47)(cid:18)(cid:13)(cid:4)(cid:17)(cid:9)(cid:31)(cid:2)(cid:7)(cid:23)(cid:6)(cid:3)(cid:7)(cid:30)(cid:5)(cid:5)(cid:5)(cid:53)(cid:6)(cid:29)(cid:11)(cid:10)(cid:4)(cid:30)(cid:32)(cid:13)(cid:5)(cid:1)(cid:2)(cid:3)(cid:2)(cid:13)(cid:3)(cid:2)(cid:19)(cid:1)(cid:2)(cid:3)(cid:2)(cid:13)(cid:3)(cid:2)(cid:19)(cid:5)(cid:5)(cid:5)(cid:35)(cid:36)(cid:37)(cid:31)(cid:38)(cid:25)(cid:21)(cid:22)(cid:39)(cid:4)(cid:17)(cid:40)(cid:18)(cid:41)(cid:42)(cid:43)(cid:44)(cid:17)(cid:19)(cid:21)(cid:22)(cid:5)(cid:19)(cid:45)(cid:18)(cid:43)(cid:44)(cid:19)(cid:21)(cid:19)(cid:43)(cid:4)(cid:5)(cid:5)(cid:5)(cid:49)(cid:35)(cid:33)(cid:3)(cid:32)(cid:13)(cid:5)(cid:12)(cid:4)(cid:7)(cid:7)(cid:12)(cid:4)(cid:7)(cid:7)(cid:5)(cid:5)(cid:47)(cid:10)(cid:31)(cid:3)(cid:20)(cid:49)(cid:35)(cid:6)(cid:8)(cid:32)(cid:33)(cid:3)(cid:14)(cid:4)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)(cid:8)(cid:9)(cid:10)(cid:11)(cid:9)(cid:12)(cid:5)(cid:10)(cid:13)(cid:14)(cid:15)(cid:16)(cid:17)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:18)(cid:1)(cid:2)(cid:19)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:2)(cid:5)(cid:14)(cid:2)(cid:11)(cid:10)(cid:7)(cid:15)(cid:16)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:8)(cid:9)(cid:10)(cid:11)(cid:12)(cid:13)(cid:2)(cid:14)(cid:15)(cid:10)(cid:16)(cid:16)(cid:5)(cid:17)(cid:10)(cid:11)(cid:18)(cid:6)(cid:19)(cid:16)(cid:11)(cid:2)(cid:20)(cid:14)(cid:10)(cid:15)(cid:15)(cid:5)(cid:21)(cid:17)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:23)(cid:23)(cid:23)(cid:24)(cid:4)(cid:10)(cid:10)(cid:25)(cid:26)(cid:27)(cid:28)(cid:29)(cid:30)(cid:31)(cid:23)(cid:27)(cid:26)(cid:23)(cid:27)(cid:30)(cid:2)(cid:32)(cid:32)(cid:25)(cid:2)(cid:25)(cid:27)(cid:27)(cid:33)(cid:33)(cid:34)(cid:31)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:10)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:37)(cid:34)(cid:33)(cid:32)(cid:23)(cid:34)(cid:30)(cid:24)(cid:25)(cid:24)(cid:4)(cid:4)(cid:34)(cid:29)(cid:32)(cid:28)(cid:33)(cid:28)(cid:32)(cid:34)(cid:4)(cid:30)(cid:31)(cid:33)(cid:37)(cid:25)(cid:37)(cid:32)(cid:10)(cid:28)(cid:37)(cid:33)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:29)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:31)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:39)(cid:40)(cid:41)(cid:42)(cid:43)(cid:40)(cid:42)(cid:41)(cid:30)(cid:33)(cid:31)(cid:31)(cid:32)(cid:31)(cid:26)(cid:29)(cid:25)(cid:10)(cid:25)(cid:30)(cid:30)(cid:23)(cid:25)(cid:26)(cid:24)(cid:34)(cid:31)(cid:33)(cid:28)(cid:25)(cid:31)(cid:2)(cid:34)(cid:37)(cid:4)(cid:37)(cid:2)(cid:29)(cid:29)(cid:37)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:32)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:4)(cid:23)(cid:24)(cid:37)(cid:27)(cid:28)(cid:26)(cid:2)(cid:34)(cid:28)(cid:31)(cid:33)(cid:37)(cid:25)(cid:34)(cid:24)(cid:2)(cid:10)(cid:27)(cid:28)(cid:34)(cid:37)(cid:37)(cid:30)(cid:24)(cid:37)(cid:37)(cid:27)(cid:27)(cid:34)(cid:4)(cid:29)(cid:25)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:6)(cid:20)(cid:16)(cid:43)(cid:2)(cid:32)(cid:2)(cid:7)(cid:3)(cid:2)(cid:13)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:4)(cid:34)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:44)(cid:39)(cid:45)(cid:43)(cid:46)(cid:41)(cid:42)(cid:34)(cid:26)(cid:33)(cid:4)(cid:2)(cid:4)(cid:33)(cid:25)(cid:25)(cid:24)(cid:31)(cid:37)(cid:28)(cid:31)(cid:24)(cid:25)(cid:29)(cid:37)(cid:31)(cid:25)(cid:10)(cid:2)(cid:10)(cid:30)(cid:27)(cid:2)(cid:31)(cid:27)(cid:25)(cid:2)(cid:2)(cid:10)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:41)(cid:46)(cid:40)(cid:14)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:27)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:46)(cid:14)(cid:14)(cid:42)(cid:6)(cid:6)(cid:47)(cid:40)(cid:42)(cid:41)(cid:48)(cid:49)(cid:43)(cid:50)(cid:47)(cid:6)(cid:41)(cid:46)(cid:41)(cid:42)(cid:25)(cid:2)(cid:10)(cid:24)(cid:37)(cid:30)(cid:28)(cid:23)(cid:31)(cid:30)(cid:28)(cid:37)(cid:24)(cid:30)(cid:4)(cid:29)(cid:30)(cid:32)(cid:10)(cid:34)(cid:27)(cid:31)(cid:25)(cid:30)(cid:24)(cid:27)(cid:28)(cid:34)(cid:2)(cid:37)(cid:29)(cid:28)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:23)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:25)(cid:24)(cid:27)(cid:32)(cid:28)(cid:37)(cid:24)(cid:26)(cid:29)(cid:26)(cid:4)(cid:31)(cid:24)(cid:33)(cid:23)(cid:23)(cid:25)(cid:26)(cid:23)(cid:4)(cid:30)(cid:31)(cid:28)(cid:2)(cid:28)(cid:2)(cid:29)(cid:24)(cid:4)(cid:28)(cid:2)(cid:33)(cid:10)(cid:2)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:2)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:31)(cid:26)(cid:37)(cid:23)(cid:10)(cid:37)(cid:25)(cid:32)(cid:32)(cid:32)(cid:24)(cid:33)(cid:2)(cid:29)(cid:2)(cid:27)(cid:4)(cid:25)(cid:29)(cid:37)(cid:29)(cid:34)(cid:10)(cid:33)(cid:24)(cid:2)(cid:27)(cid:26)(cid:32)(cid:34)(cid:27)(cid:31)(cid:4)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:28)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:4)(cid:29)(cid:24)(cid:24)(cid:29)(cid:2)(cid:30)(cid:10)(cid:27)(cid:28)(cid:27)(cid:29)(cid:28)(cid:31)(cid:26)(cid:26)(cid:28)(cid:23)(cid:25)(cid:28)(cid:33)(cid:28)(cid:28)(cid:25)(cid:28)(cid:4)(cid:37)(cid:24)(cid:27)(cid:37)(cid:25)(cid:29)(cid:28)(cid:32)(cid:22)(cid:20)(cid:35)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:35)(cid:20)(cid:10)(cid:7)(cid:9)(cid:35)(cid:8)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:27)(cid:10)(cid:9)(cid:23)(cid:13)(cid:22)(cid:7)(cid:23)(cid:36)(cid:38)(cid:2)(cid:13)(cid:20)(cid:7)(cid:16)(cid:16)(cid:7)(cid:22)(cid:9)(cid:36)(cid:46)(cid:14)(cid:14)(cid:42)(cid:6)(cid:6)(cid:47)(cid:40)(cid:42)(cid:41)(cid:48)(cid:49)(cid:43)(cid:50)(cid:47)(cid:6)(cid:41)(cid:46)(cid:41)(cid:42)(cid:24)(cid:32)(cid:33)(cid:33)(cid:30)(cid:28)(cid:10)(cid:23)(cid:4)(cid:2)(cid:34)(cid:34)(cid:29)(cid:37)(cid:37)(cid:23)(cid:2)(cid:25)(cid:28)(cid:25)(cid:10)(cid:24)(cid:30)(cid:30)(cid:4)(cid:25)(cid:37)(cid:31)(cid:24)(cid:27)(cid:29)(cid:24)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:14)(cid:15)(cid:2)(cid:10)(cid:13)(cid:17)(cid:13)(cid:2)(cid:28)(cid:2)(cid:13)(cid:2)(cid:9)(cid:32)(cid:2)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:26)(cid:33)(cid:23)(cid:27)(cid:24)(cid:24)(cid:4)(cid:29)(cid:32)(cid:24)(cid:23)(cid:34)(cid:26)(cid:26)(cid:31)(cid:27)(cid:31)(cid:31)(cid:32)(cid:33)(cid:26)(cid:25)(cid:28)(cid:29)(cid:24)(cid:37)(cid:4)(cid:4)(cid:32)(cid:32)(cid:2)(cid:32)(cid:30)(cid:26)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:53)(cid:2)(cid:11)(cid:10)(cid:7)(cid:15)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:31)(cid:26)(cid:4)(cid:31)(cid:28)(cid:26)(cid:25)(cid:30)(cid:2)(cid:24)(cid:29)(cid:26)(cid:27)(cid:25)(cid:4)(cid:37)(cid:10)(cid:25)(cid:34)(cid:27)(cid:30)(cid:29)(cid:37)(cid:31)(cid:24)(cid:37)(cid:26)(cid:24)(cid:2)(cid:34)(cid:32)(cid:31)(cid:34)(cid:10)(cid:22)(cid:13)(cid:8)(cid:35)(cid:51)(cid:7)(cid:10)(cid:52)(cid:52)(cid:18)(cid:10)(cid:18)(cid:10)(cid:35)(cid:9)(cid:2)(cid:11)(cid:13)(cid:10)(cid:28)(cid:28)(cid:7)(cid:32)(cid:35)(cid:14)(cid:22)(cid:9)(cid:9)(cid:2)(cid:32)(cid:11)(cid:7)(cid:22)(cid:9)(cid:46)(cid:32)(cid:11)(cid:7)(cid:3)(cid:7)(cid:11)(cid:19)(cid:36)(cid:32)(cid:15)(cid:10)(cid:16)(cid:16)(cid:24)(cid:53)(cid:13)(cid:22)(cid:7)(cid:23)(cid:46)(cid:9)(cid:10)(cid:15)(cid:19)(cid:11)(cid:7)(cid:32)(cid:16)(cid:1)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:5)(cid:8)(cid:9)(cid:10)(cid:11)(cid:9)(cid:12)(cid:5)(cid:10)(cid:13)(cid:14)(cid:15)(cid:16)(cid:17)(cid:2)(cid:3)(cid:4)(cid:5)(cid:6)(cid:7)(cid:18)(cid:1)(cid:2)(cid:19)Figure 6.

Illustration of Detail Analytics on Malware

with the INSTALL_PACKAGES permission. Note that the
INSTALL_PACKAGES permission is a system permission
which the application can install other unrelated applica-
tions. This shows how DroidAnalytics helps analysts to
quickly discover the malicious code of methods and classes
of the Kungfu family.
(cid:15) Class Association. Traditional analysis on malware only
focuses on one malware but can not associate malware
with other malware or applications. DroidAnalytics can
associate legitimate applications and other malware in the
class level and/or method level. Given a class signature (or
Lev2 signature), DroidAnalytics keeps track of how many
legitimate applications or malware using this particular class.
Also, with the methodology of permission recursion, Droid-
Analytics can indicate the permission usage of this class
signature. By using class association, we can easily deter-
mine which class or method may possess malicious behavior,
and which class is used for common task, say for pushing
advertisement. Lastly, for class signatures which are used
by many known malware but zero legitimate application,
these are classes that analysts need to pay special attention
to because it is very likely that they contain malicious code
and are used in many repackaged or obfuscated malware.
(cid:0) Experiment. Using DroidAnalytics, we carry out the
class association experiment using 1,000 legitimate appliac-
tions and 1,000 malware as reported by Kaspersky. After
the class association, we discover a class (Lev2) signa-
ture 2bcb4f8940f00fb7f50731ee341003df which
is used by 143 malware and zero legitimate application.
the 143 malware are all from the Geinimi
In addition,
family. Furthermore, this class has 47 API calls and uses
READ_CONTACTS and SEND_SMS permissions. Therefore,
we quickly identify this class contains malicious codes. In
the signature database, we also ﬁnd a class (Lev2) signa-
ture 9067f7292650ba0b5c725165111ef04e which
is used by 80 legitimate applications and 42 mal-
ware. Further analysis shows that
this class is used

and this

class uses

an advertisement

by similar number of legitimate applications and mal-
library
ware,
called DOMOB [18]. Another class
signature
a007d9e3754daef90ded300190903451 is used by
105 legitimate applications and 80 malware. Further exami-
nation shows that it is a class from the Google ofﬁcial library
called AdMob [19].

(Lev2)

For detail, all experimented malware samples are pre-
sented in [6], and they represent the known malware in
our database. Readers who are interested in these malware
samples can refer to [6]. The detection results is based on
the cloud anti-virus engine using various detection engines
(i.e., Kaspersky and Antiy(linux version)). Note that in the
last column, R (G) represents repackaged (generic) malware
family. For those malware families with less than ﬁve
samples, we lump them as “others” in the table. Antiy (linux
version) [20] is a commercial anti-virus product that we
obtained from the company, and the product is known to run
the same engine for detecting malware in smartphones. The
rows are sorted in alphabetical order. Highlighted rows show
the common malware families detected by both Kasper-
sky and Antiy. Others are uniquely detected by one anti-
virus product. The penultimate row shows there are 1,295
common malware samples detected by these two anti-virus
products. Hence, the number of unique malware samples is
2,148.

V. Zero-day Malware Detection

Here, we show a novel methodology in using Droid-
Analytics to detect the zero-day repackaged malware. We
analyze three zero-day malware families to illustrate the
effectiveness of our system.

A. Zero-day Malware

Zero-day malware is a new malware that current com-
mercial anti-virus systems cannot detect. Anti-virus software
usually relies on signatures to identify malware. However,

BCEEFCCEEDCCEEF...112BF123AB823ABA12BF...READ_SMS(P1)SEND_SMS(P2)INTERNET(P3)SET_WALLPAPER(P4)READ_CONTACTS(P6)READ_SMS(P1)P1, P2, P5P3, P4P1, P6P1P1, P2, P3, P4, P5P1, P6P1, P2, P5, P6P1, P2P3, P4P6P16F100INSTALL_PACKAGES(P5)P57DCF1No permissionNo permissionA4E39DBEDIE3D2EF8ABCEEDLev1 signature(Applications)Lev2 signature(Classes)Lev3 signature(Methods)PermissionREAD_SMS(P1)SEND_SMS(P2)INTERNET(P3)SET_WALLPAPER(P4)INSTALL_PACKAGES(P5)signature can only be generated when samples are obtained.
It is always a challenge for anti-virus companies to detect
the zero-day malware, then update their malware detection
engines as quickly as possible.

In this paper, we deﬁne an application as a zero-day
malware if it has malicious behavior and it cannot be
detected by popular anti-virus software (e.g., Kaspersky,
NOD32, Norton) using their latest signature database. As
of November, 2012, we use DroidAnalytics and have suc-
cessfully detected 342 zero-day repackaged malware in
six different families: AisRs, Aseiei, AIProvider, G3app,
GSmstracker and YFontmaster (please refer to Table IV
for reference). In this paper, we use the name of the injected
package (not the name of the repackaged applications) as
the name of its malware family. Furthermore, all samples
are scanned by Kaspersky, NOD32, Norton and Antiy using
their latest database in November, 2012. We also uploaded
these samples to the virustotal [21] for malware detection
analysis. Note that none of the submitted samples was
reported as a malware by these engines when we carried
out our experiments.

Family Name Number Malicious Package Name
AisRs
Aseiei
AIProvider
G3app
GSmstracker
YFontmaster
All

com.ais.rs
com.aseiei
com.android.internal.provider
com.g3app
com.gizmoquip.smstracker
com.yy.fontmaster

87
64
51
96
10
34
342

ZERO-DAY REPACKAGED MALWARE SAMPLES

Table IV

In [22], [23], authors reported that nearly 86.0% of all
Android malware are actually repackaged versions of some
legitimate applications. By camouﬂaging to some legitimate
applications, repackaged malware can easily deceive users.
Given the large percentage of repackaged malware, we
explore the effectiveness of using DroidAnalytics to detect
the zero-day repackaged malware.
B. Zero-Day Malware Detection Methodology

The process of detecting zero-day repackaged malware

can be summarized by the following steps.
Step 1: We ﬁrst construct a white list for common and
legitimate classes. For example, we add all legitimate level
2 signatures, such as those in utility libraries (e.g., Json
library) or advertisement libraries (e.g., Google Admob li-
brary, Airpush library) to the white list. All level 2 signatures
in the white list will not be used to calculate the similarity
score between two applications.
Step 2: We calculate the number of common API calls
between two given applications in the database. This can
be achieved by using the similarity score in Equation (1).

Sapp(fa; fb) = S(fa \ fb);

(1)

where fa and fb as two level 2 signature sets of two
applications a and b respectively, S(x) is a function to
indicate the total number of API calls in the set x. The
above similarity score between two repackaged malwares
focus on the common repackaged API calls that correspond
to the malicious logic, and ignore the effect of other API
calls in these two applications.
Step 3: Assume we have N applications in the database,
then we start with N clusters. The distance between two
clusters is the similarity score we mentioned in Step 2. We
select two applications which have the largest similarity
score and combine them into one cluster. For this new
cluster, we re-calculate the similarity score between this new
cluster with other N (cid:0) 2 clusters. The new similarity score
is computed by averaging all similarity scores between all
applications in two different clusters.
Step 4: Again, we combine two clusters which have the
largest similarity score. We continue this step until
the
similarity score between any two clusters is less than a pre-
deﬁned threshold T (say T is 100).
Step 5: After we ﬁnish the clustering process, we will use
anti-virus engines to scan all of these N applications. Each
application may be classiﬁed as legitimate or malicious.
Step 6: If a cluster has more than n applications (say n =
10) and a small fraction f (say f (cid:20) 0:2) is classiﬁed as
malicious. This should be a suspicious cluster since it is
very unlikely that more than n applications are similar (in
terms of class functionality) in the real-world, and most of
them are classiﬁed as benign. Hence, the similarity comes
when some of these applications are repackaged. We then
extract their common classes (using our level 2 signature)
and examine these classes. Once we ﬁnd any malicious logic
in these common classes, we discover a zero-day repackaged
malware family.
Experimental results in discovering zero-day repackaged
malware: Let us present the results of using DroidAnalytics
to discover three zero-day repackaged malware families.
- AisRs family: We discover 87 samples of AisRs fam-
ily in our database. All
the malware are repackaged
from legitimate applications (e.g., com.fengle.jumptiger,
com.mine.videoplayer) and all of them have a common
malicious package named “com.ais.rs”. This malware
contains a number of botnet commands that can be remotely
invoked. When the malware runs, it will ﬁrst communicate
with two remote servers. These two servers are camouﬂaged
as software download websites. If any of these two servers
is online, the malware will receive some commands like
downloading other .apk ﬁles. They are not necessary
malware, but they contain advertisement from the website,
“http://push.aandroid.net”. It is interesting to note that the
address is “aandroid.net”, not “android.net”. Also, one of

and

package

applications

family in our database. All

from legitimate
com.otiasj.androradio)
common malicious

the many botnet commands is to save the user’s application
installation lists and system information to the .SQLite
ﬁle, then upload this ﬁle to a remote server.
family: We discover 51 samples of
- AIProvider
AIProvider
the malware
(e.g.,
are
repackaged
jinho.eye check,
all
of
named
them have
a
are
“com.android.internal.provider”. There
several interesting characteristics of this malware. Firstly,
the malicious package name is disguised as a system
package name. Since DroidAnalytics does not detect
malware based on the package name, so our system can
easily discover this repackaged malware. Secondly,
this
malware uses DES to encrypt all SMS information (e.g.,
telephone numbers, SMS content) and store them in the
DESUtils class. Thirdly, the malware will start a service
called OperateService in the background when it
receives “BOOT_COMPLETED” broadcast. This service will
decrypt the SMS information in the DESUtils class and
use this information to send SMS messages without any
notiﬁcation.
- G3app family: We discover 96 samples of G3app family
in our database. All
the malware are repackaged from
legitimate applications (e.g., com.openg3.virtua lIncoming-
Call, com.cs.android.wc3) and all of them have a common
malicious package named “com.g3app”. There are several
malicious behaviors in the G3app malware family. Firstly,
the malware will frequently pop up notiﬁcation on the status
bar and entice users to select it. Secondly, the malware
will inject trigger codes to every button of the legitimate
application. If the user presses any button in the repackaged
application or the notiﬁcation in the status bar, the malware
will download other applications from the remote server.
We believe the hackers want to use repackaged malware to
publicize their applications and use these advertisements for
ﬁnancial gain.

VI. Related Work

Before the rapid increase of Android malware in 2011,
researchers focused on the permission and capability leaks
of Android applications. E.g., David Barrera et al. [24]
propose a methodology to explore and analyze permission-
based models in Android. Stowaway [17] is a tool for detect-
ing permission over privilege in Android, while ComDroid
[25] is a tool which detects communication vulnerabilities.
Woodpecker [26] analyzes each application on a smart-
phone to explore the reachability of a dangerous permission
from a public, unguarded interface. William Enck et al.
[27] propose a lightweight mobile phone application with
a certiﬁcation-based permission. In this paper, instead of
malware detection, we focus on designing an analytic system
that helps analysts to dissect, analyze and correlate Android
malware with other Android applications in the database.

We propose a novel signature system to identify malicious
code segments and associate with other malware in the
database. Our signature system is robust against obfuscation
techniques that hackers may use.

In August 2010, Kaspersky reported the ﬁrst SMS Trojan,
known as FakePlayer in Android systems [28]. Since then,
many malware and their variants have been discovered and
mobile malware rapidly became a serious threat. Felt et al.
study 18 Android malware in [29]. Enck et al. [30] carry
out a study with 1,100 android applications but no malware
was found. Zhou Yang et al. [31] study characterization and
evolution of Android malware with 1,260 samples. However,
they did not show how to systematically collect, analyze and
correlate these samples.

Yajin Zhou et al. [32] were the ﬁrst to present a systematic
study for the detection of malicious applications on Android
Markets. They successfully discover 211 malware. Their
system, DroidRanger, needs malware samples to extract the
footprint of each malware family before the known malware
detection. For zero day malware, DroidRanger serves as
a ﬁltering system. After the ﬁltering process, suspicious
malware needs to be manually analyzed. DroidMOSS [33]
is an Android system to detect repackaged applications
using fuzzy hashing. As stated in [33], the system is not
designed for general malware detection. Furthermore, the
similarity score provided by DoridMoss is not helpful in
malware analysis. In addition, obfuscation techniques can
change the order of classes and methods execution, and
this will
introduce large deviation in the measure used
in DroidMOSS. Michael Grace et al. develop RiskRanker
[34] to analyze whether a particular application exhibits
dangerous behavior. It uses class path as the malware family
feature to detect more mutations. However, obfuscation can
easily rearrange the opcode along an execution path. So
using class path for malware feature is not effective under
obfuscation attack. Our system overcomes these problems
by using a novel signature algorithm to extract the malware
feature at
the opcode level so it captures the semantic
meaning for signature generation.

For PC based malware, a lot of research work focus
on the signature based malware detection. For example,
authors in [15] discussed the limitation of using signature to
detect malware. In [35], authors described the obfuscation
techniques to hide malware. Authors in [36] presented an
automatic system to mine speciﬁcations of malicious behav-
ior in malware families. Paolo Milani Comparetti et al. [37]
proposed a solution to determine malicious functionalities of
malware. However, mobile malware has different features as
compared with PC based malware. It is difﬁcult to transform
a PC based malware detection solution for mobile devices.
For example, [3] reported that many anti-virus products have
poor performance in detecting Android malware mutations,
although these products performed reasonably well for PC
based malware. Repackaging is another characteristic of

android malware. Authors in [33] showed there are many
repackaged applications in Android third party markets and
signiﬁcant number of these applications is malware. Based
on the above studies, it is clear that a more sophisticated
methodology to detect and analyze Android malware is
needed.

VII. Conclusion

We present DroidAnalytics, an Android malware analytic
system which can automatically collect malware, generate
signatures for applications, identify malicious code segment
(even at the opcode level), and at the same time, associate the
malware under study with various malware and applications
in the database. Our signature methodology provides sig-
niﬁcant advantages over traditional cryptographic hash like
MD5-based signature. We show how to use DroidAnalytics
to quickly retrieve, associate and reveal malicious logics. Us-
ing the permission recursion technique and class association,
we show how to retrieve the permissions of methods, classes
and application (rather than basic package information), and
associate all applications in the opcode level. Using Droid-
Analytics, one can easily discover repackaged applications
via the similarity score. Last but not least, we have used
DroidAnalytics to detect 2,494 malware samples from 102
families, with 342 zero-day malware samples from six dif-
ferent families. We have conducted extensive experiments to
demonstrate the analytic and malware detection capabilities
of DroidAnalytics.

REFERENCES

[1] McAfee, “McAfee Threats Report: Fourth Quarter 2011,”

Tech. Rep., 2012.

[2] Contagio

Mobile.

contagiominidump.blogspot.com/

[Online].

Available:

http://

[3] M. Zheng, P. P. C. Lee, and J. C. S. Lui, “ADAM: An
Automatic and Extensible Platform to Stress Test Android
Anti-Virus Systems,” in Proceedings of the 9th Conference
on DIMVA, 2012.

[4] Scrapy. [Online]. Available: http://www.scrapy.org
[5] A. P. Felt, H. Wang, A. Moshchuk, S. Hanna, and E. Chin,
“Permission Re-Delegation: Attacks and Defenses,” in Pro-
ceedings of the 20th USENIX conference on Security, 2011.
[6] M. Zheng, M. Sun, and J. C. S. Lui, “Droidanalytics: A
signature based analytic system to collect, extract, analyze
[Online].
and associate android malware,” Tech. Rep.
Available: http://arxiv.org/abs/1302.7212

[7] G. McCluskey.

(1998) Using Java Reﬂection.

[Online].
Available: http://docs.oracle.com/javase/tutorial/reﬂect/index.
html
[Online]. Available:
https://play.google.com/store

Inc. Google Play Store.

[8] Google

[9] AndroidPIT. [Online]. Available: http://www.androidpit.ru
[10] AppChina. [Online]. Available: http://www.appchina.com/
[11] Android App Download Website: SouApp.

[Online].

Available: http://www.souapp.com/

[12] Mobile Malware Forum. [Online]. Available: https://groups.

google.com/forum/?fromgroups=#!forum/mobilemalware

[13] Android

Security Discuss

[Online]. Avail-
able: https://groups.google.com/forum/?fromgroups=#!forum/
android-security-discuss

Forum.

[14] Apktool.

[Online]. Available:

http://code.google.com/p/

android-apktool/

[15] A. Moser, C. Kruegel, and E. Kirda, “Limits of Static
Analysis for Malware Detection,” in Proceedings of the 23rd
Annual Computer Security Applications Conference, 2007.

[16] M. Zheng, P. P. C. Lee, and J. C. S. Lui. ADAM. [Online].

Available: http://ansrlab.cse.cuhk.edu.hk/software/adam/

[17] A. P. Felt, E. Chin, S. Hanna, D. Song, and D. Wagner,
“Android Permissions Demystiﬁed,” in Proceedings of the
18th ACM conference on Computer and communications
security, 2011.

[18] DOMOB. [Online]. Available: http://www.domob.cn
[19] AdMob.
[20] Antiy Labs.
[21] Virustotal. [Online]. Available: http://www.virustotal.com
[22] Abhi, “Android Malware Injected through Repackaging of

[Online]. Available: http://www.google.com/ads/
[Online]. Available: http://www.antiy.net/en/

admob
index.html

Apps,” Tech. Rep., 2012.

[23] G. Sims, “Android Malware Genome Project shows that 86%
of all malware delivered via repackaging of legitimate apps,”
Tech. Rep., 2012.

[24] D. Barrera, H. G. Kayacik, P. C. van Oorschot, and
A. Somayaji, “A Methodology for Empirical Analysis of
Permission-based Security Models and its Application to
Android,” in Proceedings of the 17th ACM conference on
Computer and communications security, 2010.

[25] E. Chin, A. P. Felt, K. Greenwood, and D. Wagner, “An-
alyzing Inter-application Communication in Android,” in
Proceedings of the 9th international conference on Mobile
systems, applications, and services, 2011.

[26] M. Grace, Y. Zhou, Z. Wang, and X. Jiang, “Systematic De-
tection of Capability Leaks in Stock Android Smartphones,”
in Proceedings of the 19th Annual Network & Distributed
System Security Symposium, 2012.

[27] W. Enck, M. Ongtang, and P. McDaniel, “On Lightweight
Mobile Phone Application Certiﬁcation,” in Proceedings of
the 16th ACM conference on Computer and communications
security, 2009.

[28] C. A. Castillo, “Android Malware Past, Present, and Future,”
White Paper of McAfee Mobile Security Working Group,
2011.
[29] A. P. Felt, M. Finifter, E. Chin, S. Hanna, and D. Wagner, “A
Survey of Mobile Malware in the Wild,” in Proceedings of the
1st ACM workshop on Security and privacy in smartphones
and mobile devices, 2011.
[30] W. Enck, D. Octeau, P. McDaniel, and S. Chaudhuri, “A
Study of Android Application Security,” in Proceedings of
the 20th USENIX conference on Security, 2011.

[31] Y. Zhou and X. Jiang, “Dissecting Android Malware: Char-
acterization and Evolution,” in Proceedings of the 33rd IEEE
Symposium on Security and Privacy, 2012.

[32] Y. Zhou, Z. Wang, W. Zhou, and X. Jiang, “Hey, You, Get
Off of My Market: Detecting Malicious Apps in Ofﬁcial and
Alternative Android Markets,” in Proceedings of the 19th
Annual Network & Distributed System Security Symposium,
2012.
[33] W. Zhou, Y. Zhou, X. Jiang, and P. Ning, “DroidMOSS: De-
tecting Repackaged Smartphone Applications in Third-Party
Android Marketplaces,” in Proceedings of the second ACM
conference on Data and Application Security and Privacy,
2012.
[34] M. Grace, Y. Zhou, Q. Zhang, S. Zou, and X. Jiang,
“RiskRanker: Scalable and Accurate Zero-day Android Mal-
ware Detection,” in Proceedings of the 10th international
conference on Mobile systems, applications, and services,
2012.
[35] P. OKane, S. Sezer, and K. McLaughlin, “Obfuscation: The
Hidden Malware,” IEEE Security and Privacy, 2011.

[36] M. Christodorescu, C. Kruegel, and S. Jha, “Mining Speciﬁ-
cations of Malicious Behavior,” in Proceedings of the the 6th
joint meeting of the European software engineering confer-
ence and the ACM SIGSOFT symposium on The foundations
of software engineering, 2007.

[37] P. M. Comparetti, G. Salvaneschi, E. Kirda, C. Kolbitsch,
C. Kruegel, and S. Zanero, “Identifying Dormant Functional-
ity in Malware Programs,” in Proceedings of the 31st IEEE
Symposium on Security and Privacy, 2010.

