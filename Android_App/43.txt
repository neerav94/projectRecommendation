AdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

AdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid OnlineAdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URLAdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URL3.2 Plagiarized Applications

Using a more scalable tool based on DNADroid [6], we
analyzed our application database to look for plagiarized
applications. While DNADroid is highly precise because it
is based on calculating subgraph isomorphism on PDGs, it
is not scalable because it requires pair-wise comparison of
apps. To avoid pairwise comparison, the tool used for this
work converts each app into a set of semantic vectors, each of
which represents a semantic feature of the program. Then,
the tool clusters the semantic vectors of all the apps using
LSH [1]. Finally, the tool considers a set of apps to be clones
if they share a large number of semantic vector clusters and
places these apps into the same clone cluster.

Each clone cluster contains applications published by dif-
ferent developers, as determined by their signing certi(cid:12)cate.
Each application appears in at most one cluster. In total, we
investigate 5,431 clone clusters consisting of 44,268 unique
applications. These clusters may or may not contain the
\victim" of plagiarism, which we call the \original app" in
this paper. Determining the original application is di(cid:14)cult
and unreliable, as described in Section 6.2.1.
3.3 Network Data

We had access to live 3G network data from a tier-1 cellu-
lar network carrier, which consisted of a sample of all tra(cid:14)c
that passed through a particular home agent in the south-
west United States. Packets were tapped from the home
agent and sent to the carrier’s research lab for capture and
analysis. The tap at the home agent was quarter-sampled
at the (cid:13)ow level, so in theory all packets in a particular
(cid:13)ow were available to be captured; however, packets were
lost from limitations in bandwidth and capture speed of the
tapping infrastructure. The network data included all 3G
internet tra(cid:14)c sent from devices registered on the carrier’s
cellular network, including protocol headers and payload.

We captured HTTP tra(cid:14)c from the tap over the course
of 12 days:
from 28 June 2012 to 10 July 2012. Devices
present on the network include both Android and iOS de-
vices, as well as feature phones and wireless cards. The
tra(cid:14)c characteristics are similar to those in [18]. To opti-
mize the capture, only 32 bytes of the protocol header were
captured along with the payload for each packet. Addition-
ally, we performed IP (cid:12)ltering so that only packets with a
source or destination IP address that corresponded with a
known Android ad server were captured. In total, we cap-
tured 2.6 billions packets in our trace. We describe how we
extract ad request data from the trace in Section 4.1.
4. METHODOLOGY

Figure 1 shows the procedure of our study. Our data came
from two sources: (1) HTTP tra(cid:14)c generated by Android
applications on a US tier-1 cellular network, and (2) An-
droid applications downloaded from Android markets. We
correlated the two datasets using advertising client IDs. In
this section we explain how we extracted these IDs, both
from the network and from applications.
4.1 Extracting Client IDs from Network Traces
We now explain how we extract client IDs from ad re-
quests sent by Android applications. We extract advertising
information from our cellular network trace (described in
Section 3.3) by analyzing ad requests at the packet level as
well as at the (cid:13)ow level. In order to identify ad requests,

we manually ran a sample application for each Android ad
provider and captured all tra(cid:14)c from the device so that we
could characterize the format of each provider’s requests.
From each ad request, we record the ad provider, client
ID, anonymized user identi(cid:12)er, and the application package
name if available. We anonymize user identi(cid:12)ers to avoid
recording any potentially sensitive device identi(cid:12)ers, such
as the IMEI. We only record ad requests with an Android
HTTP User-Agent (cid:12)eld.

To get packet level data, we look at the HTTP header
of each packet to determine if it is an ad request from a
recognized Android ad provider and record relevant adver-
tising information. To analyze ad requests at the (cid:13)ow level,
we use the 32 bytes of protocol header to reconstruct each
TCP (cid:13)ow, allowing us to observe both the ad request and
the response from the server. The bene(cid:12)ts of looking at
ad requests at the (cid:13)ow level are twofold. First, we observed
that ad requests for some ad providers are split across multi-
ple packets, especially when the request uses HTTP POST,
so it would be impossible to record the entire ad request in
this case by only looking at packets individually. Second, the
server response allows us to extract the click URL associated
with each impression so that we can match the impression
with any observed clicks in the trace. These clicks can be
linked to an impression and thus a client ID by using the
click URLs that we parse from each (cid:13)ow.

To extract client IDs, we (cid:12)rst identify the ad provider by
examining the host name in the HTTP request. For each ad
provider, we create a pattern to identify its client IDs in the
HTTP requests accurately.

4.2 Extracting Client IDs from Applications
We extract client IDs from Android applications via static
analysis. Commonly, ad providers require developers to pro-
vide their client ID in one of (cid:12)ve ways: declaring it in the
application’s manifest (cid:12)le, declaring it in a layout XML (cid:12)le,
passing it to an ad object in the application code, specifying
it as a constant string, or receiving it dynamically over the
network.

In Android Manifest

4.2.1
The most straightforward client IDs to extract are those
declared in the Android manifest (cid:12)le. Admob, for exam-
ple, recommends that developers store their client IDs in a
meta-data (cid:12)eld with the name admob publisher id. Usu-
ally the client ID is directly included in the Manifest XML;
however, in some cases there can be extra levels of indi-
rection: Android allows developers to abstract values into
constant (cid:12)les such as string.xml. In cases where the de-
veloper has abstracted the client ID using notation such
as @string/admob_id, we resolve these abstractions accord-
ingly.

In Layout XML

4.2.2
Some ad providers recommend that client IDs be included
in one of the auxiliary XML (cid:12)les that developers generate
for their application (not the manifest). Conveniently for us,
these ad providers usually provide an example for developers
to copy and replace the client ID with their own, which
provides a common naming convention for each ad library.
We take advantage of this convention by using XPATH to
search XML (cid:12)les for speci(cid:12)c XML elements known to contain

AdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URL3.2 Plagiarized Applications

Using a more scalable tool based on DNADroid [6], we
analyzed our application database to look for plagiarized
applications. While DNADroid is highly precise because it
is based on calculating subgraph isomorphism on PDGs, it
is not scalable because it requires pair-wise comparison of
apps. To avoid pairwise comparison, the tool used for this
work converts each app into a set of semantic vectors, each of
which represents a semantic feature of the program. Then,
the tool clusters the semantic vectors of all the apps using
LSH [1]. Finally, the tool considers a set of apps to be clones
if they share a large number of semantic vector clusters and
places these apps into the same clone cluster.

Each clone cluster contains applications published by dif-
ferent developers, as determined by their signing certi(cid:12)cate.
Each application appears in at most one cluster. In total, we
investigate 5,431 clone clusters consisting of 44,268 unique
applications. These clusters may or may not contain the
\victim" of plagiarism, which we call the \original app" in
this paper. Determining the original application is di(cid:14)cult
and unreliable, as described in Section 6.2.1.
3.3 Network Data

We had access to live 3G network data from a tier-1 cellu-
lar network carrier, which consisted of a sample of all tra(cid:14)c
that passed through a particular home agent in the south-
west United States. Packets were tapped from the home
agent and sent to the carrier’s research lab for capture and
analysis. The tap at the home agent was quarter-sampled
at the (cid:13)ow level, so in theory all packets in a particular
(cid:13)ow were available to be captured; however, packets were
lost from limitations in bandwidth and capture speed of the
tapping infrastructure. The network data included all 3G
internet tra(cid:14)c sent from devices registered on the carrier’s
cellular network, including protocol headers and payload.

We captured HTTP tra(cid:14)c from the tap over the course
of 12 days:
from 28 June 2012 to 10 July 2012. Devices
present on the network include both Android and iOS de-
vices, as well as feature phones and wireless cards. The
tra(cid:14)c characteristics are similar to those in [18]. To opti-
mize the capture, only 32 bytes of the protocol header were
captured along with the payload for each packet. Addition-
ally, we performed IP (cid:12)ltering so that only packets with a
source or destination IP address that corresponded with a
known Android ad server were captured. In total, we cap-
tured 2.6 billions packets in our trace. We describe how we
extract ad request data from the trace in Section 4.1.
4. METHODOLOGY

Figure 1 shows the procedure of our study. Our data came
from two sources: (1) HTTP tra(cid:14)c generated by Android
applications on a US tier-1 cellular network, and (2) An-
droid applications downloaded from Android markets. We
correlated the two datasets using advertising client IDs. In
this section we explain how we extracted these IDs, both
from the network and from applications.
4.1 Extracting Client IDs from Network Traces
We now explain how we extract client IDs from ad re-
quests sent by Android applications. We extract advertising
information from our cellular network trace (described in
Section 3.3) by analyzing ad requests at the packet level as
well as at the (cid:13)ow level. In order to identify ad requests,

we manually ran a sample application for each Android ad
provider and captured all tra(cid:14)c from the device so that we
could characterize the format of each provider’s requests.
From each ad request, we record the ad provider, client
ID, anonymized user identi(cid:12)er, and the application package
name if available. We anonymize user identi(cid:12)ers to avoid
recording any potentially sensitive device identi(cid:12)ers, such
as the IMEI. We only record ad requests with an Android
HTTP User-Agent (cid:12)eld.

To get packet level data, we look at the HTTP header
of each packet to determine if it is an ad request from a
recognized Android ad provider and record relevant adver-
tising information. To analyze ad requests at the (cid:13)ow level,
we use the 32 bytes of protocol header to reconstruct each
TCP (cid:13)ow, allowing us to observe both the ad request and
the response from the server. The bene(cid:12)ts of looking at
ad requests at the (cid:13)ow level are twofold. First, we observed
that ad requests for some ad providers are split across multi-
ple packets, especially when the request uses HTTP POST,
so it would be impossible to record the entire ad request in
this case by only looking at packets individually. Second, the
server response allows us to extract the click URL associated
with each impression so that we can match the impression
with any observed clicks in the trace. These clicks can be
linked to an impression and thus a client ID by using the
click URLs that we parse from each (cid:13)ow.

To extract client IDs, we (cid:12)rst identify the ad provider by
examining the host name in the HTTP request. For each ad
provider, we create a pattern to identify its client IDs in the
HTTP requests accurately.

4.2 Extracting Client IDs from Applications
We extract client IDs from Android applications via static
analysis. Commonly, ad providers require developers to pro-
vide their client ID in one of (cid:12)ve ways: declaring it in the
application’s manifest (cid:12)le, declaring it in a layout XML (cid:12)le,
passing it to an ad object in the application code, specifying
it as a constant string, or receiving it dynamically over the
network.

In Android Manifest

4.2.1
The most straightforward client IDs to extract are those
declared in the Android manifest (cid:12)le. Admob, for exam-
ple, recommends that developers store their client IDs in a
meta-data (cid:12)eld with the name admob publisher id. Usu-
ally the client ID is directly included in the Manifest XML;
however, in some cases there can be extra levels of indi-
rection: Android allows developers to abstract values into
constant (cid:12)les such as string.xml. In cases where the de-
veloper has abstracted the client ID using notation such
as @string/admob_id, we resolve these abstractions accord-
ingly.

In Layout XML

4.2.2
Some ad providers recommend that client IDs be included
in one of the auxiliary XML (cid:12)les that developers generate
for their application (not the manifest). Conveniently for us,
these ad providers usually provide an example for developers
to copy and replace the client ID with their own, which
provides a common naming convention for each ad library.
We take advantage of this convention by using XPATH to
search XML (cid:12)les for speci(cid:12)c XML elements known to contain

(a) Initial owners based on devel-
oper accounts (Phase 1)

(b) Owners with edges based on shared certi(cid:12)-
cates (s) and client IDs (c)

(c) Owners after merging (Phases 2
and 3)

Figure 3: Owner graph at various stages in owner merging.

client IDs. For example, Jumptap client IDs are usually in
a (cid:12)eld called jumptaplib:publisherid.

4.2.3 In Application Code
Client IDs that applications pass directly to ad library ini-
tialization methods are the most challenging to extract. The
initialization may happen at any point in the code and the
client ID may be instantiated in a number of ways, includ-
ing being passed in as a constant, received over the network,
generated dynamically, or read in from a (cid:12)le. We observed
that the (cid:12)rst two are the most common cases and focus on
them accordingly.

Speciﬁed as Constants.

We dump values from the DEX string constants section in
the application’s dex (cid:12)le and search for strings that match
the structure of client IDs for each ad library. This approach
is e(cid:11)ective for ad providers whose client IDs follow a distinc-
tive pattern. To improve the precision of this analysis, we
also implemented a static analysis tool that performs con-
stant propagation to detect when constant values are passed
to the client ID argument of ad library initialization meth-
ods. Unfortunately, we found it too slow to run on all of the
apps in our dataset, as it took several minutes per app. We
leave improving the precision of extracting constant-based
client IDs in this manner to future work.

Received Over the Network.

In addition to ad libraries, many applications include Ad-
whirl’s SDK. Adwhirl is not an ad provider, but rather o(cid:11)ers
a service that allows developers to dynamically decide which
ad provider and client ID should be used in their ad requests.
Before an application with Adwhirl makes an ad request, it
queries Adwhirl with its Adwhirl client ID and receives a set
of ad providers and client IDs, which the application then
uses to send ad requests. This service allows developers to
dynamically change the advertising behavior of their apps
without having to push a new version of their app. We han-
dle apps that use Adwhirl by (cid:12)rst extracting Adwhirl client
IDs from the application. Then, we query Adwhirl’s server
to obtain a mapping from an Adwhirl client ID to a set of
client IDs and their ad providers. This allows us to obtain
many client IDs not hardcoded in the applications.

From our application database, we extracted 1,386 unique

Adwhirl client IDs, which mapped to 1,886 unique client
IDs from one of the (cid:12)ve ad providers we eventually used in
this paper (described in Section 5.1). Of these, 1,539 (or
81.6%) were new client IDs that we had not extracted from
our applications. Speci(cid:12)cally, 764 were for admob, 523 for
millennial, and 252 for inmobi.

4.3 Determining Ownership

As our goal is to measure the impact of plagiarism on
developers, we must not regard as plagiarism similar apps
from the same developer, known as rebranded apps. Re-
branded apps may appear on the same or di(cid:11)erent markets.
In this section we discuss how we determine app ownership
by considering developer accounts, signing keys (represented
by certi(cid:12)cates), and client IDs. We make the following as-
sumptions: (cid:12)rst, each owner has her own unique set of cer-
ti(cid:12)cates that are not shared with any other owner; second,
each owner has her own unique set of client IDs that are
not shared with any other owner. In Section 7.1.1 we dis-
cuss caveats associated with these assumptions. Note, how-
ever, that these caveats only cause us to merge owners more
aggressively, resulting in lowering our measured cloning im-
pact.

Merging owners consists of three phases. First, we build
an owner graph where each node corresponds to a unique
developer account that has uploaded an application that we
crawled (Phase 1). Next, we merge owners based on shared
certi(cid:12)cates (Phase 2). Finally, we merge owners based on
shared client IDs (Phase 3). An overview of the owner graph
at various steps in the process is shown in Figure 3.

Phase 1: The (cid:12)rst phase of merging owners is to create a
graph with a node for each unique developer account. Each
developer account is identi(cid:12)ed by the tuple of the market
name and the developer’s name and is associated with one
or more apps in our database. Assuming that developer
accounts are rarely compromised, then two apps from the
same developer account must come from the same owner.
Thus, developer accounts provide an initial mapping of apps
to owners.

Phase 2: Next, we compute the set of certi(cid:12)cates whose
corresponding private keys were used to sign the apps up-
loaded by each developer account. As mentioned in Sec-
tion 2, every Android app must be signed by the developer’s
private key before it may be uploaded to a market and then

A1A5A6A9A10A2A7A3A8A4A1A5s1A6c1A9c1c1A10s4A2A7c2s2A3A8s3A4A1,A5,A6,A9,A10A2,A7A3,A8A4AdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URL3.2 Plagiarized Applications

Using a more scalable tool based on DNADroid [6], we
analyzed our application database to look for plagiarized
applications. While DNADroid is highly precise because it
is based on calculating subgraph isomorphism on PDGs, it
is not scalable because it requires pair-wise comparison of
apps. To avoid pairwise comparison, the tool used for this
work converts each app into a set of semantic vectors, each of
which represents a semantic feature of the program. Then,
the tool clusters the semantic vectors of all the apps using
LSH [1]. Finally, the tool considers a set of apps to be clones
if they share a large number of semantic vector clusters and
places these apps into the same clone cluster.

Each clone cluster contains applications published by dif-
ferent developers, as determined by their signing certi(cid:12)cate.
Each application appears in at most one cluster. In total, we
investigate 5,431 clone clusters consisting of 44,268 unique
applications. These clusters may or may not contain the
\victim" of plagiarism, which we call the \original app" in
this paper. Determining the original application is di(cid:14)cult
and unreliable, as described in Section 6.2.1.
3.3 Network Data

We had access to live 3G network data from a tier-1 cellu-
lar network carrier, which consisted of a sample of all tra(cid:14)c
that passed through a particular home agent in the south-
west United States. Packets were tapped from the home
agent and sent to the carrier’s research lab for capture and
analysis. The tap at the home agent was quarter-sampled
at the (cid:13)ow level, so in theory all packets in a particular
(cid:13)ow were available to be captured; however, packets were
lost from limitations in bandwidth and capture speed of the
tapping infrastructure. The network data included all 3G
internet tra(cid:14)c sent from devices registered on the carrier’s
cellular network, including protocol headers and payload.

We captured HTTP tra(cid:14)c from the tap over the course
of 12 days:
from 28 June 2012 to 10 July 2012. Devices
present on the network include both Android and iOS de-
vices, as well as feature phones and wireless cards. The
tra(cid:14)c characteristics are similar to those in [18]. To opti-
mize the capture, only 32 bytes of the protocol header were
captured along with the payload for each packet. Addition-
ally, we performed IP (cid:12)ltering so that only packets with a
source or destination IP address that corresponded with a
known Android ad server were captured. In total, we cap-
tured 2.6 billions packets in our trace. We describe how we
extract ad request data from the trace in Section 4.1.
4. METHODOLOGY

Figure 1 shows the procedure of our study. Our data came
from two sources: (1) HTTP tra(cid:14)c generated by Android
applications on a US tier-1 cellular network, and (2) An-
droid applications downloaded from Android markets. We
correlated the two datasets using advertising client IDs. In
this section we explain how we extracted these IDs, both
from the network and from applications.
4.1 Extracting Client IDs from Network Traces
We now explain how we extract client IDs from ad re-
quests sent by Android applications. We extract advertising
information from our cellular network trace (described in
Section 3.3) by analyzing ad requests at the packet level as
well as at the (cid:13)ow level. In order to identify ad requests,

we manually ran a sample application for each Android ad
provider and captured all tra(cid:14)c from the device so that we
could characterize the format of each provider’s requests.
From each ad request, we record the ad provider, client
ID, anonymized user identi(cid:12)er, and the application package
name if available. We anonymize user identi(cid:12)ers to avoid
recording any potentially sensitive device identi(cid:12)ers, such
as the IMEI. We only record ad requests with an Android
HTTP User-Agent (cid:12)eld.

To get packet level data, we look at the HTTP header
of each packet to determine if it is an ad request from a
recognized Android ad provider and record relevant adver-
tising information. To analyze ad requests at the (cid:13)ow level,
we use the 32 bytes of protocol header to reconstruct each
TCP (cid:13)ow, allowing us to observe both the ad request and
the response from the server. The bene(cid:12)ts of looking at
ad requests at the (cid:13)ow level are twofold. First, we observed
that ad requests for some ad providers are split across multi-
ple packets, especially when the request uses HTTP POST,
so it would be impossible to record the entire ad request in
this case by only looking at packets individually. Second, the
server response allows us to extract the click URL associated
with each impression so that we can match the impression
with any observed clicks in the trace. These clicks can be
linked to an impression and thus a client ID by using the
click URLs that we parse from each (cid:13)ow.

To extract client IDs, we (cid:12)rst identify the ad provider by
examining the host name in the HTTP request. For each ad
provider, we create a pattern to identify its client IDs in the
HTTP requests accurately.

4.2 Extracting Client IDs from Applications
We extract client IDs from Android applications via static
analysis. Commonly, ad providers require developers to pro-
vide their client ID in one of (cid:12)ve ways: declaring it in the
application’s manifest (cid:12)le, declaring it in a layout XML (cid:12)le,
passing it to an ad object in the application code, specifying
it as a constant string, or receiving it dynamically over the
network.

In Android Manifest

4.2.1
The most straightforward client IDs to extract are those
declared in the Android manifest (cid:12)le. Admob, for exam-
ple, recommends that developers store their client IDs in a
meta-data (cid:12)eld with the name admob publisher id. Usu-
ally the client ID is directly included in the Manifest XML;
however, in some cases there can be extra levels of indi-
rection: Android allows developers to abstract values into
constant (cid:12)les such as string.xml. In cases where the de-
veloper has abstracted the client ID using notation such
as @string/admob_id, we resolve these abstractions accord-
ingly.

In Layout XML

4.2.2
Some ad providers recommend that client IDs be included
in one of the auxiliary XML (cid:12)les that developers generate
for their application (not the manifest). Conveniently for us,
these ad providers usually provide an example for developers
to copy and replace the client ID with their own, which
provides a common naming convention for each ad library.
We take advantage of this convention by using XPATH to
search XML (cid:12)les for speci(cid:12)c XML elements known to contain

(a) Initial owners based on devel-
oper accounts (Phase 1)

(b) Owners with edges based on shared certi(cid:12)-
cates (s) and client IDs (c)

(c) Owners after merging (Phases 2
and 3)

Figure 3: Owner graph at various stages in owner merging.

client IDs. For example, Jumptap client IDs are usually in
a (cid:12)eld called jumptaplib:publisherid.

4.2.3 In Application Code
Client IDs that applications pass directly to ad library ini-
tialization methods are the most challenging to extract. The
initialization may happen at any point in the code and the
client ID may be instantiated in a number of ways, includ-
ing being passed in as a constant, received over the network,
generated dynamically, or read in from a (cid:12)le. We observed
that the (cid:12)rst two are the most common cases and focus on
them accordingly.

Speciﬁed as Constants.

We dump values from the DEX string constants section in
the application’s dex (cid:12)le and search for strings that match
the structure of client IDs for each ad library. This approach
is e(cid:11)ective for ad providers whose client IDs follow a distinc-
tive pattern. To improve the precision of this analysis, we
also implemented a static analysis tool that performs con-
stant propagation to detect when constant values are passed
to the client ID argument of ad library initialization meth-
ods. Unfortunately, we found it too slow to run on all of the
apps in our dataset, as it took several minutes per app. We
leave improving the precision of extracting constant-based
client IDs in this manner to future work.

Received Over the Network.

In addition to ad libraries, many applications include Ad-
whirl’s SDK. Adwhirl is not an ad provider, but rather o(cid:11)ers
a service that allows developers to dynamically decide which
ad provider and client ID should be used in their ad requests.
Before an application with Adwhirl makes an ad request, it
queries Adwhirl with its Adwhirl client ID and receives a set
of ad providers and client IDs, which the application then
uses to send ad requests. This service allows developers to
dynamically change the advertising behavior of their apps
without having to push a new version of their app. We han-
dle apps that use Adwhirl by (cid:12)rst extracting Adwhirl client
IDs from the application. Then, we query Adwhirl’s server
to obtain a mapping from an Adwhirl client ID to a set of
client IDs and their ad providers. This allows us to obtain
many client IDs not hardcoded in the applications.

From our application database, we extracted 1,386 unique

Adwhirl client IDs, which mapped to 1,886 unique client
IDs from one of the (cid:12)ve ad providers we eventually used in
this paper (described in Section 5.1). Of these, 1,539 (or
81.6%) were new client IDs that we had not extracted from
our applications. Speci(cid:12)cally, 764 were for admob, 523 for
millennial, and 252 for inmobi.

4.3 Determining Ownership

As our goal is to measure the impact of plagiarism on
developers, we must not regard as plagiarism similar apps
from the same developer, known as rebranded apps. Re-
branded apps may appear on the same or di(cid:11)erent markets.
In this section we discuss how we determine app ownership
by considering developer accounts, signing keys (represented
by certi(cid:12)cates), and client IDs. We make the following as-
sumptions: (cid:12)rst, each owner has her own unique set of cer-
ti(cid:12)cates that are not shared with any other owner; second,
each owner has her own unique set of client IDs that are
not shared with any other owner. In Section 7.1.1 we dis-
cuss caveats associated with these assumptions. Note, how-
ever, that these caveats only cause us to merge owners more
aggressively, resulting in lowering our measured cloning im-
pact.

Merging owners consists of three phases. First, we build
an owner graph where each node corresponds to a unique
developer account that has uploaded an application that we
crawled (Phase 1). Next, we merge owners based on shared
certi(cid:12)cates (Phase 2). Finally, we merge owners based on
shared client IDs (Phase 3). An overview of the owner graph
at various steps in the process is shown in Figure 3.

Phase 1: The (cid:12)rst phase of merging owners is to create a
graph with a node for each unique developer account. Each
developer account is identi(cid:12)ed by the tuple of the market
name and the developer’s name and is associated with one
or more apps in our database. Assuming that developer
accounts are rarely compromised, then two apps from the
same developer account must come from the same owner.
Thus, developer accounts provide an initial mapping of apps
to owners.

Phase 2: Next, we compute the set of certi(cid:12)cates whose
corresponding private keys were used to sign the apps up-
loaded by each developer account. As mentioned in Sec-
tion 2, every Android app must be signed by the developer’s
private key before it may be uploaded to a market and then

A1A5A6A9A10A2A7A3A8A4A1A5s1A6c1A9c1c1A10s4A2A7c2s2A3A8s3A4A1,A5,A6,A9,A10A2,A7A3,A8A4Provider
admob
airpush
inmobi
millennial
mobclix

Impressions Clicks Unique IDs
348,275
138,166
n/a
61,127
32,751

9,288,333
(cid:3)
3,212,878
(cid:3)
220,982
4,855,247
1,547,871

920
n/a
207
n/a
1,080

Table 2: Number of observed impressions, clicks, and
anonymized user identi(cid:12)ers in the network trace, broken
down by ad provider. The report of impression counts uses
packet level ad request analysis, unless otherwise noted (via
(cid:3)
). Note that we were not able to measure clicks for all
providers due to the format of their ad requests (for exam-
ple, those with chunked HTTP encoding). Also note that
inmobi does not include a user identi(cid:12)er in their ad requests.

installed on users’ phones. Since private keys are supposed
to be kept private (we discuss shared and stolen private keys
in Section 7.1.1), two developer accounts that share a cer-
ti(cid:12)cate must share the same owner so they are merged in
the graph.

Phase 3: Finally, we merge any two owners whose appli-
cations share a client ID. Client IDs are used by ad providers
to uniquely identify who should receive revenue for each ad
shown or clicked. Therefore, if two developer accounts share
a client ID, they are likely to be from the same owner.

We separate the merging of owners by certi(cid:12)cates and
client IDs into two phases because we have lower con(cid:12)dence
about merges based on client IDs. This is because client
ID extraction may have false positives while certi(cid:12)cate cal-
culation cannot. Other situations, such as a plagiarist who
leaves the original developer’s client ID intact, are discussed
in Section 7.1.1.

5. EVALUATION

In this section we summarize the raw results of our anal-
ysis and determine the accuracy of our application client ID
extraction.
5.1 Network Client ID Extraction

One important consideration of our work is which Android
ad providers to include in our analysis. We started with 16
ad providers based on their popularity in our application
database. Among these ad providers, seven1 had very small
number of ad requests in our captured tra(cid:14)c (some of them
are Chinese but our tra(cid:14)c was captured in the US), and four
had very little overlap between the client IDs observed on
the network and client IDs extracted from our application
database (Table 1)2. Therefore, we focus on the remaining
(cid:12)ve ad providers, whose number of impressions, clicks, and
unique user identi(cid:12)ers are summarized in Table 2. These
(cid:12)ve ad providers are also among the top six most prevalent
Android ad libraries reported by AppBrain [3]. Because our
network capture was lossy, we were not able to record signif-
icant click results from the trace, as we could only measure
clicks when the ad request, server response, and then click
request did not experience any loss.

1Buzzcity, Mojiva, Quattro, Vdopia, Wooboo, Youmi, Zes-
tAdz
2These four providers only represented 7% of the total num-
ber of ad requests we collected.

5.2 Application Client ID Extraction

While extracting client IDs from HTTP tra(cid:14)c generated
by Android applications is highly accurate, extracting them
automatically from Android applications themselves may
not be as reliable, because client IDs may be provided in sev-
eral di(cid:11)erent ways, some of which are unfriendly to program
analysis (Section 4). Therefore, we would like to evaluate the
accuracy of our client IDs extracted from Android applica-
tions. However, it is di(cid:14)cult to determine the ground truth,
because doing so would require us to manually review all the
applications, which is prohibitive given our large number of
applications. One might suggest that we run each applica-
tion in an emulator to extract the client IDs from its HTTP
tra(cid:14)c. However, an application may contain multiple ad li-
braries, so we may not observe the client IDs from all these
libraries during the execution of the application. Moreover,
some ad libraries would not send ad requests if they detect
that they are running in emulators.

Instead, we take advantage of the client IDs extracted
from HTTP tra(cid:14)c to estimate a lower bound of the accuracy
of our client ID extraction from applications. For each ad
provider AP, let DAP be the set of client IDs extracted from
our application databases, and NAP be the set of client IDs
extracted from our captured HTTP tra(cid:14)c. The network cov-
erage, jNAP \ DAPj=jDAPj, estimates a lower bound of the
true positive rate of our client ID extraction from applica-
tions. The database coverage, jDAP \NAPj=jNAPj, estimates
the coverage our application database on all the Android ap-
plications running on the network where we captured traces.
The results of this analysis are summarized in Table 1.
The database coverages for most providers are fairly high,
indicating that our application database represents a signif-
icant portion of all ad-supported Android applications that
are used in the geographic area where we collected the trace.
6. FINDINGS
6.1 Properties of Apps in Clone Clusters

There are a number of questions that come to mind when
investigating our clone clusters: Which markets do apps in
the clusters belong to? Which markets have the highest
proportion of apps involved in cloning? What categories are
most represented in the clusters? What advertising libraries
do cloners prefer? In this section we seek to answer these
questions by investigating common features of apps in our
clone clusters. Note, at this point we do not yet speculate as
to which app in each clone cluster is the original and which
are clones.
6.1.1 Market Characteristics
Figure 4 shows which Android markets are most preva-
lent in our clone clusters. A signi(cid:12)cant percentage of apps
in our clone clusters are from Google Play; intuitively this
makes sense as Play is the most popular Android market.
To compensate for this observation, we computed what per-
centage of all applications in our database from the mar-
ket are present in a clone cluster.
In this context, Play
does not stand out more than other markets, but a num-
ber of other markets such as AndroidSoft, and the Chinese
markets AndroidOnline, GoApk, and AppChina, have more
than a quarter of their apps in our clone clusters. To bet-
ter understand the cloning relationship between markets, we
calculated the number of similar apps between each pair of

AdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URL3.2 Plagiarized Applications

Using a more scalable tool based on DNADroid [6], we
analyzed our application database to look for plagiarized
applications. While DNADroid is highly precise because it
is based on calculating subgraph isomorphism on PDGs, it
is not scalable because it requires pair-wise comparison of
apps. To avoid pairwise comparison, the tool used for this
work converts each app into a set of semantic vectors, each of
which represents a semantic feature of the program. Then,
the tool clusters the semantic vectors of all the apps using
LSH [1]. Finally, the tool considers a set of apps to be clones
if they share a large number of semantic vector clusters and
places these apps into the same clone cluster.

Each clone cluster contains applications published by dif-
ferent developers, as determined by their signing certi(cid:12)cate.
Each application appears in at most one cluster. In total, we
investigate 5,431 clone clusters consisting of 44,268 unique
applications. These clusters may or may not contain the
\victim" of plagiarism, which we call the \original app" in
this paper. Determining the original application is di(cid:14)cult
and unreliable, as described in Section 6.2.1.
3.3 Network Data

We had access to live 3G network data from a tier-1 cellu-
lar network carrier, which consisted of a sample of all tra(cid:14)c
that passed through a particular home agent in the south-
west United States. Packets were tapped from the home
agent and sent to the carrier’s research lab for capture and
analysis. The tap at the home agent was quarter-sampled
at the (cid:13)ow level, so in theory all packets in a particular
(cid:13)ow were available to be captured; however, packets were
lost from limitations in bandwidth and capture speed of the
tapping infrastructure. The network data included all 3G
internet tra(cid:14)c sent from devices registered on the carrier’s
cellular network, including protocol headers and payload.

We captured HTTP tra(cid:14)c from the tap over the course
of 12 days:
from 28 June 2012 to 10 July 2012. Devices
present on the network include both Android and iOS de-
vices, as well as feature phones and wireless cards. The
tra(cid:14)c characteristics are similar to those in [18]. To opti-
mize the capture, only 32 bytes of the protocol header were
captured along with the payload for each packet. Addition-
ally, we performed IP (cid:12)ltering so that only packets with a
source or destination IP address that corresponded with a
known Android ad server were captured. In total, we cap-
tured 2.6 billions packets in our trace. We describe how we
extract ad request data from the trace in Section 4.1.
4. METHODOLOGY

Figure 1 shows the procedure of our study. Our data came
from two sources: (1) HTTP tra(cid:14)c generated by Android
applications on a US tier-1 cellular network, and (2) An-
droid applications downloaded from Android markets. We
correlated the two datasets using advertising client IDs. In
this section we explain how we extracted these IDs, both
from the network and from applications.
4.1 Extracting Client IDs from Network Traces
We now explain how we extract client IDs from ad re-
quests sent by Android applications. We extract advertising
information from our cellular network trace (described in
Section 3.3) by analyzing ad requests at the packet level as
well as at the (cid:13)ow level. In order to identify ad requests,

we manually ran a sample application for each Android ad
provider and captured all tra(cid:14)c from the device so that we
could characterize the format of each provider’s requests.
From each ad request, we record the ad provider, client
ID, anonymized user identi(cid:12)er, and the application package
name if available. We anonymize user identi(cid:12)ers to avoid
recording any potentially sensitive device identi(cid:12)ers, such
as the IMEI. We only record ad requests with an Android
HTTP User-Agent (cid:12)eld.

To get packet level data, we look at the HTTP header
of each packet to determine if it is an ad request from a
recognized Android ad provider and record relevant adver-
tising information. To analyze ad requests at the (cid:13)ow level,
we use the 32 bytes of protocol header to reconstruct each
TCP (cid:13)ow, allowing us to observe both the ad request and
the response from the server. The bene(cid:12)ts of looking at
ad requests at the (cid:13)ow level are twofold. First, we observed
that ad requests for some ad providers are split across multi-
ple packets, especially when the request uses HTTP POST,
so it would be impossible to record the entire ad request in
this case by only looking at packets individually. Second, the
server response allows us to extract the click URL associated
with each impression so that we can match the impression
with any observed clicks in the trace. These clicks can be
linked to an impression and thus a client ID by using the
click URLs that we parse from each (cid:13)ow.

To extract client IDs, we (cid:12)rst identify the ad provider by
examining the host name in the HTTP request. For each ad
provider, we create a pattern to identify its client IDs in the
HTTP requests accurately.

4.2 Extracting Client IDs from Applications
We extract client IDs from Android applications via static
analysis. Commonly, ad providers require developers to pro-
vide their client ID in one of (cid:12)ve ways: declaring it in the
application’s manifest (cid:12)le, declaring it in a layout XML (cid:12)le,
passing it to an ad object in the application code, specifying
it as a constant string, or receiving it dynamically over the
network.

In Android Manifest

4.2.1
The most straightforward client IDs to extract are those
declared in the Android manifest (cid:12)le. Admob, for exam-
ple, recommends that developers store their client IDs in a
meta-data (cid:12)eld with the name admob publisher id. Usu-
ally the client ID is directly included in the Manifest XML;
however, in some cases there can be extra levels of indi-
rection: Android allows developers to abstract values into
constant (cid:12)les such as string.xml. In cases where the de-
veloper has abstracted the client ID using notation such
as @string/admob_id, we resolve these abstractions accord-
ingly.

In Layout XML

4.2.2
Some ad providers recommend that client IDs be included
in one of the auxiliary XML (cid:12)les that developers generate
for their application (not the manifest). Conveniently for us,
these ad providers usually provide an example for developers
to copy and replace the client ID with their own, which
provides a common naming convention for each ad library.
We take advantage of this convention by using XPATH to
search XML (cid:12)les for speci(cid:12)c XML elements known to contain

(a) Initial owners based on devel-
oper accounts (Phase 1)

(b) Owners with edges based on shared certi(cid:12)-
cates (s) and client IDs (c)

(c) Owners after merging (Phases 2
and 3)

Figure 3: Owner graph at various stages in owner merging.

client IDs. For example, Jumptap client IDs are usually in
a (cid:12)eld called jumptaplib:publisherid.

4.2.3 In Application Code
Client IDs that applications pass directly to ad library ini-
tialization methods are the most challenging to extract. The
initialization may happen at any point in the code and the
client ID may be instantiated in a number of ways, includ-
ing being passed in as a constant, received over the network,
generated dynamically, or read in from a (cid:12)le. We observed
that the (cid:12)rst two are the most common cases and focus on
them accordingly.

Speciﬁed as Constants.

We dump values from the DEX string constants section in
the application’s dex (cid:12)le and search for strings that match
the structure of client IDs for each ad library. This approach
is e(cid:11)ective for ad providers whose client IDs follow a distinc-
tive pattern. To improve the precision of this analysis, we
also implemented a static analysis tool that performs con-
stant propagation to detect when constant values are passed
to the client ID argument of ad library initialization meth-
ods. Unfortunately, we found it too slow to run on all of the
apps in our dataset, as it took several minutes per app. We
leave improving the precision of extracting constant-based
client IDs in this manner to future work.

Received Over the Network.

In addition to ad libraries, many applications include Ad-
whirl’s SDK. Adwhirl is not an ad provider, but rather o(cid:11)ers
a service that allows developers to dynamically decide which
ad provider and client ID should be used in their ad requests.
Before an application with Adwhirl makes an ad request, it
queries Adwhirl with its Adwhirl client ID and receives a set
of ad providers and client IDs, which the application then
uses to send ad requests. This service allows developers to
dynamically change the advertising behavior of their apps
without having to push a new version of their app. We han-
dle apps that use Adwhirl by (cid:12)rst extracting Adwhirl client
IDs from the application. Then, we query Adwhirl’s server
to obtain a mapping from an Adwhirl client ID to a set of
client IDs and their ad providers. This allows us to obtain
many client IDs not hardcoded in the applications.

From our application database, we extracted 1,386 unique

Adwhirl client IDs, which mapped to 1,886 unique client
IDs from one of the (cid:12)ve ad providers we eventually used in
this paper (described in Section 5.1). Of these, 1,539 (or
81.6%) were new client IDs that we had not extracted from
our applications. Speci(cid:12)cally, 764 were for admob, 523 for
millennial, and 252 for inmobi.

4.3 Determining Ownership

As our goal is to measure the impact of plagiarism on
developers, we must not regard as plagiarism similar apps
from the same developer, known as rebranded apps. Re-
branded apps may appear on the same or di(cid:11)erent markets.
In this section we discuss how we determine app ownership
by considering developer accounts, signing keys (represented
by certi(cid:12)cates), and client IDs. We make the following as-
sumptions: (cid:12)rst, each owner has her own unique set of cer-
ti(cid:12)cates that are not shared with any other owner; second,
each owner has her own unique set of client IDs that are
not shared with any other owner. In Section 7.1.1 we dis-
cuss caveats associated with these assumptions. Note, how-
ever, that these caveats only cause us to merge owners more
aggressively, resulting in lowering our measured cloning im-
pact.

Merging owners consists of three phases. First, we build
an owner graph where each node corresponds to a unique
developer account that has uploaded an application that we
crawled (Phase 1). Next, we merge owners based on shared
certi(cid:12)cates (Phase 2). Finally, we merge owners based on
shared client IDs (Phase 3). An overview of the owner graph
at various steps in the process is shown in Figure 3.

Phase 1: The (cid:12)rst phase of merging owners is to create a
graph with a node for each unique developer account. Each
developer account is identi(cid:12)ed by the tuple of the market
name and the developer’s name and is associated with one
or more apps in our database. Assuming that developer
accounts are rarely compromised, then two apps from the
same developer account must come from the same owner.
Thus, developer accounts provide an initial mapping of apps
to owners.

Phase 2: Next, we compute the set of certi(cid:12)cates whose
corresponding private keys were used to sign the apps up-
loaded by each developer account. As mentioned in Sec-
tion 2, every Android app must be signed by the developer’s
private key before it may be uploaded to a market and then

A1A5A6A9A10A2A7A3A8A4A1A5s1A6c1A9c1c1A10s4A2A7c2s2A3A8s3A4A1,A5,A6,A9,A10A2,A7A3,A8A4Provider
admob
airpush
inmobi
millennial
mobclix

Impressions Clicks Unique IDs
348,275
138,166
n/a
61,127
32,751

9,288,333
(cid:3)
3,212,878
(cid:3)
220,982
4,855,247
1,547,871

920
n/a
207
n/a
1,080

Table 2: Number of observed impressions, clicks, and
anonymized user identi(cid:12)ers in the network trace, broken
down by ad provider. The report of impression counts uses
packet level ad request analysis, unless otherwise noted (via
(cid:3)
). Note that we were not able to measure clicks for all
providers due to the format of their ad requests (for exam-
ple, those with chunked HTTP encoding). Also note that
inmobi does not include a user identi(cid:12)er in their ad requests.

installed on users’ phones. Since private keys are supposed
to be kept private (we discuss shared and stolen private keys
in Section 7.1.1), two developer accounts that share a cer-
ti(cid:12)cate must share the same owner so they are merged in
the graph.

Phase 3: Finally, we merge any two owners whose appli-
cations share a client ID. Client IDs are used by ad providers
to uniquely identify who should receive revenue for each ad
shown or clicked. Therefore, if two developer accounts share
a client ID, they are likely to be from the same owner.

We separate the merging of owners by certi(cid:12)cates and
client IDs into two phases because we have lower con(cid:12)dence
about merges based on client IDs. This is because client
ID extraction may have false positives while certi(cid:12)cate cal-
culation cannot. Other situations, such as a plagiarist who
leaves the original developer’s client ID intact, are discussed
in Section 7.1.1.

5. EVALUATION

In this section we summarize the raw results of our anal-
ysis and determine the accuracy of our application client ID
extraction.
5.1 Network Client ID Extraction

One important consideration of our work is which Android
ad providers to include in our analysis. We started with 16
ad providers based on their popularity in our application
database. Among these ad providers, seven1 had very small
number of ad requests in our captured tra(cid:14)c (some of them
are Chinese but our tra(cid:14)c was captured in the US), and four
had very little overlap between the client IDs observed on
the network and client IDs extracted from our application
database (Table 1)2. Therefore, we focus on the remaining
(cid:12)ve ad providers, whose number of impressions, clicks, and
unique user identi(cid:12)ers are summarized in Table 2. These
(cid:12)ve ad providers are also among the top six most prevalent
Android ad libraries reported by AppBrain [3]. Because our
network capture was lossy, we were not able to record signif-
icant click results from the trace, as we could only measure
clicks when the ad request, server response, and then click
request did not experience any loss.

1Buzzcity, Mojiva, Quattro, Vdopia, Wooboo, Youmi, Zes-
tAdz
2These four providers only represented 7% of the total num-
ber of ad requests we collected.

5.2 Application Client ID Extraction

While extracting client IDs from HTTP tra(cid:14)c generated
by Android applications is highly accurate, extracting them
automatically from Android applications themselves may
not be as reliable, because client IDs may be provided in sev-
eral di(cid:11)erent ways, some of which are unfriendly to program
analysis (Section 4). Therefore, we would like to evaluate the
accuracy of our client IDs extracted from Android applica-
tions. However, it is di(cid:14)cult to determine the ground truth,
because doing so would require us to manually review all the
applications, which is prohibitive given our large number of
applications. One might suggest that we run each applica-
tion in an emulator to extract the client IDs from its HTTP
tra(cid:14)c. However, an application may contain multiple ad li-
braries, so we may not observe the client IDs from all these
libraries during the execution of the application. Moreover,
some ad libraries would not send ad requests if they detect
that they are running in emulators.

Instead, we take advantage of the client IDs extracted
from HTTP tra(cid:14)c to estimate a lower bound of the accuracy
of our client ID extraction from applications. For each ad
provider AP, let DAP be the set of client IDs extracted from
our application databases, and NAP be the set of client IDs
extracted from our captured HTTP tra(cid:14)c. The network cov-
erage, jNAP \ DAPj=jDAPj, estimates a lower bound of the
true positive rate of our client ID extraction from applica-
tions. The database coverage, jDAP \NAPj=jNAPj, estimates
the coverage our application database on all the Android ap-
plications running on the network where we captured traces.
The results of this analysis are summarized in Table 1.
The database coverages for most providers are fairly high,
indicating that our application database represents a signif-
icant portion of all ad-supported Android applications that
are used in the geographic area where we collected the trace.
6. FINDINGS
6.1 Properties of Apps in Clone Clusters

There are a number of questions that come to mind when
investigating our clone clusters: Which markets do apps in
the clusters belong to? Which markets have the highest
proportion of apps involved in cloning? What categories are
most represented in the clusters? What advertising libraries
do cloners prefer? In this section we seek to answer these
questions by investigating common features of apps in our
clone clusters. Note, at this point we do not yet speculate as
to which app in each clone cluster is the original and which
are clones.
6.1.1 Market Characteristics
Figure 4 shows which Android markets are most preva-
lent in our clone clusters. A signi(cid:12)cant percentage of apps
in our clone clusters are from Google Play; intuitively this
makes sense as Play is the most popular Android market.
To compensate for this observation, we computed what per-
centage of all applications in our database from the mar-
ket are present in a clone cluster.
In this context, Play
does not stand out more than other markets, but a num-
ber of other markets such as AndroidSoft, and the Chinese
markets AndroidOnline, GoApk, and AppChina, have more
than a quarter of their apps in our clone clusters. To bet-
ter understand the cloning relationship between markets, we
calculated the number of similar apps between each pair of

Ad Provider

admob
airpush
inmobi
millennial
mobclix
adfonic
greystripe
jumptap
smaato

Unique client IDs

from databases
51,434
8,728
514
786
2,994
59,170
59,616
8
0

from network
19,718
8,829
487
2,030
1,781
318
212
78
144

Network coverage Database coverage

21.2%
36.9%
28.6%
32.6%
38.0%
0.0%
0.3%
0.0%
n/a

55.4%
36.5%
30.2%
12.6%
63.9%
0.0%
68.4%
0.0%
0.0%

Table 1: Percentage of extracted client IDs we observed in network tra(cid:14)c and percentage of observed network client IDs we
also extracted from the application database, broken down by provider. The lower group of providers are ones which we did
not include in our study because they did not have signi(cid:12)cant overlap with our application database.

Figure 4: Plot showing the popularity of di(cid:11)erent app mar-
kets in our clone clusters. The absolute number of cloned
apps from each market is represented by the axis labelled
\Number of cloned apps", whereas the axis labelled \Per-
centage of apps that are clones" represents the popularity of
each market in our clone clusters normalized over the total
number of apps from that market in our database.

Figure 5: Plot showing the popularity of di(cid:11)erent app cate-
gories in our clone clusters. The absolute number of cloned
apps in each category is represented by the axis labelled
\Number of cloned apps", whereas axis labelled \Percent-
age of apps that are clones" represents the number of cloned
apps in each category normalized over the total number of
apps in that category in our database.

markets in a clone cluster. Speci(cid:12)cally, for the apps in given
clone cluster and a pair of markets (I; J):

M arketSimcluster(I; J) = min(apps from I; apps from J)

Then, to get a global view of the amount of similar appli-

cations between markets we calculate the total M arketSim(I; J)
as follows:

∑

M arketSim(I; J) =

M arketSimc(I; J)

c2clusters

In Figure 7, we plot the results of this calculation in an
undirected graph. To reduce the complexity of the graph,

we only show an edge between markets whose M arketSim
value is over 300 and remove unconnected markets.

We de(cid:12)ne a market as a \cloning hub" if it shares an edge
with many di(cid:11)erent markets in the graph. Play is the largest
cloning hub among all the markets, as it has a signi(cid:12)cant
cloning relationship with almost every other market. Sim-
ilarly, AndroidOnline is a cloning hub among the Chinese
markets. The existence of these cloning hubs implies one
of two things: either plagiarists prefer cloning from apps
on these markets, or that plagiarists prefer these markets
to publish their cloned apps. Since we do not speculate on
which app in a cluster is the original, we leave the determin-
ing which of these cases is true to future work. Note that the

lllllllllllllllllplayslidemeandroidonlinem360brothersoftgfaneoemarketonemobilegoapkandroidsoftandappstorefreewareloverssoftportalappchinaproandroidpocketgearandroiddownloadz050001000020000300000%10%20%30%40%50%MarketNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are cloneslllllllllllllllllllllGamesEntertainmentUtilityBusinessPersonalizationReferenceLifestyleNewsEducationMusicCommunicationSportsTravelFinanceHealthVideoPhotographySocialShoppingWeatherOther020004000600080000%5%10%15%20%25%CategoryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesAdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URL3.2 Plagiarized Applications

Using a more scalable tool based on DNADroid [6], we
analyzed our application database to look for plagiarized
applications. While DNADroid is highly precise because it
is based on calculating subgraph isomorphism on PDGs, it
is not scalable because it requires pair-wise comparison of
apps. To avoid pairwise comparison, the tool used for this
work converts each app into a set of semantic vectors, each of
which represents a semantic feature of the program. Then,
the tool clusters the semantic vectors of all the apps using
LSH [1]. Finally, the tool considers a set of apps to be clones
if they share a large number of semantic vector clusters and
places these apps into the same clone cluster.

Each clone cluster contains applications published by dif-
ferent developers, as determined by their signing certi(cid:12)cate.
Each application appears in at most one cluster. In total, we
investigate 5,431 clone clusters consisting of 44,268 unique
applications. These clusters may or may not contain the
\victim" of plagiarism, which we call the \original app" in
this paper. Determining the original application is di(cid:14)cult
and unreliable, as described in Section 6.2.1.
3.3 Network Data

We had access to live 3G network data from a tier-1 cellu-
lar network carrier, which consisted of a sample of all tra(cid:14)c
that passed through a particular home agent in the south-
west United States. Packets were tapped from the home
agent and sent to the carrier’s research lab for capture and
analysis. The tap at the home agent was quarter-sampled
at the (cid:13)ow level, so in theory all packets in a particular
(cid:13)ow were available to be captured; however, packets were
lost from limitations in bandwidth and capture speed of the
tapping infrastructure. The network data included all 3G
internet tra(cid:14)c sent from devices registered on the carrier’s
cellular network, including protocol headers and payload.

We captured HTTP tra(cid:14)c from the tap over the course
of 12 days:
from 28 June 2012 to 10 July 2012. Devices
present on the network include both Android and iOS de-
vices, as well as feature phones and wireless cards. The
tra(cid:14)c characteristics are similar to those in [18]. To opti-
mize the capture, only 32 bytes of the protocol header were
captured along with the payload for each packet. Addition-
ally, we performed IP (cid:12)ltering so that only packets with a
source or destination IP address that corresponded with a
known Android ad server were captured. In total, we cap-
tured 2.6 billions packets in our trace. We describe how we
extract ad request data from the trace in Section 4.1.
4. METHODOLOGY

Figure 1 shows the procedure of our study. Our data came
from two sources: (1) HTTP tra(cid:14)c generated by Android
applications on a US tier-1 cellular network, and (2) An-
droid applications downloaded from Android markets. We
correlated the two datasets using advertising client IDs. In
this section we explain how we extracted these IDs, both
from the network and from applications.
4.1 Extracting Client IDs from Network Traces
We now explain how we extract client IDs from ad re-
quests sent by Android applications. We extract advertising
information from our cellular network trace (described in
Section 3.3) by analyzing ad requests at the packet level as
well as at the (cid:13)ow level. In order to identify ad requests,

we manually ran a sample application for each Android ad
provider and captured all tra(cid:14)c from the device so that we
could characterize the format of each provider’s requests.
From each ad request, we record the ad provider, client
ID, anonymized user identi(cid:12)er, and the application package
name if available. We anonymize user identi(cid:12)ers to avoid
recording any potentially sensitive device identi(cid:12)ers, such
as the IMEI. We only record ad requests with an Android
HTTP User-Agent (cid:12)eld.

To get packet level data, we look at the HTTP header
of each packet to determine if it is an ad request from a
recognized Android ad provider and record relevant adver-
tising information. To analyze ad requests at the (cid:13)ow level,
we use the 32 bytes of protocol header to reconstruct each
TCP (cid:13)ow, allowing us to observe both the ad request and
the response from the server. The bene(cid:12)ts of looking at
ad requests at the (cid:13)ow level are twofold. First, we observed
that ad requests for some ad providers are split across multi-
ple packets, especially when the request uses HTTP POST,
so it would be impossible to record the entire ad request in
this case by only looking at packets individually. Second, the
server response allows us to extract the click URL associated
with each impression so that we can match the impression
with any observed clicks in the trace. These clicks can be
linked to an impression and thus a client ID by using the
click URLs that we parse from each (cid:13)ow.

To extract client IDs, we (cid:12)rst identify the ad provider by
examining the host name in the HTTP request. For each ad
provider, we create a pattern to identify its client IDs in the
HTTP requests accurately.

4.2 Extracting Client IDs from Applications
We extract client IDs from Android applications via static
analysis. Commonly, ad providers require developers to pro-
vide their client ID in one of (cid:12)ve ways: declaring it in the
application’s manifest (cid:12)le, declaring it in a layout XML (cid:12)le,
passing it to an ad object in the application code, specifying
it as a constant string, or receiving it dynamically over the
network.

In Android Manifest

4.2.1
The most straightforward client IDs to extract are those
declared in the Android manifest (cid:12)le. Admob, for exam-
ple, recommends that developers store their client IDs in a
meta-data (cid:12)eld with the name admob publisher id. Usu-
ally the client ID is directly included in the Manifest XML;
however, in some cases there can be extra levels of indi-
rection: Android allows developers to abstract values into
constant (cid:12)les such as string.xml. In cases where the de-
veloper has abstracted the client ID using notation such
as @string/admob_id, we resolve these abstractions accord-
ingly.

In Layout XML

4.2.2
Some ad providers recommend that client IDs be included
in one of the auxiliary XML (cid:12)les that developers generate
for their application (not the manifest). Conveniently for us,
these ad providers usually provide an example for developers
to copy and replace the client ID with their own, which
provides a common naming convention for each ad library.
We take advantage of this convention by using XPATH to
search XML (cid:12)les for speci(cid:12)c XML elements known to contain

(a) Initial owners based on devel-
oper accounts (Phase 1)

(b) Owners with edges based on shared certi(cid:12)-
cates (s) and client IDs (c)

(c) Owners after merging (Phases 2
and 3)

Figure 3: Owner graph at various stages in owner merging.

client IDs. For example, Jumptap client IDs are usually in
a (cid:12)eld called jumptaplib:publisherid.

4.2.3 In Application Code
Client IDs that applications pass directly to ad library ini-
tialization methods are the most challenging to extract. The
initialization may happen at any point in the code and the
client ID may be instantiated in a number of ways, includ-
ing being passed in as a constant, received over the network,
generated dynamically, or read in from a (cid:12)le. We observed
that the (cid:12)rst two are the most common cases and focus on
them accordingly.

Speciﬁed as Constants.

We dump values from the DEX string constants section in
the application’s dex (cid:12)le and search for strings that match
the structure of client IDs for each ad library. This approach
is e(cid:11)ective for ad providers whose client IDs follow a distinc-
tive pattern. To improve the precision of this analysis, we
also implemented a static analysis tool that performs con-
stant propagation to detect when constant values are passed
to the client ID argument of ad library initialization meth-
ods. Unfortunately, we found it too slow to run on all of the
apps in our dataset, as it took several minutes per app. We
leave improving the precision of extracting constant-based
client IDs in this manner to future work.

Received Over the Network.

In addition to ad libraries, many applications include Ad-
whirl’s SDK. Adwhirl is not an ad provider, but rather o(cid:11)ers
a service that allows developers to dynamically decide which
ad provider and client ID should be used in their ad requests.
Before an application with Adwhirl makes an ad request, it
queries Adwhirl with its Adwhirl client ID and receives a set
of ad providers and client IDs, which the application then
uses to send ad requests. This service allows developers to
dynamically change the advertising behavior of their apps
without having to push a new version of their app. We han-
dle apps that use Adwhirl by (cid:12)rst extracting Adwhirl client
IDs from the application. Then, we query Adwhirl’s server
to obtain a mapping from an Adwhirl client ID to a set of
client IDs and their ad providers. This allows us to obtain
many client IDs not hardcoded in the applications.

From our application database, we extracted 1,386 unique

Adwhirl client IDs, which mapped to 1,886 unique client
IDs from one of the (cid:12)ve ad providers we eventually used in
this paper (described in Section 5.1). Of these, 1,539 (or
81.6%) were new client IDs that we had not extracted from
our applications. Speci(cid:12)cally, 764 were for admob, 523 for
millennial, and 252 for inmobi.

4.3 Determining Ownership

As our goal is to measure the impact of plagiarism on
developers, we must not regard as plagiarism similar apps
from the same developer, known as rebranded apps. Re-
branded apps may appear on the same or di(cid:11)erent markets.
In this section we discuss how we determine app ownership
by considering developer accounts, signing keys (represented
by certi(cid:12)cates), and client IDs. We make the following as-
sumptions: (cid:12)rst, each owner has her own unique set of cer-
ti(cid:12)cates that are not shared with any other owner; second,
each owner has her own unique set of client IDs that are
not shared with any other owner. In Section 7.1.1 we dis-
cuss caveats associated with these assumptions. Note, how-
ever, that these caveats only cause us to merge owners more
aggressively, resulting in lowering our measured cloning im-
pact.

Merging owners consists of three phases. First, we build
an owner graph where each node corresponds to a unique
developer account that has uploaded an application that we
crawled (Phase 1). Next, we merge owners based on shared
certi(cid:12)cates (Phase 2). Finally, we merge owners based on
shared client IDs (Phase 3). An overview of the owner graph
at various steps in the process is shown in Figure 3.

Phase 1: The (cid:12)rst phase of merging owners is to create a
graph with a node for each unique developer account. Each
developer account is identi(cid:12)ed by the tuple of the market
name and the developer’s name and is associated with one
or more apps in our database. Assuming that developer
accounts are rarely compromised, then two apps from the
same developer account must come from the same owner.
Thus, developer accounts provide an initial mapping of apps
to owners.

Phase 2: Next, we compute the set of certi(cid:12)cates whose
corresponding private keys were used to sign the apps up-
loaded by each developer account. As mentioned in Sec-
tion 2, every Android app must be signed by the developer’s
private key before it may be uploaded to a market and then

A1A5A6A9A10A2A7A3A8A4A1A5s1A6c1A9c1c1A10s4A2A7c2s2A3A8s3A4A1,A5,A6,A9,A10A2,A7A3,A8A4Provider
admob
airpush
inmobi
millennial
mobclix

Impressions Clicks Unique IDs
348,275
138,166
n/a
61,127
32,751

9,288,333
(cid:3)
3,212,878
(cid:3)
220,982
4,855,247
1,547,871

920
n/a
207
n/a
1,080

Table 2: Number of observed impressions, clicks, and
anonymized user identi(cid:12)ers in the network trace, broken
down by ad provider. The report of impression counts uses
packet level ad request analysis, unless otherwise noted (via
(cid:3)
). Note that we were not able to measure clicks for all
providers due to the format of their ad requests (for exam-
ple, those with chunked HTTP encoding). Also note that
inmobi does not include a user identi(cid:12)er in their ad requests.

installed on users’ phones. Since private keys are supposed
to be kept private (we discuss shared and stolen private keys
in Section 7.1.1), two developer accounts that share a cer-
ti(cid:12)cate must share the same owner so they are merged in
the graph.

Phase 3: Finally, we merge any two owners whose appli-
cations share a client ID. Client IDs are used by ad providers
to uniquely identify who should receive revenue for each ad
shown or clicked. Therefore, if two developer accounts share
a client ID, they are likely to be from the same owner.

We separate the merging of owners by certi(cid:12)cates and
client IDs into two phases because we have lower con(cid:12)dence
about merges based on client IDs. This is because client
ID extraction may have false positives while certi(cid:12)cate cal-
culation cannot. Other situations, such as a plagiarist who
leaves the original developer’s client ID intact, are discussed
in Section 7.1.1.

5. EVALUATION

In this section we summarize the raw results of our anal-
ysis and determine the accuracy of our application client ID
extraction.
5.1 Network Client ID Extraction

One important consideration of our work is which Android
ad providers to include in our analysis. We started with 16
ad providers based on their popularity in our application
database. Among these ad providers, seven1 had very small
number of ad requests in our captured tra(cid:14)c (some of them
are Chinese but our tra(cid:14)c was captured in the US), and four
had very little overlap between the client IDs observed on
the network and client IDs extracted from our application
database (Table 1)2. Therefore, we focus on the remaining
(cid:12)ve ad providers, whose number of impressions, clicks, and
unique user identi(cid:12)ers are summarized in Table 2. These
(cid:12)ve ad providers are also among the top six most prevalent
Android ad libraries reported by AppBrain [3]. Because our
network capture was lossy, we were not able to record signif-
icant click results from the trace, as we could only measure
clicks when the ad request, server response, and then click
request did not experience any loss.

1Buzzcity, Mojiva, Quattro, Vdopia, Wooboo, Youmi, Zes-
tAdz
2These four providers only represented 7% of the total num-
ber of ad requests we collected.

5.2 Application Client ID Extraction

While extracting client IDs from HTTP tra(cid:14)c generated
by Android applications is highly accurate, extracting them
automatically from Android applications themselves may
not be as reliable, because client IDs may be provided in sev-
eral di(cid:11)erent ways, some of which are unfriendly to program
analysis (Section 4). Therefore, we would like to evaluate the
accuracy of our client IDs extracted from Android applica-
tions. However, it is di(cid:14)cult to determine the ground truth,
because doing so would require us to manually review all the
applications, which is prohibitive given our large number of
applications. One might suggest that we run each applica-
tion in an emulator to extract the client IDs from its HTTP
tra(cid:14)c. However, an application may contain multiple ad li-
braries, so we may not observe the client IDs from all these
libraries during the execution of the application. Moreover,
some ad libraries would not send ad requests if they detect
that they are running in emulators.

Instead, we take advantage of the client IDs extracted
from HTTP tra(cid:14)c to estimate a lower bound of the accuracy
of our client ID extraction from applications. For each ad
provider AP, let DAP be the set of client IDs extracted from
our application databases, and NAP be the set of client IDs
extracted from our captured HTTP tra(cid:14)c. The network cov-
erage, jNAP \ DAPj=jDAPj, estimates a lower bound of the
true positive rate of our client ID extraction from applica-
tions. The database coverage, jDAP \NAPj=jNAPj, estimates
the coverage our application database on all the Android ap-
plications running on the network where we captured traces.
The results of this analysis are summarized in Table 1.
The database coverages for most providers are fairly high,
indicating that our application database represents a signif-
icant portion of all ad-supported Android applications that
are used in the geographic area where we collected the trace.
6. FINDINGS
6.1 Properties of Apps in Clone Clusters

There are a number of questions that come to mind when
investigating our clone clusters: Which markets do apps in
the clusters belong to? Which markets have the highest
proportion of apps involved in cloning? What categories are
most represented in the clusters? What advertising libraries
do cloners prefer? In this section we seek to answer these
questions by investigating common features of apps in our
clone clusters. Note, at this point we do not yet speculate as
to which app in each clone cluster is the original and which
are clones.
6.1.1 Market Characteristics
Figure 4 shows which Android markets are most preva-
lent in our clone clusters. A signi(cid:12)cant percentage of apps
in our clone clusters are from Google Play; intuitively this
makes sense as Play is the most popular Android market.
To compensate for this observation, we computed what per-
centage of all applications in our database from the mar-
ket are present in a clone cluster.
In this context, Play
does not stand out more than other markets, but a num-
ber of other markets such as AndroidSoft, and the Chinese
markets AndroidOnline, GoApk, and AppChina, have more
than a quarter of their apps in our clone clusters. To bet-
ter understand the cloning relationship between markets, we
calculated the number of similar apps between each pair of

Ad Provider

admob
airpush
inmobi
millennial
mobclix
adfonic
greystripe
jumptap
smaato

Unique client IDs

from databases
51,434
8,728
514
786
2,994
59,170
59,616
8
0

from network
19,718
8,829
487
2,030
1,781
318
212
78
144

Network coverage Database coverage

21.2%
36.9%
28.6%
32.6%
38.0%
0.0%
0.3%
0.0%
n/a

55.4%
36.5%
30.2%
12.6%
63.9%
0.0%
68.4%
0.0%
0.0%

Table 1: Percentage of extracted client IDs we observed in network tra(cid:14)c and percentage of observed network client IDs we
also extracted from the application database, broken down by provider. The lower group of providers are ones which we did
not include in our study because they did not have signi(cid:12)cant overlap with our application database.

Figure 4: Plot showing the popularity of di(cid:11)erent app mar-
kets in our clone clusters. The absolute number of cloned
apps from each market is represented by the axis labelled
\Number of cloned apps", whereas the axis labelled \Per-
centage of apps that are clones" represents the popularity of
each market in our clone clusters normalized over the total
number of apps from that market in our database.

Figure 5: Plot showing the popularity of di(cid:11)erent app cate-
gories in our clone clusters. The absolute number of cloned
apps in each category is represented by the axis labelled
\Number of cloned apps", whereas axis labelled \Percent-
age of apps that are clones" represents the number of cloned
apps in each category normalized over the total number of
apps in that category in our database.

markets in a clone cluster. Speci(cid:12)cally, for the apps in given
clone cluster and a pair of markets (I; J):

M arketSimcluster(I; J) = min(apps from I; apps from J)

Then, to get a global view of the amount of similar appli-

cations between markets we calculate the total M arketSim(I; J)
as follows:

∑

M arketSim(I; J) =

M arketSimc(I; J)

c2clusters

In Figure 7, we plot the results of this calculation in an
undirected graph. To reduce the complexity of the graph,

we only show an edge between markets whose M arketSim
value is over 300 and remove unconnected markets.

We de(cid:12)ne a market as a \cloning hub" if it shares an edge
with many di(cid:11)erent markets in the graph. Play is the largest
cloning hub among all the markets, as it has a signi(cid:12)cant
cloning relationship with almost every other market. Sim-
ilarly, AndroidOnline is a cloning hub among the Chinese
markets. The existence of these cloning hubs implies one
of two things: either plagiarists prefer cloning from apps
on these markets, or that plagiarists prefer these markets
to publish their cloned apps. Since we do not speculate on
which app in a cluster is the original, we leave the determin-
ing which of these cases is true to future work. Note that the

lllllllllllllllllplayslidemeandroidonlinem360brothersoftgfaneoemarketonemobilegoapkandroidsoftandappstorefreewareloverssoftportalappchinaproandroidpocketgearandroiddownloadz050001000020000300000%10%20%30%40%50%MarketNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are cloneslllllllllllllllllllllGamesEntertainmentUtilityBusinessPersonalizationReferenceLifestyleNewsEducationMusicCommunicationSportsTravelFinanceHealthVideoPhotographySocialShoppingWeatherOther020004000600080000%5%10%15%20%25%CategoryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesperiods of time, allowing more advertising revenue to be
generated.

6.1.3 Ad Library Characteristics
Figure 6 gives a breakdown by ad provider of the appli-
cations in our clone clusters, as well as normalized across
our entire application database. Admob is the most popular
provider among cloned applications, but is also the most
popular among all applications, and thus does not have
a higher percentage of cloned apps compared with other
providers. On the other hand, for our Chinese ad providers,
Wooboo and Youmi, cloned applications represent a larger
subset of the total applications that use these providers.
Nonetheless, an alarmingly large percentage of applications
for each provider are in our clone clusters, meaning that they
either are clones of another app, or are a legitimate app that
has been cloned. Note that we do not consider what per-
centage of ad tra(cid:14)c was generated by our clone clusters for
each ad provider, as we do not speculate which app is the
original and want to avoid any assumptions regarding how
much tra(cid:14)c for a provider is a result of app plagiarism. In
the next section, we estimate a lower bound for how much
advertising revenue cloning siphons from legitimate applica-
tions.
6.2 Comparing Clones and Non-clones

In previous sections we examined a number of properties
of apps in our cloned clusters without distinguishing the
\original" apps from the clones.
In this section, we wish
to gain insight into the impact of cloning on developers.
Speci(cid:12)cally, we investigate the e(cid:11)ects of cloning on the orig-
inal authors’ ad revenue and user install base. To do so, the
original author in the cluster must be determined, which is
surprisingly nontrivial.

6.2.1 Determining Original App
There are a number of intuitive approaches one could use
to determine which application among a cluster of similar
applications is the original. Unfortunately, most of these
initial approaches are (cid:13)awed. For example, one could use:

(cid:15) Date (cid:12)rst uploaded to the market
(cid:15) Application popularity by number of installs or rating
(cid:15) Code size by number of methods, instructions, or other

metric

The date an application was (cid:12)rst uploaded to the market
is di(cid:14)cult to know as an external observer. Each market
knows when the application was (cid:12)rst uploaded, but unless
an external observer has been crawling markets since their
creation in both the free and paid sections, she cannot know
for sure which app came (cid:12)rst. Additionally, there have been
cases where beta releases have been taken and uploaded to
markets before the original developer’s app. Application
popularity may sometimes di(cid:11)erentiate the clone from the
original, for example in the case of Angry Birds, however,
for less popular applications, users may be just as likely to
download the clone as the original. Further, application pop-
ularity by both number of installs and ratings is vulnerable
to sybil attacks which would be relatively easy to perform
as most market accounts require only a valid email address.
Lastly, the code size of applications can easily be distorted

Figure 6: Plot showing the popularity of di(cid:11)erent ad li-
braries among apps in our clone clusters. The absolute num-
ber of cloned apps with each library is represented by the
axis labelled \Number of cloned apps", whereas axis labelled
\Percentage of apps that are clones" represents the number
of cloned apps with each library normalized over the total
number of apps with that library in our database.

prevalence of Play as a cloning hub is likely in(cid:13)uenced by
the fact Play represents 73.7% of the apps in our database.

6.1.2 Category Characteristics
We now investigate which app categories are popular among

apps in our clone clusters so that we can better understand
what types of apps are involved in cloning. One di(cid:14)culty
with comparing categories among apps from di(cid:11)erent mar-
kets is that di(cid:11)erent markets use di(cid:11)erent category names
to refer to the same type of application. To avoid this prob-
lem, we chose 21 meta-categories that represent the spec-
trum of di(cid:11)erent categories observed across all our markets
(our mapping from category strings to meta-categories is
presented in the Appendix). Figure 5 presents the num-
ber of applications in our clone clusters that belong to each
meta-category. As we did for markets, we normalize the
number of cloned apps in each category with the number of
all apps in our database for that category to determine what
percentage of apps in the category are involved in cloning.
Interestingly, \Games" is the most popular category among
apps in the clone clusters, but also has the highest preva-
lence of apps involved in cloning. Thus, markets that care
about application cloning should focus on apps categorized
as \Games." Additionally, assuming that the original app
and the clone belong to the same category, this implies pla-
giarists prefer applications categorized as \Games." We hy-
pothesize that this is because games are relatively complex,
popular among Android users, and are often run for long

llllllllllladmobmillennialairpushwoobooyoumimobclixinmobigreystripesmaatojumptapadfonic05000100001500020000250000%5%10%15%20%25%30%35%Ad LibraryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesAdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URL3.2 Plagiarized Applications

Using a more scalable tool based on DNADroid [6], we
analyzed our application database to look for plagiarized
applications. While DNADroid is highly precise because it
is based on calculating subgraph isomorphism on PDGs, it
is not scalable because it requires pair-wise comparison of
apps. To avoid pairwise comparison, the tool used for this
work converts each app into a set of semantic vectors, each of
which represents a semantic feature of the program. Then,
the tool clusters the semantic vectors of all the apps using
LSH [1]. Finally, the tool considers a set of apps to be clones
if they share a large number of semantic vector clusters and
places these apps into the same clone cluster.

Each clone cluster contains applications published by dif-
ferent developers, as determined by their signing certi(cid:12)cate.
Each application appears in at most one cluster. In total, we
investigate 5,431 clone clusters consisting of 44,268 unique
applications. These clusters may or may not contain the
\victim" of plagiarism, which we call the \original app" in
this paper. Determining the original application is di(cid:14)cult
and unreliable, as described in Section 6.2.1.
3.3 Network Data

We had access to live 3G network data from a tier-1 cellu-
lar network carrier, which consisted of a sample of all tra(cid:14)c
that passed through a particular home agent in the south-
west United States. Packets were tapped from the home
agent and sent to the carrier’s research lab for capture and
analysis. The tap at the home agent was quarter-sampled
at the (cid:13)ow level, so in theory all packets in a particular
(cid:13)ow were available to be captured; however, packets were
lost from limitations in bandwidth and capture speed of the
tapping infrastructure. The network data included all 3G
internet tra(cid:14)c sent from devices registered on the carrier’s
cellular network, including protocol headers and payload.

We captured HTTP tra(cid:14)c from the tap over the course
of 12 days:
from 28 June 2012 to 10 July 2012. Devices
present on the network include both Android and iOS de-
vices, as well as feature phones and wireless cards. The
tra(cid:14)c characteristics are similar to those in [18]. To opti-
mize the capture, only 32 bytes of the protocol header were
captured along with the payload for each packet. Addition-
ally, we performed IP (cid:12)ltering so that only packets with a
source or destination IP address that corresponded with a
known Android ad server were captured. In total, we cap-
tured 2.6 billions packets in our trace. We describe how we
extract ad request data from the trace in Section 4.1.
4. METHODOLOGY

Figure 1 shows the procedure of our study. Our data came
from two sources: (1) HTTP tra(cid:14)c generated by Android
applications on a US tier-1 cellular network, and (2) An-
droid applications downloaded from Android markets. We
correlated the two datasets using advertising client IDs. In
this section we explain how we extracted these IDs, both
from the network and from applications.
4.1 Extracting Client IDs from Network Traces
We now explain how we extract client IDs from ad re-
quests sent by Android applications. We extract advertising
information from our cellular network trace (described in
Section 3.3) by analyzing ad requests at the packet level as
well as at the (cid:13)ow level. In order to identify ad requests,

we manually ran a sample application for each Android ad
provider and captured all tra(cid:14)c from the device so that we
could characterize the format of each provider’s requests.
From each ad request, we record the ad provider, client
ID, anonymized user identi(cid:12)er, and the application package
name if available. We anonymize user identi(cid:12)ers to avoid
recording any potentially sensitive device identi(cid:12)ers, such
as the IMEI. We only record ad requests with an Android
HTTP User-Agent (cid:12)eld.

To get packet level data, we look at the HTTP header
of each packet to determine if it is an ad request from a
recognized Android ad provider and record relevant adver-
tising information. To analyze ad requests at the (cid:13)ow level,
we use the 32 bytes of protocol header to reconstruct each
TCP (cid:13)ow, allowing us to observe both the ad request and
the response from the server. The bene(cid:12)ts of looking at
ad requests at the (cid:13)ow level are twofold. First, we observed
that ad requests for some ad providers are split across multi-
ple packets, especially when the request uses HTTP POST,
so it would be impossible to record the entire ad request in
this case by only looking at packets individually. Second, the
server response allows us to extract the click URL associated
with each impression so that we can match the impression
with any observed clicks in the trace. These clicks can be
linked to an impression and thus a client ID by using the
click URLs that we parse from each (cid:13)ow.

To extract client IDs, we (cid:12)rst identify the ad provider by
examining the host name in the HTTP request. For each ad
provider, we create a pattern to identify its client IDs in the
HTTP requests accurately.

4.2 Extracting Client IDs from Applications
We extract client IDs from Android applications via static
analysis. Commonly, ad providers require developers to pro-
vide their client ID in one of (cid:12)ve ways: declaring it in the
application’s manifest (cid:12)le, declaring it in a layout XML (cid:12)le,
passing it to an ad object in the application code, specifying
it as a constant string, or receiving it dynamically over the
network.

In Android Manifest

4.2.1
The most straightforward client IDs to extract are those
declared in the Android manifest (cid:12)le. Admob, for exam-
ple, recommends that developers store their client IDs in a
meta-data (cid:12)eld with the name admob publisher id. Usu-
ally the client ID is directly included in the Manifest XML;
however, in some cases there can be extra levels of indi-
rection: Android allows developers to abstract values into
constant (cid:12)les such as string.xml. In cases where the de-
veloper has abstracted the client ID using notation such
as @string/admob_id, we resolve these abstractions accord-
ingly.

In Layout XML

4.2.2
Some ad providers recommend that client IDs be included
in one of the auxiliary XML (cid:12)les that developers generate
for their application (not the manifest). Conveniently for us,
these ad providers usually provide an example for developers
to copy and replace the client ID with their own, which
provides a common naming convention for each ad library.
We take advantage of this convention by using XPATH to
search XML (cid:12)les for speci(cid:12)c XML elements known to contain

(a) Initial owners based on devel-
oper accounts (Phase 1)

(b) Owners with edges based on shared certi(cid:12)-
cates (s) and client IDs (c)

(c) Owners after merging (Phases 2
and 3)

Figure 3: Owner graph at various stages in owner merging.

client IDs. For example, Jumptap client IDs are usually in
a (cid:12)eld called jumptaplib:publisherid.

4.2.3 In Application Code
Client IDs that applications pass directly to ad library ini-
tialization methods are the most challenging to extract. The
initialization may happen at any point in the code and the
client ID may be instantiated in a number of ways, includ-
ing being passed in as a constant, received over the network,
generated dynamically, or read in from a (cid:12)le. We observed
that the (cid:12)rst two are the most common cases and focus on
them accordingly.

Speciﬁed as Constants.

We dump values from the DEX string constants section in
the application’s dex (cid:12)le and search for strings that match
the structure of client IDs for each ad library. This approach
is e(cid:11)ective for ad providers whose client IDs follow a distinc-
tive pattern. To improve the precision of this analysis, we
also implemented a static analysis tool that performs con-
stant propagation to detect when constant values are passed
to the client ID argument of ad library initialization meth-
ods. Unfortunately, we found it too slow to run on all of the
apps in our dataset, as it took several minutes per app. We
leave improving the precision of extracting constant-based
client IDs in this manner to future work.

Received Over the Network.

In addition to ad libraries, many applications include Ad-
whirl’s SDK. Adwhirl is not an ad provider, but rather o(cid:11)ers
a service that allows developers to dynamically decide which
ad provider and client ID should be used in their ad requests.
Before an application with Adwhirl makes an ad request, it
queries Adwhirl with its Adwhirl client ID and receives a set
of ad providers and client IDs, which the application then
uses to send ad requests. This service allows developers to
dynamically change the advertising behavior of their apps
without having to push a new version of their app. We han-
dle apps that use Adwhirl by (cid:12)rst extracting Adwhirl client
IDs from the application. Then, we query Adwhirl’s server
to obtain a mapping from an Adwhirl client ID to a set of
client IDs and their ad providers. This allows us to obtain
many client IDs not hardcoded in the applications.

From our application database, we extracted 1,386 unique

Adwhirl client IDs, which mapped to 1,886 unique client
IDs from one of the (cid:12)ve ad providers we eventually used in
this paper (described in Section 5.1). Of these, 1,539 (or
81.6%) were new client IDs that we had not extracted from
our applications. Speci(cid:12)cally, 764 were for admob, 523 for
millennial, and 252 for inmobi.

4.3 Determining Ownership

As our goal is to measure the impact of plagiarism on
developers, we must not regard as plagiarism similar apps
from the same developer, known as rebranded apps. Re-
branded apps may appear on the same or di(cid:11)erent markets.
In this section we discuss how we determine app ownership
by considering developer accounts, signing keys (represented
by certi(cid:12)cates), and client IDs. We make the following as-
sumptions: (cid:12)rst, each owner has her own unique set of cer-
ti(cid:12)cates that are not shared with any other owner; second,
each owner has her own unique set of client IDs that are
not shared with any other owner. In Section 7.1.1 we dis-
cuss caveats associated with these assumptions. Note, how-
ever, that these caveats only cause us to merge owners more
aggressively, resulting in lowering our measured cloning im-
pact.

Merging owners consists of three phases. First, we build
an owner graph where each node corresponds to a unique
developer account that has uploaded an application that we
crawled (Phase 1). Next, we merge owners based on shared
certi(cid:12)cates (Phase 2). Finally, we merge owners based on
shared client IDs (Phase 3). An overview of the owner graph
at various steps in the process is shown in Figure 3.

Phase 1: The (cid:12)rst phase of merging owners is to create a
graph with a node for each unique developer account. Each
developer account is identi(cid:12)ed by the tuple of the market
name and the developer’s name and is associated with one
or more apps in our database. Assuming that developer
accounts are rarely compromised, then two apps from the
same developer account must come from the same owner.
Thus, developer accounts provide an initial mapping of apps
to owners.

Phase 2: Next, we compute the set of certi(cid:12)cates whose
corresponding private keys were used to sign the apps up-
loaded by each developer account. As mentioned in Sec-
tion 2, every Android app must be signed by the developer’s
private key before it may be uploaded to a market and then

A1A5A6A9A10A2A7A3A8A4A1A5s1A6c1A9c1c1A10s4A2A7c2s2A3A8s3A4A1,A5,A6,A9,A10A2,A7A3,A8A4Provider
admob
airpush
inmobi
millennial
mobclix

Impressions Clicks Unique IDs
348,275
138,166
n/a
61,127
32,751

9,288,333
(cid:3)
3,212,878
(cid:3)
220,982
4,855,247
1,547,871

920
n/a
207
n/a
1,080

Table 2: Number of observed impressions, clicks, and
anonymized user identi(cid:12)ers in the network trace, broken
down by ad provider. The report of impression counts uses
packet level ad request analysis, unless otherwise noted (via
(cid:3)
). Note that we were not able to measure clicks for all
providers due to the format of their ad requests (for exam-
ple, those with chunked HTTP encoding). Also note that
inmobi does not include a user identi(cid:12)er in their ad requests.

installed on users’ phones. Since private keys are supposed
to be kept private (we discuss shared and stolen private keys
in Section 7.1.1), two developer accounts that share a cer-
ti(cid:12)cate must share the same owner so they are merged in
the graph.

Phase 3: Finally, we merge any two owners whose appli-
cations share a client ID. Client IDs are used by ad providers
to uniquely identify who should receive revenue for each ad
shown or clicked. Therefore, if two developer accounts share
a client ID, they are likely to be from the same owner.

We separate the merging of owners by certi(cid:12)cates and
client IDs into two phases because we have lower con(cid:12)dence
about merges based on client IDs. This is because client
ID extraction may have false positives while certi(cid:12)cate cal-
culation cannot. Other situations, such as a plagiarist who
leaves the original developer’s client ID intact, are discussed
in Section 7.1.1.

5. EVALUATION

In this section we summarize the raw results of our anal-
ysis and determine the accuracy of our application client ID
extraction.
5.1 Network Client ID Extraction

One important consideration of our work is which Android
ad providers to include in our analysis. We started with 16
ad providers based on their popularity in our application
database. Among these ad providers, seven1 had very small
number of ad requests in our captured tra(cid:14)c (some of them
are Chinese but our tra(cid:14)c was captured in the US), and four
had very little overlap between the client IDs observed on
the network and client IDs extracted from our application
database (Table 1)2. Therefore, we focus on the remaining
(cid:12)ve ad providers, whose number of impressions, clicks, and
unique user identi(cid:12)ers are summarized in Table 2. These
(cid:12)ve ad providers are also among the top six most prevalent
Android ad libraries reported by AppBrain [3]. Because our
network capture was lossy, we were not able to record signif-
icant click results from the trace, as we could only measure
clicks when the ad request, server response, and then click
request did not experience any loss.

1Buzzcity, Mojiva, Quattro, Vdopia, Wooboo, Youmi, Zes-
tAdz
2These four providers only represented 7% of the total num-
ber of ad requests we collected.

5.2 Application Client ID Extraction

While extracting client IDs from HTTP tra(cid:14)c generated
by Android applications is highly accurate, extracting them
automatically from Android applications themselves may
not be as reliable, because client IDs may be provided in sev-
eral di(cid:11)erent ways, some of which are unfriendly to program
analysis (Section 4). Therefore, we would like to evaluate the
accuracy of our client IDs extracted from Android applica-
tions. However, it is di(cid:14)cult to determine the ground truth,
because doing so would require us to manually review all the
applications, which is prohibitive given our large number of
applications. One might suggest that we run each applica-
tion in an emulator to extract the client IDs from its HTTP
tra(cid:14)c. However, an application may contain multiple ad li-
braries, so we may not observe the client IDs from all these
libraries during the execution of the application. Moreover,
some ad libraries would not send ad requests if they detect
that they are running in emulators.

Instead, we take advantage of the client IDs extracted
from HTTP tra(cid:14)c to estimate a lower bound of the accuracy
of our client ID extraction from applications. For each ad
provider AP, let DAP be the set of client IDs extracted from
our application databases, and NAP be the set of client IDs
extracted from our captured HTTP tra(cid:14)c. The network cov-
erage, jNAP \ DAPj=jDAPj, estimates a lower bound of the
true positive rate of our client ID extraction from applica-
tions. The database coverage, jDAP \NAPj=jNAPj, estimates
the coverage our application database on all the Android ap-
plications running on the network where we captured traces.
The results of this analysis are summarized in Table 1.
The database coverages for most providers are fairly high,
indicating that our application database represents a signif-
icant portion of all ad-supported Android applications that
are used in the geographic area where we collected the trace.
6. FINDINGS
6.1 Properties of Apps in Clone Clusters

There are a number of questions that come to mind when
investigating our clone clusters: Which markets do apps in
the clusters belong to? Which markets have the highest
proportion of apps involved in cloning? What categories are
most represented in the clusters? What advertising libraries
do cloners prefer? In this section we seek to answer these
questions by investigating common features of apps in our
clone clusters. Note, at this point we do not yet speculate as
to which app in each clone cluster is the original and which
are clones.
6.1.1 Market Characteristics
Figure 4 shows which Android markets are most preva-
lent in our clone clusters. A signi(cid:12)cant percentage of apps
in our clone clusters are from Google Play; intuitively this
makes sense as Play is the most popular Android market.
To compensate for this observation, we computed what per-
centage of all applications in our database from the mar-
ket are present in a clone cluster.
In this context, Play
does not stand out more than other markets, but a num-
ber of other markets such as AndroidSoft, and the Chinese
markets AndroidOnline, GoApk, and AppChina, have more
than a quarter of their apps in our clone clusters. To bet-
ter understand the cloning relationship between markets, we
calculated the number of similar apps between each pair of

Ad Provider

admob
airpush
inmobi
millennial
mobclix
adfonic
greystripe
jumptap
smaato

Unique client IDs

from databases
51,434
8,728
514
786
2,994
59,170
59,616
8
0

from network
19,718
8,829
487
2,030
1,781
318
212
78
144

Network coverage Database coverage

21.2%
36.9%
28.6%
32.6%
38.0%
0.0%
0.3%
0.0%
n/a

55.4%
36.5%
30.2%
12.6%
63.9%
0.0%
68.4%
0.0%
0.0%

Table 1: Percentage of extracted client IDs we observed in network tra(cid:14)c and percentage of observed network client IDs we
also extracted from the application database, broken down by provider. The lower group of providers are ones which we did
not include in our study because they did not have signi(cid:12)cant overlap with our application database.

Figure 4: Plot showing the popularity of di(cid:11)erent app mar-
kets in our clone clusters. The absolute number of cloned
apps from each market is represented by the axis labelled
\Number of cloned apps", whereas the axis labelled \Per-
centage of apps that are clones" represents the popularity of
each market in our clone clusters normalized over the total
number of apps from that market in our database.

Figure 5: Plot showing the popularity of di(cid:11)erent app cate-
gories in our clone clusters. The absolute number of cloned
apps in each category is represented by the axis labelled
\Number of cloned apps", whereas axis labelled \Percent-
age of apps that are clones" represents the number of cloned
apps in each category normalized over the total number of
apps in that category in our database.

markets in a clone cluster. Speci(cid:12)cally, for the apps in given
clone cluster and a pair of markets (I; J):

M arketSimcluster(I; J) = min(apps from I; apps from J)

Then, to get a global view of the amount of similar appli-

cations between markets we calculate the total M arketSim(I; J)
as follows:

∑

M arketSim(I; J) =

M arketSimc(I; J)

c2clusters

In Figure 7, we plot the results of this calculation in an
undirected graph. To reduce the complexity of the graph,

we only show an edge between markets whose M arketSim
value is over 300 and remove unconnected markets.

We de(cid:12)ne a market as a \cloning hub" if it shares an edge
with many di(cid:11)erent markets in the graph. Play is the largest
cloning hub among all the markets, as it has a signi(cid:12)cant
cloning relationship with almost every other market. Sim-
ilarly, AndroidOnline is a cloning hub among the Chinese
markets. The existence of these cloning hubs implies one
of two things: either plagiarists prefer cloning from apps
on these markets, or that plagiarists prefer these markets
to publish their cloned apps. Since we do not speculate on
which app in a cluster is the original, we leave the determin-
ing which of these cases is true to future work. Note that the

lllllllllllllllllplayslidemeandroidonlinem360brothersoftgfaneoemarketonemobilegoapkandroidsoftandappstorefreewareloverssoftportalappchinaproandroidpocketgearandroiddownloadz050001000020000300000%10%20%30%40%50%MarketNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are cloneslllllllllllllllllllllGamesEntertainmentUtilityBusinessPersonalizationReferenceLifestyleNewsEducationMusicCommunicationSportsTravelFinanceHealthVideoPhotographySocialShoppingWeatherOther020004000600080000%5%10%15%20%25%CategoryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesperiods of time, allowing more advertising revenue to be
generated.

6.1.3 Ad Library Characteristics
Figure 6 gives a breakdown by ad provider of the appli-
cations in our clone clusters, as well as normalized across
our entire application database. Admob is the most popular
provider among cloned applications, but is also the most
popular among all applications, and thus does not have
a higher percentage of cloned apps compared with other
providers. On the other hand, for our Chinese ad providers,
Wooboo and Youmi, cloned applications represent a larger
subset of the total applications that use these providers.
Nonetheless, an alarmingly large percentage of applications
for each provider are in our clone clusters, meaning that they
either are clones of another app, or are a legitimate app that
has been cloned. Note that we do not consider what per-
centage of ad tra(cid:14)c was generated by our clone clusters for
each ad provider, as we do not speculate which app is the
original and want to avoid any assumptions regarding how
much tra(cid:14)c for a provider is a result of app plagiarism. In
the next section, we estimate a lower bound for how much
advertising revenue cloning siphons from legitimate applica-
tions.
6.2 Comparing Clones and Non-clones

In previous sections we examined a number of properties
of apps in our cloned clusters without distinguishing the
\original" apps from the clones.
In this section, we wish
to gain insight into the impact of cloning on developers.
Speci(cid:12)cally, we investigate the e(cid:11)ects of cloning on the orig-
inal authors’ ad revenue and user install base. To do so, the
original author in the cluster must be determined, which is
surprisingly nontrivial.

6.2.1 Determining Original App
There are a number of intuitive approaches one could use
to determine which application among a cluster of similar
applications is the original. Unfortunately, most of these
initial approaches are (cid:13)awed. For example, one could use:

(cid:15) Date (cid:12)rst uploaded to the market
(cid:15) Application popularity by number of installs or rating
(cid:15) Code size by number of methods, instructions, or other

metric

The date an application was (cid:12)rst uploaded to the market
is di(cid:14)cult to know as an external observer. Each market
knows when the application was (cid:12)rst uploaded, but unless
an external observer has been crawling markets since their
creation in both the free and paid sections, she cannot know
for sure which app came (cid:12)rst. Additionally, there have been
cases where beta releases have been taken and uploaded to
markets before the original developer’s app. Application
popularity may sometimes di(cid:11)erentiate the clone from the
original, for example in the case of Angry Birds, however,
for less popular applications, users may be just as likely to
download the clone as the original. Further, application pop-
ularity by both number of installs and ratings is vulnerable
to sybil attacks which would be relatively easy to perform
as most market accounts require only a valid email address.
Lastly, the code size of applications can easily be distorted

Figure 6: Plot showing the popularity of di(cid:11)erent ad li-
braries among apps in our clone clusters. The absolute num-
ber of cloned apps with each library is represented by the
axis labelled \Number of cloned apps", whereas axis labelled
\Percentage of apps that are clones" represents the number
of cloned apps with each library normalized over the total
number of apps with that library in our database.

prevalence of Play as a cloning hub is likely in(cid:13)uenced by
the fact Play represents 73.7% of the apps in our database.

6.1.2 Category Characteristics
We now investigate which app categories are popular among

apps in our clone clusters so that we can better understand
what types of apps are involved in cloning. One di(cid:14)culty
with comparing categories among apps from di(cid:11)erent mar-
kets is that di(cid:11)erent markets use di(cid:11)erent category names
to refer to the same type of application. To avoid this prob-
lem, we chose 21 meta-categories that represent the spec-
trum of di(cid:11)erent categories observed across all our markets
(our mapping from category strings to meta-categories is
presented in the Appendix). Figure 5 presents the num-
ber of applications in our clone clusters that belong to each
meta-category. As we did for markets, we normalize the
number of cloned apps in each category with the number of
all apps in our database for that category to determine what
percentage of apps in the category are involved in cloning.
Interestingly, \Games" is the most popular category among
apps in the clone clusters, but also has the highest preva-
lence of apps involved in cloning. Thus, markets that care
about application cloning should focus on apps categorized
as \Games." Additionally, assuming that the original app
and the clone belong to the same category, this implies pla-
giarists prefer applications categorized as \Games." We hy-
pothesize that this is because games are relatively complex,
popular among Android users, and are often run for long

llllllllllladmobmillennialairpushwoobooyoumimobclixinmobigreystripesmaatojumptapadfonic05000100001500020000250000%5%10%15%20%25%30%35%Ad LibraryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesFigure 7: Markets which have a signi(cid:12)cant cloning relationship. The thickness of an edge is proportional to the M arketSim
value between the markets, and the height of a node is proportional to the sum of the edge weights for a given market. Markets
with nodes colored blue are US-based markets whereas markets with nodes colored red are Chinese-based markets.

Num Clusters
LostImpstotal
P ercLostImpstotal
LostU serstotal
P ercLostU serstotal

P1
610
1,764,609
52%
166,534
49%

P2
370
1,076,614
51%
122,718
48%

P3
128
56,884
14%
3,808
10%

Table 3: Total amount of lost impressions and users across
all of our clone clusters between each phase of developer
merging. The value of Num Clusters represents how many
clone clusters had more than one owner after each phase.
P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3,
respectively.

by plagiarists to make the plagiarized app appear larger or
smaller.

Rather than rely on one of these (cid:13)awed approaches, we
instead use an approach that estimates a lower bound on
our (cid:12)ndings. For each cluster we deem the owner with the
most observed impressions to be the original author and all
other owners are treated as plagiarists. In the case where
clones are more popular than the original, we will mislabel
the original author as a plagiarist, but this is acceptable as
we will only underestimate the percentage of lost advertising
tra(cid:14)c. Indeed, this approach guarantees we will not overes-
timate the number of lost impressions from mislabeling the
original as the above approaches might, as we only consider
the least popular owners in a clone cluster as plagiarists
(other caveats presented in Section 7.1.2). As we will see,
merging developer accounts has signi(cid:12)cant impact over our
results when app owners within a clone cluster are merged
by certi(cid:12)cate or client ID, and in some cases may attribute
all apps within a cluster to the same merged owner. We do
not consider such cases in our computations of lost revenue,
as they do not represent fraudulent cloning.
6.2.2 How much revenue do clones siphon from the

original authors?

In order to determine the impact of plagiarism on the ad-
vertising revenue of the original application, we (cid:12)rst observe

that hard dollar amounts are di(cid:14)cult to determine when
looking at advertising network tra(cid:14)c alone. This is because
an impression does not explicitly indicate how much it is
worth in an ad request, as the ad provider does not want to
disclose how much it or its a(cid:14)liated developers are making.
Instead, we show what percentage of lost ad tra(cid:14)c devel-
opers experience by comparing the ratio of impressions that
belong to plagiarized applications compared with the total
number of impressions we observed belonging to applica-
tions in our clone clusters. The number of lost impressions
for a cluster is represented by LostImpscluster, and the per-
centage of lost impressions for a cluster is this value divided
by all impressions attributed to apps in the cluster, times
100 (represented by P ercLostImpscluster). Additionally,
LostImpstotal represents the total number of plagiarized
app impressions over all the clusters, and P ercLostImpstotal
represents what percentage of all impressions from all clus-
ters that are a results of LostImpstotal.

As previously stated, we consider the original author in a
cluster as the app owner with the greatest amount of adver-
tising tra(cid:14)c, thus the numerator is the number of impres-
sions for all apps in the cluster not owned by this author.
Additionally, we do not consider clusters with only a single
owner. Figure 8a shows a CDF of the P ercImpsLostcluster
values across our clone clusters for each stage of applica-
tion owner merging. When only considering developer ac-
counts on their own (Phase 1 of the owner graph, see Sec-
tion 4.3) nearly 25% of the clusters have exactly 50% lost
revenue. This is a result of clusters having exactly two ap-
plications which belong to di(cid:11)erent developer accounts but
which share a client ID. Intuitively, we would want to re-
move these anomalies by merging developer accounts where
it makes sense. However, merging by certi(cid:12)cates alone,
which is very accurate, does not signi(cid:12)cantly change the
distribution of lost revenue across our clusters (Phase 2 of
owner graph). Thus, we use the results of Phase 3 of the
owner graph where owners are merged by client IDs to en-
sure that our results do not overestimate the percentage of
lost revenue. Figure 8b shows the impact of merging at each
stage on the P ercImpsLostcluster values, and Table 3 sum-

slidemebrothersoft 344play   1460  1325eoemarketgoapk 396m360  822gfan 629  809androidonline 609  1447 549 448 319onemobile  751AdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URL3.2 Plagiarized Applications

Using a more scalable tool based on DNADroid [6], we
analyzed our application database to look for plagiarized
applications. While DNADroid is highly precise because it
is based on calculating subgraph isomorphism on PDGs, it
is not scalable because it requires pair-wise comparison of
apps. To avoid pairwise comparison, the tool used for this
work converts each app into a set of semantic vectors, each of
which represents a semantic feature of the program. Then,
the tool clusters the semantic vectors of all the apps using
LSH [1]. Finally, the tool considers a set of apps to be clones
if they share a large number of semantic vector clusters and
places these apps into the same clone cluster.

Each clone cluster contains applications published by dif-
ferent developers, as determined by their signing certi(cid:12)cate.
Each application appears in at most one cluster. In total, we
investigate 5,431 clone clusters consisting of 44,268 unique
applications. These clusters may or may not contain the
\victim" of plagiarism, which we call the \original app" in
this paper. Determining the original application is di(cid:14)cult
and unreliable, as described in Section 6.2.1.
3.3 Network Data

We had access to live 3G network data from a tier-1 cellu-
lar network carrier, which consisted of a sample of all tra(cid:14)c
that passed through a particular home agent in the south-
west United States. Packets were tapped from the home
agent and sent to the carrier’s research lab for capture and
analysis. The tap at the home agent was quarter-sampled
at the (cid:13)ow level, so in theory all packets in a particular
(cid:13)ow were available to be captured; however, packets were
lost from limitations in bandwidth and capture speed of the
tapping infrastructure. The network data included all 3G
internet tra(cid:14)c sent from devices registered on the carrier’s
cellular network, including protocol headers and payload.

We captured HTTP tra(cid:14)c from the tap over the course
of 12 days:
from 28 June 2012 to 10 July 2012. Devices
present on the network include both Android and iOS de-
vices, as well as feature phones and wireless cards. The
tra(cid:14)c characteristics are similar to those in [18]. To opti-
mize the capture, only 32 bytes of the protocol header were
captured along with the payload for each packet. Addition-
ally, we performed IP (cid:12)ltering so that only packets with a
source or destination IP address that corresponded with a
known Android ad server were captured. In total, we cap-
tured 2.6 billions packets in our trace. We describe how we
extract ad request data from the trace in Section 4.1.
4. METHODOLOGY

Figure 1 shows the procedure of our study. Our data came
from two sources: (1) HTTP tra(cid:14)c generated by Android
applications on a US tier-1 cellular network, and (2) An-
droid applications downloaded from Android markets. We
correlated the two datasets using advertising client IDs. In
this section we explain how we extracted these IDs, both
from the network and from applications.
4.1 Extracting Client IDs from Network Traces
We now explain how we extract client IDs from ad re-
quests sent by Android applications. We extract advertising
information from our cellular network trace (described in
Section 3.3) by analyzing ad requests at the packet level as
well as at the (cid:13)ow level. In order to identify ad requests,

we manually ran a sample application for each Android ad
provider and captured all tra(cid:14)c from the device so that we
could characterize the format of each provider’s requests.
From each ad request, we record the ad provider, client
ID, anonymized user identi(cid:12)er, and the application package
name if available. We anonymize user identi(cid:12)ers to avoid
recording any potentially sensitive device identi(cid:12)ers, such
as the IMEI. We only record ad requests with an Android
HTTP User-Agent (cid:12)eld.

To get packet level data, we look at the HTTP header
of each packet to determine if it is an ad request from a
recognized Android ad provider and record relevant adver-
tising information. To analyze ad requests at the (cid:13)ow level,
we use the 32 bytes of protocol header to reconstruct each
TCP (cid:13)ow, allowing us to observe both the ad request and
the response from the server. The bene(cid:12)ts of looking at
ad requests at the (cid:13)ow level are twofold. First, we observed
that ad requests for some ad providers are split across multi-
ple packets, especially when the request uses HTTP POST,
so it would be impossible to record the entire ad request in
this case by only looking at packets individually. Second, the
server response allows us to extract the click URL associated
with each impression so that we can match the impression
with any observed clicks in the trace. These clicks can be
linked to an impression and thus a client ID by using the
click URLs that we parse from each (cid:13)ow.

To extract client IDs, we (cid:12)rst identify the ad provider by
examining the host name in the HTTP request. For each ad
provider, we create a pattern to identify its client IDs in the
HTTP requests accurately.

4.2 Extracting Client IDs from Applications
We extract client IDs from Android applications via static
analysis. Commonly, ad providers require developers to pro-
vide their client ID in one of (cid:12)ve ways: declaring it in the
application’s manifest (cid:12)le, declaring it in a layout XML (cid:12)le,
passing it to an ad object in the application code, specifying
it as a constant string, or receiving it dynamically over the
network.

In Android Manifest

4.2.1
The most straightforward client IDs to extract are those
declared in the Android manifest (cid:12)le. Admob, for exam-
ple, recommends that developers store their client IDs in a
meta-data (cid:12)eld with the name admob publisher id. Usu-
ally the client ID is directly included in the Manifest XML;
however, in some cases there can be extra levels of indi-
rection: Android allows developers to abstract values into
constant (cid:12)les such as string.xml. In cases where the de-
veloper has abstracted the client ID using notation such
as @string/admob_id, we resolve these abstractions accord-
ingly.

In Layout XML

4.2.2
Some ad providers recommend that client IDs be included
in one of the auxiliary XML (cid:12)les that developers generate
for their application (not the manifest). Conveniently for us,
these ad providers usually provide an example for developers
to copy and replace the client ID with their own, which
provides a common naming convention for each ad library.
We take advantage of this convention by using XPATH to
search XML (cid:12)les for speci(cid:12)c XML elements known to contain

(a) Initial owners based on devel-
oper accounts (Phase 1)

(b) Owners with edges based on shared certi(cid:12)-
cates (s) and client IDs (c)

(c) Owners after merging (Phases 2
and 3)

Figure 3: Owner graph at various stages in owner merging.

client IDs. For example, Jumptap client IDs are usually in
a (cid:12)eld called jumptaplib:publisherid.

4.2.3 In Application Code
Client IDs that applications pass directly to ad library ini-
tialization methods are the most challenging to extract. The
initialization may happen at any point in the code and the
client ID may be instantiated in a number of ways, includ-
ing being passed in as a constant, received over the network,
generated dynamically, or read in from a (cid:12)le. We observed
that the (cid:12)rst two are the most common cases and focus on
them accordingly.

Speciﬁed as Constants.

We dump values from the DEX string constants section in
the application’s dex (cid:12)le and search for strings that match
the structure of client IDs for each ad library. This approach
is e(cid:11)ective for ad providers whose client IDs follow a distinc-
tive pattern. To improve the precision of this analysis, we
also implemented a static analysis tool that performs con-
stant propagation to detect when constant values are passed
to the client ID argument of ad library initialization meth-
ods. Unfortunately, we found it too slow to run on all of the
apps in our dataset, as it took several minutes per app. We
leave improving the precision of extracting constant-based
client IDs in this manner to future work.

Received Over the Network.

In addition to ad libraries, many applications include Ad-
whirl’s SDK. Adwhirl is not an ad provider, but rather o(cid:11)ers
a service that allows developers to dynamically decide which
ad provider and client ID should be used in their ad requests.
Before an application with Adwhirl makes an ad request, it
queries Adwhirl with its Adwhirl client ID and receives a set
of ad providers and client IDs, which the application then
uses to send ad requests. This service allows developers to
dynamically change the advertising behavior of their apps
without having to push a new version of their app. We han-
dle apps that use Adwhirl by (cid:12)rst extracting Adwhirl client
IDs from the application. Then, we query Adwhirl’s server
to obtain a mapping from an Adwhirl client ID to a set of
client IDs and their ad providers. This allows us to obtain
many client IDs not hardcoded in the applications.

From our application database, we extracted 1,386 unique

Adwhirl client IDs, which mapped to 1,886 unique client
IDs from one of the (cid:12)ve ad providers we eventually used in
this paper (described in Section 5.1). Of these, 1,539 (or
81.6%) were new client IDs that we had not extracted from
our applications. Speci(cid:12)cally, 764 were for admob, 523 for
millennial, and 252 for inmobi.

4.3 Determining Ownership

As our goal is to measure the impact of plagiarism on
developers, we must not regard as plagiarism similar apps
from the same developer, known as rebranded apps. Re-
branded apps may appear on the same or di(cid:11)erent markets.
In this section we discuss how we determine app ownership
by considering developer accounts, signing keys (represented
by certi(cid:12)cates), and client IDs. We make the following as-
sumptions: (cid:12)rst, each owner has her own unique set of cer-
ti(cid:12)cates that are not shared with any other owner; second,
each owner has her own unique set of client IDs that are
not shared with any other owner. In Section 7.1.1 we dis-
cuss caveats associated with these assumptions. Note, how-
ever, that these caveats only cause us to merge owners more
aggressively, resulting in lowering our measured cloning im-
pact.

Merging owners consists of three phases. First, we build
an owner graph where each node corresponds to a unique
developer account that has uploaded an application that we
crawled (Phase 1). Next, we merge owners based on shared
certi(cid:12)cates (Phase 2). Finally, we merge owners based on
shared client IDs (Phase 3). An overview of the owner graph
at various steps in the process is shown in Figure 3.

Phase 1: The (cid:12)rst phase of merging owners is to create a
graph with a node for each unique developer account. Each
developer account is identi(cid:12)ed by the tuple of the market
name and the developer’s name and is associated with one
or more apps in our database. Assuming that developer
accounts are rarely compromised, then two apps from the
same developer account must come from the same owner.
Thus, developer accounts provide an initial mapping of apps
to owners.

Phase 2: Next, we compute the set of certi(cid:12)cates whose
corresponding private keys were used to sign the apps up-
loaded by each developer account. As mentioned in Sec-
tion 2, every Android app must be signed by the developer’s
private key before it may be uploaded to a market and then

A1A5A6A9A10A2A7A3A8A4A1A5s1A6c1A9c1c1A10s4A2A7c2s2A3A8s3A4A1,A5,A6,A9,A10A2,A7A3,A8A4Provider
admob
airpush
inmobi
millennial
mobclix

Impressions Clicks Unique IDs
348,275
138,166
n/a
61,127
32,751

9,288,333
(cid:3)
3,212,878
(cid:3)
220,982
4,855,247
1,547,871

920
n/a
207
n/a
1,080

Table 2: Number of observed impressions, clicks, and
anonymized user identi(cid:12)ers in the network trace, broken
down by ad provider. The report of impression counts uses
packet level ad request analysis, unless otherwise noted (via
(cid:3)
). Note that we were not able to measure clicks for all
providers due to the format of their ad requests (for exam-
ple, those with chunked HTTP encoding). Also note that
inmobi does not include a user identi(cid:12)er in their ad requests.

installed on users’ phones. Since private keys are supposed
to be kept private (we discuss shared and stolen private keys
in Section 7.1.1), two developer accounts that share a cer-
ti(cid:12)cate must share the same owner so they are merged in
the graph.

Phase 3: Finally, we merge any two owners whose appli-
cations share a client ID. Client IDs are used by ad providers
to uniquely identify who should receive revenue for each ad
shown or clicked. Therefore, if two developer accounts share
a client ID, they are likely to be from the same owner.

We separate the merging of owners by certi(cid:12)cates and
client IDs into two phases because we have lower con(cid:12)dence
about merges based on client IDs. This is because client
ID extraction may have false positives while certi(cid:12)cate cal-
culation cannot. Other situations, such as a plagiarist who
leaves the original developer’s client ID intact, are discussed
in Section 7.1.1.

5. EVALUATION

In this section we summarize the raw results of our anal-
ysis and determine the accuracy of our application client ID
extraction.
5.1 Network Client ID Extraction

One important consideration of our work is which Android
ad providers to include in our analysis. We started with 16
ad providers based on their popularity in our application
database. Among these ad providers, seven1 had very small
number of ad requests in our captured tra(cid:14)c (some of them
are Chinese but our tra(cid:14)c was captured in the US), and four
had very little overlap between the client IDs observed on
the network and client IDs extracted from our application
database (Table 1)2. Therefore, we focus on the remaining
(cid:12)ve ad providers, whose number of impressions, clicks, and
unique user identi(cid:12)ers are summarized in Table 2. These
(cid:12)ve ad providers are also among the top six most prevalent
Android ad libraries reported by AppBrain [3]. Because our
network capture was lossy, we were not able to record signif-
icant click results from the trace, as we could only measure
clicks when the ad request, server response, and then click
request did not experience any loss.

1Buzzcity, Mojiva, Quattro, Vdopia, Wooboo, Youmi, Zes-
tAdz
2These four providers only represented 7% of the total num-
ber of ad requests we collected.

5.2 Application Client ID Extraction

While extracting client IDs from HTTP tra(cid:14)c generated
by Android applications is highly accurate, extracting them
automatically from Android applications themselves may
not be as reliable, because client IDs may be provided in sev-
eral di(cid:11)erent ways, some of which are unfriendly to program
analysis (Section 4). Therefore, we would like to evaluate the
accuracy of our client IDs extracted from Android applica-
tions. However, it is di(cid:14)cult to determine the ground truth,
because doing so would require us to manually review all the
applications, which is prohibitive given our large number of
applications. One might suggest that we run each applica-
tion in an emulator to extract the client IDs from its HTTP
tra(cid:14)c. However, an application may contain multiple ad li-
braries, so we may not observe the client IDs from all these
libraries during the execution of the application. Moreover,
some ad libraries would not send ad requests if they detect
that they are running in emulators.

Instead, we take advantage of the client IDs extracted
from HTTP tra(cid:14)c to estimate a lower bound of the accuracy
of our client ID extraction from applications. For each ad
provider AP, let DAP be the set of client IDs extracted from
our application databases, and NAP be the set of client IDs
extracted from our captured HTTP tra(cid:14)c. The network cov-
erage, jNAP \ DAPj=jDAPj, estimates a lower bound of the
true positive rate of our client ID extraction from applica-
tions. The database coverage, jDAP \NAPj=jNAPj, estimates
the coverage our application database on all the Android ap-
plications running on the network where we captured traces.
The results of this analysis are summarized in Table 1.
The database coverages for most providers are fairly high,
indicating that our application database represents a signif-
icant portion of all ad-supported Android applications that
are used in the geographic area where we collected the trace.
6. FINDINGS
6.1 Properties of Apps in Clone Clusters

There are a number of questions that come to mind when
investigating our clone clusters: Which markets do apps in
the clusters belong to? Which markets have the highest
proportion of apps involved in cloning? What categories are
most represented in the clusters? What advertising libraries
do cloners prefer? In this section we seek to answer these
questions by investigating common features of apps in our
clone clusters. Note, at this point we do not yet speculate as
to which app in each clone cluster is the original and which
are clones.
6.1.1 Market Characteristics
Figure 4 shows which Android markets are most preva-
lent in our clone clusters. A signi(cid:12)cant percentage of apps
in our clone clusters are from Google Play; intuitively this
makes sense as Play is the most popular Android market.
To compensate for this observation, we computed what per-
centage of all applications in our database from the mar-
ket are present in a clone cluster.
In this context, Play
does not stand out more than other markets, but a num-
ber of other markets such as AndroidSoft, and the Chinese
markets AndroidOnline, GoApk, and AppChina, have more
than a quarter of their apps in our clone clusters. To bet-
ter understand the cloning relationship between markets, we
calculated the number of similar apps between each pair of

Ad Provider

admob
airpush
inmobi
millennial
mobclix
adfonic
greystripe
jumptap
smaato

Unique client IDs

from databases
51,434
8,728
514
786
2,994
59,170
59,616
8
0

from network
19,718
8,829
487
2,030
1,781
318
212
78
144

Network coverage Database coverage

21.2%
36.9%
28.6%
32.6%
38.0%
0.0%
0.3%
0.0%
n/a

55.4%
36.5%
30.2%
12.6%
63.9%
0.0%
68.4%
0.0%
0.0%

Table 1: Percentage of extracted client IDs we observed in network tra(cid:14)c and percentage of observed network client IDs we
also extracted from the application database, broken down by provider. The lower group of providers are ones which we did
not include in our study because they did not have signi(cid:12)cant overlap with our application database.

Figure 4: Plot showing the popularity of di(cid:11)erent app mar-
kets in our clone clusters. The absolute number of cloned
apps from each market is represented by the axis labelled
\Number of cloned apps", whereas the axis labelled \Per-
centage of apps that are clones" represents the popularity of
each market in our clone clusters normalized over the total
number of apps from that market in our database.

Figure 5: Plot showing the popularity of di(cid:11)erent app cate-
gories in our clone clusters. The absolute number of cloned
apps in each category is represented by the axis labelled
\Number of cloned apps", whereas axis labelled \Percent-
age of apps that are clones" represents the number of cloned
apps in each category normalized over the total number of
apps in that category in our database.

markets in a clone cluster. Speci(cid:12)cally, for the apps in given
clone cluster and a pair of markets (I; J):

M arketSimcluster(I; J) = min(apps from I; apps from J)

Then, to get a global view of the amount of similar appli-

cations between markets we calculate the total M arketSim(I; J)
as follows:

∑

M arketSim(I; J) =

M arketSimc(I; J)

c2clusters

In Figure 7, we plot the results of this calculation in an
undirected graph. To reduce the complexity of the graph,

we only show an edge between markets whose M arketSim
value is over 300 and remove unconnected markets.

We de(cid:12)ne a market as a \cloning hub" if it shares an edge
with many di(cid:11)erent markets in the graph. Play is the largest
cloning hub among all the markets, as it has a signi(cid:12)cant
cloning relationship with almost every other market. Sim-
ilarly, AndroidOnline is a cloning hub among the Chinese
markets. The existence of these cloning hubs implies one
of two things: either plagiarists prefer cloning from apps
on these markets, or that plagiarists prefer these markets
to publish their cloned apps. Since we do not speculate on
which app in a cluster is the original, we leave the determin-
ing which of these cases is true to future work. Note that the

lllllllllllllllllplayslidemeandroidonlinem360brothersoftgfaneoemarketonemobilegoapkandroidsoftandappstorefreewareloverssoftportalappchinaproandroidpocketgearandroiddownloadz050001000020000300000%10%20%30%40%50%MarketNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are cloneslllllllllllllllllllllGamesEntertainmentUtilityBusinessPersonalizationReferenceLifestyleNewsEducationMusicCommunicationSportsTravelFinanceHealthVideoPhotographySocialShoppingWeatherOther020004000600080000%5%10%15%20%25%CategoryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesperiods of time, allowing more advertising revenue to be
generated.

6.1.3 Ad Library Characteristics
Figure 6 gives a breakdown by ad provider of the appli-
cations in our clone clusters, as well as normalized across
our entire application database. Admob is the most popular
provider among cloned applications, but is also the most
popular among all applications, and thus does not have
a higher percentage of cloned apps compared with other
providers. On the other hand, for our Chinese ad providers,
Wooboo and Youmi, cloned applications represent a larger
subset of the total applications that use these providers.
Nonetheless, an alarmingly large percentage of applications
for each provider are in our clone clusters, meaning that they
either are clones of another app, or are a legitimate app that
has been cloned. Note that we do not consider what per-
centage of ad tra(cid:14)c was generated by our clone clusters for
each ad provider, as we do not speculate which app is the
original and want to avoid any assumptions regarding how
much tra(cid:14)c for a provider is a result of app plagiarism. In
the next section, we estimate a lower bound for how much
advertising revenue cloning siphons from legitimate applica-
tions.
6.2 Comparing Clones and Non-clones

In previous sections we examined a number of properties
of apps in our cloned clusters without distinguishing the
\original" apps from the clones.
In this section, we wish
to gain insight into the impact of cloning on developers.
Speci(cid:12)cally, we investigate the e(cid:11)ects of cloning on the orig-
inal authors’ ad revenue and user install base. To do so, the
original author in the cluster must be determined, which is
surprisingly nontrivial.

6.2.1 Determining Original App
There are a number of intuitive approaches one could use
to determine which application among a cluster of similar
applications is the original. Unfortunately, most of these
initial approaches are (cid:13)awed. For example, one could use:

(cid:15) Date (cid:12)rst uploaded to the market
(cid:15) Application popularity by number of installs or rating
(cid:15) Code size by number of methods, instructions, or other

metric

The date an application was (cid:12)rst uploaded to the market
is di(cid:14)cult to know as an external observer. Each market
knows when the application was (cid:12)rst uploaded, but unless
an external observer has been crawling markets since their
creation in both the free and paid sections, she cannot know
for sure which app came (cid:12)rst. Additionally, there have been
cases where beta releases have been taken and uploaded to
markets before the original developer’s app. Application
popularity may sometimes di(cid:11)erentiate the clone from the
original, for example in the case of Angry Birds, however,
for less popular applications, users may be just as likely to
download the clone as the original. Further, application pop-
ularity by both number of installs and ratings is vulnerable
to sybil attacks which would be relatively easy to perform
as most market accounts require only a valid email address.
Lastly, the code size of applications can easily be distorted

Figure 6: Plot showing the popularity of di(cid:11)erent ad li-
braries among apps in our clone clusters. The absolute num-
ber of cloned apps with each library is represented by the
axis labelled \Number of cloned apps", whereas axis labelled
\Percentage of apps that are clones" represents the number
of cloned apps with each library normalized over the total
number of apps with that library in our database.

prevalence of Play as a cloning hub is likely in(cid:13)uenced by
the fact Play represents 73.7% of the apps in our database.

6.1.2 Category Characteristics
We now investigate which app categories are popular among

apps in our clone clusters so that we can better understand
what types of apps are involved in cloning. One di(cid:14)culty
with comparing categories among apps from di(cid:11)erent mar-
kets is that di(cid:11)erent markets use di(cid:11)erent category names
to refer to the same type of application. To avoid this prob-
lem, we chose 21 meta-categories that represent the spec-
trum of di(cid:11)erent categories observed across all our markets
(our mapping from category strings to meta-categories is
presented in the Appendix). Figure 5 presents the num-
ber of applications in our clone clusters that belong to each
meta-category. As we did for markets, we normalize the
number of cloned apps in each category with the number of
all apps in our database for that category to determine what
percentage of apps in the category are involved in cloning.
Interestingly, \Games" is the most popular category among
apps in the clone clusters, but also has the highest preva-
lence of apps involved in cloning. Thus, markets that care
about application cloning should focus on apps categorized
as \Games." Additionally, assuming that the original app
and the clone belong to the same category, this implies pla-
giarists prefer applications categorized as \Games." We hy-
pothesize that this is because games are relatively complex,
popular among Android users, and are often run for long

llllllllllladmobmillennialairpushwoobooyoumimobclixinmobigreystripesmaatojumptapadfonic05000100001500020000250000%5%10%15%20%25%30%35%Ad LibraryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesFigure 7: Markets which have a signi(cid:12)cant cloning relationship. The thickness of an edge is proportional to the M arketSim
value between the markets, and the height of a node is proportional to the sum of the edge weights for a given market. Markets
with nodes colored blue are US-based markets whereas markets with nodes colored red are Chinese-based markets.

Num Clusters
LostImpstotal
P ercLostImpstotal
LostU serstotal
P ercLostU serstotal

P1
610
1,764,609
52%
166,534
49%

P2
370
1,076,614
51%
122,718
48%

P3
128
56,884
14%
3,808
10%

Table 3: Total amount of lost impressions and users across
all of our clone clusters between each phase of developer
merging. The value of Num Clusters represents how many
clone clusters had more than one owner after each phase.
P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3,
respectively.

by plagiarists to make the plagiarized app appear larger or
smaller.

Rather than rely on one of these (cid:13)awed approaches, we
instead use an approach that estimates a lower bound on
our (cid:12)ndings. For each cluster we deem the owner with the
most observed impressions to be the original author and all
other owners are treated as plagiarists. In the case where
clones are more popular than the original, we will mislabel
the original author as a plagiarist, but this is acceptable as
we will only underestimate the percentage of lost advertising
tra(cid:14)c. Indeed, this approach guarantees we will not overes-
timate the number of lost impressions from mislabeling the
original as the above approaches might, as we only consider
the least popular owners in a clone cluster as plagiarists
(other caveats presented in Section 7.1.2). As we will see,
merging developer accounts has signi(cid:12)cant impact over our
results when app owners within a clone cluster are merged
by certi(cid:12)cate or client ID, and in some cases may attribute
all apps within a cluster to the same merged owner. We do
not consider such cases in our computations of lost revenue,
as they do not represent fraudulent cloning.
6.2.2 How much revenue do clones siphon from the

original authors?

In order to determine the impact of plagiarism on the ad-
vertising revenue of the original application, we (cid:12)rst observe

that hard dollar amounts are di(cid:14)cult to determine when
looking at advertising network tra(cid:14)c alone. This is because
an impression does not explicitly indicate how much it is
worth in an ad request, as the ad provider does not want to
disclose how much it or its a(cid:14)liated developers are making.
Instead, we show what percentage of lost ad tra(cid:14)c devel-
opers experience by comparing the ratio of impressions that
belong to plagiarized applications compared with the total
number of impressions we observed belonging to applica-
tions in our clone clusters. The number of lost impressions
for a cluster is represented by LostImpscluster, and the per-
centage of lost impressions for a cluster is this value divided
by all impressions attributed to apps in the cluster, times
100 (represented by P ercLostImpscluster). Additionally,
LostImpstotal represents the total number of plagiarized
app impressions over all the clusters, and P ercLostImpstotal
represents what percentage of all impressions from all clus-
ters that are a results of LostImpstotal.

As previously stated, we consider the original author in a
cluster as the app owner with the greatest amount of adver-
tising tra(cid:14)c, thus the numerator is the number of impres-
sions for all apps in the cluster not owned by this author.
Additionally, we do not consider clusters with only a single
owner. Figure 8a shows a CDF of the P ercImpsLostcluster
values across our clone clusters for each stage of applica-
tion owner merging. When only considering developer ac-
counts on their own (Phase 1 of the owner graph, see Sec-
tion 4.3) nearly 25% of the clusters have exactly 50% lost
revenue. This is a result of clusters having exactly two ap-
plications which belong to di(cid:11)erent developer accounts but
which share a client ID. Intuitively, we would want to re-
move these anomalies by merging developer accounts where
it makes sense. However, merging by certi(cid:12)cates alone,
which is very accurate, does not signi(cid:12)cantly change the
distribution of lost revenue across our clusters (Phase 2 of
owner graph). Thus, we use the results of Phase 3 of the
owner graph where owners are merged by client IDs to en-
sure that our results do not overestimate the percentage of
lost revenue. Figure 8b shows the impact of merging at each
stage on the P ercImpsLostcluster values, and Table 3 sum-

slidemebrothersoft 344play   1460  1325eoemarketgoapk 396m360  822gfan 629  809androidonline 609  1447 549 448 319onemobile  751(a) P ercLostImpscluster

(b) P ercLostImpstotal

Figure 8: CDF and boxplot of percent impact to developers in terms of impressions for each phase of merging on the owner
graph. P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3, respectively.

(a) P ercLostU serscluster

(b) P ercLostU serstotal

Figure 9: CDF and boxplot of percent impact to developers in terms of users for each phase of merging on the owner graph.
P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3, respectively.

0%20%40%60%80%100%0%20%40%60%80%100%Percent revenue lostPercent of clustersP1P2P3P1P2P3Lost Revenue0%20%40%60%80%100%Percentage Lost0%20%40%60%80%100%0%20%40%60%80%100%Percent users lostPercent of clustersP1P2P3P1P2P3Lost Users0%20%40%60%80%100%Percentage LostAdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URL3.2 Plagiarized Applications

Using a more scalable tool based on DNADroid [6], we
analyzed our application database to look for plagiarized
applications. While DNADroid is highly precise because it
is based on calculating subgraph isomorphism on PDGs, it
is not scalable because it requires pair-wise comparison of
apps. To avoid pairwise comparison, the tool used for this
work converts each app into a set of semantic vectors, each of
which represents a semantic feature of the program. Then,
the tool clusters the semantic vectors of all the apps using
LSH [1]. Finally, the tool considers a set of apps to be clones
if they share a large number of semantic vector clusters and
places these apps into the same clone cluster.

Each clone cluster contains applications published by dif-
ferent developers, as determined by their signing certi(cid:12)cate.
Each application appears in at most one cluster. In total, we
investigate 5,431 clone clusters consisting of 44,268 unique
applications. These clusters may or may not contain the
\victim" of plagiarism, which we call the \original app" in
this paper. Determining the original application is di(cid:14)cult
and unreliable, as described in Section 6.2.1.
3.3 Network Data

We had access to live 3G network data from a tier-1 cellu-
lar network carrier, which consisted of a sample of all tra(cid:14)c
that passed through a particular home agent in the south-
west United States. Packets were tapped from the home
agent and sent to the carrier’s research lab for capture and
analysis. The tap at the home agent was quarter-sampled
at the (cid:13)ow level, so in theory all packets in a particular
(cid:13)ow were available to be captured; however, packets were
lost from limitations in bandwidth and capture speed of the
tapping infrastructure. The network data included all 3G
internet tra(cid:14)c sent from devices registered on the carrier’s
cellular network, including protocol headers and payload.

We captured HTTP tra(cid:14)c from the tap over the course
of 12 days:
from 28 June 2012 to 10 July 2012. Devices
present on the network include both Android and iOS de-
vices, as well as feature phones and wireless cards. The
tra(cid:14)c characteristics are similar to those in [18]. To opti-
mize the capture, only 32 bytes of the protocol header were
captured along with the payload for each packet. Addition-
ally, we performed IP (cid:12)ltering so that only packets with a
source or destination IP address that corresponded with a
known Android ad server were captured. In total, we cap-
tured 2.6 billions packets in our trace. We describe how we
extract ad request data from the trace in Section 4.1.
4. METHODOLOGY

Figure 1 shows the procedure of our study. Our data came
from two sources: (1) HTTP tra(cid:14)c generated by Android
applications on a US tier-1 cellular network, and (2) An-
droid applications downloaded from Android markets. We
correlated the two datasets using advertising client IDs. In
this section we explain how we extracted these IDs, both
from the network and from applications.
4.1 Extracting Client IDs from Network Traces
We now explain how we extract client IDs from ad re-
quests sent by Android applications. We extract advertising
information from our cellular network trace (described in
Section 3.3) by analyzing ad requests at the packet level as
well as at the (cid:13)ow level. In order to identify ad requests,

we manually ran a sample application for each Android ad
provider and captured all tra(cid:14)c from the device so that we
could characterize the format of each provider’s requests.
From each ad request, we record the ad provider, client
ID, anonymized user identi(cid:12)er, and the application package
name if available. We anonymize user identi(cid:12)ers to avoid
recording any potentially sensitive device identi(cid:12)ers, such
as the IMEI. We only record ad requests with an Android
HTTP User-Agent (cid:12)eld.

To get packet level data, we look at the HTTP header
of each packet to determine if it is an ad request from a
recognized Android ad provider and record relevant adver-
tising information. To analyze ad requests at the (cid:13)ow level,
we use the 32 bytes of protocol header to reconstruct each
TCP (cid:13)ow, allowing us to observe both the ad request and
the response from the server. The bene(cid:12)ts of looking at
ad requests at the (cid:13)ow level are twofold. First, we observed
that ad requests for some ad providers are split across multi-
ple packets, especially when the request uses HTTP POST,
so it would be impossible to record the entire ad request in
this case by only looking at packets individually. Second, the
server response allows us to extract the click URL associated
with each impression so that we can match the impression
with any observed clicks in the trace. These clicks can be
linked to an impression and thus a client ID by using the
click URLs that we parse from each (cid:13)ow.

To extract client IDs, we (cid:12)rst identify the ad provider by
examining the host name in the HTTP request. For each ad
provider, we create a pattern to identify its client IDs in the
HTTP requests accurately.

4.2 Extracting Client IDs from Applications
We extract client IDs from Android applications via static
analysis. Commonly, ad providers require developers to pro-
vide their client ID in one of (cid:12)ve ways: declaring it in the
application’s manifest (cid:12)le, declaring it in a layout XML (cid:12)le,
passing it to an ad object in the application code, specifying
it as a constant string, or receiving it dynamically over the
network.

In Android Manifest

4.2.1
The most straightforward client IDs to extract are those
declared in the Android manifest (cid:12)le. Admob, for exam-
ple, recommends that developers store their client IDs in a
meta-data (cid:12)eld with the name admob publisher id. Usu-
ally the client ID is directly included in the Manifest XML;
however, in some cases there can be extra levels of indi-
rection: Android allows developers to abstract values into
constant (cid:12)les such as string.xml. In cases where the de-
veloper has abstracted the client ID using notation such
as @string/admob_id, we resolve these abstractions accord-
ingly.

In Layout XML

4.2.2
Some ad providers recommend that client IDs be included
in one of the auxiliary XML (cid:12)les that developers generate
for their application (not the manifest). Conveniently for us,
these ad providers usually provide an example for developers
to copy and replace the client ID with their own, which
provides a common naming convention for each ad library.
We take advantage of this convention by using XPATH to
search XML (cid:12)les for speci(cid:12)c XML elements known to contain

(a) Initial owners based on devel-
oper accounts (Phase 1)

(b) Owners with edges based on shared certi(cid:12)-
cates (s) and client IDs (c)

(c) Owners after merging (Phases 2
and 3)

Figure 3: Owner graph at various stages in owner merging.

client IDs. For example, Jumptap client IDs are usually in
a (cid:12)eld called jumptaplib:publisherid.

4.2.3 In Application Code
Client IDs that applications pass directly to ad library ini-
tialization methods are the most challenging to extract. The
initialization may happen at any point in the code and the
client ID may be instantiated in a number of ways, includ-
ing being passed in as a constant, received over the network,
generated dynamically, or read in from a (cid:12)le. We observed
that the (cid:12)rst two are the most common cases and focus on
them accordingly.

Speciﬁed as Constants.

We dump values from the DEX string constants section in
the application’s dex (cid:12)le and search for strings that match
the structure of client IDs for each ad library. This approach
is e(cid:11)ective for ad providers whose client IDs follow a distinc-
tive pattern. To improve the precision of this analysis, we
also implemented a static analysis tool that performs con-
stant propagation to detect when constant values are passed
to the client ID argument of ad library initialization meth-
ods. Unfortunately, we found it too slow to run on all of the
apps in our dataset, as it took several minutes per app. We
leave improving the precision of extracting constant-based
client IDs in this manner to future work.

Received Over the Network.

In addition to ad libraries, many applications include Ad-
whirl’s SDK. Adwhirl is not an ad provider, but rather o(cid:11)ers
a service that allows developers to dynamically decide which
ad provider and client ID should be used in their ad requests.
Before an application with Adwhirl makes an ad request, it
queries Adwhirl with its Adwhirl client ID and receives a set
of ad providers and client IDs, which the application then
uses to send ad requests. This service allows developers to
dynamically change the advertising behavior of their apps
without having to push a new version of their app. We han-
dle apps that use Adwhirl by (cid:12)rst extracting Adwhirl client
IDs from the application. Then, we query Adwhirl’s server
to obtain a mapping from an Adwhirl client ID to a set of
client IDs and their ad providers. This allows us to obtain
many client IDs not hardcoded in the applications.

From our application database, we extracted 1,386 unique

Adwhirl client IDs, which mapped to 1,886 unique client
IDs from one of the (cid:12)ve ad providers we eventually used in
this paper (described in Section 5.1). Of these, 1,539 (or
81.6%) were new client IDs that we had not extracted from
our applications. Speci(cid:12)cally, 764 were for admob, 523 for
millennial, and 252 for inmobi.

4.3 Determining Ownership

As our goal is to measure the impact of plagiarism on
developers, we must not regard as plagiarism similar apps
from the same developer, known as rebranded apps. Re-
branded apps may appear on the same or di(cid:11)erent markets.
In this section we discuss how we determine app ownership
by considering developer accounts, signing keys (represented
by certi(cid:12)cates), and client IDs. We make the following as-
sumptions: (cid:12)rst, each owner has her own unique set of cer-
ti(cid:12)cates that are not shared with any other owner; second,
each owner has her own unique set of client IDs that are
not shared with any other owner. In Section 7.1.1 we dis-
cuss caveats associated with these assumptions. Note, how-
ever, that these caveats only cause us to merge owners more
aggressively, resulting in lowering our measured cloning im-
pact.

Merging owners consists of three phases. First, we build
an owner graph where each node corresponds to a unique
developer account that has uploaded an application that we
crawled (Phase 1). Next, we merge owners based on shared
certi(cid:12)cates (Phase 2). Finally, we merge owners based on
shared client IDs (Phase 3). An overview of the owner graph
at various steps in the process is shown in Figure 3.

Phase 1: The (cid:12)rst phase of merging owners is to create a
graph with a node for each unique developer account. Each
developer account is identi(cid:12)ed by the tuple of the market
name and the developer’s name and is associated with one
or more apps in our database. Assuming that developer
accounts are rarely compromised, then two apps from the
same developer account must come from the same owner.
Thus, developer accounts provide an initial mapping of apps
to owners.

Phase 2: Next, we compute the set of certi(cid:12)cates whose
corresponding private keys were used to sign the apps up-
loaded by each developer account. As mentioned in Sec-
tion 2, every Android app must be signed by the developer’s
private key before it may be uploaded to a market and then

A1A5A6A9A10A2A7A3A8A4A1A5s1A6c1A9c1c1A10s4A2A7c2s2A3A8s3A4A1,A5,A6,A9,A10A2,A7A3,A8A4Provider
admob
airpush
inmobi
millennial
mobclix

Impressions Clicks Unique IDs
348,275
138,166
n/a
61,127
32,751

9,288,333
(cid:3)
3,212,878
(cid:3)
220,982
4,855,247
1,547,871

920
n/a
207
n/a
1,080

Table 2: Number of observed impressions, clicks, and
anonymized user identi(cid:12)ers in the network trace, broken
down by ad provider. The report of impression counts uses
packet level ad request analysis, unless otherwise noted (via
(cid:3)
). Note that we were not able to measure clicks for all
providers due to the format of their ad requests (for exam-
ple, those with chunked HTTP encoding). Also note that
inmobi does not include a user identi(cid:12)er in their ad requests.

installed on users’ phones. Since private keys are supposed
to be kept private (we discuss shared and stolen private keys
in Section 7.1.1), two developer accounts that share a cer-
ti(cid:12)cate must share the same owner so they are merged in
the graph.

Phase 3: Finally, we merge any two owners whose appli-
cations share a client ID. Client IDs are used by ad providers
to uniquely identify who should receive revenue for each ad
shown or clicked. Therefore, if two developer accounts share
a client ID, they are likely to be from the same owner.

We separate the merging of owners by certi(cid:12)cates and
client IDs into two phases because we have lower con(cid:12)dence
about merges based on client IDs. This is because client
ID extraction may have false positives while certi(cid:12)cate cal-
culation cannot. Other situations, such as a plagiarist who
leaves the original developer’s client ID intact, are discussed
in Section 7.1.1.

5. EVALUATION

In this section we summarize the raw results of our anal-
ysis and determine the accuracy of our application client ID
extraction.
5.1 Network Client ID Extraction

One important consideration of our work is which Android
ad providers to include in our analysis. We started with 16
ad providers based on their popularity in our application
database. Among these ad providers, seven1 had very small
number of ad requests in our captured tra(cid:14)c (some of them
are Chinese but our tra(cid:14)c was captured in the US), and four
had very little overlap between the client IDs observed on
the network and client IDs extracted from our application
database (Table 1)2. Therefore, we focus on the remaining
(cid:12)ve ad providers, whose number of impressions, clicks, and
unique user identi(cid:12)ers are summarized in Table 2. These
(cid:12)ve ad providers are also among the top six most prevalent
Android ad libraries reported by AppBrain [3]. Because our
network capture was lossy, we were not able to record signif-
icant click results from the trace, as we could only measure
clicks when the ad request, server response, and then click
request did not experience any loss.

1Buzzcity, Mojiva, Quattro, Vdopia, Wooboo, Youmi, Zes-
tAdz
2These four providers only represented 7% of the total num-
ber of ad requests we collected.

5.2 Application Client ID Extraction

While extracting client IDs from HTTP tra(cid:14)c generated
by Android applications is highly accurate, extracting them
automatically from Android applications themselves may
not be as reliable, because client IDs may be provided in sev-
eral di(cid:11)erent ways, some of which are unfriendly to program
analysis (Section 4). Therefore, we would like to evaluate the
accuracy of our client IDs extracted from Android applica-
tions. However, it is di(cid:14)cult to determine the ground truth,
because doing so would require us to manually review all the
applications, which is prohibitive given our large number of
applications. One might suggest that we run each applica-
tion in an emulator to extract the client IDs from its HTTP
tra(cid:14)c. However, an application may contain multiple ad li-
braries, so we may not observe the client IDs from all these
libraries during the execution of the application. Moreover,
some ad libraries would not send ad requests if they detect
that they are running in emulators.

Instead, we take advantage of the client IDs extracted
from HTTP tra(cid:14)c to estimate a lower bound of the accuracy
of our client ID extraction from applications. For each ad
provider AP, let DAP be the set of client IDs extracted from
our application databases, and NAP be the set of client IDs
extracted from our captured HTTP tra(cid:14)c. The network cov-
erage, jNAP \ DAPj=jDAPj, estimates a lower bound of the
true positive rate of our client ID extraction from applica-
tions. The database coverage, jDAP \NAPj=jNAPj, estimates
the coverage our application database on all the Android ap-
plications running on the network where we captured traces.
The results of this analysis are summarized in Table 1.
The database coverages for most providers are fairly high,
indicating that our application database represents a signif-
icant portion of all ad-supported Android applications that
are used in the geographic area where we collected the trace.
6. FINDINGS
6.1 Properties of Apps in Clone Clusters

There are a number of questions that come to mind when
investigating our clone clusters: Which markets do apps in
the clusters belong to? Which markets have the highest
proportion of apps involved in cloning? What categories are
most represented in the clusters? What advertising libraries
do cloners prefer? In this section we seek to answer these
questions by investigating common features of apps in our
clone clusters. Note, at this point we do not yet speculate as
to which app in each clone cluster is the original and which
are clones.
6.1.1 Market Characteristics
Figure 4 shows which Android markets are most preva-
lent in our clone clusters. A signi(cid:12)cant percentage of apps
in our clone clusters are from Google Play; intuitively this
makes sense as Play is the most popular Android market.
To compensate for this observation, we computed what per-
centage of all applications in our database from the mar-
ket are present in a clone cluster.
In this context, Play
does not stand out more than other markets, but a num-
ber of other markets such as AndroidSoft, and the Chinese
markets AndroidOnline, GoApk, and AppChina, have more
than a quarter of their apps in our clone clusters. To bet-
ter understand the cloning relationship between markets, we
calculated the number of similar apps between each pair of

Ad Provider

admob
airpush
inmobi
millennial
mobclix
adfonic
greystripe
jumptap
smaato

Unique client IDs

from databases
51,434
8,728
514
786
2,994
59,170
59,616
8
0

from network
19,718
8,829
487
2,030
1,781
318
212
78
144

Network coverage Database coverage

21.2%
36.9%
28.6%
32.6%
38.0%
0.0%
0.3%
0.0%
n/a

55.4%
36.5%
30.2%
12.6%
63.9%
0.0%
68.4%
0.0%
0.0%

Table 1: Percentage of extracted client IDs we observed in network tra(cid:14)c and percentage of observed network client IDs we
also extracted from the application database, broken down by provider. The lower group of providers are ones which we did
not include in our study because they did not have signi(cid:12)cant overlap with our application database.

Figure 4: Plot showing the popularity of di(cid:11)erent app mar-
kets in our clone clusters. The absolute number of cloned
apps from each market is represented by the axis labelled
\Number of cloned apps", whereas the axis labelled \Per-
centage of apps that are clones" represents the popularity of
each market in our clone clusters normalized over the total
number of apps from that market in our database.

Figure 5: Plot showing the popularity of di(cid:11)erent app cate-
gories in our clone clusters. The absolute number of cloned
apps in each category is represented by the axis labelled
\Number of cloned apps", whereas axis labelled \Percent-
age of apps that are clones" represents the number of cloned
apps in each category normalized over the total number of
apps in that category in our database.

markets in a clone cluster. Speci(cid:12)cally, for the apps in given
clone cluster and a pair of markets (I; J):

M arketSimcluster(I; J) = min(apps from I; apps from J)

Then, to get a global view of the amount of similar appli-

cations between markets we calculate the total M arketSim(I; J)
as follows:

∑

M arketSim(I; J) =

M arketSimc(I; J)

c2clusters

In Figure 7, we plot the results of this calculation in an
undirected graph. To reduce the complexity of the graph,

we only show an edge between markets whose M arketSim
value is over 300 and remove unconnected markets.

We de(cid:12)ne a market as a \cloning hub" if it shares an edge
with many di(cid:11)erent markets in the graph. Play is the largest
cloning hub among all the markets, as it has a signi(cid:12)cant
cloning relationship with almost every other market. Sim-
ilarly, AndroidOnline is a cloning hub among the Chinese
markets. The existence of these cloning hubs implies one
of two things: either plagiarists prefer cloning from apps
on these markets, or that plagiarists prefer these markets
to publish their cloned apps. Since we do not speculate on
which app in a cluster is the original, we leave the determin-
ing which of these cases is true to future work. Note that the

lllllllllllllllllplayslidemeandroidonlinem360brothersoftgfaneoemarketonemobilegoapkandroidsoftandappstorefreewareloverssoftportalappchinaproandroidpocketgearandroiddownloadz050001000020000300000%10%20%30%40%50%MarketNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are cloneslllllllllllllllllllllGamesEntertainmentUtilityBusinessPersonalizationReferenceLifestyleNewsEducationMusicCommunicationSportsTravelFinanceHealthVideoPhotographySocialShoppingWeatherOther020004000600080000%5%10%15%20%25%CategoryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesperiods of time, allowing more advertising revenue to be
generated.

6.1.3 Ad Library Characteristics
Figure 6 gives a breakdown by ad provider of the appli-
cations in our clone clusters, as well as normalized across
our entire application database. Admob is the most popular
provider among cloned applications, but is also the most
popular among all applications, and thus does not have
a higher percentage of cloned apps compared with other
providers. On the other hand, for our Chinese ad providers,
Wooboo and Youmi, cloned applications represent a larger
subset of the total applications that use these providers.
Nonetheless, an alarmingly large percentage of applications
for each provider are in our clone clusters, meaning that they
either are clones of another app, or are a legitimate app that
has been cloned. Note that we do not consider what per-
centage of ad tra(cid:14)c was generated by our clone clusters for
each ad provider, as we do not speculate which app is the
original and want to avoid any assumptions regarding how
much tra(cid:14)c for a provider is a result of app plagiarism. In
the next section, we estimate a lower bound for how much
advertising revenue cloning siphons from legitimate applica-
tions.
6.2 Comparing Clones and Non-clones

In previous sections we examined a number of properties
of apps in our cloned clusters without distinguishing the
\original" apps from the clones.
In this section, we wish
to gain insight into the impact of cloning on developers.
Speci(cid:12)cally, we investigate the e(cid:11)ects of cloning on the orig-
inal authors’ ad revenue and user install base. To do so, the
original author in the cluster must be determined, which is
surprisingly nontrivial.

6.2.1 Determining Original App
There are a number of intuitive approaches one could use
to determine which application among a cluster of similar
applications is the original. Unfortunately, most of these
initial approaches are (cid:13)awed. For example, one could use:

(cid:15) Date (cid:12)rst uploaded to the market
(cid:15) Application popularity by number of installs or rating
(cid:15) Code size by number of methods, instructions, or other

metric

The date an application was (cid:12)rst uploaded to the market
is di(cid:14)cult to know as an external observer. Each market
knows when the application was (cid:12)rst uploaded, but unless
an external observer has been crawling markets since their
creation in both the free and paid sections, she cannot know
for sure which app came (cid:12)rst. Additionally, there have been
cases where beta releases have been taken and uploaded to
markets before the original developer’s app. Application
popularity may sometimes di(cid:11)erentiate the clone from the
original, for example in the case of Angry Birds, however,
for less popular applications, users may be just as likely to
download the clone as the original. Further, application pop-
ularity by both number of installs and ratings is vulnerable
to sybil attacks which would be relatively easy to perform
as most market accounts require only a valid email address.
Lastly, the code size of applications can easily be distorted

Figure 6: Plot showing the popularity of di(cid:11)erent ad li-
braries among apps in our clone clusters. The absolute num-
ber of cloned apps with each library is represented by the
axis labelled \Number of cloned apps", whereas axis labelled
\Percentage of apps that are clones" represents the number
of cloned apps with each library normalized over the total
number of apps with that library in our database.

prevalence of Play as a cloning hub is likely in(cid:13)uenced by
the fact Play represents 73.7% of the apps in our database.

6.1.2 Category Characteristics
We now investigate which app categories are popular among

apps in our clone clusters so that we can better understand
what types of apps are involved in cloning. One di(cid:14)culty
with comparing categories among apps from di(cid:11)erent mar-
kets is that di(cid:11)erent markets use di(cid:11)erent category names
to refer to the same type of application. To avoid this prob-
lem, we chose 21 meta-categories that represent the spec-
trum of di(cid:11)erent categories observed across all our markets
(our mapping from category strings to meta-categories is
presented in the Appendix). Figure 5 presents the num-
ber of applications in our clone clusters that belong to each
meta-category. As we did for markets, we normalize the
number of cloned apps in each category with the number of
all apps in our database for that category to determine what
percentage of apps in the category are involved in cloning.
Interestingly, \Games" is the most popular category among
apps in the clone clusters, but also has the highest preva-
lence of apps involved in cloning. Thus, markets that care
about application cloning should focus on apps categorized
as \Games." Additionally, assuming that the original app
and the clone belong to the same category, this implies pla-
giarists prefer applications categorized as \Games." We hy-
pothesize that this is because games are relatively complex,
popular among Android users, and are often run for long

llllllllllladmobmillennialairpushwoobooyoumimobclixinmobigreystripesmaatojumptapadfonic05000100001500020000250000%5%10%15%20%25%30%35%Ad LibraryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesFigure 7: Markets which have a signi(cid:12)cant cloning relationship. The thickness of an edge is proportional to the M arketSim
value between the markets, and the height of a node is proportional to the sum of the edge weights for a given market. Markets
with nodes colored blue are US-based markets whereas markets with nodes colored red are Chinese-based markets.

Num Clusters
LostImpstotal
P ercLostImpstotal
LostU serstotal
P ercLostU serstotal

P1
610
1,764,609
52%
166,534
49%

P2
370
1,076,614
51%
122,718
48%

P3
128
56,884
14%
3,808
10%

Table 3: Total amount of lost impressions and users across
all of our clone clusters between each phase of developer
merging. The value of Num Clusters represents how many
clone clusters had more than one owner after each phase.
P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3,
respectively.

by plagiarists to make the plagiarized app appear larger or
smaller.

Rather than rely on one of these (cid:13)awed approaches, we
instead use an approach that estimates a lower bound on
our (cid:12)ndings. For each cluster we deem the owner with the
most observed impressions to be the original author and all
other owners are treated as plagiarists. In the case where
clones are more popular than the original, we will mislabel
the original author as a plagiarist, but this is acceptable as
we will only underestimate the percentage of lost advertising
tra(cid:14)c. Indeed, this approach guarantees we will not overes-
timate the number of lost impressions from mislabeling the
original as the above approaches might, as we only consider
the least popular owners in a clone cluster as plagiarists
(other caveats presented in Section 7.1.2). As we will see,
merging developer accounts has signi(cid:12)cant impact over our
results when app owners within a clone cluster are merged
by certi(cid:12)cate or client ID, and in some cases may attribute
all apps within a cluster to the same merged owner. We do
not consider such cases in our computations of lost revenue,
as they do not represent fraudulent cloning.
6.2.2 How much revenue do clones siphon from the

original authors?

In order to determine the impact of plagiarism on the ad-
vertising revenue of the original application, we (cid:12)rst observe

that hard dollar amounts are di(cid:14)cult to determine when
looking at advertising network tra(cid:14)c alone. This is because
an impression does not explicitly indicate how much it is
worth in an ad request, as the ad provider does not want to
disclose how much it or its a(cid:14)liated developers are making.
Instead, we show what percentage of lost ad tra(cid:14)c devel-
opers experience by comparing the ratio of impressions that
belong to plagiarized applications compared with the total
number of impressions we observed belonging to applica-
tions in our clone clusters. The number of lost impressions
for a cluster is represented by LostImpscluster, and the per-
centage of lost impressions for a cluster is this value divided
by all impressions attributed to apps in the cluster, times
100 (represented by P ercLostImpscluster). Additionally,
LostImpstotal represents the total number of plagiarized
app impressions over all the clusters, and P ercLostImpstotal
represents what percentage of all impressions from all clus-
ters that are a results of LostImpstotal.

As previously stated, we consider the original author in a
cluster as the app owner with the greatest amount of adver-
tising tra(cid:14)c, thus the numerator is the number of impres-
sions for all apps in the cluster not owned by this author.
Additionally, we do not consider clusters with only a single
owner. Figure 8a shows a CDF of the P ercImpsLostcluster
values across our clone clusters for each stage of applica-
tion owner merging. When only considering developer ac-
counts on their own (Phase 1 of the owner graph, see Sec-
tion 4.3) nearly 25% of the clusters have exactly 50% lost
revenue. This is a result of clusters having exactly two ap-
plications which belong to di(cid:11)erent developer accounts but
which share a client ID. Intuitively, we would want to re-
move these anomalies by merging developer accounts where
it makes sense. However, merging by certi(cid:12)cates alone,
which is very accurate, does not signi(cid:12)cantly change the
distribution of lost revenue across our clusters (Phase 2 of
owner graph). Thus, we use the results of Phase 3 of the
owner graph where owners are merged by client IDs to en-
sure that our results do not overestimate the percentage of
lost revenue. Figure 8b shows the impact of merging at each
stage on the P ercImpsLostcluster values, and Table 3 sum-

slidemebrothersoft 344play   1460  1325eoemarketgoapk 396m360  822gfan 629  809androidonline 609  1447 549 448 319onemobile  751(a) P ercLostImpscluster

(b) P ercLostImpstotal

Figure 8: CDF and boxplot of percent impact to developers in terms of impressions for each phase of merging on the owner
graph. P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3, respectively.

(a) P ercLostU serscluster

(b) P ercLostU serstotal

Figure 9: CDF and boxplot of percent impact to developers in terms of users for each phase of merging on the owner graph.
P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3, respectively.

0%20%40%60%80%100%0%20%40%60%80%100%Percent revenue lostPercent of clustersP1P2P3P1P2P3Lost Revenue0%20%40%60%80%100%Percentage Lost0%20%40%60%80%100%0%20%40%60%80%100%Percent users lostPercent of clustersP1P2P3P1P2P3Lost Users0%20%40%60%80%100%Percentage Lostmarizes the total impact over all the clusters. Alarmingly,
the value of LostImpstotal after all developer account merg-
ing is complete is 14%, meaning that authors who are the
target of cloning on average lost 14% of their advertising
revenue to application plagiarism, assuming the users who
downloaded the plagiarized versions would have used the
original app instead.
6.2.3 How much of the user base do clones divert

from the original app?

To determine how much user base application plagiarism
siphons from the original authors, we used the anonymized
device identi(cid:12)ers present in the ad tra(cid:14)c from our network
trace to estimate the number of unique users per application.
Similar to lost impressions, we compute the LostU serscluster
and P ercLostU serscluster values for each cluster and plot
the distribution in Figure 9a. We also compute the total
number of lost users across all our clusters as LostU serstotal
and the percentage lost across all the clusters as P ercLost-
U serstotal. The value of these are summarized in Figure 9b
and Table 3. We see that on average, 10% of the user base
for an author in our clone clusters is siphoned due to plagia-
rism if we assume the users who downloaded the plagiarized
applications would have used the original app if no plagia-
rism were present.

7. DISCUSSION
7.1 Limitations

7.1.1 Authorship Determination
During our exploration of potential methods for merging
owners we encountered several challenges. All of these chal-
lenges could cause our analysis to merge developer accounts
more aggresively, potentially causing us to underestimate
lost impressions and users due to plagiarism.

Certiﬁcates Shared By Many Apps.

We found that some certi(cid:12)cates are present on many apps
that are associated with a large number of developer ac-
counts on several markets. Eight certi(cid:12)cates were present on
apps from over one hundred developer accounts, the largest
having 413. After manually reviewing the developer ac-
counts associated with several of the most prevalent cer-
ti(cid:12)cates, we decided that either one or several parties made
a signi(cid:12)cant attempt to distribute their apps across many
developer accounts or that the private keys were leaked or
stolen. In fact, we discovered one of the certi(cid:12)cates corre-
sponds to a private key used in the Android Open Source
Project3 (AOSP). These keys are often used to sign custom
ROMs. Apps signed with these keys can run with greater
privileges when running on a custom ROM and some mal-
ware has been found to take advantage of this [21]. Regard-
less of why many developer accounts share a certi(cid:12)cate, we
were surprised to (cid:12)nd that two apps sharing a certi(cid:12)cate
may not necessarily have the same owner.

Apps With Multiple Certiﬁcates.

Though it has not been discussed in the literature to the
best of our knowledge and is only brie(cid:13)y mentioned in the
Android documentation page on signing apps [23], Android

3http://source.android.com/

apps may be signed with multiple developer keys. We found
667 apps in our dataset that have more than one certi(cid:12)cate,
with the largest having four. Android developers may do
this as a means to collaborate with another developer or to
ease the process of selling an app to a company [15, 19].

We hoped to use apps with multiple keys to merge owners
in possession of at least one of the keys. Intuitively, if one
app is signed by developer keys A and B, one would like
to merge the owners of each key, as the developer of an
app should have possession of each key that signed her app.
We manually reviewed a number of cases where we tried
to merge owners based on apps with multiple keys. While
in several cases the developer accounts of each key seemed
related, this was not always the case. Thus, in this work we
ignore any app with multiple certi(cid:12)cates as they may taint
our results. Furthermore, these apps constitute a very small
portion of our dataset (667 out of 265,359 apps).

Lazy Cloning.

We de(cid:12)ne \lazy cloning" to be cases when a cloner copies
an app but does not change all of the client IDs in ad libraries
contained in the original app. This would cause our analysis
to merge the owners representing the original developer and
the cloner, as they are responsible for apps that share a
client ID. We believe this occurs infrequently in practice, as
one of the major incentives behind cloning is (cid:12)nancial gains.
7.1.2 Estimation on Lost Revenue and User Base
Since we cannot identify the original app in a clone cluster
reliably, we choose the most popular app, measured by the
number of ad impressions, as the original app. While this
decision provides a lower bound estimation on the percent
lost revenue and user base in most cases, it would fail in the
following unusual cases.

Failure to merge owners.

When we fail to merge two di(cid:11)erent developer accounts of
the same owner, we could in(cid:13)ate the number of unique own-
ers in a clone cluster. This would happen when an owner
publishes similar apps from di(cid:11)erent developer accounts us-
ing di(cid:11)erent certi(cid:12)cates and di(cid:11)erent client IDs. Additional
information, such as payment accounts and addresses, from
app markets or ad providers could improve our app owner-
ship determination.

Sharing of client IDs between different apps.

We assume that one client ID is speci(cid:12)c to one family
of similar apps. However, if a developer includes the same
client ID in di(cid:11)erent apps but only some of them are in a
clone cluster, we could in(cid:13)ate the number of impressions
generated by the apps in the cluster. To verify this occurs
rarely in practice, we calculated the total number of client
IDs of which only a subset were in a cluster. Only 0.65%
of our client IDs appear in apps both in and out of a clus-
ter; thus, client ID sharing does not signi(cid:12)cantly impact our
results.

Missing original apps.

If our database fails to include the original app for a clus-
ter, we may overestimate the losses in cases where the miss-
ing original app is very popular. For example, we could (cid:12)nd
a large impression or user base di(cid:11)erential between two An-
gry Birds clones, leading us to calculate a strong developer

AdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URL3.2 Plagiarized Applications

Using a more scalable tool based on DNADroid [6], we
analyzed our application database to look for plagiarized
applications. While DNADroid is highly precise because it
is based on calculating subgraph isomorphism on PDGs, it
is not scalable because it requires pair-wise comparison of
apps. To avoid pairwise comparison, the tool used for this
work converts each app into a set of semantic vectors, each of
which represents a semantic feature of the program. Then,
the tool clusters the semantic vectors of all the apps using
LSH [1]. Finally, the tool considers a set of apps to be clones
if they share a large number of semantic vector clusters and
places these apps into the same clone cluster.

Each clone cluster contains applications published by dif-
ferent developers, as determined by their signing certi(cid:12)cate.
Each application appears in at most one cluster. In total, we
investigate 5,431 clone clusters consisting of 44,268 unique
applications. These clusters may or may not contain the
\victim" of plagiarism, which we call the \original app" in
this paper. Determining the original application is di(cid:14)cult
and unreliable, as described in Section 6.2.1.
3.3 Network Data

We had access to live 3G network data from a tier-1 cellu-
lar network carrier, which consisted of a sample of all tra(cid:14)c
that passed through a particular home agent in the south-
west United States. Packets were tapped from the home
agent and sent to the carrier’s research lab for capture and
analysis. The tap at the home agent was quarter-sampled
at the (cid:13)ow level, so in theory all packets in a particular
(cid:13)ow were available to be captured; however, packets were
lost from limitations in bandwidth and capture speed of the
tapping infrastructure. The network data included all 3G
internet tra(cid:14)c sent from devices registered on the carrier’s
cellular network, including protocol headers and payload.

We captured HTTP tra(cid:14)c from the tap over the course
of 12 days:
from 28 June 2012 to 10 July 2012. Devices
present on the network include both Android and iOS de-
vices, as well as feature phones and wireless cards. The
tra(cid:14)c characteristics are similar to those in [18]. To opti-
mize the capture, only 32 bytes of the protocol header were
captured along with the payload for each packet. Addition-
ally, we performed IP (cid:12)ltering so that only packets with a
source or destination IP address that corresponded with a
known Android ad server were captured. In total, we cap-
tured 2.6 billions packets in our trace. We describe how we
extract ad request data from the trace in Section 4.1.
4. METHODOLOGY

Figure 1 shows the procedure of our study. Our data came
from two sources: (1) HTTP tra(cid:14)c generated by Android
applications on a US tier-1 cellular network, and (2) An-
droid applications downloaded from Android markets. We
correlated the two datasets using advertising client IDs. In
this section we explain how we extracted these IDs, both
from the network and from applications.
4.1 Extracting Client IDs from Network Traces
We now explain how we extract client IDs from ad re-
quests sent by Android applications. We extract advertising
information from our cellular network trace (described in
Section 3.3) by analyzing ad requests at the packet level as
well as at the (cid:13)ow level. In order to identify ad requests,

we manually ran a sample application for each Android ad
provider and captured all tra(cid:14)c from the device so that we
could characterize the format of each provider’s requests.
From each ad request, we record the ad provider, client
ID, anonymized user identi(cid:12)er, and the application package
name if available. We anonymize user identi(cid:12)ers to avoid
recording any potentially sensitive device identi(cid:12)ers, such
as the IMEI. We only record ad requests with an Android
HTTP User-Agent (cid:12)eld.

To get packet level data, we look at the HTTP header
of each packet to determine if it is an ad request from a
recognized Android ad provider and record relevant adver-
tising information. To analyze ad requests at the (cid:13)ow level,
we use the 32 bytes of protocol header to reconstruct each
TCP (cid:13)ow, allowing us to observe both the ad request and
the response from the server. The bene(cid:12)ts of looking at
ad requests at the (cid:13)ow level are twofold. First, we observed
that ad requests for some ad providers are split across multi-
ple packets, especially when the request uses HTTP POST,
so it would be impossible to record the entire ad request in
this case by only looking at packets individually. Second, the
server response allows us to extract the click URL associated
with each impression so that we can match the impression
with any observed clicks in the trace. These clicks can be
linked to an impression and thus a client ID by using the
click URLs that we parse from each (cid:13)ow.

To extract client IDs, we (cid:12)rst identify the ad provider by
examining the host name in the HTTP request. For each ad
provider, we create a pattern to identify its client IDs in the
HTTP requests accurately.

4.2 Extracting Client IDs from Applications
We extract client IDs from Android applications via static
analysis. Commonly, ad providers require developers to pro-
vide their client ID in one of (cid:12)ve ways: declaring it in the
application’s manifest (cid:12)le, declaring it in a layout XML (cid:12)le,
passing it to an ad object in the application code, specifying
it as a constant string, or receiving it dynamically over the
network.

In Android Manifest

4.2.1
The most straightforward client IDs to extract are those
declared in the Android manifest (cid:12)le. Admob, for exam-
ple, recommends that developers store their client IDs in a
meta-data (cid:12)eld with the name admob publisher id. Usu-
ally the client ID is directly included in the Manifest XML;
however, in some cases there can be extra levels of indi-
rection: Android allows developers to abstract values into
constant (cid:12)les such as string.xml. In cases where the de-
veloper has abstracted the client ID using notation such
as @string/admob_id, we resolve these abstractions accord-
ingly.

In Layout XML

4.2.2
Some ad providers recommend that client IDs be included
in one of the auxiliary XML (cid:12)les that developers generate
for their application (not the manifest). Conveniently for us,
these ad providers usually provide an example for developers
to copy and replace the client ID with their own, which
provides a common naming convention for each ad library.
We take advantage of this convention by using XPATH to
search XML (cid:12)les for speci(cid:12)c XML elements known to contain

(a) Initial owners based on devel-
oper accounts (Phase 1)

(b) Owners with edges based on shared certi(cid:12)-
cates (s) and client IDs (c)

(c) Owners after merging (Phases 2
and 3)

Figure 3: Owner graph at various stages in owner merging.

client IDs. For example, Jumptap client IDs are usually in
a (cid:12)eld called jumptaplib:publisherid.

4.2.3 In Application Code
Client IDs that applications pass directly to ad library ini-
tialization methods are the most challenging to extract. The
initialization may happen at any point in the code and the
client ID may be instantiated in a number of ways, includ-
ing being passed in as a constant, received over the network,
generated dynamically, or read in from a (cid:12)le. We observed
that the (cid:12)rst two are the most common cases and focus on
them accordingly.

Speciﬁed as Constants.

We dump values from the DEX string constants section in
the application’s dex (cid:12)le and search for strings that match
the structure of client IDs for each ad library. This approach
is e(cid:11)ective for ad providers whose client IDs follow a distinc-
tive pattern. To improve the precision of this analysis, we
also implemented a static analysis tool that performs con-
stant propagation to detect when constant values are passed
to the client ID argument of ad library initialization meth-
ods. Unfortunately, we found it too slow to run on all of the
apps in our dataset, as it took several minutes per app. We
leave improving the precision of extracting constant-based
client IDs in this manner to future work.

Received Over the Network.

In addition to ad libraries, many applications include Ad-
whirl’s SDK. Adwhirl is not an ad provider, but rather o(cid:11)ers
a service that allows developers to dynamically decide which
ad provider and client ID should be used in their ad requests.
Before an application with Adwhirl makes an ad request, it
queries Adwhirl with its Adwhirl client ID and receives a set
of ad providers and client IDs, which the application then
uses to send ad requests. This service allows developers to
dynamically change the advertising behavior of their apps
without having to push a new version of their app. We han-
dle apps that use Adwhirl by (cid:12)rst extracting Adwhirl client
IDs from the application. Then, we query Adwhirl’s server
to obtain a mapping from an Adwhirl client ID to a set of
client IDs and their ad providers. This allows us to obtain
many client IDs not hardcoded in the applications.

From our application database, we extracted 1,386 unique

Adwhirl client IDs, which mapped to 1,886 unique client
IDs from one of the (cid:12)ve ad providers we eventually used in
this paper (described in Section 5.1). Of these, 1,539 (or
81.6%) were new client IDs that we had not extracted from
our applications. Speci(cid:12)cally, 764 were for admob, 523 for
millennial, and 252 for inmobi.

4.3 Determining Ownership

As our goal is to measure the impact of plagiarism on
developers, we must not regard as plagiarism similar apps
from the same developer, known as rebranded apps. Re-
branded apps may appear on the same or di(cid:11)erent markets.
In this section we discuss how we determine app ownership
by considering developer accounts, signing keys (represented
by certi(cid:12)cates), and client IDs. We make the following as-
sumptions: (cid:12)rst, each owner has her own unique set of cer-
ti(cid:12)cates that are not shared with any other owner; second,
each owner has her own unique set of client IDs that are
not shared with any other owner. In Section 7.1.1 we dis-
cuss caveats associated with these assumptions. Note, how-
ever, that these caveats only cause us to merge owners more
aggressively, resulting in lowering our measured cloning im-
pact.

Merging owners consists of three phases. First, we build
an owner graph where each node corresponds to a unique
developer account that has uploaded an application that we
crawled (Phase 1). Next, we merge owners based on shared
certi(cid:12)cates (Phase 2). Finally, we merge owners based on
shared client IDs (Phase 3). An overview of the owner graph
at various steps in the process is shown in Figure 3.

Phase 1: The (cid:12)rst phase of merging owners is to create a
graph with a node for each unique developer account. Each
developer account is identi(cid:12)ed by the tuple of the market
name and the developer’s name and is associated with one
or more apps in our database. Assuming that developer
accounts are rarely compromised, then two apps from the
same developer account must come from the same owner.
Thus, developer accounts provide an initial mapping of apps
to owners.

Phase 2: Next, we compute the set of certi(cid:12)cates whose
corresponding private keys were used to sign the apps up-
loaded by each developer account. As mentioned in Sec-
tion 2, every Android app must be signed by the developer’s
private key before it may be uploaded to a market and then

A1A5A6A9A10A2A7A3A8A4A1A5s1A6c1A9c1c1A10s4A2A7c2s2A3A8s3A4A1,A5,A6,A9,A10A2,A7A3,A8A4Provider
admob
airpush
inmobi
millennial
mobclix

Impressions Clicks Unique IDs
348,275
138,166
n/a
61,127
32,751

9,288,333
(cid:3)
3,212,878
(cid:3)
220,982
4,855,247
1,547,871

920
n/a
207
n/a
1,080

Table 2: Number of observed impressions, clicks, and
anonymized user identi(cid:12)ers in the network trace, broken
down by ad provider. The report of impression counts uses
packet level ad request analysis, unless otherwise noted (via
(cid:3)
). Note that we were not able to measure clicks for all
providers due to the format of their ad requests (for exam-
ple, those with chunked HTTP encoding). Also note that
inmobi does not include a user identi(cid:12)er in their ad requests.

installed on users’ phones. Since private keys are supposed
to be kept private (we discuss shared and stolen private keys
in Section 7.1.1), two developer accounts that share a cer-
ti(cid:12)cate must share the same owner so they are merged in
the graph.

Phase 3: Finally, we merge any two owners whose appli-
cations share a client ID. Client IDs are used by ad providers
to uniquely identify who should receive revenue for each ad
shown or clicked. Therefore, if two developer accounts share
a client ID, they are likely to be from the same owner.

We separate the merging of owners by certi(cid:12)cates and
client IDs into two phases because we have lower con(cid:12)dence
about merges based on client IDs. This is because client
ID extraction may have false positives while certi(cid:12)cate cal-
culation cannot. Other situations, such as a plagiarist who
leaves the original developer’s client ID intact, are discussed
in Section 7.1.1.

5. EVALUATION

In this section we summarize the raw results of our anal-
ysis and determine the accuracy of our application client ID
extraction.
5.1 Network Client ID Extraction

One important consideration of our work is which Android
ad providers to include in our analysis. We started with 16
ad providers based on their popularity in our application
database. Among these ad providers, seven1 had very small
number of ad requests in our captured tra(cid:14)c (some of them
are Chinese but our tra(cid:14)c was captured in the US), and four
had very little overlap between the client IDs observed on
the network and client IDs extracted from our application
database (Table 1)2. Therefore, we focus on the remaining
(cid:12)ve ad providers, whose number of impressions, clicks, and
unique user identi(cid:12)ers are summarized in Table 2. These
(cid:12)ve ad providers are also among the top six most prevalent
Android ad libraries reported by AppBrain [3]. Because our
network capture was lossy, we were not able to record signif-
icant click results from the trace, as we could only measure
clicks when the ad request, server response, and then click
request did not experience any loss.

1Buzzcity, Mojiva, Quattro, Vdopia, Wooboo, Youmi, Zes-
tAdz
2These four providers only represented 7% of the total num-
ber of ad requests we collected.

5.2 Application Client ID Extraction

While extracting client IDs from HTTP tra(cid:14)c generated
by Android applications is highly accurate, extracting them
automatically from Android applications themselves may
not be as reliable, because client IDs may be provided in sev-
eral di(cid:11)erent ways, some of which are unfriendly to program
analysis (Section 4). Therefore, we would like to evaluate the
accuracy of our client IDs extracted from Android applica-
tions. However, it is di(cid:14)cult to determine the ground truth,
because doing so would require us to manually review all the
applications, which is prohibitive given our large number of
applications. One might suggest that we run each applica-
tion in an emulator to extract the client IDs from its HTTP
tra(cid:14)c. However, an application may contain multiple ad li-
braries, so we may not observe the client IDs from all these
libraries during the execution of the application. Moreover,
some ad libraries would not send ad requests if they detect
that they are running in emulators.

Instead, we take advantage of the client IDs extracted
from HTTP tra(cid:14)c to estimate a lower bound of the accuracy
of our client ID extraction from applications. For each ad
provider AP, let DAP be the set of client IDs extracted from
our application databases, and NAP be the set of client IDs
extracted from our captured HTTP tra(cid:14)c. The network cov-
erage, jNAP \ DAPj=jDAPj, estimates a lower bound of the
true positive rate of our client ID extraction from applica-
tions. The database coverage, jDAP \NAPj=jNAPj, estimates
the coverage our application database on all the Android ap-
plications running on the network where we captured traces.
The results of this analysis are summarized in Table 1.
The database coverages for most providers are fairly high,
indicating that our application database represents a signif-
icant portion of all ad-supported Android applications that
are used in the geographic area where we collected the trace.
6. FINDINGS
6.1 Properties of Apps in Clone Clusters

There are a number of questions that come to mind when
investigating our clone clusters: Which markets do apps in
the clusters belong to? Which markets have the highest
proportion of apps involved in cloning? What categories are
most represented in the clusters? What advertising libraries
do cloners prefer? In this section we seek to answer these
questions by investigating common features of apps in our
clone clusters. Note, at this point we do not yet speculate as
to which app in each clone cluster is the original and which
are clones.
6.1.1 Market Characteristics
Figure 4 shows which Android markets are most preva-
lent in our clone clusters. A signi(cid:12)cant percentage of apps
in our clone clusters are from Google Play; intuitively this
makes sense as Play is the most popular Android market.
To compensate for this observation, we computed what per-
centage of all applications in our database from the mar-
ket are present in a clone cluster.
In this context, Play
does not stand out more than other markets, but a num-
ber of other markets such as AndroidSoft, and the Chinese
markets AndroidOnline, GoApk, and AppChina, have more
than a quarter of their apps in our clone clusters. To bet-
ter understand the cloning relationship between markets, we
calculated the number of similar apps between each pair of

Ad Provider

admob
airpush
inmobi
millennial
mobclix
adfonic
greystripe
jumptap
smaato

Unique client IDs

from databases
51,434
8,728
514
786
2,994
59,170
59,616
8
0

from network
19,718
8,829
487
2,030
1,781
318
212
78
144

Network coverage Database coverage

21.2%
36.9%
28.6%
32.6%
38.0%
0.0%
0.3%
0.0%
n/a

55.4%
36.5%
30.2%
12.6%
63.9%
0.0%
68.4%
0.0%
0.0%

Table 1: Percentage of extracted client IDs we observed in network tra(cid:14)c and percentage of observed network client IDs we
also extracted from the application database, broken down by provider. The lower group of providers are ones which we did
not include in our study because they did not have signi(cid:12)cant overlap with our application database.

Figure 4: Plot showing the popularity of di(cid:11)erent app mar-
kets in our clone clusters. The absolute number of cloned
apps from each market is represented by the axis labelled
\Number of cloned apps", whereas the axis labelled \Per-
centage of apps that are clones" represents the popularity of
each market in our clone clusters normalized over the total
number of apps from that market in our database.

Figure 5: Plot showing the popularity of di(cid:11)erent app cate-
gories in our clone clusters. The absolute number of cloned
apps in each category is represented by the axis labelled
\Number of cloned apps", whereas axis labelled \Percent-
age of apps that are clones" represents the number of cloned
apps in each category normalized over the total number of
apps in that category in our database.

markets in a clone cluster. Speci(cid:12)cally, for the apps in given
clone cluster and a pair of markets (I; J):

M arketSimcluster(I; J) = min(apps from I; apps from J)

Then, to get a global view of the amount of similar appli-

cations between markets we calculate the total M arketSim(I; J)
as follows:

∑

M arketSim(I; J) =

M arketSimc(I; J)

c2clusters

In Figure 7, we plot the results of this calculation in an
undirected graph. To reduce the complexity of the graph,

we only show an edge between markets whose M arketSim
value is over 300 and remove unconnected markets.

We de(cid:12)ne a market as a \cloning hub" if it shares an edge
with many di(cid:11)erent markets in the graph. Play is the largest
cloning hub among all the markets, as it has a signi(cid:12)cant
cloning relationship with almost every other market. Sim-
ilarly, AndroidOnline is a cloning hub among the Chinese
markets. The existence of these cloning hubs implies one
of two things: either plagiarists prefer cloning from apps
on these markets, or that plagiarists prefer these markets
to publish their cloned apps. Since we do not speculate on
which app in a cluster is the original, we leave the determin-
ing which of these cases is true to future work. Note that the

lllllllllllllllllplayslidemeandroidonlinem360brothersoftgfaneoemarketonemobilegoapkandroidsoftandappstorefreewareloverssoftportalappchinaproandroidpocketgearandroiddownloadz050001000020000300000%10%20%30%40%50%MarketNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are cloneslllllllllllllllllllllGamesEntertainmentUtilityBusinessPersonalizationReferenceLifestyleNewsEducationMusicCommunicationSportsTravelFinanceHealthVideoPhotographySocialShoppingWeatherOther020004000600080000%5%10%15%20%25%CategoryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesperiods of time, allowing more advertising revenue to be
generated.

6.1.3 Ad Library Characteristics
Figure 6 gives a breakdown by ad provider of the appli-
cations in our clone clusters, as well as normalized across
our entire application database. Admob is the most popular
provider among cloned applications, but is also the most
popular among all applications, and thus does not have
a higher percentage of cloned apps compared with other
providers. On the other hand, for our Chinese ad providers,
Wooboo and Youmi, cloned applications represent a larger
subset of the total applications that use these providers.
Nonetheless, an alarmingly large percentage of applications
for each provider are in our clone clusters, meaning that they
either are clones of another app, or are a legitimate app that
has been cloned. Note that we do not consider what per-
centage of ad tra(cid:14)c was generated by our clone clusters for
each ad provider, as we do not speculate which app is the
original and want to avoid any assumptions regarding how
much tra(cid:14)c for a provider is a result of app plagiarism. In
the next section, we estimate a lower bound for how much
advertising revenue cloning siphons from legitimate applica-
tions.
6.2 Comparing Clones and Non-clones

In previous sections we examined a number of properties
of apps in our cloned clusters without distinguishing the
\original" apps from the clones.
In this section, we wish
to gain insight into the impact of cloning on developers.
Speci(cid:12)cally, we investigate the e(cid:11)ects of cloning on the orig-
inal authors’ ad revenue and user install base. To do so, the
original author in the cluster must be determined, which is
surprisingly nontrivial.

6.2.1 Determining Original App
There are a number of intuitive approaches one could use
to determine which application among a cluster of similar
applications is the original. Unfortunately, most of these
initial approaches are (cid:13)awed. For example, one could use:

(cid:15) Date (cid:12)rst uploaded to the market
(cid:15) Application popularity by number of installs or rating
(cid:15) Code size by number of methods, instructions, or other

metric

The date an application was (cid:12)rst uploaded to the market
is di(cid:14)cult to know as an external observer. Each market
knows when the application was (cid:12)rst uploaded, but unless
an external observer has been crawling markets since their
creation in both the free and paid sections, she cannot know
for sure which app came (cid:12)rst. Additionally, there have been
cases where beta releases have been taken and uploaded to
markets before the original developer’s app. Application
popularity may sometimes di(cid:11)erentiate the clone from the
original, for example in the case of Angry Birds, however,
for less popular applications, users may be just as likely to
download the clone as the original. Further, application pop-
ularity by both number of installs and ratings is vulnerable
to sybil attacks which would be relatively easy to perform
as most market accounts require only a valid email address.
Lastly, the code size of applications can easily be distorted

Figure 6: Plot showing the popularity of di(cid:11)erent ad li-
braries among apps in our clone clusters. The absolute num-
ber of cloned apps with each library is represented by the
axis labelled \Number of cloned apps", whereas axis labelled
\Percentage of apps that are clones" represents the number
of cloned apps with each library normalized over the total
number of apps with that library in our database.

prevalence of Play as a cloning hub is likely in(cid:13)uenced by
the fact Play represents 73.7% of the apps in our database.

6.1.2 Category Characteristics
We now investigate which app categories are popular among

apps in our clone clusters so that we can better understand
what types of apps are involved in cloning. One di(cid:14)culty
with comparing categories among apps from di(cid:11)erent mar-
kets is that di(cid:11)erent markets use di(cid:11)erent category names
to refer to the same type of application. To avoid this prob-
lem, we chose 21 meta-categories that represent the spec-
trum of di(cid:11)erent categories observed across all our markets
(our mapping from category strings to meta-categories is
presented in the Appendix). Figure 5 presents the num-
ber of applications in our clone clusters that belong to each
meta-category. As we did for markets, we normalize the
number of cloned apps in each category with the number of
all apps in our database for that category to determine what
percentage of apps in the category are involved in cloning.
Interestingly, \Games" is the most popular category among
apps in the clone clusters, but also has the highest preva-
lence of apps involved in cloning. Thus, markets that care
about application cloning should focus on apps categorized
as \Games." Additionally, assuming that the original app
and the clone belong to the same category, this implies pla-
giarists prefer applications categorized as \Games." We hy-
pothesize that this is because games are relatively complex,
popular among Android users, and are often run for long

llllllllllladmobmillennialairpushwoobooyoumimobclixinmobigreystripesmaatojumptapadfonic05000100001500020000250000%5%10%15%20%25%30%35%Ad LibraryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesFigure 7: Markets which have a signi(cid:12)cant cloning relationship. The thickness of an edge is proportional to the M arketSim
value between the markets, and the height of a node is proportional to the sum of the edge weights for a given market. Markets
with nodes colored blue are US-based markets whereas markets with nodes colored red are Chinese-based markets.

Num Clusters
LostImpstotal
P ercLostImpstotal
LostU serstotal
P ercLostU serstotal

P1
610
1,764,609
52%
166,534
49%

P2
370
1,076,614
51%
122,718
48%

P3
128
56,884
14%
3,808
10%

Table 3: Total amount of lost impressions and users across
all of our clone clusters between each phase of developer
merging. The value of Num Clusters represents how many
clone clusters had more than one owner after each phase.
P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3,
respectively.

by plagiarists to make the plagiarized app appear larger or
smaller.

Rather than rely on one of these (cid:13)awed approaches, we
instead use an approach that estimates a lower bound on
our (cid:12)ndings. For each cluster we deem the owner with the
most observed impressions to be the original author and all
other owners are treated as plagiarists. In the case where
clones are more popular than the original, we will mislabel
the original author as a plagiarist, but this is acceptable as
we will only underestimate the percentage of lost advertising
tra(cid:14)c. Indeed, this approach guarantees we will not overes-
timate the number of lost impressions from mislabeling the
original as the above approaches might, as we only consider
the least popular owners in a clone cluster as plagiarists
(other caveats presented in Section 7.1.2). As we will see,
merging developer accounts has signi(cid:12)cant impact over our
results when app owners within a clone cluster are merged
by certi(cid:12)cate or client ID, and in some cases may attribute
all apps within a cluster to the same merged owner. We do
not consider such cases in our computations of lost revenue,
as they do not represent fraudulent cloning.
6.2.2 How much revenue do clones siphon from the

original authors?

In order to determine the impact of plagiarism on the ad-
vertising revenue of the original application, we (cid:12)rst observe

that hard dollar amounts are di(cid:14)cult to determine when
looking at advertising network tra(cid:14)c alone. This is because
an impression does not explicitly indicate how much it is
worth in an ad request, as the ad provider does not want to
disclose how much it or its a(cid:14)liated developers are making.
Instead, we show what percentage of lost ad tra(cid:14)c devel-
opers experience by comparing the ratio of impressions that
belong to plagiarized applications compared with the total
number of impressions we observed belonging to applica-
tions in our clone clusters. The number of lost impressions
for a cluster is represented by LostImpscluster, and the per-
centage of lost impressions for a cluster is this value divided
by all impressions attributed to apps in the cluster, times
100 (represented by P ercLostImpscluster). Additionally,
LostImpstotal represents the total number of plagiarized
app impressions over all the clusters, and P ercLostImpstotal
represents what percentage of all impressions from all clus-
ters that are a results of LostImpstotal.

As previously stated, we consider the original author in a
cluster as the app owner with the greatest amount of adver-
tising tra(cid:14)c, thus the numerator is the number of impres-
sions for all apps in the cluster not owned by this author.
Additionally, we do not consider clusters with only a single
owner. Figure 8a shows a CDF of the P ercImpsLostcluster
values across our clone clusters for each stage of applica-
tion owner merging. When only considering developer ac-
counts on their own (Phase 1 of the owner graph, see Sec-
tion 4.3) nearly 25% of the clusters have exactly 50% lost
revenue. This is a result of clusters having exactly two ap-
plications which belong to di(cid:11)erent developer accounts but
which share a client ID. Intuitively, we would want to re-
move these anomalies by merging developer accounts where
it makes sense. However, merging by certi(cid:12)cates alone,
which is very accurate, does not signi(cid:12)cantly change the
distribution of lost revenue across our clusters (Phase 2 of
owner graph). Thus, we use the results of Phase 3 of the
owner graph where owners are merged by client IDs to en-
sure that our results do not overestimate the percentage of
lost revenue. Figure 8b shows the impact of merging at each
stage on the P ercImpsLostcluster values, and Table 3 sum-

slidemebrothersoft 344play   1460  1325eoemarketgoapk 396m360  822gfan 629  809androidonline 609  1447 549 448 319onemobile  751(a) P ercLostImpscluster

(b) P ercLostImpstotal

Figure 8: CDF and boxplot of percent impact to developers in terms of impressions for each phase of merging on the owner
graph. P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3, respectively.

(a) P ercLostU serscluster

(b) P ercLostU serstotal

Figure 9: CDF and boxplot of percent impact to developers in terms of users for each phase of merging on the owner graph.
P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3, respectively.

0%20%40%60%80%100%0%20%40%60%80%100%Percent revenue lostPercent of clustersP1P2P3P1P2P3Lost Revenue0%20%40%60%80%100%Percentage Lost0%20%40%60%80%100%0%20%40%60%80%100%Percent users lostPercent of clustersP1P2P3P1P2P3Lost Users0%20%40%60%80%100%Percentage Lostmarizes the total impact over all the clusters. Alarmingly,
the value of LostImpstotal after all developer account merg-
ing is complete is 14%, meaning that authors who are the
target of cloning on average lost 14% of their advertising
revenue to application plagiarism, assuming the users who
downloaded the plagiarized versions would have used the
original app instead.
6.2.3 How much of the user base do clones divert

from the original app?

To determine how much user base application plagiarism
siphons from the original authors, we used the anonymized
device identi(cid:12)ers present in the ad tra(cid:14)c from our network
trace to estimate the number of unique users per application.
Similar to lost impressions, we compute the LostU serscluster
and P ercLostU serscluster values for each cluster and plot
the distribution in Figure 9a. We also compute the total
number of lost users across all our clusters as LostU serstotal
and the percentage lost across all the clusters as P ercLost-
U serstotal. The value of these are summarized in Figure 9b
and Table 3. We see that on average, 10% of the user base
for an author in our clone clusters is siphoned due to plagia-
rism if we assume the users who downloaded the plagiarized
applications would have used the original app if no plagia-
rism were present.

7. DISCUSSION
7.1 Limitations

7.1.1 Authorship Determination
During our exploration of potential methods for merging
owners we encountered several challenges. All of these chal-
lenges could cause our analysis to merge developer accounts
more aggresively, potentially causing us to underestimate
lost impressions and users due to plagiarism.

Certiﬁcates Shared By Many Apps.

We found that some certi(cid:12)cates are present on many apps
that are associated with a large number of developer ac-
counts on several markets. Eight certi(cid:12)cates were present on
apps from over one hundred developer accounts, the largest
having 413. After manually reviewing the developer ac-
counts associated with several of the most prevalent cer-
ti(cid:12)cates, we decided that either one or several parties made
a signi(cid:12)cant attempt to distribute their apps across many
developer accounts or that the private keys were leaked or
stolen. In fact, we discovered one of the certi(cid:12)cates corre-
sponds to a private key used in the Android Open Source
Project3 (AOSP). These keys are often used to sign custom
ROMs. Apps signed with these keys can run with greater
privileges when running on a custom ROM and some mal-
ware has been found to take advantage of this [21]. Regard-
less of why many developer accounts share a certi(cid:12)cate, we
were surprised to (cid:12)nd that two apps sharing a certi(cid:12)cate
may not necessarily have the same owner.

Apps With Multiple Certiﬁcates.

Though it has not been discussed in the literature to the
best of our knowledge and is only brie(cid:13)y mentioned in the
Android documentation page on signing apps [23], Android

3http://source.android.com/

apps may be signed with multiple developer keys. We found
667 apps in our dataset that have more than one certi(cid:12)cate,
with the largest having four. Android developers may do
this as a means to collaborate with another developer or to
ease the process of selling an app to a company [15, 19].

We hoped to use apps with multiple keys to merge owners
in possession of at least one of the keys. Intuitively, if one
app is signed by developer keys A and B, one would like
to merge the owners of each key, as the developer of an
app should have possession of each key that signed her app.
We manually reviewed a number of cases where we tried
to merge owners based on apps with multiple keys. While
in several cases the developer accounts of each key seemed
related, this was not always the case. Thus, in this work we
ignore any app with multiple certi(cid:12)cates as they may taint
our results. Furthermore, these apps constitute a very small
portion of our dataset (667 out of 265,359 apps).

Lazy Cloning.

We de(cid:12)ne \lazy cloning" to be cases when a cloner copies
an app but does not change all of the client IDs in ad libraries
contained in the original app. This would cause our analysis
to merge the owners representing the original developer and
the cloner, as they are responsible for apps that share a
client ID. We believe this occurs infrequently in practice, as
one of the major incentives behind cloning is (cid:12)nancial gains.
7.1.2 Estimation on Lost Revenue and User Base
Since we cannot identify the original app in a clone cluster
reliably, we choose the most popular app, measured by the
number of ad impressions, as the original app. While this
decision provides a lower bound estimation on the percent
lost revenue and user base in most cases, it would fail in the
following unusual cases.

Failure to merge owners.

When we fail to merge two di(cid:11)erent developer accounts of
the same owner, we could in(cid:13)ate the number of unique own-
ers in a clone cluster. This would happen when an owner
publishes similar apps from di(cid:11)erent developer accounts us-
ing di(cid:11)erent certi(cid:12)cates and di(cid:11)erent client IDs. Additional
information, such as payment accounts and addresses, from
app markets or ad providers could improve our app owner-
ship determination.

Sharing of client IDs between different apps.

We assume that one client ID is speci(cid:12)c to one family
of similar apps. However, if a developer includes the same
client ID in di(cid:11)erent apps but only some of them are in a
clone cluster, we could in(cid:13)ate the number of impressions
generated by the apps in the cluster. To verify this occurs
rarely in practice, we calculated the total number of client
IDs of which only a subset were in a cluster. Only 0.65%
of our client IDs appear in apps both in and out of a clus-
ter; thus, client ID sharing does not signi(cid:12)cantly impact our
results.

Missing original apps.

If our database fails to include the original app for a clus-
ter, we may overestimate the losses in cases where the miss-
ing original app is very popular. For example, we could (cid:12)nd
a large impression or user base di(cid:11)erential between two An-
gry Birds clones, leading us to calculate a strong developer

loss. However, by missing the original Angry Birds app we
wouldn’t see that it had many impressions, so the real loss
ratio is quite low. We believe this is unlikely to occur as
our crawling focused on both newly published and popular
apps.

Paid apps.

The estimated lost revenue and users is based on the as-
sumption that if a clone app were unavailable,
its users
would have installed the original app and spent the same
amount of time on it. Since we focus exclusively on free
apps, it is reasonable to assume there is little di(cid:11)erence be-
tween (cid:12)nding, installing, and running the original app and
its clones. However, this assumption may not hold when
considering paid apps.

7.2 Potential Steps to Reduce Cloning

A primary goal of our e(cid:11)ort to gain insight into the current
state of Android app cloning is to protect Android develop-
ers and users. Technical solutions such as the automatic
plagiarism detection methods used for this work [6] should
be employed by markets to improve the speed with which
clones are caught and removed from markets. Reducing the
lifetime of clones on markets limits their downloads and thus
their impact.

However, as Android apps are straightforward to decom-
pile, modify, and resubmit to markets, we do not believe
technical solutions alone are su(cid:14)cient. Detection tools can
always continue to be improved, but it is unlikely that a tool
can catch every clone, whether it’s due to lack of access to
every app across every market or signi(cid:12)cant code obfusca-
tions. Instead, we believe reducing economic incentives is a
more e(cid:11)ective way to limit app cloning. For example, if all
markets began charging at least a nominal registration fee
then cloners would have to make back the registration cost
from their clones before the account is banned or they will
lose money. This also disincentives a plagiarist from cre-
ating many developer accounts, possibly making plagiarism
detection easier. Similarly, ad providers could also charge a
registration fee or delay ad revenue payout for some period
of time to allow the developer’s apps to be vetted. By in-
creasing the time and/or cost to create developer accounts
or sign up with ad providers, legitimate developers may be
slightly a(cid:11)ected but cloners wishing to create many devel-
oper or ad provider accounts can be signi(cid:12)cantly impeded.
We o(cid:11)er these potential solutions with caution, as one of
the great advantages of the Android ecosystem is its open-
ness and low barrier to entry. The associated costs must be
carefully weighed to reduce cloning while not discouraging
legitimate developers.

8. RELATED WORK

Malicious activities on Android.

Prior work examined information leaks within an applica-
tion [9] and between applications [8]. Researchers discussed
privacy violations in third-party libraries, especially adver-
tising libraries [12, 22, 20, 24]. [29] characterized Android
malware. DroidMOSS [28] and DNADroid [6] detected
repackaged and cloned Android applications.

Examining the impact of malicious activities.

Kanich et al. investigated the underground economy of
spam [14, 17]. Prior work examining the impact of malicious
activities primarily focused on fraud that harmed the user,
such as fake anti-virus software [26], keyloggers [13], and
spam [25]. By contrast, application plagiarism detriments
mainly the original developers of the plagiarized applica-
tions by taking away their users and advertising revenue.
Online advertising fraud has been extensively studied in the
literature [7, 11, 27]; however, application cloning does not
necessarily imply advertising fraud because the advertiser
still receives impressions and clicks from the users of cloned
applications.

9. CONCLUSION

In this paper we presented AdRob, which is designed to be
the (cid:12)rst step towards understanding the economic incentives
of application plagiarism on Android markets. We charac-
terized application plagiarism and its impact on developers
by crawling 265,359 free applications from 17 Android mar-
kets around the world and detecting clones among them.
We captured live HTTP tra(cid:14)c generated by mobile appli-
cations at a tier-1 US cellular carrier for 12 days, and ex-
tracted client IDs from both applications and network traces
to correlate the two datasets. Based on the data, we (cid:12)rst ex-
amined properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examined how cloned applications
a(cid:11)ect the origin developers. We estimated a lower bound on
the revenue that cloned applications siphon from the original
developers, and the user base that cloned applications divert
from the original applications, and (cid:12)nd an alarmingly high
percentage of impressions is siphoned from developers who
are victims of plagiarism. To the best of our knowledge, this
is the (cid:12)rst large scale study on the characteristics of cloned
applications and their impact on the original developers.

10. ACKNOWLEDGEMENTS

We would like to thank Sharad Agarwal and the anony-
mous reviewers for their insightful feedback, as well as Liang
Cai, Dennis Xu, Ben Sanders, Justin Horton, and Jon Vron-
sky for their assistance in obtaining Android applications.
This paper is based upon work supported by the National
Science Foundation under Grant No. 1018964.

References
[1] A. Andoni and P. Indyk. \Near-optimal hashing al-
gorithms for approximate nearest neighbor in high di-
mensions". In: Foundations of Computer Science, 2006.
FOCS’06. 47th Annual IEEE Symposium on. Ieee. 2006,
pp. 459{468.

[2] Jason Ankeny. Feds seize Android app marketplaces
Applanet, AppBucket in piracy sting. Aug. 22, 2012.
url: http://www.fiercemobilecontent.com/story/
feds-seize-android-app-marketplaces-applanet-
appbucket-piracy-sting/2012-08-22.

[3] AppBrain. Android Ad networks. Mar. 2013. url: http:

//www.appbrain.com/stats/libraries/ad.

[4] AppBrain. Number of available android applications.
Nov. 2012. url: http://www.appbrain.com/stats/
number-of-android-apps.

AdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URL3.2 Plagiarized Applications

Using a more scalable tool based on DNADroid [6], we
analyzed our application database to look for plagiarized
applications. While DNADroid is highly precise because it
is based on calculating subgraph isomorphism on PDGs, it
is not scalable because it requires pair-wise comparison of
apps. To avoid pairwise comparison, the tool used for this
work converts each app into a set of semantic vectors, each of
which represents a semantic feature of the program. Then,
the tool clusters the semantic vectors of all the apps using
LSH [1]. Finally, the tool considers a set of apps to be clones
if they share a large number of semantic vector clusters and
places these apps into the same clone cluster.

Each clone cluster contains applications published by dif-
ferent developers, as determined by their signing certi(cid:12)cate.
Each application appears in at most one cluster. In total, we
investigate 5,431 clone clusters consisting of 44,268 unique
applications. These clusters may or may not contain the
\victim" of plagiarism, which we call the \original app" in
this paper. Determining the original application is di(cid:14)cult
and unreliable, as described in Section 6.2.1.
3.3 Network Data

We had access to live 3G network data from a tier-1 cellu-
lar network carrier, which consisted of a sample of all tra(cid:14)c
that passed through a particular home agent in the south-
west United States. Packets were tapped from the home
agent and sent to the carrier’s research lab for capture and
analysis. The tap at the home agent was quarter-sampled
at the (cid:13)ow level, so in theory all packets in a particular
(cid:13)ow were available to be captured; however, packets were
lost from limitations in bandwidth and capture speed of the
tapping infrastructure. The network data included all 3G
internet tra(cid:14)c sent from devices registered on the carrier’s
cellular network, including protocol headers and payload.

We captured HTTP tra(cid:14)c from the tap over the course
of 12 days:
from 28 June 2012 to 10 July 2012. Devices
present on the network include both Android and iOS de-
vices, as well as feature phones and wireless cards. The
tra(cid:14)c characteristics are similar to those in [18]. To opti-
mize the capture, only 32 bytes of the protocol header were
captured along with the payload for each packet. Addition-
ally, we performed IP (cid:12)ltering so that only packets with a
source or destination IP address that corresponded with a
known Android ad server were captured. In total, we cap-
tured 2.6 billions packets in our trace. We describe how we
extract ad request data from the trace in Section 4.1.
4. METHODOLOGY

Figure 1 shows the procedure of our study. Our data came
from two sources: (1) HTTP tra(cid:14)c generated by Android
applications on a US tier-1 cellular network, and (2) An-
droid applications downloaded from Android markets. We
correlated the two datasets using advertising client IDs. In
this section we explain how we extracted these IDs, both
from the network and from applications.
4.1 Extracting Client IDs from Network Traces
We now explain how we extract client IDs from ad re-
quests sent by Android applications. We extract advertising
information from our cellular network trace (described in
Section 3.3) by analyzing ad requests at the packet level as
well as at the (cid:13)ow level. In order to identify ad requests,

we manually ran a sample application for each Android ad
provider and captured all tra(cid:14)c from the device so that we
could characterize the format of each provider’s requests.
From each ad request, we record the ad provider, client
ID, anonymized user identi(cid:12)er, and the application package
name if available. We anonymize user identi(cid:12)ers to avoid
recording any potentially sensitive device identi(cid:12)ers, such
as the IMEI. We only record ad requests with an Android
HTTP User-Agent (cid:12)eld.

To get packet level data, we look at the HTTP header
of each packet to determine if it is an ad request from a
recognized Android ad provider and record relevant adver-
tising information. To analyze ad requests at the (cid:13)ow level,
we use the 32 bytes of protocol header to reconstruct each
TCP (cid:13)ow, allowing us to observe both the ad request and
the response from the server. The bene(cid:12)ts of looking at
ad requests at the (cid:13)ow level are twofold. First, we observed
that ad requests for some ad providers are split across multi-
ple packets, especially when the request uses HTTP POST,
so it would be impossible to record the entire ad request in
this case by only looking at packets individually. Second, the
server response allows us to extract the click URL associated
with each impression so that we can match the impression
with any observed clicks in the trace. These clicks can be
linked to an impression and thus a client ID by using the
click URLs that we parse from each (cid:13)ow.

To extract client IDs, we (cid:12)rst identify the ad provider by
examining the host name in the HTTP request. For each ad
provider, we create a pattern to identify its client IDs in the
HTTP requests accurately.

4.2 Extracting Client IDs from Applications
We extract client IDs from Android applications via static
analysis. Commonly, ad providers require developers to pro-
vide their client ID in one of (cid:12)ve ways: declaring it in the
application’s manifest (cid:12)le, declaring it in a layout XML (cid:12)le,
passing it to an ad object in the application code, specifying
it as a constant string, or receiving it dynamically over the
network.

In Android Manifest

4.2.1
The most straightforward client IDs to extract are those
declared in the Android manifest (cid:12)le. Admob, for exam-
ple, recommends that developers store their client IDs in a
meta-data (cid:12)eld with the name admob publisher id. Usu-
ally the client ID is directly included in the Manifest XML;
however, in some cases there can be extra levels of indi-
rection: Android allows developers to abstract values into
constant (cid:12)les such as string.xml. In cases where the de-
veloper has abstracted the client ID using notation such
as @string/admob_id, we resolve these abstractions accord-
ingly.

In Layout XML

4.2.2
Some ad providers recommend that client IDs be included
in one of the auxiliary XML (cid:12)les that developers generate
for their application (not the manifest). Conveniently for us,
these ad providers usually provide an example for developers
to copy and replace the client ID with their own, which
provides a common naming convention for each ad library.
We take advantage of this convention by using XPATH to
search XML (cid:12)les for speci(cid:12)c XML elements known to contain

(a) Initial owners based on devel-
oper accounts (Phase 1)

(b) Owners with edges based on shared certi(cid:12)-
cates (s) and client IDs (c)

(c) Owners after merging (Phases 2
and 3)

Figure 3: Owner graph at various stages in owner merging.

client IDs. For example, Jumptap client IDs are usually in
a (cid:12)eld called jumptaplib:publisherid.

4.2.3 In Application Code
Client IDs that applications pass directly to ad library ini-
tialization methods are the most challenging to extract. The
initialization may happen at any point in the code and the
client ID may be instantiated in a number of ways, includ-
ing being passed in as a constant, received over the network,
generated dynamically, or read in from a (cid:12)le. We observed
that the (cid:12)rst two are the most common cases and focus on
them accordingly.

Speciﬁed as Constants.

We dump values from the DEX string constants section in
the application’s dex (cid:12)le and search for strings that match
the structure of client IDs for each ad library. This approach
is e(cid:11)ective for ad providers whose client IDs follow a distinc-
tive pattern. To improve the precision of this analysis, we
also implemented a static analysis tool that performs con-
stant propagation to detect when constant values are passed
to the client ID argument of ad library initialization meth-
ods. Unfortunately, we found it too slow to run on all of the
apps in our dataset, as it took several minutes per app. We
leave improving the precision of extracting constant-based
client IDs in this manner to future work.

Received Over the Network.

In addition to ad libraries, many applications include Ad-
whirl’s SDK. Adwhirl is not an ad provider, but rather o(cid:11)ers
a service that allows developers to dynamically decide which
ad provider and client ID should be used in their ad requests.
Before an application with Adwhirl makes an ad request, it
queries Adwhirl with its Adwhirl client ID and receives a set
of ad providers and client IDs, which the application then
uses to send ad requests. This service allows developers to
dynamically change the advertising behavior of their apps
without having to push a new version of their app. We han-
dle apps that use Adwhirl by (cid:12)rst extracting Adwhirl client
IDs from the application. Then, we query Adwhirl’s server
to obtain a mapping from an Adwhirl client ID to a set of
client IDs and their ad providers. This allows us to obtain
many client IDs not hardcoded in the applications.

From our application database, we extracted 1,386 unique

Adwhirl client IDs, which mapped to 1,886 unique client
IDs from one of the (cid:12)ve ad providers we eventually used in
this paper (described in Section 5.1). Of these, 1,539 (or
81.6%) were new client IDs that we had not extracted from
our applications. Speci(cid:12)cally, 764 were for admob, 523 for
millennial, and 252 for inmobi.

4.3 Determining Ownership

As our goal is to measure the impact of plagiarism on
developers, we must not regard as plagiarism similar apps
from the same developer, known as rebranded apps. Re-
branded apps may appear on the same or di(cid:11)erent markets.
In this section we discuss how we determine app ownership
by considering developer accounts, signing keys (represented
by certi(cid:12)cates), and client IDs. We make the following as-
sumptions: (cid:12)rst, each owner has her own unique set of cer-
ti(cid:12)cates that are not shared with any other owner; second,
each owner has her own unique set of client IDs that are
not shared with any other owner. In Section 7.1.1 we dis-
cuss caveats associated with these assumptions. Note, how-
ever, that these caveats only cause us to merge owners more
aggressively, resulting in lowering our measured cloning im-
pact.

Merging owners consists of three phases. First, we build
an owner graph where each node corresponds to a unique
developer account that has uploaded an application that we
crawled (Phase 1). Next, we merge owners based on shared
certi(cid:12)cates (Phase 2). Finally, we merge owners based on
shared client IDs (Phase 3). An overview of the owner graph
at various steps in the process is shown in Figure 3.

Phase 1: The (cid:12)rst phase of merging owners is to create a
graph with a node for each unique developer account. Each
developer account is identi(cid:12)ed by the tuple of the market
name and the developer’s name and is associated with one
or more apps in our database. Assuming that developer
accounts are rarely compromised, then two apps from the
same developer account must come from the same owner.
Thus, developer accounts provide an initial mapping of apps
to owners.

Phase 2: Next, we compute the set of certi(cid:12)cates whose
corresponding private keys were used to sign the apps up-
loaded by each developer account. As mentioned in Sec-
tion 2, every Android app must be signed by the developer’s
private key before it may be uploaded to a market and then

A1A5A6A9A10A2A7A3A8A4A1A5s1A6c1A9c1c1A10s4A2A7c2s2A3A8s3A4A1,A5,A6,A9,A10A2,A7A3,A8A4Provider
admob
airpush
inmobi
millennial
mobclix

Impressions Clicks Unique IDs
348,275
138,166
n/a
61,127
32,751

9,288,333
(cid:3)
3,212,878
(cid:3)
220,982
4,855,247
1,547,871

920
n/a
207
n/a
1,080

Table 2: Number of observed impressions, clicks, and
anonymized user identi(cid:12)ers in the network trace, broken
down by ad provider. The report of impression counts uses
packet level ad request analysis, unless otherwise noted (via
(cid:3)
). Note that we were not able to measure clicks for all
providers due to the format of their ad requests (for exam-
ple, those with chunked HTTP encoding). Also note that
inmobi does not include a user identi(cid:12)er in their ad requests.

installed on users’ phones. Since private keys are supposed
to be kept private (we discuss shared and stolen private keys
in Section 7.1.1), two developer accounts that share a cer-
ti(cid:12)cate must share the same owner so they are merged in
the graph.

Phase 3: Finally, we merge any two owners whose appli-
cations share a client ID. Client IDs are used by ad providers
to uniquely identify who should receive revenue for each ad
shown or clicked. Therefore, if two developer accounts share
a client ID, they are likely to be from the same owner.

We separate the merging of owners by certi(cid:12)cates and
client IDs into two phases because we have lower con(cid:12)dence
about merges based on client IDs. This is because client
ID extraction may have false positives while certi(cid:12)cate cal-
culation cannot. Other situations, such as a plagiarist who
leaves the original developer’s client ID intact, are discussed
in Section 7.1.1.

5. EVALUATION

In this section we summarize the raw results of our anal-
ysis and determine the accuracy of our application client ID
extraction.
5.1 Network Client ID Extraction

One important consideration of our work is which Android
ad providers to include in our analysis. We started with 16
ad providers based on their popularity in our application
database. Among these ad providers, seven1 had very small
number of ad requests in our captured tra(cid:14)c (some of them
are Chinese but our tra(cid:14)c was captured in the US), and four
had very little overlap between the client IDs observed on
the network and client IDs extracted from our application
database (Table 1)2. Therefore, we focus on the remaining
(cid:12)ve ad providers, whose number of impressions, clicks, and
unique user identi(cid:12)ers are summarized in Table 2. These
(cid:12)ve ad providers are also among the top six most prevalent
Android ad libraries reported by AppBrain [3]. Because our
network capture was lossy, we were not able to record signif-
icant click results from the trace, as we could only measure
clicks when the ad request, server response, and then click
request did not experience any loss.

1Buzzcity, Mojiva, Quattro, Vdopia, Wooboo, Youmi, Zes-
tAdz
2These four providers only represented 7% of the total num-
ber of ad requests we collected.

5.2 Application Client ID Extraction

While extracting client IDs from HTTP tra(cid:14)c generated
by Android applications is highly accurate, extracting them
automatically from Android applications themselves may
not be as reliable, because client IDs may be provided in sev-
eral di(cid:11)erent ways, some of which are unfriendly to program
analysis (Section 4). Therefore, we would like to evaluate the
accuracy of our client IDs extracted from Android applica-
tions. However, it is di(cid:14)cult to determine the ground truth,
because doing so would require us to manually review all the
applications, which is prohibitive given our large number of
applications. One might suggest that we run each applica-
tion in an emulator to extract the client IDs from its HTTP
tra(cid:14)c. However, an application may contain multiple ad li-
braries, so we may not observe the client IDs from all these
libraries during the execution of the application. Moreover,
some ad libraries would not send ad requests if they detect
that they are running in emulators.

Instead, we take advantage of the client IDs extracted
from HTTP tra(cid:14)c to estimate a lower bound of the accuracy
of our client ID extraction from applications. For each ad
provider AP, let DAP be the set of client IDs extracted from
our application databases, and NAP be the set of client IDs
extracted from our captured HTTP tra(cid:14)c. The network cov-
erage, jNAP \ DAPj=jDAPj, estimates a lower bound of the
true positive rate of our client ID extraction from applica-
tions. The database coverage, jDAP \NAPj=jNAPj, estimates
the coverage our application database on all the Android ap-
plications running on the network where we captured traces.
The results of this analysis are summarized in Table 1.
The database coverages for most providers are fairly high,
indicating that our application database represents a signif-
icant portion of all ad-supported Android applications that
are used in the geographic area where we collected the trace.
6. FINDINGS
6.1 Properties of Apps in Clone Clusters

There are a number of questions that come to mind when
investigating our clone clusters: Which markets do apps in
the clusters belong to? Which markets have the highest
proportion of apps involved in cloning? What categories are
most represented in the clusters? What advertising libraries
do cloners prefer? In this section we seek to answer these
questions by investigating common features of apps in our
clone clusters. Note, at this point we do not yet speculate as
to which app in each clone cluster is the original and which
are clones.
6.1.1 Market Characteristics
Figure 4 shows which Android markets are most preva-
lent in our clone clusters. A signi(cid:12)cant percentage of apps
in our clone clusters are from Google Play; intuitively this
makes sense as Play is the most popular Android market.
To compensate for this observation, we computed what per-
centage of all applications in our database from the mar-
ket are present in a clone cluster.
In this context, Play
does not stand out more than other markets, but a num-
ber of other markets such as AndroidSoft, and the Chinese
markets AndroidOnline, GoApk, and AppChina, have more
than a quarter of their apps in our clone clusters. To bet-
ter understand the cloning relationship between markets, we
calculated the number of similar apps between each pair of

Ad Provider

admob
airpush
inmobi
millennial
mobclix
adfonic
greystripe
jumptap
smaato

Unique client IDs

from databases
51,434
8,728
514
786
2,994
59,170
59,616
8
0

from network
19,718
8,829
487
2,030
1,781
318
212
78
144

Network coverage Database coverage

21.2%
36.9%
28.6%
32.6%
38.0%
0.0%
0.3%
0.0%
n/a

55.4%
36.5%
30.2%
12.6%
63.9%
0.0%
68.4%
0.0%
0.0%

Table 1: Percentage of extracted client IDs we observed in network tra(cid:14)c and percentage of observed network client IDs we
also extracted from the application database, broken down by provider. The lower group of providers are ones which we did
not include in our study because they did not have signi(cid:12)cant overlap with our application database.

Figure 4: Plot showing the popularity of di(cid:11)erent app mar-
kets in our clone clusters. The absolute number of cloned
apps from each market is represented by the axis labelled
\Number of cloned apps", whereas the axis labelled \Per-
centage of apps that are clones" represents the popularity of
each market in our clone clusters normalized over the total
number of apps from that market in our database.

Figure 5: Plot showing the popularity of di(cid:11)erent app cate-
gories in our clone clusters. The absolute number of cloned
apps in each category is represented by the axis labelled
\Number of cloned apps", whereas axis labelled \Percent-
age of apps that are clones" represents the number of cloned
apps in each category normalized over the total number of
apps in that category in our database.

markets in a clone cluster. Speci(cid:12)cally, for the apps in given
clone cluster and a pair of markets (I; J):

M arketSimcluster(I; J) = min(apps from I; apps from J)

Then, to get a global view of the amount of similar appli-

cations between markets we calculate the total M arketSim(I; J)
as follows:

∑

M arketSim(I; J) =

M arketSimc(I; J)

c2clusters

In Figure 7, we plot the results of this calculation in an
undirected graph. To reduce the complexity of the graph,

we only show an edge between markets whose M arketSim
value is over 300 and remove unconnected markets.

We de(cid:12)ne a market as a \cloning hub" if it shares an edge
with many di(cid:11)erent markets in the graph. Play is the largest
cloning hub among all the markets, as it has a signi(cid:12)cant
cloning relationship with almost every other market. Sim-
ilarly, AndroidOnline is a cloning hub among the Chinese
markets. The existence of these cloning hubs implies one
of two things: either plagiarists prefer cloning from apps
on these markets, or that plagiarists prefer these markets
to publish their cloned apps. Since we do not speculate on
which app in a cluster is the original, we leave the determin-
ing which of these cases is true to future work. Note that the

lllllllllllllllllplayslidemeandroidonlinem360brothersoftgfaneoemarketonemobilegoapkandroidsoftandappstorefreewareloverssoftportalappchinaproandroidpocketgearandroiddownloadz050001000020000300000%10%20%30%40%50%MarketNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are cloneslllllllllllllllllllllGamesEntertainmentUtilityBusinessPersonalizationReferenceLifestyleNewsEducationMusicCommunicationSportsTravelFinanceHealthVideoPhotographySocialShoppingWeatherOther020004000600080000%5%10%15%20%25%CategoryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesperiods of time, allowing more advertising revenue to be
generated.

6.1.3 Ad Library Characteristics
Figure 6 gives a breakdown by ad provider of the appli-
cations in our clone clusters, as well as normalized across
our entire application database. Admob is the most popular
provider among cloned applications, but is also the most
popular among all applications, and thus does not have
a higher percentage of cloned apps compared with other
providers. On the other hand, for our Chinese ad providers,
Wooboo and Youmi, cloned applications represent a larger
subset of the total applications that use these providers.
Nonetheless, an alarmingly large percentage of applications
for each provider are in our clone clusters, meaning that they
either are clones of another app, or are a legitimate app that
has been cloned. Note that we do not consider what per-
centage of ad tra(cid:14)c was generated by our clone clusters for
each ad provider, as we do not speculate which app is the
original and want to avoid any assumptions regarding how
much tra(cid:14)c for a provider is a result of app plagiarism. In
the next section, we estimate a lower bound for how much
advertising revenue cloning siphons from legitimate applica-
tions.
6.2 Comparing Clones and Non-clones

In previous sections we examined a number of properties
of apps in our cloned clusters without distinguishing the
\original" apps from the clones.
In this section, we wish
to gain insight into the impact of cloning on developers.
Speci(cid:12)cally, we investigate the e(cid:11)ects of cloning on the orig-
inal authors’ ad revenue and user install base. To do so, the
original author in the cluster must be determined, which is
surprisingly nontrivial.

6.2.1 Determining Original App
There are a number of intuitive approaches one could use
to determine which application among a cluster of similar
applications is the original. Unfortunately, most of these
initial approaches are (cid:13)awed. For example, one could use:

(cid:15) Date (cid:12)rst uploaded to the market
(cid:15) Application popularity by number of installs or rating
(cid:15) Code size by number of methods, instructions, or other

metric

The date an application was (cid:12)rst uploaded to the market
is di(cid:14)cult to know as an external observer. Each market
knows when the application was (cid:12)rst uploaded, but unless
an external observer has been crawling markets since their
creation in both the free and paid sections, she cannot know
for sure which app came (cid:12)rst. Additionally, there have been
cases where beta releases have been taken and uploaded to
markets before the original developer’s app. Application
popularity may sometimes di(cid:11)erentiate the clone from the
original, for example in the case of Angry Birds, however,
for less popular applications, users may be just as likely to
download the clone as the original. Further, application pop-
ularity by both number of installs and ratings is vulnerable
to sybil attacks which would be relatively easy to perform
as most market accounts require only a valid email address.
Lastly, the code size of applications can easily be distorted

Figure 6: Plot showing the popularity of di(cid:11)erent ad li-
braries among apps in our clone clusters. The absolute num-
ber of cloned apps with each library is represented by the
axis labelled \Number of cloned apps", whereas axis labelled
\Percentage of apps that are clones" represents the number
of cloned apps with each library normalized over the total
number of apps with that library in our database.

prevalence of Play as a cloning hub is likely in(cid:13)uenced by
the fact Play represents 73.7% of the apps in our database.

6.1.2 Category Characteristics
We now investigate which app categories are popular among

apps in our clone clusters so that we can better understand
what types of apps are involved in cloning. One di(cid:14)culty
with comparing categories among apps from di(cid:11)erent mar-
kets is that di(cid:11)erent markets use di(cid:11)erent category names
to refer to the same type of application. To avoid this prob-
lem, we chose 21 meta-categories that represent the spec-
trum of di(cid:11)erent categories observed across all our markets
(our mapping from category strings to meta-categories is
presented in the Appendix). Figure 5 presents the num-
ber of applications in our clone clusters that belong to each
meta-category. As we did for markets, we normalize the
number of cloned apps in each category with the number of
all apps in our database for that category to determine what
percentage of apps in the category are involved in cloning.
Interestingly, \Games" is the most popular category among
apps in the clone clusters, but also has the highest preva-
lence of apps involved in cloning. Thus, markets that care
about application cloning should focus on apps categorized
as \Games." Additionally, assuming that the original app
and the clone belong to the same category, this implies pla-
giarists prefer applications categorized as \Games." We hy-
pothesize that this is because games are relatively complex,
popular among Android users, and are often run for long

llllllllllladmobmillennialairpushwoobooyoumimobclixinmobigreystripesmaatojumptapadfonic05000100001500020000250000%5%10%15%20%25%30%35%Ad LibraryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesFigure 7: Markets which have a signi(cid:12)cant cloning relationship. The thickness of an edge is proportional to the M arketSim
value between the markets, and the height of a node is proportional to the sum of the edge weights for a given market. Markets
with nodes colored blue are US-based markets whereas markets with nodes colored red are Chinese-based markets.

Num Clusters
LostImpstotal
P ercLostImpstotal
LostU serstotal
P ercLostU serstotal

P1
610
1,764,609
52%
166,534
49%

P2
370
1,076,614
51%
122,718
48%

P3
128
56,884
14%
3,808
10%

Table 3: Total amount of lost impressions and users across
all of our clone clusters between each phase of developer
merging. The value of Num Clusters represents how many
clone clusters had more than one owner after each phase.
P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3,
respectively.

by plagiarists to make the plagiarized app appear larger or
smaller.

Rather than rely on one of these (cid:13)awed approaches, we
instead use an approach that estimates a lower bound on
our (cid:12)ndings. For each cluster we deem the owner with the
most observed impressions to be the original author and all
other owners are treated as plagiarists. In the case where
clones are more popular than the original, we will mislabel
the original author as a plagiarist, but this is acceptable as
we will only underestimate the percentage of lost advertising
tra(cid:14)c. Indeed, this approach guarantees we will not overes-
timate the number of lost impressions from mislabeling the
original as the above approaches might, as we only consider
the least popular owners in a clone cluster as plagiarists
(other caveats presented in Section 7.1.2). As we will see,
merging developer accounts has signi(cid:12)cant impact over our
results when app owners within a clone cluster are merged
by certi(cid:12)cate or client ID, and in some cases may attribute
all apps within a cluster to the same merged owner. We do
not consider such cases in our computations of lost revenue,
as they do not represent fraudulent cloning.
6.2.2 How much revenue do clones siphon from the

original authors?

In order to determine the impact of plagiarism on the ad-
vertising revenue of the original application, we (cid:12)rst observe

that hard dollar amounts are di(cid:14)cult to determine when
looking at advertising network tra(cid:14)c alone. This is because
an impression does not explicitly indicate how much it is
worth in an ad request, as the ad provider does not want to
disclose how much it or its a(cid:14)liated developers are making.
Instead, we show what percentage of lost ad tra(cid:14)c devel-
opers experience by comparing the ratio of impressions that
belong to plagiarized applications compared with the total
number of impressions we observed belonging to applica-
tions in our clone clusters. The number of lost impressions
for a cluster is represented by LostImpscluster, and the per-
centage of lost impressions for a cluster is this value divided
by all impressions attributed to apps in the cluster, times
100 (represented by P ercLostImpscluster). Additionally,
LostImpstotal represents the total number of plagiarized
app impressions over all the clusters, and P ercLostImpstotal
represents what percentage of all impressions from all clus-
ters that are a results of LostImpstotal.

As previously stated, we consider the original author in a
cluster as the app owner with the greatest amount of adver-
tising tra(cid:14)c, thus the numerator is the number of impres-
sions for all apps in the cluster not owned by this author.
Additionally, we do not consider clusters with only a single
owner. Figure 8a shows a CDF of the P ercImpsLostcluster
values across our clone clusters for each stage of applica-
tion owner merging. When only considering developer ac-
counts on their own (Phase 1 of the owner graph, see Sec-
tion 4.3) nearly 25% of the clusters have exactly 50% lost
revenue. This is a result of clusters having exactly two ap-
plications which belong to di(cid:11)erent developer accounts but
which share a client ID. Intuitively, we would want to re-
move these anomalies by merging developer accounts where
it makes sense. However, merging by certi(cid:12)cates alone,
which is very accurate, does not signi(cid:12)cantly change the
distribution of lost revenue across our clusters (Phase 2 of
owner graph). Thus, we use the results of Phase 3 of the
owner graph where owners are merged by client IDs to en-
sure that our results do not overestimate the percentage of
lost revenue. Figure 8b shows the impact of merging at each
stage on the P ercImpsLostcluster values, and Table 3 sum-

slidemebrothersoft 344play   1460  1325eoemarketgoapk 396m360  822gfan 629  809androidonline 609  1447 549 448 319onemobile  751(a) P ercLostImpscluster

(b) P ercLostImpstotal

Figure 8: CDF and boxplot of percent impact to developers in terms of impressions for each phase of merging on the owner
graph. P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3, respectively.

(a) P ercLostU serscluster

(b) P ercLostU serstotal

Figure 9: CDF and boxplot of percent impact to developers in terms of users for each phase of merging on the owner graph.
P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3, respectively.

0%20%40%60%80%100%0%20%40%60%80%100%Percent revenue lostPercent of clustersP1P2P3P1P2P3Lost Revenue0%20%40%60%80%100%Percentage Lost0%20%40%60%80%100%0%20%40%60%80%100%Percent users lostPercent of clustersP1P2P3P1P2P3Lost Users0%20%40%60%80%100%Percentage Lostmarizes the total impact over all the clusters. Alarmingly,
the value of LostImpstotal after all developer account merg-
ing is complete is 14%, meaning that authors who are the
target of cloning on average lost 14% of their advertising
revenue to application plagiarism, assuming the users who
downloaded the plagiarized versions would have used the
original app instead.
6.2.3 How much of the user base do clones divert

from the original app?

To determine how much user base application plagiarism
siphons from the original authors, we used the anonymized
device identi(cid:12)ers present in the ad tra(cid:14)c from our network
trace to estimate the number of unique users per application.
Similar to lost impressions, we compute the LostU serscluster
and P ercLostU serscluster values for each cluster and plot
the distribution in Figure 9a. We also compute the total
number of lost users across all our clusters as LostU serstotal
and the percentage lost across all the clusters as P ercLost-
U serstotal. The value of these are summarized in Figure 9b
and Table 3. We see that on average, 10% of the user base
for an author in our clone clusters is siphoned due to plagia-
rism if we assume the users who downloaded the plagiarized
applications would have used the original app if no plagia-
rism were present.

7. DISCUSSION
7.1 Limitations

7.1.1 Authorship Determination
During our exploration of potential methods for merging
owners we encountered several challenges. All of these chal-
lenges could cause our analysis to merge developer accounts
more aggresively, potentially causing us to underestimate
lost impressions and users due to plagiarism.

Certiﬁcates Shared By Many Apps.

We found that some certi(cid:12)cates are present on many apps
that are associated with a large number of developer ac-
counts on several markets. Eight certi(cid:12)cates were present on
apps from over one hundred developer accounts, the largest
having 413. After manually reviewing the developer ac-
counts associated with several of the most prevalent cer-
ti(cid:12)cates, we decided that either one or several parties made
a signi(cid:12)cant attempt to distribute their apps across many
developer accounts or that the private keys were leaked or
stolen. In fact, we discovered one of the certi(cid:12)cates corre-
sponds to a private key used in the Android Open Source
Project3 (AOSP). These keys are often used to sign custom
ROMs. Apps signed with these keys can run with greater
privileges when running on a custom ROM and some mal-
ware has been found to take advantage of this [21]. Regard-
less of why many developer accounts share a certi(cid:12)cate, we
were surprised to (cid:12)nd that two apps sharing a certi(cid:12)cate
may not necessarily have the same owner.

Apps With Multiple Certiﬁcates.

Though it has not been discussed in the literature to the
best of our knowledge and is only brie(cid:13)y mentioned in the
Android documentation page on signing apps [23], Android

3http://source.android.com/

apps may be signed with multiple developer keys. We found
667 apps in our dataset that have more than one certi(cid:12)cate,
with the largest having four. Android developers may do
this as a means to collaborate with another developer or to
ease the process of selling an app to a company [15, 19].

We hoped to use apps with multiple keys to merge owners
in possession of at least one of the keys. Intuitively, if one
app is signed by developer keys A and B, one would like
to merge the owners of each key, as the developer of an
app should have possession of each key that signed her app.
We manually reviewed a number of cases where we tried
to merge owners based on apps with multiple keys. While
in several cases the developer accounts of each key seemed
related, this was not always the case. Thus, in this work we
ignore any app with multiple certi(cid:12)cates as they may taint
our results. Furthermore, these apps constitute a very small
portion of our dataset (667 out of 265,359 apps).

Lazy Cloning.

We de(cid:12)ne \lazy cloning" to be cases when a cloner copies
an app but does not change all of the client IDs in ad libraries
contained in the original app. This would cause our analysis
to merge the owners representing the original developer and
the cloner, as they are responsible for apps that share a
client ID. We believe this occurs infrequently in practice, as
one of the major incentives behind cloning is (cid:12)nancial gains.
7.1.2 Estimation on Lost Revenue and User Base
Since we cannot identify the original app in a clone cluster
reliably, we choose the most popular app, measured by the
number of ad impressions, as the original app. While this
decision provides a lower bound estimation on the percent
lost revenue and user base in most cases, it would fail in the
following unusual cases.

Failure to merge owners.

When we fail to merge two di(cid:11)erent developer accounts of
the same owner, we could in(cid:13)ate the number of unique own-
ers in a clone cluster. This would happen when an owner
publishes similar apps from di(cid:11)erent developer accounts us-
ing di(cid:11)erent certi(cid:12)cates and di(cid:11)erent client IDs. Additional
information, such as payment accounts and addresses, from
app markets or ad providers could improve our app owner-
ship determination.

Sharing of client IDs between different apps.

We assume that one client ID is speci(cid:12)c to one family
of similar apps. However, if a developer includes the same
client ID in di(cid:11)erent apps but only some of them are in a
clone cluster, we could in(cid:13)ate the number of impressions
generated by the apps in the cluster. To verify this occurs
rarely in practice, we calculated the total number of client
IDs of which only a subset were in a cluster. Only 0.65%
of our client IDs appear in apps both in and out of a clus-
ter; thus, client ID sharing does not signi(cid:12)cantly impact our
results.

Missing original apps.

If our database fails to include the original app for a clus-
ter, we may overestimate the losses in cases where the miss-
ing original app is very popular. For example, we could (cid:12)nd
a large impression or user base di(cid:11)erential between two An-
gry Birds clones, leading us to calculate a strong developer

loss. However, by missing the original Angry Birds app we
wouldn’t see that it had many impressions, so the real loss
ratio is quite low. We believe this is unlikely to occur as
our crawling focused on both newly published and popular
apps.

Paid apps.

The estimated lost revenue and users is based on the as-
sumption that if a clone app were unavailable,
its users
would have installed the original app and spent the same
amount of time on it. Since we focus exclusively on free
apps, it is reasonable to assume there is little di(cid:11)erence be-
tween (cid:12)nding, installing, and running the original app and
its clones. However, this assumption may not hold when
considering paid apps.

7.2 Potential Steps to Reduce Cloning

A primary goal of our e(cid:11)ort to gain insight into the current
state of Android app cloning is to protect Android develop-
ers and users. Technical solutions such as the automatic
plagiarism detection methods used for this work [6] should
be employed by markets to improve the speed with which
clones are caught and removed from markets. Reducing the
lifetime of clones on markets limits their downloads and thus
their impact.

However, as Android apps are straightforward to decom-
pile, modify, and resubmit to markets, we do not believe
technical solutions alone are su(cid:14)cient. Detection tools can
always continue to be improved, but it is unlikely that a tool
can catch every clone, whether it’s due to lack of access to
every app across every market or signi(cid:12)cant code obfusca-
tions. Instead, we believe reducing economic incentives is a
more e(cid:11)ective way to limit app cloning. For example, if all
markets began charging at least a nominal registration fee
then cloners would have to make back the registration cost
from their clones before the account is banned or they will
lose money. This also disincentives a plagiarist from cre-
ating many developer accounts, possibly making plagiarism
detection easier. Similarly, ad providers could also charge a
registration fee or delay ad revenue payout for some period
of time to allow the developer’s apps to be vetted. By in-
creasing the time and/or cost to create developer accounts
or sign up with ad providers, legitimate developers may be
slightly a(cid:11)ected but cloners wishing to create many devel-
oper or ad provider accounts can be signi(cid:12)cantly impeded.
We o(cid:11)er these potential solutions with caution, as one of
the great advantages of the Android ecosystem is its open-
ness and low barrier to entry. The associated costs must be
carefully weighed to reduce cloning while not discouraging
legitimate developers.

8. RELATED WORK

Malicious activities on Android.

Prior work examined information leaks within an applica-
tion [9] and between applications [8]. Researchers discussed
privacy violations in third-party libraries, especially adver-
tising libraries [12, 22, 20, 24]. [29] characterized Android
malware. DroidMOSS [28] and DNADroid [6] detected
repackaged and cloned Android applications.

Examining the impact of malicious activities.

Kanich et al. investigated the underground economy of
spam [14, 17]. Prior work examining the impact of malicious
activities primarily focused on fraud that harmed the user,
such as fake anti-virus software [26], keyloggers [13], and
spam [25]. By contrast, application plagiarism detriments
mainly the original developers of the plagiarized applica-
tions by taking away their users and advertising revenue.
Online advertising fraud has been extensively studied in the
literature [7, 11, 27]; however, application cloning does not
necessarily imply advertising fraud because the advertiser
still receives impressions and clicks from the users of cloned
applications.

9. CONCLUSION

In this paper we presented AdRob, which is designed to be
the (cid:12)rst step towards understanding the economic incentives
of application plagiarism on Android markets. We charac-
terized application plagiarism and its impact on developers
by crawling 265,359 free applications from 17 Android mar-
kets around the world and detecting clones among them.
We captured live HTTP tra(cid:14)c generated by mobile appli-
cations at a tier-1 US cellular carrier for 12 days, and ex-
tracted client IDs from both applications and network traces
to correlate the two datasets. Based on the data, we (cid:12)rst ex-
amined properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examined how cloned applications
a(cid:11)ect the origin developers. We estimated a lower bound on
the revenue that cloned applications siphon from the original
developers, and the user base that cloned applications divert
from the original applications, and (cid:12)nd an alarmingly high
percentage of impressions is siphoned from developers who
are victims of plagiarism. To the best of our knowledge, this
is the (cid:12)rst large scale study on the characteristics of cloned
applications and their impact on the original developers.

10. ACKNOWLEDGEMENTS

We would like to thank Sharad Agarwal and the anony-
mous reviewers for their insightful feedback, as well as Liang
Cai, Dennis Xu, Ben Sanders, Justin Horton, and Jon Vron-
sky for their assistance in obtaining Android applications.
This paper is based upon work supported by the National
Science Foundation under Grant No. 1018964.

References
[1] A. Andoni and P. Indyk. \Near-optimal hashing al-
gorithms for approximate nearest neighbor in high di-
mensions". In: Foundations of Computer Science, 2006.
FOCS’06. 47th Annual IEEE Symposium on. Ieee. 2006,
pp. 459{468.

[2] Jason Ankeny. Feds seize Android app marketplaces
Applanet, AppBucket in piracy sting. Aug. 22, 2012.
url: http://www.fiercemobilecontent.com/story/
feds-seize-android-app-marketplaces-applanet-
appbucket-piracy-sting/2012-08-22.

[3] AppBrain. Android Ad networks. Mar. 2013. url: http:

//www.appbrain.com/stats/libraries/ad.

[4] AppBrain. Number of available android applications.
Nov. 2012. url: http://www.appbrain.com/stats/
number-of-android-apps.

[5] Brut.alll. Android-Apktool. url: http://code.google.

com/p/android-apktool.

[6] J. Crussell, C. Gibler, and H. Chen. \Attack of the

Clones: Detecting Cloned Applications on Android Mar-
kets". In: Computer Security{ESORICS 2012 (2012),
pp. 37{54.

[7] N. Daswani et al. \Online advertising fraud". In: Crime-
ware: Understanding New Attacks and Defenses (2008).
[8] M. Dietz, S. Shekhar, Y. Pisetsky, A. Shu, and D.S.

Wallach. \Quire: lightweight provenance for smart phone
operating systems". In: USENIX Security. 2011.

[9] William Enck, Landon P. Cox, and Jaeyeon Jung. \Taint-

Droid: An Information-Flow Tracking System for Re-
altime Privacy Monitoring on Smartphones". In: (2010).
[10] Jesus Freke. Smali/Baksmali. url: http : / / code .

google.com/p/smali.

[11] Mona Gandhi, Markus Jakobsson, and Jacob Ratkiewicz.

\Badvertisements: Stealthy click-fraud with unwitting
accessories". In: Online Fraud, Part I Journal of Digi-
tal Forensic Practice, Volume 1, Special Issue 2. 2006.
[12] M.C. Grace, W. Zhou, X. Jiang, and A.R. Sadeghi.
\Unsafe exposure analysis of mobile in-app advertise-
ments". In: Proceedings of the (cid:12)fth ACM conference
on Security and Privacy in Wireless and Mobile Net-
works. ACM. 2012, pp. 101{112.

[13] T. Holz, M. Engelberth, and F. Freiling. \Learning
more about the underground economy: A case-study
of keyloggers and dropzones". In: Computer Security{
ESORICS 2009 (2009), pp. 1{18.

[14] Chris Kanich et al. \Show Me the Money: Characteriz-
ing Spam-advertised Revenue". In: USENIX Security
Symposium. San Francisco, CA, Aug. 2011.

[15] Keystore and Aliases - is there a use to multiple aliases?

Dec. 2012. url: http://stackoverflow.com/questions/
2667399/keystore- and- aliases- is- there- a- use-
to-multiple-aliases.

[16] Eric Lafortune. Proguard. url: http : / / proguard .

sourceforge.net.

[17] Kirill Levchenko et al. \Click Trajectories: End-to-End
Analysis of the Spam Value Chain". In: IEEE Sympo-
sium and Security and Privacy. Oakland, CA, May
2011.

[18] H. Liu, C.N. Chuah, H. Zang, and S. Gatmir-motahari.
\Evolving Landscape of Cellular Network Tra(cid:14)c". In:
Computer Communications and Networks (ICCCN),
2012 21st International Conference on. IEEE. 2012,
pp. 1{7.

[19] Multiple Signatures and Shared UIDs. Dec. 2012. url:
https://groups.google.com/forum/?fromgroups=
#!topic/android-security-discuss/LyyEWyFg5xc.

[20] P. Pearce, A.P. Felt, G. Nunez, and D. Wagner. \Ad-
Droid: Privilege Separation for Applications and Ad-
vertisers in Android". In: Proceedings of the 7th ACM
Symposium on Information, Computer and Commu-
nications Security. ACM. 2012.

[21] Security Alert: Malware Found Targeting Custom ROMs
(jSMSHider). Dec. 2012. url: https://blog.lookout.
com/blog/2011/06/15/security- alert- malware-
found-targeting-custom-roms-jsmshider/.

[22] S. Shekhar, M. Dietz, and D.S. Wallach. \Adsplit: Sep-
arating smartphone advertising from applications". In:
CoRR, abs/1202.4030 (2012).

[23] Signing Your Applications. Dec. 2012. url: http://
developer . android . com / tools / publishing / app -
signing.html.

[24] R. Stevens, C. Gibler, J. Crussell, J. Erickson, and H.
Chen. \Investigating User Privacy in Android Ad Li-
braries". In: IEEE Mobile Security Technologies (MoST),
San Francisco, CA (2012).

[25] B. Stone-Gross, T. Holz, G. Stringhini, and G. Vi-
gna. \The underground economy of spam: A botmas-
ters perspective of coordinating large-scale spam cam-
paigns". In: USENIX Workshop on Large-Scale Ex-
ploits and Emergent Threats (LEET). 2011.

[26] B. Stone-Gross et al. \The underground economy of
fake antivirus software". In: Economics of Information
Security and Privacy III (2011), pp. 55{78.

[27] B. Stone-Gross et al. \Understanding fraudulent ac-
tivities in online ad exchanges". In: Proceedings of the
2011 ACM SIGCOMM conference on Internet mea-
surement conference. ACM. 2011, pp. 279{294.

[28] W. Zhou, Y. Zhou, X. Jiang, and P. Ning. \Detect-
ing repackaged smartphone applications in third-party
android marketplaces". In: Proceedings of the second
ACM conference on Data and Application Security and
Privacy. ACM. 2012, pp. 317{326.

[29] Y. Zhou and X. Jiang. \Dissecting android malware:
Characterization and evolution". In: Security and Pri-
vacy (SP), 2012 IEEE Symposium on. IEEE. 2012,
pp. 95{109.

AdRob: Examining the Landscape and Impact of

Android Application Plagiarism

Clint Gibler

UC Davis

cdgibler@ucdavis.edu

Hao Chen
UC Davis

hchen@cs.ucdavis.edu

Ryan Stevens

UC Davis

rcstevens@ucdavis.edu

Jonathan Crussell

UC Davis

jcrussell@ucdavis.edu

Hui Zang

Sprint Research

hui.zang@sprint.com

Heesook Choi
Sprint Research

heesook.choi@sprint.com

ABSTRACT
Malicious activities involving Android applications are ris-
ing rapidly. As prior work on cyber-crimes suggests, we
need to understand the economic incentives of the crimi-
nals to design the most e(cid:11)ective defenses. In this paper, we
investigate application plagiarism on Android markets at a
large scale. We take the (cid:12)rst step to characterize plagia-
rized applications and estimate their impact on the original
application developers. We (cid:12)rst crawled 265,359 free ap-
plications from 17 Android markets around the world and
ran a tool to identify similar applications (\clones"). Based
on the data, we examined properties of the cloned applica-
tions, including their distribution across di(cid:11)erent markets,
application categories, and ad libraries. Next, we examined
how cloned applications a(cid:11)ect the original developers. We
captured HTTP advertising tra(cid:14)c generated by mobile ap-
plications at a tier-1 US cellular carrier for 12 days. To
associate each Android application with its advertising traf-
(cid:12)c, we extracted a unique advertising identi(cid:12)er (called the
client ID) from both the applications and the network traces.
We estimate a lower bound on the advertising revenue that
cloned applications siphon from the original developers, and
the user base that cloned applications divert from the orig-
inal applications. To the best of our knowledge, this is the
(cid:12)rst large scale study on the characteristics of cloned mobile
applications and their impact on the original developers.

Categories and Subject Descriptors
D.4.6 [Software]: Security and Protection; K.4.1 [Computers
and Society]: Public Policy Issues|Abuse and crime in-
volving computers

General Terms
Security, Economics

Permission to make digital or hard copies of all or part of this work for
personal or classroom use is granted without fee provided that copies are
not made or distributed for proﬁt or commercial advantage and that copies
bear this notice and the full citation on the ﬁrst page. To copy otherwise, to
republish, to post on servers or to redistribute to lists, requires prior speciﬁc
permission and/or a fee.
MobiSys’13, June 2528, 2013, Taipei, Taiwan
Copyright 2013 ACM 978-1-4503-1672-9/13/06 ...$15.00.

Keywords
Android; underground economy; plagiarism; advertising; mo-
bile; measurement

1.

INTRODUCTION

As mobile applications become more popular and lucra-
tive, they also become a more likely target for criminals and
other miscreants. A malicious activity unique to mobile ap-
plication markets is large-scale application plagiarism [2].
This is because mobile applications, especially Android ap-
plications, are straightforward to reverse engineer and copy.
We de(cid:12)ne a cloned application as an app that is a modi(cid:12)ed
copy of another app, and thus shares a signi(cid:12)cant portion
of its application code with the original. A plagarized ap-
plication is a cloned app that was fraudulently copied from
one developer to another. Prior studies showed that indeed
there are many cloned applications on mobile markets [6, 28].
However, these studies leave many questions unanswered.
From the plagiarists’ point of view, what are their incen-
tives? From the users’ point of view, how often do they run
plagiarized applications? From the original application de-
velopers’ point of view, to what extent does the practice of
application plagarism impact them? The answers to these
questions would have deep research, technical, and policy
implications. For example, even if there were many pla-
giarized applications on the mobile markets, if users rarely
download and run them, perhaps dealing with them is not a
priority. On the other hand, if the plagiarized applications
severely a(cid:11)ect the economic interests of original application
developers, we must deal with them swiftly and adequately
to sustain interest in legitimate application development.

We take the (cid:12)rst step toward answering the above ques-
tions. We use a technique that combines static application
analysis with network analysis to bring a number of rele-
vant insights into this problem. These techniques allow us
to (cid:12)nd cloned applications in the wild, to analyze the promi-
nent properties among these clones, and to analyze the pop-
ularity and pro(cid:12)tability of these clones. During the process,
we face several challenges. First, we must download a large
number of applications from various markets (because often
the plagiarized and original applications appear on di(cid:11)erent
markets) and detect clones among them using an automatic
tool. Second, we must capture a large amount of live net-
work data from mobile applications, allowing us to extract

relevant advertising information to bring insight into each
app’s advertising revenue. Note that these traces must be
from large numbers of real users una(cid:14)liated with and un-
a(cid:11)ected by our study. This precludes generating traces in
our lab, because the users aren’t \real," and capturing net-
work tra(cid:14)c at our university, because the user population
is not large or diverse enough. Finally, we must associate
the original and plagiarized applications with their network
traces to determine how much advertising revenue plagia-
rized applications receive relative to the original. For the
purpose of this work, we attempt to distinguish rebranded
apps (apps from the same developer with high code simi-
larity) from truly plagiarized apps by merging developer ac-
counts accross markets. We collectively refer to these tech-
niques, along with the results presented, as AdRob.
1.1 Overview

The analysis used for AdRob consists of the following

steps (Figure 1).

(cid:15) We crawled 265,359 free Android applications from 17
markets around the world. Then, we ran a tool [6]
to (cid:12)nd clones within these applications, resulting in
44,268 cloned apps.

(cid:15) We captured live HTTP advertising tra(cid:14)c generated
by mobile applications at a tier-1 US cellular carrier for
12 days, resulting in 2.6 billion packets and 19,125,311
ad impressions.

(cid:15) We link cloned applications detected in our lab to their
network tra(cid:14)c by their client IDs. Most free Android
applications include one or more advertising libraries.
For each ad library, the application includes a client
ID, which is sent along with the ad requests so that the
ad provider can credit the application developer for ad
impressions or clicks. We use static analysis to extract
client IDs from the downloaded applications. Then,
we extract client IDs for popular ad providers from
captured HTTP tra(cid:14)c. Finally, we correlate these two
sets of client IDs.

Using the data acquired in the above steps, we (cid:12)rst ex-
amine properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examine how cloned applications
a(cid:11)ect the original developers. We estimate a lower bound on
the percent revenue that cloned applications siphon from the
original developers, and the percent user base that cloned
applications divert from the original applications. To the
best of our knowledge, this is the (cid:12)rst large scale study on
the characteristics of cloned applications and their impact
on the original developers.

We make the following contributions:
(cid:15) We conduct a large scale study on the characteristics
of cloned applications and their impact on the original
developers. This serves as a (cid:12)rst step toward under-
standing the incentives of application plagiarists.

(cid:15) We combine static analysis with live network analysis
to correlate the static properties of an application to
its network characteristics. Using this methodology,
we link applications crawled from major Android mar-
kets to their live traces in a tier-1 US cellular network

Figure 1: Overview of the AdRob methodology.

carrier, which allows us to understand the impact of
plagiarism broadly and deeply.

(cid:15) We propose the use of client IDs in ad requests to corre-
late Android applications to their live network traces.
We present approaches for extracting client IDs from
both application code and network traces.

(cid:15) We describe an approach to determine the ownership
of apps using developer accounts, signing keys, and
client IDs.

Non-Goal.

This work does not consider ad fraud. While app pla-
giarism detriments primarily the original developers of the
plagiarized apps by siphoning their users and advertising
revenue, ad fraud harms mainly the advertisers. Moreover,
online ad fraud has been extensively studied [7, 11, 27]. Our
work is the (cid:12)rst to measure the impact of app plagiarism on
the original developers.

2. BACKGROUND
2.1 Android Background

Android is a Linux-based smart phone operating system
designed by Google that is designed to run Android appli-
cations (apps) that are downloaded from various Android
app markets. An Android application is distributed as an
apk (cid:12)le, which is similar to a Java jar (cid:12)le. The apk is a
zip archive which contains all the code and data needed to
install and run the app.

The largest and most popular app market is Google Play
(also called the o(cid:14)cial Android market), which consists of
over 550,000 applications by various developers [4]. In ad-
dition to Google Play, there are a number of third-party
Android markets where users can go to download apps, for
example the Amazon Appstore or SlideMe. There are vari-
ous reasons developers would choose to release their apps on
third-party markets: many do not charge to create a devel-
oper account and upload applications, they may have less
stringent terms of service, or developers may simply want

Network TraceClone ClustersTier-1 Cellular ProviderNetwork Client IDsCaptureApp Client IDsAd Request AnalysisCrawlClone DetectionClient ID ExtractionClonesApp DBGoogle PlaySlideMEAndroid Onlineto increase the exposure of their apps across these di(cid:11)erent
markets.

Before an app may be submitted to a market, it must be
digitally signed by a certi(cid:12)cate for which the developer owns
the private key. This certi(cid:12)cate is used by Android to deter-
mine authorship and trust relationships between apps [23].
Android phones and emulators will only install apps that are
signed. Android developer certi(cid:12)cates may be self-signed, so
there is little barrier for a developer to create as many cer-
ti(cid:12)cates as she wishes. However, for Android to allow an
app to seamlessly update to the next version, the newer ver-
sion must be signed with the same certi(cid:12)cate. Otherwise,
the user will be prompted to install the newer version as if
it were a separate app.

An important (cid:12)le which is included with every app is the
Android Manifest (cid:12)le. This XML document contains a num-
ber of parameters that the Android framework needs in or-
der to run the app. This includes the names of the Activities,
which are the di(cid:11)erent screens of the app, the permissions
the app requires and the API version. Developers may also
use this XML document to store any additional information
the app may use; for example, advertising parameters are
sometimes speci(cid:12)ed here.
2.2 Android Application Cloning

Android applications are written in Java and compiled
into Dalvik bytecode in order to run on Android’s Dalvik
Virtual Machine. Dalvik bytecode is very well structured
and clearly separates code from data which makes it much
easier to reverse engineer than traditional machine code.

To protect their application from reverse engineering, pru-
dent developers may use a tool called Proguard [16] to per-
form class and function name obfuscation.
It can also be
used to obfuscate the package name of included libraries.
However, Proguard alone is not enough to protect apps from
being reverse engineered or cloned. Open-source tools such
as ApkTool [5] and smali [10] make it straightforward for
unscrupulous individuals to reverse engineer, modify, and
recompile the Dalvik bytecode of an Android application
for distribution.
2.3 Advertising on Android

An Android developer who wants to make money by dis-
playing advertisements as part of her application must sign
up with an ad provider and download the provider’s adver-
tising SDK, which is a library (in the form of a jar (cid:12)le) that
the developer includes in the app. The SDK provides an
API for displaying an ad in the application, and abstracts
away the complexity involved with fetching, displaying, and
managing advertisements for the ad provider (an overview
of which is shown in Figure 2).

In order to receive payment for ads shown in the applica-
tion, the developer is given a client ID by the ad provider
that uniquely identi(cid:12)es the app; this client ID is then spec-
i(cid:12)ed in the application such that it is available to the ad li-
brary SDK. When it is time to display an ad, the SDK sends
an ad request over HTTP to the ad provider’s ad server. The
ad request includes the client ID, a device identi(cid:12)er (for ex-
ample, the IMEI), and other (cid:12)elds such as demographic in-
formation. The exact format of the ad request and the (cid:12)elds
present di(cid:11)ers between ad providers. Once the request is re-
ceived, the ad server responds with the image URL of the
ad to display and a click URL that opens in the browser

Figure 2: Overview of ad library SDK and ad server inter-
action.

app if the ad is clicked. A successful ad request and asso-
ciated response is called an impression and represents one
instance of an ad being displayed to the user. To track the
clicks, the ad server generates a unique click URL for each
impression which points to one of the provider’s ad servers.
When the browser opens this page the click is matched with
its associated impression and recorded before the browser is
redirected to the advertisement’s landing page. Unlike ad
requests, the click request does not contain the client ID of
the application as the ad server can lookup the client ID once
the click is matched with the impression that generated it.
As we will explain in Section 4, this extra level of indirection
prevented us from obtaining suitable click results.

3. DATASET

In this section we describe the data used in our study. The
two main datasets are a large collection of downloaded An-
droid applications, which we analyzed to (cid:12)nd clones, and 3G
network data from a tier-1 cellular carrier, which provided
us insight into the advertising behavior of applications in
our database.
3.1 Application Database

Our collection of Android applications consists of 265,359
Android apps from 17 markets around the world. Figure 4
shows these markets. The apps were collected via automated
crawling and stored in a database along with any meta in-
formation provided by the market (such as developer name,
number of downloads, and category). Only free applications
are included in the collection. The breakdown across vari-
ous markets is as follows: 73.7% of the apps are from the
o(cid:14)cial Google Play market, 14.7% are from 9 third-party
English markets, 13.8% are from 6 third-party Chinese mar-
kets, and 0.46% are from 2 Russian markets. Even though
we may not have crawled all the markets or have downloaded
all the applications from each market, our analysis in Sec-
tion 4 indicates that our collection represents a signi(cid:12)cant
portion of all the applications that include ads running on
US cellular networks.

App APKAd ServerAd Library SDKAd RequestAd and Click URLClickAdvertiser's URL3.2 Plagiarized Applications

Using a more scalable tool based on DNADroid [6], we
analyzed our application database to look for plagiarized
applications. While DNADroid is highly precise because it
is based on calculating subgraph isomorphism on PDGs, it
is not scalable because it requires pair-wise comparison of
apps. To avoid pairwise comparison, the tool used for this
work converts each app into a set of semantic vectors, each of
which represents a semantic feature of the program. Then,
the tool clusters the semantic vectors of all the apps using
LSH [1]. Finally, the tool considers a set of apps to be clones
if they share a large number of semantic vector clusters and
places these apps into the same clone cluster.

Each clone cluster contains applications published by dif-
ferent developers, as determined by their signing certi(cid:12)cate.
Each application appears in at most one cluster. In total, we
investigate 5,431 clone clusters consisting of 44,268 unique
applications. These clusters may or may not contain the
\victim" of plagiarism, which we call the \original app" in
this paper. Determining the original application is di(cid:14)cult
and unreliable, as described in Section 6.2.1.
3.3 Network Data

We had access to live 3G network data from a tier-1 cellu-
lar network carrier, which consisted of a sample of all tra(cid:14)c
that passed through a particular home agent in the south-
west United States. Packets were tapped from the home
agent and sent to the carrier’s research lab for capture and
analysis. The tap at the home agent was quarter-sampled
at the (cid:13)ow level, so in theory all packets in a particular
(cid:13)ow were available to be captured; however, packets were
lost from limitations in bandwidth and capture speed of the
tapping infrastructure. The network data included all 3G
internet tra(cid:14)c sent from devices registered on the carrier’s
cellular network, including protocol headers and payload.

We captured HTTP tra(cid:14)c from the tap over the course
of 12 days:
from 28 June 2012 to 10 July 2012. Devices
present on the network include both Android and iOS de-
vices, as well as feature phones and wireless cards. The
tra(cid:14)c characteristics are similar to those in [18]. To opti-
mize the capture, only 32 bytes of the protocol header were
captured along with the payload for each packet. Addition-
ally, we performed IP (cid:12)ltering so that only packets with a
source or destination IP address that corresponded with a
known Android ad server were captured. In total, we cap-
tured 2.6 billions packets in our trace. We describe how we
extract ad request data from the trace in Section 4.1.
4. METHODOLOGY

Figure 1 shows the procedure of our study. Our data came
from two sources: (1) HTTP tra(cid:14)c generated by Android
applications on a US tier-1 cellular network, and (2) An-
droid applications downloaded from Android markets. We
correlated the two datasets using advertising client IDs. In
this section we explain how we extracted these IDs, both
from the network and from applications.
4.1 Extracting Client IDs from Network Traces
We now explain how we extract client IDs from ad re-
quests sent by Android applications. We extract advertising
information from our cellular network trace (described in
Section 3.3) by analyzing ad requests at the packet level as
well as at the (cid:13)ow level. In order to identify ad requests,

we manually ran a sample application for each Android ad
provider and captured all tra(cid:14)c from the device so that we
could characterize the format of each provider’s requests.
From each ad request, we record the ad provider, client
ID, anonymized user identi(cid:12)er, and the application package
name if available. We anonymize user identi(cid:12)ers to avoid
recording any potentially sensitive device identi(cid:12)ers, such
as the IMEI. We only record ad requests with an Android
HTTP User-Agent (cid:12)eld.

To get packet level data, we look at the HTTP header
of each packet to determine if it is an ad request from a
recognized Android ad provider and record relevant adver-
tising information. To analyze ad requests at the (cid:13)ow level,
we use the 32 bytes of protocol header to reconstruct each
TCP (cid:13)ow, allowing us to observe both the ad request and
the response from the server. The bene(cid:12)ts of looking at
ad requests at the (cid:13)ow level are twofold. First, we observed
that ad requests for some ad providers are split across multi-
ple packets, especially when the request uses HTTP POST,
so it would be impossible to record the entire ad request in
this case by only looking at packets individually. Second, the
server response allows us to extract the click URL associated
with each impression so that we can match the impression
with any observed clicks in the trace. These clicks can be
linked to an impression and thus a client ID by using the
click URLs that we parse from each (cid:13)ow.

To extract client IDs, we (cid:12)rst identify the ad provider by
examining the host name in the HTTP request. For each ad
provider, we create a pattern to identify its client IDs in the
HTTP requests accurately.

4.2 Extracting Client IDs from Applications
We extract client IDs from Android applications via static
analysis. Commonly, ad providers require developers to pro-
vide their client ID in one of (cid:12)ve ways: declaring it in the
application’s manifest (cid:12)le, declaring it in a layout XML (cid:12)le,
passing it to an ad object in the application code, specifying
it as a constant string, or receiving it dynamically over the
network.

In Android Manifest

4.2.1
The most straightforward client IDs to extract are those
declared in the Android manifest (cid:12)le. Admob, for exam-
ple, recommends that developers store their client IDs in a
meta-data (cid:12)eld with the name admob publisher id. Usu-
ally the client ID is directly included in the Manifest XML;
however, in some cases there can be extra levels of indi-
rection: Android allows developers to abstract values into
constant (cid:12)les such as string.xml. In cases where the de-
veloper has abstracted the client ID using notation such
as @string/admob_id, we resolve these abstractions accord-
ingly.

In Layout XML

4.2.2
Some ad providers recommend that client IDs be included
in one of the auxiliary XML (cid:12)les that developers generate
for their application (not the manifest). Conveniently for us,
these ad providers usually provide an example for developers
to copy and replace the client ID with their own, which
provides a common naming convention for each ad library.
We take advantage of this convention by using XPATH to
search XML (cid:12)les for speci(cid:12)c XML elements known to contain

(a) Initial owners based on devel-
oper accounts (Phase 1)

(b) Owners with edges based on shared certi(cid:12)-
cates (s) and client IDs (c)

(c) Owners after merging (Phases 2
and 3)

Figure 3: Owner graph at various stages in owner merging.

client IDs. For example, Jumptap client IDs are usually in
a (cid:12)eld called jumptaplib:publisherid.

4.2.3 In Application Code
Client IDs that applications pass directly to ad library ini-
tialization methods are the most challenging to extract. The
initialization may happen at any point in the code and the
client ID may be instantiated in a number of ways, includ-
ing being passed in as a constant, received over the network,
generated dynamically, or read in from a (cid:12)le. We observed
that the (cid:12)rst two are the most common cases and focus on
them accordingly.

Speciﬁed as Constants.

We dump values from the DEX string constants section in
the application’s dex (cid:12)le and search for strings that match
the structure of client IDs for each ad library. This approach
is e(cid:11)ective for ad providers whose client IDs follow a distinc-
tive pattern. To improve the precision of this analysis, we
also implemented a static analysis tool that performs con-
stant propagation to detect when constant values are passed
to the client ID argument of ad library initialization meth-
ods. Unfortunately, we found it too slow to run on all of the
apps in our dataset, as it took several minutes per app. We
leave improving the precision of extracting constant-based
client IDs in this manner to future work.

Received Over the Network.

In addition to ad libraries, many applications include Ad-
whirl’s SDK. Adwhirl is not an ad provider, but rather o(cid:11)ers
a service that allows developers to dynamically decide which
ad provider and client ID should be used in their ad requests.
Before an application with Adwhirl makes an ad request, it
queries Adwhirl with its Adwhirl client ID and receives a set
of ad providers and client IDs, which the application then
uses to send ad requests. This service allows developers to
dynamically change the advertising behavior of their apps
without having to push a new version of their app. We han-
dle apps that use Adwhirl by (cid:12)rst extracting Adwhirl client
IDs from the application. Then, we query Adwhirl’s server
to obtain a mapping from an Adwhirl client ID to a set of
client IDs and their ad providers. This allows us to obtain
many client IDs not hardcoded in the applications.

From our application database, we extracted 1,386 unique

Adwhirl client IDs, which mapped to 1,886 unique client
IDs from one of the (cid:12)ve ad providers we eventually used in
this paper (described in Section 5.1). Of these, 1,539 (or
81.6%) were new client IDs that we had not extracted from
our applications. Speci(cid:12)cally, 764 were for admob, 523 for
millennial, and 252 for inmobi.

4.3 Determining Ownership

As our goal is to measure the impact of plagiarism on
developers, we must not regard as plagiarism similar apps
from the same developer, known as rebranded apps. Re-
branded apps may appear on the same or di(cid:11)erent markets.
In this section we discuss how we determine app ownership
by considering developer accounts, signing keys (represented
by certi(cid:12)cates), and client IDs. We make the following as-
sumptions: (cid:12)rst, each owner has her own unique set of cer-
ti(cid:12)cates that are not shared with any other owner; second,
each owner has her own unique set of client IDs that are
not shared with any other owner. In Section 7.1.1 we dis-
cuss caveats associated with these assumptions. Note, how-
ever, that these caveats only cause us to merge owners more
aggressively, resulting in lowering our measured cloning im-
pact.

Merging owners consists of three phases. First, we build
an owner graph where each node corresponds to a unique
developer account that has uploaded an application that we
crawled (Phase 1). Next, we merge owners based on shared
certi(cid:12)cates (Phase 2). Finally, we merge owners based on
shared client IDs (Phase 3). An overview of the owner graph
at various steps in the process is shown in Figure 3.

Phase 1: The (cid:12)rst phase of merging owners is to create a
graph with a node for each unique developer account. Each
developer account is identi(cid:12)ed by the tuple of the market
name and the developer’s name and is associated with one
or more apps in our database. Assuming that developer
accounts are rarely compromised, then two apps from the
same developer account must come from the same owner.
Thus, developer accounts provide an initial mapping of apps
to owners.

Phase 2: Next, we compute the set of certi(cid:12)cates whose
corresponding private keys were used to sign the apps up-
loaded by each developer account. As mentioned in Sec-
tion 2, every Android app must be signed by the developer’s
private key before it may be uploaded to a market and then

A1A5A6A9A10A2A7A3A8A4A1A5s1A6c1A9c1c1A10s4A2A7c2s2A3A8s3A4A1,A5,A6,A9,A10A2,A7A3,A8A4Provider
admob
airpush
inmobi
millennial
mobclix

Impressions Clicks Unique IDs
348,275
138,166
n/a
61,127
32,751

9,288,333
(cid:3)
3,212,878
(cid:3)
220,982
4,855,247
1,547,871

920
n/a
207
n/a
1,080

Table 2: Number of observed impressions, clicks, and
anonymized user identi(cid:12)ers in the network trace, broken
down by ad provider. The report of impression counts uses
packet level ad request analysis, unless otherwise noted (via
(cid:3)
). Note that we were not able to measure clicks for all
providers due to the format of their ad requests (for exam-
ple, those with chunked HTTP encoding). Also note that
inmobi does not include a user identi(cid:12)er in their ad requests.

installed on users’ phones. Since private keys are supposed
to be kept private (we discuss shared and stolen private keys
in Section 7.1.1), two developer accounts that share a cer-
ti(cid:12)cate must share the same owner so they are merged in
the graph.

Phase 3: Finally, we merge any two owners whose appli-
cations share a client ID. Client IDs are used by ad providers
to uniquely identify who should receive revenue for each ad
shown or clicked. Therefore, if two developer accounts share
a client ID, they are likely to be from the same owner.

We separate the merging of owners by certi(cid:12)cates and
client IDs into two phases because we have lower con(cid:12)dence
about merges based on client IDs. This is because client
ID extraction may have false positives while certi(cid:12)cate cal-
culation cannot. Other situations, such as a plagiarist who
leaves the original developer’s client ID intact, are discussed
in Section 7.1.1.

5. EVALUATION

In this section we summarize the raw results of our anal-
ysis and determine the accuracy of our application client ID
extraction.
5.1 Network Client ID Extraction

One important consideration of our work is which Android
ad providers to include in our analysis. We started with 16
ad providers based on their popularity in our application
database. Among these ad providers, seven1 had very small
number of ad requests in our captured tra(cid:14)c (some of them
are Chinese but our tra(cid:14)c was captured in the US), and four
had very little overlap between the client IDs observed on
the network and client IDs extracted from our application
database (Table 1)2. Therefore, we focus on the remaining
(cid:12)ve ad providers, whose number of impressions, clicks, and
unique user identi(cid:12)ers are summarized in Table 2. These
(cid:12)ve ad providers are also among the top six most prevalent
Android ad libraries reported by AppBrain [3]. Because our
network capture was lossy, we were not able to record signif-
icant click results from the trace, as we could only measure
clicks when the ad request, server response, and then click
request did not experience any loss.

1Buzzcity, Mojiva, Quattro, Vdopia, Wooboo, Youmi, Zes-
tAdz
2These four providers only represented 7% of the total num-
ber of ad requests we collected.

5.2 Application Client ID Extraction

While extracting client IDs from HTTP tra(cid:14)c generated
by Android applications is highly accurate, extracting them
automatically from Android applications themselves may
not be as reliable, because client IDs may be provided in sev-
eral di(cid:11)erent ways, some of which are unfriendly to program
analysis (Section 4). Therefore, we would like to evaluate the
accuracy of our client IDs extracted from Android applica-
tions. However, it is di(cid:14)cult to determine the ground truth,
because doing so would require us to manually review all the
applications, which is prohibitive given our large number of
applications. One might suggest that we run each applica-
tion in an emulator to extract the client IDs from its HTTP
tra(cid:14)c. However, an application may contain multiple ad li-
braries, so we may not observe the client IDs from all these
libraries during the execution of the application. Moreover,
some ad libraries would not send ad requests if they detect
that they are running in emulators.

Instead, we take advantage of the client IDs extracted
from HTTP tra(cid:14)c to estimate a lower bound of the accuracy
of our client ID extraction from applications. For each ad
provider AP, let DAP be the set of client IDs extracted from
our application databases, and NAP be the set of client IDs
extracted from our captured HTTP tra(cid:14)c. The network cov-
erage, jNAP \ DAPj=jDAPj, estimates a lower bound of the
true positive rate of our client ID extraction from applica-
tions. The database coverage, jDAP \NAPj=jNAPj, estimates
the coverage our application database on all the Android ap-
plications running on the network where we captured traces.
The results of this analysis are summarized in Table 1.
The database coverages for most providers are fairly high,
indicating that our application database represents a signif-
icant portion of all ad-supported Android applications that
are used in the geographic area where we collected the trace.
6. FINDINGS
6.1 Properties of Apps in Clone Clusters

There are a number of questions that come to mind when
investigating our clone clusters: Which markets do apps in
the clusters belong to? Which markets have the highest
proportion of apps involved in cloning? What categories are
most represented in the clusters? What advertising libraries
do cloners prefer? In this section we seek to answer these
questions by investigating common features of apps in our
clone clusters. Note, at this point we do not yet speculate as
to which app in each clone cluster is the original and which
are clones.
6.1.1 Market Characteristics
Figure 4 shows which Android markets are most preva-
lent in our clone clusters. A signi(cid:12)cant percentage of apps
in our clone clusters are from Google Play; intuitively this
makes sense as Play is the most popular Android market.
To compensate for this observation, we computed what per-
centage of all applications in our database from the mar-
ket are present in a clone cluster.
In this context, Play
does not stand out more than other markets, but a num-
ber of other markets such as AndroidSoft, and the Chinese
markets AndroidOnline, GoApk, and AppChina, have more
than a quarter of their apps in our clone clusters. To bet-
ter understand the cloning relationship between markets, we
calculated the number of similar apps between each pair of

Ad Provider

admob
airpush
inmobi
millennial
mobclix
adfonic
greystripe
jumptap
smaato

Unique client IDs

from databases
51,434
8,728
514
786
2,994
59,170
59,616
8
0

from network
19,718
8,829
487
2,030
1,781
318
212
78
144

Network coverage Database coverage

21.2%
36.9%
28.6%
32.6%
38.0%
0.0%
0.3%
0.0%
n/a

55.4%
36.5%
30.2%
12.6%
63.9%
0.0%
68.4%
0.0%
0.0%

Table 1: Percentage of extracted client IDs we observed in network tra(cid:14)c and percentage of observed network client IDs we
also extracted from the application database, broken down by provider. The lower group of providers are ones which we did
not include in our study because they did not have signi(cid:12)cant overlap with our application database.

Figure 4: Plot showing the popularity of di(cid:11)erent app mar-
kets in our clone clusters. The absolute number of cloned
apps from each market is represented by the axis labelled
\Number of cloned apps", whereas the axis labelled \Per-
centage of apps that are clones" represents the popularity of
each market in our clone clusters normalized over the total
number of apps from that market in our database.

Figure 5: Plot showing the popularity of di(cid:11)erent app cate-
gories in our clone clusters. The absolute number of cloned
apps in each category is represented by the axis labelled
\Number of cloned apps", whereas axis labelled \Percent-
age of apps that are clones" represents the number of cloned
apps in each category normalized over the total number of
apps in that category in our database.

markets in a clone cluster. Speci(cid:12)cally, for the apps in given
clone cluster and a pair of markets (I; J):

M arketSimcluster(I; J) = min(apps from I; apps from J)

Then, to get a global view of the amount of similar appli-

cations between markets we calculate the total M arketSim(I; J)
as follows:

∑

M arketSim(I; J) =

M arketSimc(I; J)

c2clusters

In Figure 7, we plot the results of this calculation in an
undirected graph. To reduce the complexity of the graph,

we only show an edge between markets whose M arketSim
value is over 300 and remove unconnected markets.

We de(cid:12)ne a market as a \cloning hub" if it shares an edge
with many di(cid:11)erent markets in the graph. Play is the largest
cloning hub among all the markets, as it has a signi(cid:12)cant
cloning relationship with almost every other market. Sim-
ilarly, AndroidOnline is a cloning hub among the Chinese
markets. The existence of these cloning hubs implies one
of two things: either plagiarists prefer cloning from apps
on these markets, or that plagiarists prefer these markets
to publish their cloned apps. Since we do not speculate on
which app in a cluster is the original, we leave the determin-
ing which of these cases is true to future work. Note that the

lllllllllllllllllplayslidemeandroidonlinem360brothersoftgfaneoemarketonemobilegoapkandroidsoftandappstorefreewareloverssoftportalappchinaproandroidpocketgearandroiddownloadz050001000020000300000%10%20%30%40%50%MarketNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are cloneslllllllllllllllllllllGamesEntertainmentUtilityBusinessPersonalizationReferenceLifestyleNewsEducationMusicCommunicationSportsTravelFinanceHealthVideoPhotographySocialShoppingWeatherOther020004000600080000%5%10%15%20%25%CategoryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesperiods of time, allowing more advertising revenue to be
generated.

6.1.3 Ad Library Characteristics
Figure 6 gives a breakdown by ad provider of the appli-
cations in our clone clusters, as well as normalized across
our entire application database. Admob is the most popular
provider among cloned applications, but is also the most
popular among all applications, and thus does not have
a higher percentage of cloned apps compared with other
providers. On the other hand, for our Chinese ad providers,
Wooboo and Youmi, cloned applications represent a larger
subset of the total applications that use these providers.
Nonetheless, an alarmingly large percentage of applications
for each provider are in our clone clusters, meaning that they
either are clones of another app, or are a legitimate app that
has been cloned. Note that we do not consider what per-
centage of ad tra(cid:14)c was generated by our clone clusters for
each ad provider, as we do not speculate which app is the
original and want to avoid any assumptions regarding how
much tra(cid:14)c for a provider is a result of app plagiarism. In
the next section, we estimate a lower bound for how much
advertising revenue cloning siphons from legitimate applica-
tions.
6.2 Comparing Clones and Non-clones

In previous sections we examined a number of properties
of apps in our cloned clusters without distinguishing the
\original" apps from the clones.
In this section, we wish
to gain insight into the impact of cloning on developers.
Speci(cid:12)cally, we investigate the e(cid:11)ects of cloning on the orig-
inal authors’ ad revenue and user install base. To do so, the
original author in the cluster must be determined, which is
surprisingly nontrivial.

6.2.1 Determining Original App
There are a number of intuitive approaches one could use
to determine which application among a cluster of similar
applications is the original. Unfortunately, most of these
initial approaches are (cid:13)awed. For example, one could use:

(cid:15) Date (cid:12)rst uploaded to the market
(cid:15) Application popularity by number of installs or rating
(cid:15) Code size by number of methods, instructions, or other

metric

The date an application was (cid:12)rst uploaded to the market
is di(cid:14)cult to know as an external observer. Each market
knows when the application was (cid:12)rst uploaded, but unless
an external observer has been crawling markets since their
creation in both the free and paid sections, she cannot know
for sure which app came (cid:12)rst. Additionally, there have been
cases where beta releases have been taken and uploaded to
markets before the original developer’s app. Application
popularity may sometimes di(cid:11)erentiate the clone from the
original, for example in the case of Angry Birds, however,
for less popular applications, users may be just as likely to
download the clone as the original. Further, application pop-
ularity by both number of installs and ratings is vulnerable
to sybil attacks which would be relatively easy to perform
as most market accounts require only a valid email address.
Lastly, the code size of applications can easily be distorted

Figure 6: Plot showing the popularity of di(cid:11)erent ad li-
braries among apps in our clone clusters. The absolute num-
ber of cloned apps with each library is represented by the
axis labelled \Number of cloned apps", whereas axis labelled
\Percentage of apps that are clones" represents the number
of cloned apps with each library normalized over the total
number of apps with that library in our database.

prevalence of Play as a cloning hub is likely in(cid:13)uenced by
the fact Play represents 73.7% of the apps in our database.

6.1.2 Category Characteristics
We now investigate which app categories are popular among

apps in our clone clusters so that we can better understand
what types of apps are involved in cloning. One di(cid:14)culty
with comparing categories among apps from di(cid:11)erent mar-
kets is that di(cid:11)erent markets use di(cid:11)erent category names
to refer to the same type of application. To avoid this prob-
lem, we chose 21 meta-categories that represent the spec-
trum of di(cid:11)erent categories observed across all our markets
(our mapping from category strings to meta-categories is
presented in the Appendix). Figure 5 presents the num-
ber of applications in our clone clusters that belong to each
meta-category. As we did for markets, we normalize the
number of cloned apps in each category with the number of
all apps in our database for that category to determine what
percentage of apps in the category are involved in cloning.
Interestingly, \Games" is the most popular category among
apps in the clone clusters, but also has the highest preva-
lence of apps involved in cloning. Thus, markets that care
about application cloning should focus on apps categorized
as \Games." Additionally, assuming that the original app
and the clone belong to the same category, this implies pla-
giarists prefer applications categorized as \Games." We hy-
pothesize that this is because games are relatively complex,
popular among Android users, and are often run for long

llllllllllladmobmillennialairpushwoobooyoumimobclixinmobigreystripesmaatojumptapadfonic05000100001500020000250000%5%10%15%20%25%30%35%Ad LibraryNumber of cloned appsPercentage of apps that are cloneslNumber of cloned appsPercentage of apps that are clonesFigure 7: Markets which have a signi(cid:12)cant cloning relationship. The thickness of an edge is proportional to the M arketSim
value between the markets, and the height of a node is proportional to the sum of the edge weights for a given market. Markets
with nodes colored blue are US-based markets whereas markets with nodes colored red are Chinese-based markets.

Num Clusters
LostImpstotal
P ercLostImpstotal
LostU serstotal
P ercLostU serstotal

P1
610
1,764,609
52%
166,534
49%

P2
370
1,076,614
51%
122,718
48%

P3
128
56,884
14%
3,808
10%

Table 3: Total amount of lost impressions and users across
all of our clone clusters between each phase of developer
merging. The value of Num Clusters represents how many
clone clusters had more than one owner after each phase.
P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3,
respectively.

by plagiarists to make the plagiarized app appear larger or
smaller.

Rather than rely on one of these (cid:13)awed approaches, we
instead use an approach that estimates a lower bound on
our (cid:12)ndings. For each cluster we deem the owner with the
most observed impressions to be the original author and all
other owners are treated as plagiarists. In the case where
clones are more popular than the original, we will mislabel
the original author as a plagiarist, but this is acceptable as
we will only underestimate the percentage of lost advertising
tra(cid:14)c. Indeed, this approach guarantees we will not overes-
timate the number of lost impressions from mislabeling the
original as the above approaches might, as we only consider
the least popular owners in a clone cluster as plagiarists
(other caveats presented in Section 7.1.2). As we will see,
merging developer accounts has signi(cid:12)cant impact over our
results when app owners within a clone cluster are merged
by certi(cid:12)cate or client ID, and in some cases may attribute
all apps within a cluster to the same merged owner. We do
not consider such cases in our computations of lost revenue,
as they do not represent fraudulent cloning.
6.2.2 How much revenue do clones siphon from the

original authors?

In order to determine the impact of plagiarism on the ad-
vertising revenue of the original application, we (cid:12)rst observe

that hard dollar amounts are di(cid:14)cult to determine when
looking at advertising network tra(cid:14)c alone. This is because
an impression does not explicitly indicate how much it is
worth in an ad request, as the ad provider does not want to
disclose how much it or its a(cid:14)liated developers are making.
Instead, we show what percentage of lost ad tra(cid:14)c devel-
opers experience by comparing the ratio of impressions that
belong to plagiarized applications compared with the total
number of impressions we observed belonging to applica-
tions in our clone clusters. The number of lost impressions
for a cluster is represented by LostImpscluster, and the per-
centage of lost impressions for a cluster is this value divided
by all impressions attributed to apps in the cluster, times
100 (represented by P ercLostImpscluster). Additionally,
LostImpstotal represents the total number of plagiarized
app impressions over all the clusters, and P ercLostImpstotal
represents what percentage of all impressions from all clus-
ters that are a results of LostImpstotal.

As previously stated, we consider the original author in a
cluster as the app owner with the greatest amount of adver-
tising tra(cid:14)c, thus the numerator is the number of impres-
sions for all apps in the cluster not owned by this author.
Additionally, we do not consider clusters with only a single
owner. Figure 8a shows a CDF of the P ercImpsLostcluster
values across our clone clusters for each stage of applica-
tion owner merging. When only considering developer ac-
counts on their own (Phase 1 of the owner graph, see Sec-
tion 4.3) nearly 25% of the clusters have exactly 50% lost
revenue. This is a result of clusters having exactly two ap-
plications which belong to di(cid:11)erent developer accounts but
which share a client ID. Intuitively, we would want to re-
move these anomalies by merging developer accounts where
it makes sense. However, merging by certi(cid:12)cates alone,
which is very accurate, does not signi(cid:12)cantly change the
distribution of lost revenue across our clusters (Phase 2 of
owner graph). Thus, we use the results of Phase 3 of the
owner graph where owners are merged by client IDs to en-
sure that our results do not overestimate the percentage of
lost revenue. Figure 8b shows the impact of merging at each
stage on the P ercImpsLostcluster values, and Table 3 sum-

slidemebrothersoft 344play   1460  1325eoemarketgoapk 396m360  822gfan 629  809androidonline 609  1447 549 448 319onemobile  751(a) P ercLostImpscluster

(b) P ercLostImpstotal

Figure 8: CDF and boxplot of percent impact to developers in terms of impressions for each phase of merging on the owner
graph. P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3, respectively.

(a) P ercLostU serscluster

(b) P ercLostU serstotal

Figure 9: CDF and boxplot of percent impact to developers in terms of users for each phase of merging on the owner graph.
P1, P2, and P3 represent Phase 1, Phase 2, and Phase 3, respectively.

0%20%40%60%80%100%0%20%40%60%80%100%Percent revenue lostPercent of clustersP1P2P3P1P2P3Lost Revenue0%20%40%60%80%100%Percentage Lost0%20%40%60%80%100%0%20%40%60%80%100%Percent users lostPercent of clustersP1P2P3P1P2P3Lost Users0%20%40%60%80%100%Percentage Lostmarizes the total impact over all the clusters. Alarmingly,
the value of LostImpstotal after all developer account merg-
ing is complete is 14%, meaning that authors who are the
target of cloning on average lost 14% of their advertising
revenue to application plagiarism, assuming the users who
downloaded the plagiarized versions would have used the
original app instead.
6.2.3 How much of the user base do clones divert

from the original app?

To determine how much user base application plagiarism
siphons from the original authors, we used the anonymized
device identi(cid:12)ers present in the ad tra(cid:14)c from our network
trace to estimate the number of unique users per application.
Similar to lost impressions, we compute the LostU serscluster
and P ercLostU serscluster values for each cluster and plot
the distribution in Figure 9a. We also compute the total
number of lost users across all our clusters as LostU serstotal
and the percentage lost across all the clusters as P ercLost-
U serstotal. The value of these are summarized in Figure 9b
and Table 3. We see that on average, 10% of the user base
for an author in our clone clusters is siphoned due to plagia-
rism if we assume the users who downloaded the plagiarized
applications would have used the original app if no plagia-
rism were present.

7. DISCUSSION
7.1 Limitations

7.1.1 Authorship Determination
During our exploration of potential methods for merging
owners we encountered several challenges. All of these chal-
lenges could cause our analysis to merge developer accounts
more aggresively, potentially causing us to underestimate
lost impressions and users due to plagiarism.

Certiﬁcates Shared By Many Apps.

We found that some certi(cid:12)cates are present on many apps
that are associated with a large number of developer ac-
counts on several markets. Eight certi(cid:12)cates were present on
apps from over one hundred developer accounts, the largest
having 413. After manually reviewing the developer ac-
counts associated with several of the most prevalent cer-
ti(cid:12)cates, we decided that either one or several parties made
a signi(cid:12)cant attempt to distribute their apps across many
developer accounts or that the private keys were leaked or
stolen. In fact, we discovered one of the certi(cid:12)cates corre-
sponds to a private key used in the Android Open Source
Project3 (AOSP). These keys are often used to sign custom
ROMs. Apps signed with these keys can run with greater
privileges when running on a custom ROM and some mal-
ware has been found to take advantage of this [21]. Regard-
less of why many developer accounts share a certi(cid:12)cate, we
were surprised to (cid:12)nd that two apps sharing a certi(cid:12)cate
may not necessarily have the same owner.

Apps With Multiple Certiﬁcates.

Though it has not been discussed in the literature to the
best of our knowledge and is only brie(cid:13)y mentioned in the
Android documentation page on signing apps [23], Android

3http://source.android.com/

apps may be signed with multiple developer keys. We found
667 apps in our dataset that have more than one certi(cid:12)cate,
with the largest having four. Android developers may do
this as a means to collaborate with another developer or to
ease the process of selling an app to a company [15, 19].

We hoped to use apps with multiple keys to merge owners
in possession of at least one of the keys. Intuitively, if one
app is signed by developer keys A and B, one would like
to merge the owners of each key, as the developer of an
app should have possession of each key that signed her app.
We manually reviewed a number of cases where we tried
to merge owners based on apps with multiple keys. While
in several cases the developer accounts of each key seemed
related, this was not always the case. Thus, in this work we
ignore any app with multiple certi(cid:12)cates as they may taint
our results. Furthermore, these apps constitute a very small
portion of our dataset (667 out of 265,359 apps).

Lazy Cloning.

We de(cid:12)ne \lazy cloning" to be cases when a cloner copies
an app but does not change all of the client IDs in ad libraries
contained in the original app. This would cause our analysis
to merge the owners representing the original developer and
the cloner, as they are responsible for apps that share a
client ID. We believe this occurs infrequently in practice, as
one of the major incentives behind cloning is (cid:12)nancial gains.
7.1.2 Estimation on Lost Revenue and User Base
Since we cannot identify the original app in a clone cluster
reliably, we choose the most popular app, measured by the
number of ad impressions, as the original app. While this
decision provides a lower bound estimation on the percent
lost revenue and user base in most cases, it would fail in the
following unusual cases.

Failure to merge owners.

When we fail to merge two di(cid:11)erent developer accounts of
the same owner, we could in(cid:13)ate the number of unique own-
ers in a clone cluster. This would happen when an owner
publishes similar apps from di(cid:11)erent developer accounts us-
ing di(cid:11)erent certi(cid:12)cates and di(cid:11)erent client IDs. Additional
information, such as payment accounts and addresses, from
app markets or ad providers could improve our app owner-
ship determination.

Sharing of client IDs between different apps.

We assume that one client ID is speci(cid:12)c to one family
of similar apps. However, if a developer includes the same
client ID in di(cid:11)erent apps but only some of them are in a
clone cluster, we could in(cid:13)ate the number of impressions
generated by the apps in the cluster. To verify this occurs
rarely in practice, we calculated the total number of client
IDs of which only a subset were in a cluster. Only 0.65%
of our client IDs appear in apps both in and out of a clus-
ter; thus, client ID sharing does not signi(cid:12)cantly impact our
results.

Missing original apps.

If our database fails to include the original app for a clus-
ter, we may overestimate the losses in cases where the miss-
ing original app is very popular. For example, we could (cid:12)nd
a large impression or user base di(cid:11)erential between two An-
gry Birds clones, leading us to calculate a strong developer

loss. However, by missing the original Angry Birds app we
wouldn’t see that it had many impressions, so the real loss
ratio is quite low. We believe this is unlikely to occur as
our crawling focused on both newly published and popular
apps.

Paid apps.

The estimated lost revenue and users is based on the as-
sumption that if a clone app were unavailable,
its users
would have installed the original app and spent the same
amount of time on it. Since we focus exclusively on free
apps, it is reasonable to assume there is little di(cid:11)erence be-
tween (cid:12)nding, installing, and running the original app and
its clones. However, this assumption may not hold when
considering paid apps.

7.2 Potential Steps to Reduce Cloning

A primary goal of our e(cid:11)ort to gain insight into the current
state of Android app cloning is to protect Android develop-
ers and users. Technical solutions such as the automatic
plagiarism detection methods used for this work [6] should
be employed by markets to improve the speed with which
clones are caught and removed from markets. Reducing the
lifetime of clones on markets limits their downloads and thus
their impact.

However, as Android apps are straightforward to decom-
pile, modify, and resubmit to markets, we do not believe
technical solutions alone are su(cid:14)cient. Detection tools can
always continue to be improved, but it is unlikely that a tool
can catch every clone, whether it’s due to lack of access to
every app across every market or signi(cid:12)cant code obfusca-
tions. Instead, we believe reducing economic incentives is a
more e(cid:11)ective way to limit app cloning. For example, if all
markets began charging at least a nominal registration fee
then cloners would have to make back the registration cost
from their clones before the account is banned or they will
lose money. This also disincentives a plagiarist from cre-
ating many developer accounts, possibly making plagiarism
detection easier. Similarly, ad providers could also charge a
registration fee or delay ad revenue payout for some period
of time to allow the developer’s apps to be vetted. By in-
creasing the time and/or cost to create developer accounts
or sign up with ad providers, legitimate developers may be
slightly a(cid:11)ected but cloners wishing to create many devel-
oper or ad provider accounts can be signi(cid:12)cantly impeded.
We o(cid:11)er these potential solutions with caution, as one of
the great advantages of the Android ecosystem is its open-
ness and low barrier to entry. The associated costs must be
carefully weighed to reduce cloning while not discouraging
legitimate developers.

8. RELATED WORK

Malicious activities on Android.

Prior work examined information leaks within an applica-
tion [9] and between applications [8]. Researchers discussed
privacy violations in third-party libraries, especially adver-
tising libraries [12, 22, 20, 24]. [29] characterized Android
malware. DroidMOSS [28] and DNADroid [6] detected
repackaged and cloned Android applications.

Examining the impact of malicious activities.

Kanich et al. investigated the underground economy of
spam [14, 17]. Prior work examining the impact of malicious
activities primarily focused on fraud that harmed the user,
such as fake anti-virus software [26], keyloggers [13], and
spam [25]. By contrast, application plagiarism detriments
mainly the original developers of the plagiarized applica-
tions by taking away their users and advertising revenue.
Online advertising fraud has been extensively studied in the
literature [7, 11, 27]; however, application cloning does not
necessarily imply advertising fraud because the advertiser
still receives impressions and clicks from the users of cloned
applications.

9. CONCLUSION

In this paper we presented AdRob, which is designed to be
the (cid:12)rst step towards understanding the economic incentives
of application plagiarism on Android markets. We charac-
terized application plagiarism and its impact on developers
by crawling 265,359 free applications from 17 Android mar-
kets around the world and detecting clones among them.
We captured live HTTP tra(cid:14)c generated by mobile appli-
cations at a tier-1 US cellular carrier for 12 days, and ex-
tracted client IDs from both applications and network traces
to correlate the two datasets. Based on the data, we (cid:12)rst ex-
amined properties of the cloned applications, including their
distribution across di(cid:11)erent markets, application categories,
and ad libraries. Next, we examined how cloned applications
a(cid:11)ect the origin developers. We estimated a lower bound on
the revenue that cloned applications siphon from the original
developers, and the user base that cloned applications divert
from the original applications, and (cid:12)nd an alarmingly high
percentage of impressions is siphoned from developers who
are victims of plagiarism. To the best of our knowledge, this
is the (cid:12)rst large scale study on the characteristics of cloned
applications and their impact on the original developers.

10. ACKNOWLEDGEMENTS

We would like to thank Sharad Agarwal and the anony-
mous reviewers for their insightful feedback, as well as Liang
Cai, Dennis Xu, Ben Sanders, Justin Horton, and Jon Vron-
sky for their assistance in obtaining Android applications.
This paper is based upon work supported by the National
Science Foundation under Grant No. 1018964.

References
[1] A. Andoni and P. Indyk. \Near-optimal hashing al-
gorithms for approximate nearest neighbor in high di-
mensions". In: Foundations of Computer Science, 2006.
FOCS’06. 47th Annual IEEE Symposium on. Ieee. 2006,
pp. 459{468.

[2] Jason Ankeny. Feds seize Android app marketplaces
Applanet, AppBucket in piracy sting. Aug. 22, 2012.
url: http://www.fiercemobilecontent.com/story/
feds-seize-android-app-marketplaces-applanet-
appbucket-piracy-sting/2012-08-22.

[3] AppBrain. Android Ad networks. Mar. 2013. url: http:

//www.appbrain.com/stats/libraries/ad.

[4] AppBrain. Number of available android applications.
Nov. 2012. url: http://www.appbrain.com/stats/
number-of-android-apps.

[5] Brut.alll. Android-Apktool. url: http://code.google.

com/p/android-apktool.

[6] J. Crussell, C. Gibler, and H. Chen. \Attack of the

Clones: Detecting Cloned Applications on Android Mar-
kets". In: Computer Security{ESORICS 2012 (2012),
pp. 37{54.

[7] N. Daswani et al. \Online advertising fraud". In: Crime-
ware: Understanding New Attacks and Defenses (2008).
[8] M. Dietz, S. Shekhar, Y. Pisetsky, A. Shu, and D.S.

Wallach. \Quire: lightweight provenance for smart phone
operating systems". In: USENIX Security. 2011.

[9] William Enck, Landon P. Cox, and Jaeyeon Jung. \Taint-

Droid: An Information-Flow Tracking System for Re-
altime Privacy Monitoring on Smartphones". In: (2010).
[10] Jesus Freke. Smali/Baksmali. url: http : / / code .

google.com/p/smali.

[11] Mona Gandhi, Markus Jakobsson, and Jacob Ratkiewicz.

\Badvertisements: Stealthy click-fraud with unwitting
accessories". In: Online Fraud, Part I Journal of Digi-
tal Forensic Practice, Volume 1, Special Issue 2. 2006.
[12] M.C. Grace, W. Zhou, X. Jiang, and A.R. Sadeghi.
\Unsafe exposure analysis of mobile in-app advertise-
ments". In: Proceedings of the (cid:12)fth ACM conference
on Security and Privacy in Wireless and Mobile Net-
works. ACM. 2012, pp. 101{112.

[13] T. Holz, M. Engelberth, and F. Freiling. \Learning
more about the underground economy: A case-study
of keyloggers and dropzones". In: Computer Security{
ESORICS 2009 (2009), pp. 1{18.

[14] Chris Kanich et al. \Show Me the Money: Characteriz-
ing Spam-advertised Revenue". In: USENIX Security
Symposium. San Francisco, CA, Aug. 2011.

[15] Keystore and Aliases - is there a use to multiple aliases?

Dec. 2012. url: http://stackoverflow.com/questions/
2667399/keystore- and- aliases- is- there- a- use-
to-multiple-aliases.

[16] Eric Lafortune. Proguard. url: http : / / proguard .

sourceforge.net.

[17] Kirill Levchenko et al. \Click Trajectories: End-to-End
Analysis of the Spam Value Chain". In: IEEE Sympo-
sium and Security and Privacy. Oakland, CA, May
2011.

[18] H. Liu, C.N. Chuah, H. Zang, and S. Gatmir-motahari.
\Evolving Landscape of Cellular Network Tra(cid:14)c". In:
Computer Communications and Networks (ICCCN),
2012 21st International Conference on. IEEE. 2012,
pp. 1{7.

[19] Multiple Signatures and Shared UIDs. Dec. 2012. url:
https://groups.google.com/forum/?fromgroups=
#!topic/android-security-discuss/LyyEWyFg5xc.

[20] P. Pearce, A.P. Felt, G. Nunez, and D. Wagner. \Ad-
Droid: Privilege Separation for Applications and Ad-
vertisers in Android". In: Proceedings of the 7th ACM
Symposium on Information, Computer and Commu-
nications Security. ACM. 2012.

[21] Security Alert: Malware Found Targeting Custom ROMs
(jSMSHider). Dec. 2012. url: https://blog.lookout.
com/blog/2011/06/15/security- alert- malware-
found-targeting-custom-roms-jsmshider/.

[22] S. Shekhar, M. Dietz, and D.S. Wallach. \Adsplit: Sep-
arating smartphone advertising from applications". In:
CoRR, abs/1202.4030 (2012).

[23] Signing Your Applications. Dec. 2012. url: http://
developer . android . com / tools / publishing / app -
signing.html.

[24] R. Stevens, C. Gibler, J. Crussell, J. Erickson, and H.
Chen. \Investigating User Privacy in Android Ad Li-
braries". In: IEEE Mobile Security Technologies (MoST),
San Francisco, CA (2012).

[25] B. Stone-Gross, T. Holz, G. Stringhini, and G. Vi-
gna. \The underground economy of spam: A botmas-
ters perspective of coordinating large-scale spam cam-
paigns". In: USENIX Workshop on Large-Scale Ex-
ploits and Emergent Threats (LEET). 2011.

[26] B. Stone-Gross et al. \The underground economy of
fake antivirus software". In: Economics of Information
Security and Privacy III (2011), pp. 55{78.

[27] B. Stone-Gross et al. \Understanding fraudulent ac-
tivities in online ad exchanges". In: Proceedings of the
2011 ACM SIGCOMM conference on Internet mea-
surement conference. ACM. 2011, pp. 279{294.

[28] W. Zhou, Y. Zhou, X. Jiang, and P. Ning. \Detect-
ing repackaged smartphone applications in third-party
android marketplaces". In: Proceedings of the second
ACM conference on Data and Application Security and
Privacy. ACM. 2012, pp. 317{326.

[29] Y. Zhou and X. Jiang. \Dissecting android malware:
Characterization and evolution". In: Security and Pri-
vacy (SP), 2012 IEEE Symposium on. IEEE. 2012,
pp. 95{109.

APPENDIX
Table 4: Mapping from market category strings to meta-
categories. Meta-categories with just one market category
are excluded.

Meta-category Market category

Business Business

Enterprise

Entertainment Comics

Entertainment

Games Arcade & Action

Brain & Puzzle
Cards & Casino
Casual
Fun & Games
Games
Racing
Sports Games

Health Health

Health & Fitness
Medical

Music Music

Music & Audio

News News

News & Magazines

Other Developer / Programmer

Home & Hobby
Other
Religion

Personalization Personalization

Wallpapers

Reference Books & Reference

E-books
Ebooks & Reference
Reference

Social Collaboration

Social
Social Responsibility

Travel Transportation

Travel
Travel & Local

Utility Email & SMS

Libraries & Demo
Location & Maps
Productivity
System
Tools
Utilities

Video Media & Video

Multimedia

