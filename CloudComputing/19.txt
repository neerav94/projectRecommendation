Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

Automatic Schedule Control for Distributed 
Software Development in Cloud Computing 

Environments 

 

Chung Yung, Shao-Zong Chen, and Jen-Tsung Hsieh 

Department of Computer Science and Information Engineering 

National Dong Hwa University, Hualien, TAIWAN 

Email: {yung@mail, m9721505@ems, 610021068@ems}.ndhu.edu.tw 

 
 
 

in  application  design,  development 

Abstract—This  paper  proposes  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development 
in  cloud  computing 
environments.    Cloud  computing  environments  provide 
more flexibility than conventional computing environments.  
In  particular,  platform  as  a  service  (PaaS)  provides  more 
flexibility 
testing, 
deployment,  hosting,  team  collaboration,  web  service  and 
database  integration,  scalability,  and  versioning. 
  The 
WebSD  model  is  a  new  management  model  of  distributed 
software  development  for  cloud  computing  environments.  
However,  WebSD  does  not 
include  functionality  for 
schedule  control.    We  design  new  operations  and  add  into 
the  WebSD  model  such  that  the  distributed  software 
development  may  be  managed  with  automatic  assistance  in 
schedule  control.    We  call  the  extended  model  as  SDot. 
Inherited from WebSD, SDot also offers a common platform 
for  various  roles  involved  in  the  distributed  software 
development,  and  SDot 
is  also  appropriate  for  the 
management  of  distributed  software  development  in  cloud 
computing  environments.    We  present  the  application  of 
SDot to a practical software project as a case study to show 
the  effectiveness  of  SDot  in  schedule  control  for  the 
management of distributed software development. 
 
Index  Terms—schedule  control,  distributed 
software 
development,  software  development  management,  cloud 
computing environment. 
 

I. 

INTRODUCTION 

Overall speaking, the objective of software engineering 
is  to  guarantee  the  delivery  of  high-quality  software  on 
time  and  within  budget  [1].    In  the  past  decade, 
developing  software  systems  with  globally  distributed 
teams  is  popularly  applied  to  a  lot  software  projects  [2]. 
With  the  development  of  software  technology  and  the 
rapid extension of application areas, the cost and schedule 
of  distributed  software  development  may  get  out  of 
control  easily  if  the  projects  are  not  managed  with 
intensive care [3]. 

Based  on  54  works  of  distributed 

software 
development published from 1998 to 2009, da Silva et al. 
concluded  that  the  strong  evidence  about  the  effect  of 

                                                           

 Manuscript received June 10, 2013; revised August 27, 2013. 

©2014 Engineering and Technology Publishing
doi: 10.12720/jiii.2.1.39-44

39

using  the  best  practices,  models,  and  tools  in  distributed 
software  development  projects  is  still  scarce  in  the 
literature  [4].    The  ultimate  goal  of  distributed  software 
development  is  fully  using  all  the  resources,  including 
computing  devices  and  human  resources,  to  achieve 
flexibility,  quality  and  cost  down.    On  the  other  hand, 
there  exist  several  challenges  in  globally  distributed 
software  development, 
in 
communication, formal change management, planning for 
system  integration,  project  monitoring  across  distributed 
teams,  standard  distributed  development 
tools,  and 
integrated management tools [5]. 

formalization 

such  as 

Cloud computing is not only a term that refers to data, 
processing,  or  experiences  that  reside  somewhere  in  the 
cloud  that  we  call  as  the  internet.  Nowadays,  cloud 
computing reforms the way how companies operate with 
data  and  applications  in  the  processes  of  inventing, 
developing, deploying, scaling, updating, maintaining and 
paying for resources that undergo the changes [6]-[8]. 

A  cloud  computing  environment  can  be  defined  as  a 
computing  environment  that  provides  everything  as  a 
service,  including  infrastructure  as  a  service  (IaaS), 
platform  as  a  service  (PaaS),  and  software  as  a  service 
(SaaS).  The  software  systems  developed 
in  cloud 
computing  environments  suffer  from  the  same  problems 
that  plague  the  conventional  distributed  and  parallel 
software  systems;  they  are  complex  to  design,  develop, 
test,  deploy,  and  manage  [9].  While  various  cloud 
services  are  either  available  or  under  development,  the 
industry  calls  for  a  new  model  of  distributed  software 
development  management  that  is  specialized  for  cloud 
computing environments [6], [10]. 

With such a background, Yung et al. propose WebSD, 
which  is  a  new  management  model  of  distributed 
software  development  management  for  cloud  computing 
environments  [6].    WebSD  contributes  in  the  following 
aspects. 

  WebSD  simplifies  the  conventional  hierarchical 

architecture of distributed software development, 

  WebSD  extends  conventional  models  to  allow 
outsourcing  parts  of  the  software  development  to 
fellow companies, and 

  WebSD  provides  various  views  to  the  distributed 
software  development  for  the  roles  involved, 

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

Automatic Schedule Control for Distributed 
Software Development in Cloud Computing 

Environments 

 

Chung Yung, Shao-Zong Chen, and Jen-Tsung Hsieh 

Department of Computer Science and Information Engineering 

National Dong Hwa University, Hualien, TAIWAN 

Email: {yung@mail, m9721505@ems, 610021068@ems}.ndhu.edu.tw 

 
 
 

in  application  design,  development 

Abstract—This  paper  proposes  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development 
in  cloud  computing 
environments.    Cloud  computing  environments  provide 
more flexibility than conventional computing environments.  
In  particular,  platform  as  a  service  (PaaS)  provides  more 
flexibility 
testing, 
deployment,  hosting,  team  collaboration,  web  service  and 
database  integration,  scalability,  and  versioning. 
  The 
WebSD  model  is  a  new  management  model  of  distributed 
software  development  for  cloud  computing  environments.  
However,  WebSD  does  not 
include  functionality  for 
schedule  control.    We  design  new  operations  and  add  into 
the  WebSD  model  such  that  the  distributed  software 
development  may  be  managed  with  automatic  assistance  in 
schedule  control.    We  call  the  extended  model  as  SDot. 
Inherited from WebSD, SDot also offers a common platform 
for  various  roles  involved  in  the  distributed  software 
development,  and  SDot 
is  also  appropriate  for  the 
management  of  distributed  software  development  in  cloud 
computing  environments.    We  present  the  application  of 
SDot to a practical software project as a case study to show 
the  effectiveness  of  SDot  in  schedule  control  for  the 
management of distributed software development. 
 
Index  Terms—schedule  control,  distributed 
software 
development,  software  development  management,  cloud 
computing environment. 
 

I. 

INTRODUCTION 

Overall speaking, the objective of software engineering 
is  to  guarantee  the  delivery  of  high-quality  software  on 
time  and  within  budget  [1].    In  the  past  decade, 
developing  software  systems  with  globally  distributed 
teams  is  popularly  applied  to  a  lot  software  projects  [2]. 
With  the  development  of  software  technology  and  the 
rapid extension of application areas, the cost and schedule 
of  distributed  software  development  may  get  out  of 
control  easily  if  the  projects  are  not  managed  with 
intensive care [3]. 

Based  on  54  works  of  distributed 

software 
development published from 1998 to 2009, da Silva et al. 
concluded  that  the  strong  evidence  about  the  effect  of 

                                                           

 Manuscript received June 10, 2013; revised August 27, 2013. 

©2014 Engineering and Technology Publishing
doi: 10.12720/jiii.2.1.39-44

39

using  the  best  practices,  models,  and  tools  in  distributed 
software  development  projects  is  still  scarce  in  the 
literature  [4].    The  ultimate  goal  of  distributed  software 
development  is  fully  using  all  the  resources,  including 
computing  devices  and  human  resources,  to  achieve 
flexibility,  quality  and  cost  down.    On  the  other  hand, 
there  exist  several  challenges  in  globally  distributed 
software  development, 
in 
communication, formal change management, planning for 
system  integration,  project  monitoring  across  distributed 
teams,  standard  distributed  development 
tools,  and 
integrated management tools [5]. 

formalization 

such  as 

Cloud computing is not only a term that refers to data, 
processing,  or  experiences  that  reside  somewhere  in  the 
cloud  that  we  call  as  the  internet.  Nowadays,  cloud 
computing reforms the way how companies operate with 
data  and  applications  in  the  processes  of  inventing, 
developing, deploying, scaling, updating, maintaining and 
paying for resources that undergo the changes [6]-[8]. 

A  cloud  computing  environment  can  be  defined  as  a 
computing  environment  that  provides  everything  as  a 
service,  including  infrastructure  as  a  service  (IaaS), 
platform  as  a  service  (PaaS),  and  software  as  a  service 
(SaaS).  The  software  systems  developed 
in  cloud 
computing  environments  suffer  from  the  same  problems 
that  plague  the  conventional  distributed  and  parallel 
software  systems;  they  are  complex  to  design,  develop, 
test,  deploy,  and  manage  [9].  While  various  cloud 
services  are  either  available  or  under  development,  the 
industry  calls  for  a  new  model  of  distributed  software 
development  management  that  is  specialized  for  cloud 
computing environments [6], [10]. 

With such a background, Yung et al. propose WebSD, 
which  is  a  new  management  model  of  distributed 
software  development  management  for  cloud  computing 
environments  [6].    WebSD  contributes  in  the  following 
aspects. 

  WebSD  simplifies  the  conventional  hierarchical 

architecture of distributed software development, 

  WebSD  extends  conventional  models  to  allow 
outsourcing  parts  of  the  software  development  to 
fellow companies, and 

  WebSD  provides  various  views  to  the  distributed 
software  development  for  the  roles  involved, 

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

including  project  managers,  software  developers, 
software 
to 
cooperate in a common and open model. 

testers,  and  software  debuggers, 

However,  WebSD  does  not  include  any  specialized 
functionality  for  schedule  control,  which  motivates  our 
work presented in this paper. 

We  design  new  operations  and  add  into  the  WebSD 
model  such  that  the  distributed  software  development 
may  be  managed  with  automatic  assistance  in  schedule 
control.  We call the extended model as  SDot.  Inherited 
from  WebSD,  SDot  also  offers  a  common  platform  for 
various  roles 
the  distributed  software 
development,  and  SDot  is  also  appropriate  for  the 
management  of  distributed  software  development  in 
cloud  computing  environments. 
the 
application  of  SDot  to  a  practical  software  project  as  a 
case study to show the effectiveness of SDot in schedule 

  We  present 

involved 

in 

control  for  the  management  of  distributed  software 
development. 

This  paper  is  organized  as  follows.  The  next  section 
briefly  describes  the  WebSD  model.  Our  new  SDot 
model is presented in section 3. Application of SDot to a 
practical  case  is  described  in  section  4.  And  at  last  is  a 
brief conclusion. 

II.  THE WEBSD MODEL 

In this section, we briefly describe the WebSD model, 
which  is  a  web-based  management  model  of  distributed 
software development for cloud computing environments 
[6]. 

In the WebSD model, a software project of distributed 
development  is  described  as  a  well-designed  set  of 
modules, which are units of encapsulation. The life-cycle 
for  developing  a  module  in  a  software  system  is  defined 
by the state transition diagram shown in Fig. 1. 

Figure 1. The state transition diagram of the WebSD model 

 

 
As  an  example,  the  state  of  a  module  is  initially  A. 
After it is assigned to a group for programming, the state 
goes  to  B.    Once  the  assigned  group  accepts  the  job  of 
programming,  the  state  goes  to  C.    When  the  group 
reports  the  finish  of  programming,  the  state  goes  to  D. 
Then,  it  is  assigned  for  testing  and  the  state  goes  to  E. 
Once  the  assigned  group  accepts  the  job  of  testing,  the 
state  goes  to  F.    When  the  group  reports  the  finish  of 
testing and no bug is found, the state goes to G.  And then, 
the  project  manager  performs  the  integration  tests.    If  it 
passes  the  integration  tests,  the  state  goes  to  L  and  the 
development of the module is complete. 

Extended  from  the  definition  of  the  life-cycle  of 
developing a module, they define the status of a software 
project using distributed development as follows. 

Definition 

(Status  of  a  software  project  using 

distributed development, P) 

Given  a  module  set  M  of  k  modules  and  a  software 
project  consisting  of  the  k  modules,  the  status  of  the 
project P is defined as 

P = {pi|1 ≤ i ≤ k}, 

using  distributed  development,  we  may  derive  and  keep 
record  of 
software 
development in an official manner. 

the  progress  of  distributed 

III.  AUTOMATIC SCHEDULE CONTROL 

This  section  proposes  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development  for  cloud  computing 
environments.  We call the extended model as SDot. 

The  primary  operations  of  distributed  software 
development  modeled  in  SDot  are  listed  in  Fig.  2.    We 
briefly describe each operation as follows. 
1.1.  Assignp:  A  project  manager  assigns  the  job  of  programming  a 

module to a group. 

1.2.  Acceptp: A group accepts the job of programming a module. 
1.3.  Finishp: A group finishes the job of programming a module. 
1.4.  Rejectp: A group rejects the job of programming a module. 
1.5.  Withdrawp:  A  group  withdraws  the  acceptance  of  programming 

a module. 

1.6.  Expirep: The job of programming a module gets expired. 
1.7.  Extendp:  A  group  applies  for  an  extension  in  programming  a 

1.8.  Approvep:  A  project  manager  approves  the  extension  in 

where each pi is a pair ⟨ mi, si⟩ , mi ∈ M = {m1, ..., mk}, 
and  si  ∈  S  =  {A,  B,  C,  D,  E,  F,  G,  H,  I,  J,  K,  L}.             

module. 

programming a module. 

One  of  the  advantages  of  the  WebSD  model  is  that 
with  the  definition  of  the  status  of  a  software  project 

2.1.  Assignu:  A  project  manager  assigns  the  job  of  testing a  module 

to a group. 

©2014 Engineering and Technology Publishing

40

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

Automatic Schedule Control for Distributed 
Software Development in Cloud Computing 

Environments 

 

Chung Yung, Shao-Zong Chen, and Jen-Tsung Hsieh 

Department of Computer Science and Information Engineering 

National Dong Hwa University, Hualien, TAIWAN 

Email: {yung@mail, m9721505@ems, 610021068@ems}.ndhu.edu.tw 

 
 
 

in  application  design,  development 

Abstract—This  paper  proposes  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development 
in  cloud  computing 
environments.    Cloud  computing  environments  provide 
more flexibility than conventional computing environments.  
In  particular,  platform  as  a  service  (PaaS)  provides  more 
flexibility 
testing, 
deployment,  hosting,  team  collaboration,  web  service  and 
database  integration,  scalability,  and  versioning. 
  The 
WebSD  model  is  a  new  management  model  of  distributed 
software  development  for  cloud  computing  environments.  
However,  WebSD  does  not 
include  functionality  for 
schedule  control.    We  design  new  operations  and  add  into 
the  WebSD  model  such  that  the  distributed  software 
development  may  be  managed  with  automatic  assistance  in 
schedule  control.    We  call  the  extended  model  as  SDot. 
Inherited from WebSD, SDot also offers a common platform 
for  various  roles  involved  in  the  distributed  software 
development,  and  SDot 
is  also  appropriate  for  the 
management  of  distributed  software  development  in  cloud 
computing  environments.    We  present  the  application  of 
SDot to a practical software project as a case study to show 
the  effectiveness  of  SDot  in  schedule  control  for  the 
management of distributed software development. 
 
Index  Terms—schedule  control,  distributed 
software 
development,  software  development  management,  cloud 
computing environment. 
 

I. 

INTRODUCTION 

Overall speaking, the objective of software engineering 
is  to  guarantee  the  delivery  of  high-quality  software  on 
time  and  within  budget  [1].    In  the  past  decade, 
developing  software  systems  with  globally  distributed 
teams  is  popularly  applied  to  a  lot  software  projects  [2]. 
With  the  development  of  software  technology  and  the 
rapid extension of application areas, the cost and schedule 
of  distributed  software  development  may  get  out  of 
control  easily  if  the  projects  are  not  managed  with 
intensive care [3]. 

Based  on  54  works  of  distributed 

software 
development published from 1998 to 2009, da Silva et al. 
concluded  that  the  strong  evidence  about  the  effect  of 

                                                           

 Manuscript received June 10, 2013; revised August 27, 2013. 

©2014 Engineering and Technology Publishing
doi: 10.12720/jiii.2.1.39-44

39

using  the  best  practices,  models,  and  tools  in  distributed 
software  development  projects  is  still  scarce  in  the 
literature  [4].    The  ultimate  goal  of  distributed  software 
development  is  fully  using  all  the  resources,  including 
computing  devices  and  human  resources,  to  achieve 
flexibility,  quality  and  cost  down.    On  the  other  hand, 
there  exist  several  challenges  in  globally  distributed 
software  development, 
in 
communication, formal change management, planning for 
system  integration,  project  monitoring  across  distributed 
teams,  standard  distributed  development 
tools,  and 
integrated management tools [5]. 

formalization 

such  as 

Cloud computing is not only a term that refers to data, 
processing,  or  experiences  that  reside  somewhere  in  the 
cloud  that  we  call  as  the  internet.  Nowadays,  cloud 
computing reforms the way how companies operate with 
data  and  applications  in  the  processes  of  inventing, 
developing, deploying, scaling, updating, maintaining and 
paying for resources that undergo the changes [6]-[8]. 

A  cloud  computing  environment  can  be  defined  as  a 
computing  environment  that  provides  everything  as  a 
service,  including  infrastructure  as  a  service  (IaaS), 
platform  as  a  service  (PaaS),  and  software  as  a  service 
(SaaS).  The  software  systems  developed 
in  cloud 
computing  environments  suffer  from  the  same  problems 
that  plague  the  conventional  distributed  and  parallel 
software  systems;  they  are  complex  to  design,  develop, 
test,  deploy,  and  manage  [9].  While  various  cloud 
services  are  either  available  or  under  development,  the 
industry  calls  for  a  new  model  of  distributed  software 
development  management  that  is  specialized  for  cloud 
computing environments [6], [10]. 

With such a background, Yung et al. propose WebSD, 
which  is  a  new  management  model  of  distributed 
software  development  management  for  cloud  computing 
environments  [6].    WebSD  contributes  in  the  following 
aspects. 

  WebSD  simplifies  the  conventional  hierarchical 

architecture of distributed software development, 

  WebSD  extends  conventional  models  to  allow 
outsourcing  parts  of  the  software  development  to 
fellow companies, and 

  WebSD  provides  various  views  to  the  distributed 
software  development  for  the  roles  involved, 

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

including  project  managers,  software  developers, 
software 
to 
cooperate in a common and open model. 

testers,  and  software  debuggers, 

However,  WebSD  does  not  include  any  specialized 
functionality  for  schedule  control,  which  motivates  our 
work presented in this paper. 

We  design  new  operations  and  add  into  the  WebSD 
model  such  that  the  distributed  software  development 
may  be  managed  with  automatic  assistance  in  schedule 
control.  We call the extended model as  SDot.  Inherited 
from  WebSD,  SDot  also  offers  a  common  platform  for 
various  roles 
the  distributed  software 
development,  and  SDot  is  also  appropriate  for  the 
management  of  distributed  software  development  in 
cloud  computing  environments. 
the 
application  of  SDot  to  a  practical  software  project  as  a 
case study to show the effectiveness of SDot in schedule 

  We  present 

involved 

in 

control  for  the  management  of  distributed  software 
development. 

This  paper  is  organized  as  follows.  The  next  section 
briefly  describes  the  WebSD  model.  Our  new  SDot 
model is presented in section 3. Application of SDot to a 
practical  case  is  described  in  section  4.  And  at  last  is  a 
brief conclusion. 

II.  THE WEBSD MODEL 

In this section, we briefly describe the WebSD model, 
which  is  a  web-based  management  model  of  distributed 
software development for cloud computing environments 
[6]. 

In the WebSD model, a software project of distributed 
development  is  described  as  a  well-designed  set  of 
modules, which are units of encapsulation. The life-cycle 
for  developing  a  module  in  a  software  system  is  defined 
by the state transition diagram shown in Fig. 1. 

Figure 1. The state transition diagram of the WebSD model 

 

 
As  an  example,  the  state  of  a  module  is  initially  A. 
After it is assigned to a group for programming, the state 
goes  to  B.    Once  the  assigned  group  accepts  the  job  of 
programming,  the  state  goes  to  C.    When  the  group 
reports  the  finish  of  programming,  the  state  goes  to  D. 
Then,  it  is  assigned  for  testing  and  the  state  goes  to  E. 
Once  the  assigned  group  accepts  the  job  of  testing,  the 
state  goes  to  F.    When  the  group  reports  the  finish  of 
testing and no bug is found, the state goes to G.  And then, 
the  project  manager  performs  the  integration  tests.    If  it 
passes  the  integration  tests,  the  state  goes  to  L  and  the 
development of the module is complete. 

Extended  from  the  definition  of  the  life-cycle  of 
developing a module, they define the status of a software 
project using distributed development as follows. 

Definition 

(Status  of  a  software  project  using 

distributed development, P) 

Given  a  module  set  M  of  k  modules  and  a  software 
project  consisting  of  the  k  modules,  the  status  of  the 
project P is defined as 

P = {pi|1 ≤ i ≤ k}, 

using  distributed  development,  we  may  derive  and  keep 
record  of 
software 
development in an official manner. 

the  progress  of  distributed 

III.  AUTOMATIC SCHEDULE CONTROL 

This  section  proposes  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development  for  cloud  computing 
environments.  We call the extended model as SDot. 

The  primary  operations  of  distributed  software 
development  modeled  in  SDot  are  listed  in  Fig.  2.    We 
briefly describe each operation as follows. 
1.1.  Assignp:  A  project  manager  assigns  the  job  of  programming  a 

module to a group. 

1.2.  Acceptp: A group accepts the job of programming a module. 
1.3.  Finishp: A group finishes the job of programming a module. 
1.4.  Rejectp: A group rejects the job of programming a module. 
1.5.  Withdrawp:  A  group  withdraws  the  acceptance  of  programming 

a module. 

1.6.  Expirep: The job of programming a module gets expired. 
1.7.  Extendp:  A  group  applies  for  an  extension  in  programming  a 

1.8.  Approvep:  A  project  manager  approves  the  extension  in 

where each pi is a pair ⟨ mi, si⟩ , mi ∈ M = {m1, ..., mk}, 
and  si  ∈  S  =  {A,  B,  C,  D,  E,  F,  G,  H,  I,  J,  K,  L}.             

module. 

programming a module. 

One  of  the  advantages  of  the  WebSD  model  is  that 
with  the  definition  of  the  status  of  a  software  project 

2.1.  Assignu:  A  project  manager  assigns  the  job  of  testing a  module 

to a group. 

©2014 Engineering and Technology Publishing

40

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

2.2.  Acceptu: A group accepts the job of testing a module. 
2.3.  Finishu: A group finishes the job of testing a module. 
2.4.  Rejectu: A group rejects the job of testing a module. 
2.5.  Withdrawu:  A  group  withdraws  the  acceptance  of  testing  a 

module. 

2.6.  Expireu: The job of testing a module gets expired. 
2.7.  Extendu: A group applies for an extension in testing a module. 
2.8.  Approveu: A project manager approves the extension in testing a 

module. 

3.6.  Expires: The job of integration testing for a module gets expired. 
3.7.  Extends:  A  group  applies  for  an  extension  in  integration  testing 

for a module. 

3.8.  Approves:  A  project  manager  approves  the  extension  in 

integration testing for a module. 

3.9.  Reports:  A  group  reports  bugs  after  integration  testing  for  a 

module. 

4.1.  Assignd:  A  project  manager  assigns  the  job  of  debugging  a 

module to a group. 

2.9.  Reportu: A group reports bugs after testing a module. 
3.1.  Assigns: A project manager assigns the job of integration testing 

for a module to a group. 

3.2.  Accepts:  A  group  accepts  the  job  of  integration  testing  for  a 

4.2.  Acceptd: A group accepts the job of debugging a module. 
4.3.  Finishd: A group finishes the job of debugging a module. 
4.4.  Rejectd: A group rejects the job of debugging a module. 
4.5.  Withdrawd:  A  group  withdraws  the  acceptance  of  debugging  a 

module. 

module. 

3.3.  Finishs:  A  group  finishes  the  job  of  integration  testing  for  a 

module. 

4.6.  Expired: The job of debugging a module gets expired. 
4.7.  Extendd:  A  group  applies  for  an  extension  in  debugging  a 

3.4.  Rejects:  A  group  rejects  the  job  of  integration  testing  for  a 

module. 

module. 

4.8.  Approved:  A  project  manager  approves  the  extension  in 

3.5.  Withdraws:  A  group  withdraws  the  acceptance  of  integration 

debugging a module. 

testing for a module. 

PHASE 

P1  

 Programming 

P2  

Unit Testing 

P3  

Integration Testing 

P4 

Debugging 

OPERATION 

Expirep 
Extendp 

1.1  Assignp 
1.2  Acceptp 
1.3 
Finishp 
1.4  Rejectp 
1.5  Withdrawp 
1.6 
1.7 
1.8  Approvep 
2.1.  Assignu 
2.2.  Acceptu 
2.3.  Finishu 
2.4.  Rejectu 
2.5.  Withdrawu 
2.6.  Expireu 
2.7.  Extendu 
2.8.  Approveu 
2.9.  Reportu 
3.1.  Assigns 
3.2.  Accepts 
3.3.  Finishs 
3.4.  Rejects 
3.5.  Withdraws 
3.6.  Expires 
3.7.  Extends 
3.8.  Approves 
3.9.  Reports 
4.1.  Assignd 
4.2.  Acceptd 
4.3.  Finishd 
4.4.  Rejectd 
4.5.  Withdrawd 
4.6.  Expired 
4.7.  Extendd 
4.8.  Approved 

Figure 2. Primary operations in distributed software development 

Extended  from  the  WebSD  model,  the  life-cycle  of  a 
module  in  the  distributed  software  development  is 
defined by a state transition diagram shown in Fig. 3. 

In the design of SDot, we note the following: 
 
 

SDot  is  so  flexible  that  it  allows  a  module  in  the 
software  be  developed  and  tested  by  a  group  at 
different locations. 
 

 

 

 

In  SDot,  a  group  in  the  globally  virtual  team  may 
get only the information involved with the group. 
In  SDot,  the  project  manager  has  the  freedom  of 
dynamic  adjustment  in  distributing  the  job  of 
programming,  testing,  or  debugging  a  module  to  a 
group of his/her choice. 
SDot  can  be  easily  applied  to  the  management  of 
practical  projects  with  distributed 
software 
development. 

©2014 Engineering and Technology Publishing

41

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

Automatic Schedule Control for Distributed 
Software Development in Cloud Computing 

Environments 

 

Chung Yung, Shao-Zong Chen, and Jen-Tsung Hsieh 

Department of Computer Science and Information Engineering 

National Dong Hwa University, Hualien, TAIWAN 

Email: {yung@mail, m9721505@ems, 610021068@ems}.ndhu.edu.tw 

 
 
 

in  application  design,  development 

Abstract—This  paper  proposes  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development 
in  cloud  computing 
environments.    Cloud  computing  environments  provide 
more flexibility than conventional computing environments.  
In  particular,  platform  as  a  service  (PaaS)  provides  more 
flexibility 
testing, 
deployment,  hosting,  team  collaboration,  web  service  and 
database  integration,  scalability,  and  versioning. 
  The 
WebSD  model  is  a  new  management  model  of  distributed 
software  development  for  cloud  computing  environments.  
However,  WebSD  does  not 
include  functionality  for 
schedule  control.    We  design  new  operations  and  add  into 
the  WebSD  model  such  that  the  distributed  software 
development  may  be  managed  with  automatic  assistance  in 
schedule  control.    We  call  the  extended  model  as  SDot. 
Inherited from WebSD, SDot also offers a common platform 
for  various  roles  involved  in  the  distributed  software 
development,  and  SDot 
is  also  appropriate  for  the 
management  of  distributed  software  development  in  cloud 
computing  environments.    We  present  the  application  of 
SDot to a practical software project as a case study to show 
the  effectiveness  of  SDot  in  schedule  control  for  the 
management of distributed software development. 
 
Index  Terms—schedule  control,  distributed 
software 
development,  software  development  management,  cloud 
computing environment. 
 

I. 

INTRODUCTION 

Overall speaking, the objective of software engineering 
is  to  guarantee  the  delivery  of  high-quality  software  on 
time  and  within  budget  [1].    In  the  past  decade, 
developing  software  systems  with  globally  distributed 
teams  is  popularly  applied  to  a  lot  software  projects  [2]. 
With  the  development  of  software  technology  and  the 
rapid extension of application areas, the cost and schedule 
of  distributed  software  development  may  get  out  of 
control  easily  if  the  projects  are  not  managed  with 
intensive care [3]. 

Based  on  54  works  of  distributed 

software 
development published from 1998 to 2009, da Silva et al. 
concluded  that  the  strong  evidence  about  the  effect  of 

                                                           

 Manuscript received June 10, 2013; revised August 27, 2013. 

©2014 Engineering and Technology Publishing
doi: 10.12720/jiii.2.1.39-44

39

using  the  best  practices,  models,  and  tools  in  distributed 
software  development  projects  is  still  scarce  in  the 
literature  [4].    The  ultimate  goal  of  distributed  software 
development  is  fully  using  all  the  resources,  including 
computing  devices  and  human  resources,  to  achieve 
flexibility,  quality  and  cost  down.    On  the  other  hand, 
there  exist  several  challenges  in  globally  distributed 
software  development, 
in 
communication, formal change management, planning for 
system  integration,  project  monitoring  across  distributed 
teams,  standard  distributed  development 
tools,  and 
integrated management tools [5]. 

formalization 

such  as 

Cloud computing is not only a term that refers to data, 
processing,  or  experiences  that  reside  somewhere  in  the 
cloud  that  we  call  as  the  internet.  Nowadays,  cloud 
computing reforms the way how companies operate with 
data  and  applications  in  the  processes  of  inventing, 
developing, deploying, scaling, updating, maintaining and 
paying for resources that undergo the changes [6]-[8]. 

A  cloud  computing  environment  can  be  defined  as  a 
computing  environment  that  provides  everything  as  a 
service,  including  infrastructure  as  a  service  (IaaS), 
platform  as  a  service  (PaaS),  and  software  as  a  service 
(SaaS).  The  software  systems  developed 
in  cloud 
computing  environments  suffer  from  the  same  problems 
that  plague  the  conventional  distributed  and  parallel 
software  systems;  they  are  complex  to  design,  develop, 
test,  deploy,  and  manage  [9].  While  various  cloud 
services  are  either  available  or  under  development,  the 
industry  calls  for  a  new  model  of  distributed  software 
development  management  that  is  specialized  for  cloud 
computing environments [6], [10]. 

With such a background, Yung et al. propose WebSD, 
which  is  a  new  management  model  of  distributed 
software  development  management  for  cloud  computing 
environments  [6].    WebSD  contributes  in  the  following 
aspects. 

  WebSD  simplifies  the  conventional  hierarchical 

architecture of distributed software development, 

  WebSD  extends  conventional  models  to  allow 
outsourcing  parts  of  the  software  development  to 
fellow companies, and 

  WebSD  provides  various  views  to  the  distributed 
software  development  for  the  roles  involved, 

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

including  project  managers,  software  developers, 
software 
to 
cooperate in a common and open model. 

testers,  and  software  debuggers, 

However,  WebSD  does  not  include  any  specialized 
functionality  for  schedule  control,  which  motivates  our 
work presented in this paper. 

We  design  new  operations  and  add  into  the  WebSD 
model  such  that  the  distributed  software  development 
may  be  managed  with  automatic  assistance  in  schedule 
control.  We call the extended model as  SDot.  Inherited 
from  WebSD,  SDot  also  offers  a  common  platform  for 
various  roles 
the  distributed  software 
development,  and  SDot  is  also  appropriate  for  the 
management  of  distributed  software  development  in 
cloud  computing  environments. 
the 
application  of  SDot  to  a  practical  software  project  as  a 
case study to show the effectiveness of SDot in schedule 

  We  present 

involved 

in 

control  for  the  management  of  distributed  software 
development. 

This  paper  is  organized  as  follows.  The  next  section 
briefly  describes  the  WebSD  model.  Our  new  SDot 
model is presented in section 3. Application of SDot to a 
practical  case  is  described  in  section  4.  And  at  last  is  a 
brief conclusion. 

II.  THE WEBSD MODEL 

In this section, we briefly describe the WebSD model, 
which  is  a  web-based  management  model  of  distributed 
software development for cloud computing environments 
[6]. 

In the WebSD model, a software project of distributed 
development  is  described  as  a  well-designed  set  of 
modules, which are units of encapsulation. The life-cycle 
for  developing  a  module  in  a  software  system  is  defined 
by the state transition diagram shown in Fig. 1. 

Figure 1. The state transition diagram of the WebSD model 

 

 
As  an  example,  the  state  of  a  module  is  initially  A. 
After it is assigned to a group for programming, the state 
goes  to  B.    Once  the  assigned  group  accepts  the  job  of 
programming,  the  state  goes  to  C.    When  the  group 
reports  the  finish  of  programming,  the  state  goes  to  D. 
Then,  it  is  assigned  for  testing  and  the  state  goes  to  E. 
Once  the  assigned  group  accepts  the  job  of  testing,  the 
state  goes  to  F.    When  the  group  reports  the  finish  of 
testing and no bug is found, the state goes to G.  And then, 
the  project  manager  performs  the  integration  tests.    If  it 
passes  the  integration  tests,  the  state  goes  to  L  and  the 
development of the module is complete. 

Extended  from  the  definition  of  the  life-cycle  of 
developing a module, they define the status of a software 
project using distributed development as follows. 

Definition 

(Status  of  a  software  project  using 

distributed development, P) 

Given  a  module  set  M  of  k  modules  and  a  software 
project  consisting  of  the  k  modules,  the  status  of  the 
project P is defined as 

P = {pi|1 ≤ i ≤ k}, 

using  distributed  development,  we  may  derive  and  keep 
record  of 
software 
development in an official manner. 

the  progress  of  distributed 

III.  AUTOMATIC SCHEDULE CONTROL 

This  section  proposes  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development  for  cloud  computing 
environments.  We call the extended model as SDot. 

The  primary  operations  of  distributed  software 
development  modeled  in  SDot  are  listed  in  Fig.  2.    We 
briefly describe each operation as follows. 
1.1.  Assignp:  A  project  manager  assigns  the  job  of  programming  a 

module to a group. 

1.2.  Acceptp: A group accepts the job of programming a module. 
1.3.  Finishp: A group finishes the job of programming a module. 
1.4.  Rejectp: A group rejects the job of programming a module. 
1.5.  Withdrawp:  A  group  withdraws  the  acceptance  of  programming 

a module. 

1.6.  Expirep: The job of programming a module gets expired. 
1.7.  Extendp:  A  group  applies  for  an  extension  in  programming  a 

1.8.  Approvep:  A  project  manager  approves  the  extension  in 

where each pi is a pair ⟨ mi, si⟩ , mi ∈ M = {m1, ..., mk}, 
and  si  ∈  S  =  {A,  B,  C,  D,  E,  F,  G,  H,  I,  J,  K,  L}.             

module. 

programming a module. 

One  of  the  advantages  of  the  WebSD  model  is  that 
with  the  definition  of  the  status  of  a  software  project 

2.1.  Assignu:  A  project  manager  assigns  the  job  of  testing a  module 

to a group. 

©2014 Engineering and Technology Publishing

40

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

2.2.  Acceptu: A group accepts the job of testing a module. 
2.3.  Finishu: A group finishes the job of testing a module. 
2.4.  Rejectu: A group rejects the job of testing a module. 
2.5.  Withdrawu:  A  group  withdraws  the  acceptance  of  testing  a 

module. 

2.6.  Expireu: The job of testing a module gets expired. 
2.7.  Extendu: A group applies for an extension in testing a module. 
2.8.  Approveu: A project manager approves the extension in testing a 

module. 

3.6.  Expires: The job of integration testing for a module gets expired. 
3.7.  Extends:  A  group  applies  for  an  extension  in  integration  testing 

for a module. 

3.8.  Approves:  A  project  manager  approves  the  extension  in 

integration testing for a module. 

3.9.  Reports:  A  group  reports  bugs  after  integration  testing  for  a 

module. 

4.1.  Assignd:  A  project  manager  assigns  the  job  of  debugging  a 

module to a group. 

2.9.  Reportu: A group reports bugs after testing a module. 
3.1.  Assigns: A project manager assigns the job of integration testing 

for a module to a group. 

3.2.  Accepts:  A  group  accepts  the  job  of  integration  testing  for  a 

4.2.  Acceptd: A group accepts the job of debugging a module. 
4.3.  Finishd: A group finishes the job of debugging a module. 
4.4.  Rejectd: A group rejects the job of debugging a module. 
4.5.  Withdrawd:  A  group  withdraws  the  acceptance  of  debugging  a 

module. 

module. 

3.3.  Finishs:  A  group  finishes  the  job  of  integration  testing  for  a 

module. 

4.6.  Expired: The job of debugging a module gets expired. 
4.7.  Extendd:  A  group  applies  for  an  extension  in  debugging  a 

3.4.  Rejects:  A  group  rejects  the  job  of  integration  testing  for  a 

module. 

module. 

4.8.  Approved:  A  project  manager  approves  the  extension  in 

3.5.  Withdraws:  A  group  withdraws  the  acceptance  of  integration 

debugging a module. 

testing for a module. 

PHASE 

P1  

 Programming 

P2  

Unit Testing 

P3  

Integration Testing 

P4 

Debugging 

OPERATION 

Expirep 
Extendp 

1.1  Assignp 
1.2  Acceptp 
1.3 
Finishp 
1.4  Rejectp 
1.5  Withdrawp 
1.6 
1.7 
1.8  Approvep 
2.1.  Assignu 
2.2.  Acceptu 
2.3.  Finishu 
2.4.  Rejectu 
2.5.  Withdrawu 
2.6.  Expireu 
2.7.  Extendu 
2.8.  Approveu 
2.9.  Reportu 
3.1.  Assigns 
3.2.  Accepts 
3.3.  Finishs 
3.4.  Rejects 
3.5.  Withdraws 
3.6.  Expires 
3.7.  Extends 
3.8.  Approves 
3.9.  Reports 
4.1.  Assignd 
4.2.  Acceptd 
4.3.  Finishd 
4.4.  Rejectd 
4.5.  Withdrawd 
4.6.  Expired 
4.7.  Extendd 
4.8.  Approved 

Figure 2. Primary operations in distributed software development 

Extended  from  the  WebSD  model,  the  life-cycle  of  a 
module  in  the  distributed  software  development  is 
defined by a state transition diagram shown in Fig. 3. 

In the design of SDot, we note the following: 
 
 

SDot  is  so  flexible  that  it  allows  a  module  in  the 
software  be  developed  and  tested  by  a  group  at 
different locations. 
 

 

 

 

In  SDot,  a  group  in  the  globally  virtual  team  may 
get only the information involved with the group. 
In  SDot,  the  project  manager  has  the  freedom  of 
dynamic  adjustment  in  distributing  the  job  of 
programming,  testing,  or  debugging  a  module  to  a 
group of his/her choice. 
SDot  can  be  easily  applied  to  the  management  of 
practical  projects  with  distributed 
software 
development. 

©2014 Engineering and Technology Publishing

41

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

Figure 3. The state transition diagram of the SDot model 

 

IV.  APPLICATION OF SDOT TO A PRACTICAL PROJECT 

For  a  validation,  we  apply  the  SDot  model  to  a 
practical  project  called  ConsMan.   ConsMan  is  a  project 
of  distributed  software  development  for  building  a  web-
based  distributed  information  management  system.    The 
ConsMan  project  was  executed  between  2006  and  2007 
for  an  energy  and  power  company  in  Taiwan  that  our 
second  author  works  with.    Note  that  in  this  case,  the 
SDot model is applied after the project is closed, based on 
the  documentation  kept  during  the  execution  of  the 
project.  While  the  whole  details  of  ConsMan  are 
available,  simplification  and  adaption  are  applied  for  the 
purpose  of  clarity  in  presentation.    In  this  section,  we 
only show the top-level activities in executing ConsMan. 
The  ConsMan  project  with  three  top-level  modules  is 
developed by a virtual team consisting of five groups, of 
which  one  group  is  an  in-house  management  group  (g1: 
TWPCMan),  two  groups  are  outsourced  programming 
groups  of  agents  and  consultants  (g2:  TWAC,  and  g3: 
MLAC),  and  the  other  two  groups  are  off-site  testing 
groups (g4: TWPCN, and g5: TWPCS). 

Here,  we  briefly  describe  the  progress  in  developing 
the top-level modules as follows.    ConsMan has a global 
virtual  team  consisted  of  5  groups  (G  =  {g1,  g2,  g3,  g4, 
g5}), of which g1 is the project management group; g2 and 
g3 are the programming and debugging groups; g4 and g5 
are the testing groups.  The ConsMan project consists of 
3  top-level  modules  (M  =  {m1,  m2,  m3}),  which  are 
developed in a distributed way with the following steps: 
1)  On  day  d1,  g1  performs  Assignp(m1,  g2,  d2), 
Assignp(m2,  g3,  d2),  and  Assignp(m3,  g3,  d2).      g2 
performs  Rejectp(m1).    g3  performs  Acceptp(m2)  and 
Acceptp(m3). 

2)  On  day  d2,  g1  performs  Assignp(m1,  g2,  d3).    g2 
performs  Acceptp(m1).    g3  performs  Withdrawp(m3).  
The system automatically performs Expirep(m2). 

3)  On  day  d3,  g1  performs  Assignp(m2,  g2,  d4)  and 
Assignp(m3,  g3,  d4).    g2  performs  Finishp(m1)  and 
Acceptp(m2).   g3 performs Acceptp(m3). 

4)  On  day  d4,  g1  performs  Assignu(m1,  g5,  d5).    g3 
performs  Finishp(m2)  and  Finishp(m3).    g5  performs 
Acceptu(m1). 

5)  On  day  d5,  g1  performs  Assignu(m2,  g5,  d6)  and 
  g5  performs  Reportu(m1), 

Assignu(m3,  g5,  d6). 
Acceptu(m2), and Rejectu(m3). 

6)  On  day  d6,  g1  performs  Assignd(m1,  g5,  d8)  and 
Assignu(m3,  g4,  d7).    g4  performs  Rejectd(m1)  and 
Acceptu(m3).  g5 performs Extendu(m2, d8). 

7)  On  day  d7,  g1  performs  Assignd(m1,  g3,  d10)  and 
Approveu(m2,  d8).    g3  performs  Acceptd(m1).    g4 
performs Withdrawu(m2). 

8)  On  day  d8,  g1  performs  Assignu(m3,  g5,  d9).    g5 

performs Finishu(m2) and Acceptu(m3). 

9)  On day d9, g5 performs Finishu(m3). 
10)  On day d10, g3 performs Extendd(m1, d12). 
11)  On day d11, g1 performs Approved(m1, d12). 
12)  On day d12, g3 performs Finishd(m1). 
13)  On  day  d13,  g1  performs  Assignu(m1,  g5,  d14).    g5 

performs Acceptu(m1). 

14)  On day d14, g5 performs Finishu(m1). 
15)  On  day  d15,  g1  performs  Assigns(m1,  g4,  d22), 
Assigns(m2,  g4,  d22),  and  Assigns(m3,  g4,  d22).    g4 
performs Accepts(m1), Accepts(m2), and Accepts(m3). 

16)  On day d16, g4 performs Reports(m1). 
17)  On  day  d17,  g1  performs  Assignd(m1,  g3,  d18).    g3 

performs Acceptd(m1). 

18)  On day d18, g3 performs Finishd (m1). 
19)  On  day  d19,  g1  performs  Assignu(m1,  g5,  d20).    g5 

performs Acceptu(m1). 

20)  On day d20, g5 performs Finishu(m1). 
21)  On  day  d21,  g1  performs  Assigns(m1,  g4,  d22).    g4 

performs Accepts(m1). 

22)  On day d22, g4 performs Finishs(m1), Finishs(m2), and 

Finishs(m3). 

As such, the ConsMan project is complete on day d22.  

©2014 Engineering and Technology Publishing

42

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

Automatic Schedule Control for Distributed 
Software Development in Cloud Computing 

Environments 

 

Chung Yung, Shao-Zong Chen, and Jen-Tsung Hsieh 

Department of Computer Science and Information Engineering 

National Dong Hwa University, Hualien, TAIWAN 

Email: {yung@mail, m9721505@ems, 610021068@ems}.ndhu.edu.tw 

 
 
 

in  application  design,  development 

Abstract—This  paper  proposes  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development 
in  cloud  computing 
environments.    Cloud  computing  environments  provide 
more flexibility than conventional computing environments.  
In  particular,  platform  as  a  service  (PaaS)  provides  more 
flexibility 
testing, 
deployment,  hosting,  team  collaboration,  web  service  and 
database  integration,  scalability,  and  versioning. 
  The 
WebSD  model  is  a  new  management  model  of  distributed 
software  development  for  cloud  computing  environments.  
However,  WebSD  does  not 
include  functionality  for 
schedule  control.    We  design  new  operations  and  add  into 
the  WebSD  model  such  that  the  distributed  software 
development  may  be  managed  with  automatic  assistance  in 
schedule  control.    We  call  the  extended  model  as  SDot. 
Inherited from WebSD, SDot also offers a common platform 
for  various  roles  involved  in  the  distributed  software 
development,  and  SDot 
is  also  appropriate  for  the 
management  of  distributed  software  development  in  cloud 
computing  environments.    We  present  the  application  of 
SDot to a practical software project as a case study to show 
the  effectiveness  of  SDot  in  schedule  control  for  the 
management of distributed software development. 
 
Index  Terms—schedule  control,  distributed 
software 
development,  software  development  management,  cloud 
computing environment. 
 

I. 

INTRODUCTION 

Overall speaking, the objective of software engineering 
is  to  guarantee  the  delivery  of  high-quality  software  on 
time  and  within  budget  [1].    In  the  past  decade, 
developing  software  systems  with  globally  distributed 
teams  is  popularly  applied  to  a  lot  software  projects  [2]. 
With  the  development  of  software  technology  and  the 
rapid extension of application areas, the cost and schedule 
of  distributed  software  development  may  get  out  of 
control  easily  if  the  projects  are  not  managed  with 
intensive care [3]. 

Based  on  54  works  of  distributed 

software 
development published from 1998 to 2009, da Silva et al. 
concluded  that  the  strong  evidence  about  the  effect  of 

                                                           

 Manuscript received June 10, 2013; revised August 27, 2013. 

©2014 Engineering and Technology Publishing
doi: 10.12720/jiii.2.1.39-44

39

using  the  best  practices,  models,  and  tools  in  distributed 
software  development  projects  is  still  scarce  in  the 
literature  [4].    The  ultimate  goal  of  distributed  software 
development  is  fully  using  all  the  resources,  including 
computing  devices  and  human  resources,  to  achieve 
flexibility,  quality  and  cost  down.    On  the  other  hand, 
there  exist  several  challenges  in  globally  distributed 
software  development, 
in 
communication, formal change management, planning for 
system  integration,  project  monitoring  across  distributed 
teams,  standard  distributed  development 
tools,  and 
integrated management tools [5]. 

formalization 

such  as 

Cloud computing is not only a term that refers to data, 
processing,  or  experiences  that  reside  somewhere  in  the 
cloud  that  we  call  as  the  internet.  Nowadays,  cloud 
computing reforms the way how companies operate with 
data  and  applications  in  the  processes  of  inventing, 
developing, deploying, scaling, updating, maintaining and 
paying for resources that undergo the changes [6]-[8]. 

A  cloud  computing  environment  can  be  defined  as  a 
computing  environment  that  provides  everything  as  a 
service,  including  infrastructure  as  a  service  (IaaS), 
platform  as  a  service  (PaaS),  and  software  as  a  service 
(SaaS).  The  software  systems  developed 
in  cloud 
computing  environments  suffer  from  the  same  problems 
that  plague  the  conventional  distributed  and  parallel 
software  systems;  they  are  complex  to  design,  develop, 
test,  deploy,  and  manage  [9].  While  various  cloud 
services  are  either  available  or  under  development,  the 
industry  calls  for  a  new  model  of  distributed  software 
development  management  that  is  specialized  for  cloud 
computing environments [6], [10]. 

With such a background, Yung et al. propose WebSD, 
which  is  a  new  management  model  of  distributed 
software  development  management  for  cloud  computing 
environments  [6].    WebSD  contributes  in  the  following 
aspects. 

  WebSD  simplifies  the  conventional  hierarchical 

architecture of distributed software development, 

  WebSD  extends  conventional  models  to  allow 
outsourcing  parts  of  the  software  development  to 
fellow companies, and 

  WebSD  provides  various  views  to  the  distributed 
software  development  for  the  roles  involved, 

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

including  project  managers,  software  developers, 
software 
to 
cooperate in a common and open model. 

testers,  and  software  debuggers, 

However,  WebSD  does  not  include  any  specialized 
functionality  for  schedule  control,  which  motivates  our 
work presented in this paper. 

We  design  new  operations  and  add  into  the  WebSD 
model  such  that  the  distributed  software  development 
may  be  managed  with  automatic  assistance  in  schedule 
control.  We call the extended model as  SDot.  Inherited 
from  WebSD,  SDot  also  offers  a  common  platform  for 
various  roles 
the  distributed  software 
development,  and  SDot  is  also  appropriate  for  the 
management  of  distributed  software  development  in 
cloud  computing  environments. 
the 
application  of  SDot  to  a  practical  software  project  as  a 
case study to show the effectiveness of SDot in schedule 

  We  present 

involved 

in 

control  for  the  management  of  distributed  software 
development. 

This  paper  is  organized  as  follows.  The  next  section 
briefly  describes  the  WebSD  model.  Our  new  SDot 
model is presented in section 3. Application of SDot to a 
practical  case  is  described  in  section  4.  And  at  last  is  a 
brief conclusion. 

II.  THE WEBSD MODEL 

In this section, we briefly describe the WebSD model, 
which  is  a  web-based  management  model  of  distributed 
software development for cloud computing environments 
[6]. 

In the WebSD model, a software project of distributed 
development  is  described  as  a  well-designed  set  of 
modules, which are units of encapsulation. The life-cycle 
for  developing  a  module  in  a  software  system  is  defined 
by the state transition diagram shown in Fig. 1. 

Figure 1. The state transition diagram of the WebSD model 

 

 
As  an  example,  the  state  of  a  module  is  initially  A. 
After it is assigned to a group for programming, the state 
goes  to  B.    Once  the  assigned  group  accepts  the  job  of 
programming,  the  state  goes  to  C.    When  the  group 
reports  the  finish  of  programming,  the  state  goes  to  D. 
Then,  it  is  assigned  for  testing  and  the  state  goes  to  E. 
Once  the  assigned  group  accepts  the  job  of  testing,  the 
state  goes  to  F.    When  the  group  reports  the  finish  of 
testing and no bug is found, the state goes to G.  And then, 
the  project  manager  performs  the  integration  tests.    If  it 
passes  the  integration  tests,  the  state  goes  to  L  and  the 
development of the module is complete. 

Extended  from  the  definition  of  the  life-cycle  of 
developing a module, they define the status of a software 
project using distributed development as follows. 

Definition 

(Status  of  a  software  project  using 

distributed development, P) 

Given  a  module  set  M  of  k  modules  and  a  software 
project  consisting  of  the  k  modules,  the  status  of  the 
project P is defined as 

P = {pi|1 ≤ i ≤ k}, 

using  distributed  development,  we  may  derive  and  keep 
record  of 
software 
development in an official manner. 

the  progress  of  distributed 

III.  AUTOMATIC SCHEDULE CONTROL 

This  section  proposes  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development  for  cloud  computing 
environments.  We call the extended model as SDot. 

The  primary  operations  of  distributed  software 
development  modeled  in  SDot  are  listed  in  Fig.  2.    We 
briefly describe each operation as follows. 
1.1.  Assignp:  A  project  manager  assigns  the  job  of  programming  a 

module to a group. 

1.2.  Acceptp: A group accepts the job of programming a module. 
1.3.  Finishp: A group finishes the job of programming a module. 
1.4.  Rejectp: A group rejects the job of programming a module. 
1.5.  Withdrawp:  A  group  withdraws  the  acceptance  of  programming 

a module. 

1.6.  Expirep: The job of programming a module gets expired. 
1.7.  Extendp:  A  group  applies  for  an  extension  in  programming  a 

1.8.  Approvep:  A  project  manager  approves  the  extension  in 

where each pi is a pair ⟨ mi, si⟩ , mi ∈ M = {m1, ..., mk}, 
and  si  ∈  S  =  {A,  B,  C,  D,  E,  F,  G,  H,  I,  J,  K,  L}.             

module. 

programming a module. 

One  of  the  advantages  of  the  WebSD  model  is  that 
with  the  definition  of  the  status  of  a  software  project 

2.1.  Assignu:  A  project  manager  assigns  the  job  of  testing a  module 

to a group. 

©2014 Engineering and Technology Publishing

40

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

2.2.  Acceptu: A group accepts the job of testing a module. 
2.3.  Finishu: A group finishes the job of testing a module. 
2.4.  Rejectu: A group rejects the job of testing a module. 
2.5.  Withdrawu:  A  group  withdraws  the  acceptance  of  testing  a 

module. 

2.6.  Expireu: The job of testing a module gets expired. 
2.7.  Extendu: A group applies for an extension in testing a module. 
2.8.  Approveu: A project manager approves the extension in testing a 

module. 

3.6.  Expires: The job of integration testing for a module gets expired. 
3.7.  Extends:  A  group  applies  for  an  extension  in  integration  testing 

for a module. 

3.8.  Approves:  A  project  manager  approves  the  extension  in 

integration testing for a module. 

3.9.  Reports:  A  group  reports  bugs  after  integration  testing  for  a 

module. 

4.1.  Assignd:  A  project  manager  assigns  the  job  of  debugging  a 

module to a group. 

2.9.  Reportu: A group reports bugs after testing a module. 
3.1.  Assigns: A project manager assigns the job of integration testing 

for a module to a group. 

3.2.  Accepts:  A  group  accepts  the  job  of  integration  testing  for  a 

4.2.  Acceptd: A group accepts the job of debugging a module. 
4.3.  Finishd: A group finishes the job of debugging a module. 
4.4.  Rejectd: A group rejects the job of debugging a module. 
4.5.  Withdrawd:  A  group  withdraws  the  acceptance  of  debugging  a 

module. 

module. 

3.3.  Finishs:  A  group  finishes  the  job  of  integration  testing  for  a 

module. 

4.6.  Expired: The job of debugging a module gets expired. 
4.7.  Extendd:  A  group  applies  for  an  extension  in  debugging  a 

3.4.  Rejects:  A  group  rejects  the  job  of  integration  testing  for  a 

module. 

module. 

4.8.  Approved:  A  project  manager  approves  the  extension  in 

3.5.  Withdraws:  A  group  withdraws  the  acceptance  of  integration 

debugging a module. 

testing for a module. 

PHASE 

P1  

 Programming 

P2  

Unit Testing 

P3  

Integration Testing 

P4 

Debugging 

OPERATION 

Expirep 
Extendp 

1.1  Assignp 
1.2  Acceptp 
1.3 
Finishp 
1.4  Rejectp 
1.5  Withdrawp 
1.6 
1.7 
1.8  Approvep 
2.1.  Assignu 
2.2.  Acceptu 
2.3.  Finishu 
2.4.  Rejectu 
2.5.  Withdrawu 
2.6.  Expireu 
2.7.  Extendu 
2.8.  Approveu 
2.9.  Reportu 
3.1.  Assigns 
3.2.  Accepts 
3.3.  Finishs 
3.4.  Rejects 
3.5.  Withdraws 
3.6.  Expires 
3.7.  Extends 
3.8.  Approves 
3.9.  Reports 
4.1.  Assignd 
4.2.  Acceptd 
4.3.  Finishd 
4.4.  Rejectd 
4.5.  Withdrawd 
4.6.  Expired 
4.7.  Extendd 
4.8.  Approved 

Figure 2. Primary operations in distributed software development 

Extended  from  the  WebSD  model,  the  life-cycle  of  a 
module  in  the  distributed  software  development  is 
defined by a state transition diagram shown in Fig. 3. 

In the design of SDot, we note the following: 
 
 

SDot  is  so  flexible  that  it  allows  a  module  in  the 
software  be  developed  and  tested  by  a  group  at 
different locations. 
 

 

 

 

In  SDot,  a  group  in  the  globally  virtual  team  may 
get only the information involved with the group. 
In  SDot,  the  project  manager  has  the  freedom  of 
dynamic  adjustment  in  distributing  the  job  of 
programming,  testing,  or  debugging  a  module  to  a 
group of his/her choice. 
SDot  can  be  easily  applied  to  the  management  of 
practical  projects  with  distributed 
software 
development. 

©2014 Engineering and Technology Publishing

41

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

Figure 3. The state transition diagram of the SDot model 

 

IV.  APPLICATION OF SDOT TO A PRACTICAL PROJECT 

For  a  validation,  we  apply  the  SDot  model  to  a 
practical  project  called  ConsMan.   ConsMan  is  a  project 
of  distributed  software  development  for  building  a  web-
based  distributed  information  management  system.    The 
ConsMan  project  was  executed  between  2006  and  2007 
for  an  energy  and  power  company  in  Taiwan  that  our 
second  author  works  with.    Note  that  in  this  case,  the 
SDot model is applied after the project is closed, based on 
the  documentation  kept  during  the  execution  of  the 
project.  While  the  whole  details  of  ConsMan  are 
available,  simplification  and  adaption  are  applied  for  the 
purpose  of  clarity  in  presentation.    In  this  section,  we 
only show the top-level activities in executing ConsMan. 
The  ConsMan  project  with  three  top-level  modules  is 
developed by a virtual team consisting of five groups, of 
which  one  group  is  an  in-house  management  group  (g1: 
TWPCMan),  two  groups  are  outsourced  programming 
groups  of  agents  and  consultants  (g2:  TWAC,  and  g3: 
MLAC),  and  the  other  two  groups  are  off-site  testing 
groups (g4: TWPCN, and g5: TWPCS). 

Here,  we  briefly  describe  the  progress  in  developing 
the top-level modules as follows.    ConsMan has a global 
virtual  team  consisted  of  5  groups  (G  =  {g1,  g2,  g3,  g4, 
g5}), of which g1 is the project management group; g2 and 
g3 are the programming and debugging groups; g4 and g5 
are the testing groups.  The ConsMan project consists of 
3  top-level  modules  (M  =  {m1,  m2,  m3}),  which  are 
developed in a distributed way with the following steps: 
1)  On  day  d1,  g1  performs  Assignp(m1,  g2,  d2), 
Assignp(m2,  g3,  d2),  and  Assignp(m3,  g3,  d2).      g2 
performs  Rejectp(m1).    g3  performs  Acceptp(m2)  and 
Acceptp(m3). 

2)  On  day  d2,  g1  performs  Assignp(m1,  g2,  d3).    g2 
performs  Acceptp(m1).    g3  performs  Withdrawp(m3).  
The system automatically performs Expirep(m2). 

3)  On  day  d3,  g1  performs  Assignp(m2,  g2,  d4)  and 
Assignp(m3,  g3,  d4).    g2  performs  Finishp(m1)  and 
Acceptp(m2).   g3 performs Acceptp(m3). 

4)  On  day  d4,  g1  performs  Assignu(m1,  g5,  d5).    g3 
performs  Finishp(m2)  and  Finishp(m3).    g5  performs 
Acceptu(m1). 

5)  On  day  d5,  g1  performs  Assignu(m2,  g5,  d6)  and 
  g5  performs  Reportu(m1), 

Assignu(m3,  g5,  d6). 
Acceptu(m2), and Rejectu(m3). 

6)  On  day  d6,  g1  performs  Assignd(m1,  g5,  d8)  and 
Assignu(m3,  g4,  d7).    g4  performs  Rejectd(m1)  and 
Acceptu(m3).  g5 performs Extendu(m2, d8). 

7)  On  day  d7,  g1  performs  Assignd(m1,  g3,  d10)  and 
Approveu(m2,  d8).    g3  performs  Acceptd(m1).    g4 
performs Withdrawu(m2). 

8)  On  day  d8,  g1  performs  Assignu(m3,  g5,  d9).    g5 

performs Finishu(m2) and Acceptu(m3). 

9)  On day d9, g5 performs Finishu(m3). 
10)  On day d10, g3 performs Extendd(m1, d12). 
11)  On day d11, g1 performs Approved(m1, d12). 
12)  On day d12, g3 performs Finishd(m1). 
13)  On  day  d13,  g1  performs  Assignu(m1,  g5,  d14).    g5 

performs Acceptu(m1). 

14)  On day d14, g5 performs Finishu(m1). 
15)  On  day  d15,  g1  performs  Assigns(m1,  g4,  d22), 
Assigns(m2,  g4,  d22),  and  Assigns(m3,  g4,  d22).    g4 
performs Accepts(m1), Accepts(m2), and Accepts(m3). 

16)  On day d16, g4 performs Reports(m1). 
17)  On  day  d17,  g1  performs  Assignd(m1,  g3,  d18).    g3 

performs Acceptd(m1). 

18)  On day d18, g3 performs Finishd (m1). 
19)  On  day  d19,  g1  performs  Assignu(m1,  g5,  d20).    g5 

performs Acceptu(m1). 

20)  On day d20, g5 performs Finishu(m1). 
21)  On  day  d21,  g1  performs  Assigns(m1,  g4,  d22).    g4 

performs Accepts(m1). 

22)  On day d22, g4 performs Finishs(m1), Finishs(m2), and 

Finishs(m3). 

As such, the ConsMan project is complete on day d22.  

©2014 Engineering and Technology Publishing

42

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

The complete record of applying the SDot model to the 

top-level modules of ConsMan is shown in Fig. 4. 

Module 

States (d1) 

Operations 

States (d2) 

Operations 

States (d3) 

Operations 

States (d4) 

Operations 

States (d5) 

Operations 

States (d6) 

Operations 

States (d7) 

Operations 

States (d8) 

Operations 

States (d9) 
Operations 
States (d10) 
Operations 
States (d11) 
Operations 
States (d12) 
Operations 
States (d13) 

Operations 

States (d14) 
Operations 
States (d15) 

Operations 

States (d16) 
Operations 
States (d17) 

Operations 

States (d18) 
Operations 
States (d19) 

Operations 

States (d20) 
Operations 
States (d21) 

Operations 

States (d22) 
Operations 
States (final) 

m1 
A 

g1: Assignp(m1, g2, d2) 

g2: Rejectp(m1) 

A 

g1: Assignp(m1, g2, d3) 

g2: Acceptp(m1) 

C 

g2: Finishp(m1) 

E 

g1: Assignu(m1, g5, d5) 

g5: Acceptu(m1) 

G 

g5: Reportu(m1) 

I 

g1: Assignd(m1, g2, d7) 

g4: Rejectd(m1) 

I 

g1: Assignd(m1, g3, d10) 

g3: Acceptd(m1) 

K 

 

K 
 
K 

g3: Extendd(m1, d12) 

L 

g1: Approved(m1, d12) 

K 

g3: Finishd(m1) 

E 

g1: Assignu(m1, g5, d14) 

g5: Acceptu(m1) 

G 

g5: Finishu(m1) 

M 

m2 
A 

m3 
A 

g1: Assignp(m2, g2, d2) 

g3: Acceptp(m2) 

C 

g1: Assignp(m3, g3, d2) 

g3: Acceptp(m3) 

C 

S: Expirep(m2) 

g3: Withdrawp(m3) 

A 

g1: Assignp(m2, g2, d4) 

g2: Acceptp(m2) 

C 

A 

g1: Assignp(m3, g3, d4) 

g3: Acceptp(m3) 

C 

g3: Finishp(m2) 

g3: Finishp(m3) 

E 

g1: Assignu(m2, g5, d6) 

g5: Acceptu(m2) 

G 

g5: Extendu(m2, d8) 

H 

E 

g1: Assignu(m3, g5, d6) 

g5: Rejectu(m3) 

E 

g1: Assignu(m3, g4, d7) 

g4: Acceptu(m3) 

G 

g1: Approveu(m2, d8) 

g4: Withdrawu(m3) 

G 

g5: Finishu(m2) 

M 

 

M 

 

M 

 

M 

 

M 

 

M 

 

M 

E 

g1: Assignu(m3, g5, d9) 

g5: Acceptu(m3) 

G 

g5: Finishu(m3) 

M 

 

M 

 

M 

 

M 

 

M 

 

M 

g1: Assigns(m1, g4, d22) 

g4: Accepts(m1) 

g1: Assigns(m2, g4, d22) 

g4: Accepts(m2) 

g1: Assigns(m3, g4, d22) 

g4: Accepts(m3) 

O 

g4: Reports(m1) 

I 

g1: Assignd(m1, g3, d18) 

g3: Acceptd(m1) 

K 

g3: Finishd(m1) 

E 

g1: Assignu(m1, g5, d20) 

g5: Acceptu(m1) 

G 

g5: Finishu(m1) 

M 

g1: Assigns(m1, g4, d22) 

g4: Accepts(m1) 

O 

g4: Finishs(m1) 

Q 

O 
 
O 

 

O 
 
O 

 

O 
 
O 

 

O 

O 
 
O 

 

O 
 
O 

 

O 
 
O 

 

O 

g4: Finishs(m2) 

Q 

g4: Finishs(m3) 

Q 

Figure 4. Applying the SDot model to keep record of the progress in the ConsMan project 

©2014 Engineering and Technology Publishing

 

43

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

Automatic Schedule Control for Distributed 
Software Development in Cloud Computing 

Environments 

 

Chung Yung, Shao-Zong Chen, and Jen-Tsung Hsieh 

Department of Computer Science and Information Engineering 

National Dong Hwa University, Hualien, TAIWAN 

Email: {yung@mail, m9721505@ems, 610021068@ems}.ndhu.edu.tw 

 
 
 

in  application  design,  development 

Abstract—This  paper  proposes  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development 
in  cloud  computing 
environments.    Cloud  computing  environments  provide 
more flexibility than conventional computing environments.  
In  particular,  platform  as  a  service  (PaaS)  provides  more 
flexibility 
testing, 
deployment,  hosting,  team  collaboration,  web  service  and 
database  integration,  scalability,  and  versioning. 
  The 
WebSD  model  is  a  new  management  model  of  distributed 
software  development  for  cloud  computing  environments.  
However,  WebSD  does  not 
include  functionality  for 
schedule  control.    We  design  new  operations  and  add  into 
the  WebSD  model  such  that  the  distributed  software 
development  may  be  managed  with  automatic  assistance  in 
schedule  control.    We  call  the  extended  model  as  SDot. 
Inherited from WebSD, SDot also offers a common platform 
for  various  roles  involved  in  the  distributed  software 
development,  and  SDot 
is  also  appropriate  for  the 
management  of  distributed  software  development  in  cloud 
computing  environments.    We  present  the  application  of 
SDot to a practical software project as a case study to show 
the  effectiveness  of  SDot  in  schedule  control  for  the 
management of distributed software development. 
 
Index  Terms—schedule  control,  distributed 
software 
development,  software  development  management,  cloud 
computing environment. 
 

I. 

INTRODUCTION 

Overall speaking, the objective of software engineering 
is  to  guarantee  the  delivery  of  high-quality  software  on 
time  and  within  budget  [1].    In  the  past  decade, 
developing  software  systems  with  globally  distributed 
teams  is  popularly  applied  to  a  lot  software  projects  [2]. 
With  the  development  of  software  technology  and  the 
rapid extension of application areas, the cost and schedule 
of  distributed  software  development  may  get  out  of 
control  easily  if  the  projects  are  not  managed  with 
intensive care [3]. 

Based  on  54  works  of  distributed 

software 
development published from 1998 to 2009, da Silva et al. 
concluded  that  the  strong  evidence  about  the  effect  of 

                                                           

 Manuscript received June 10, 2013; revised August 27, 2013. 

©2014 Engineering and Technology Publishing
doi: 10.12720/jiii.2.1.39-44

39

using  the  best  practices,  models,  and  tools  in  distributed 
software  development  projects  is  still  scarce  in  the 
literature  [4].    The  ultimate  goal  of  distributed  software 
development  is  fully  using  all  the  resources,  including 
computing  devices  and  human  resources,  to  achieve 
flexibility,  quality  and  cost  down.    On  the  other  hand, 
there  exist  several  challenges  in  globally  distributed 
software  development, 
in 
communication, formal change management, planning for 
system  integration,  project  monitoring  across  distributed 
teams,  standard  distributed  development 
tools,  and 
integrated management tools [5]. 

formalization 

such  as 

Cloud computing is not only a term that refers to data, 
processing,  or  experiences  that  reside  somewhere  in  the 
cloud  that  we  call  as  the  internet.  Nowadays,  cloud 
computing reforms the way how companies operate with 
data  and  applications  in  the  processes  of  inventing, 
developing, deploying, scaling, updating, maintaining and 
paying for resources that undergo the changes [6]-[8]. 

A  cloud  computing  environment  can  be  defined  as  a 
computing  environment  that  provides  everything  as  a 
service,  including  infrastructure  as  a  service  (IaaS), 
platform  as  a  service  (PaaS),  and  software  as  a  service 
(SaaS).  The  software  systems  developed 
in  cloud 
computing  environments  suffer  from  the  same  problems 
that  plague  the  conventional  distributed  and  parallel 
software  systems;  they  are  complex  to  design,  develop, 
test,  deploy,  and  manage  [9].  While  various  cloud 
services  are  either  available  or  under  development,  the 
industry  calls  for  a  new  model  of  distributed  software 
development  management  that  is  specialized  for  cloud 
computing environments [6], [10]. 

With such a background, Yung et al. propose WebSD, 
which  is  a  new  management  model  of  distributed 
software  development  management  for  cloud  computing 
environments  [6].    WebSD  contributes  in  the  following 
aspects. 

  WebSD  simplifies  the  conventional  hierarchical 

architecture of distributed software development, 

  WebSD  extends  conventional  models  to  allow 
outsourcing  parts  of  the  software  development  to 
fellow companies, and 

  WebSD  provides  various  views  to  the  distributed 
software  development  for  the  roles  involved, 

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

including  project  managers,  software  developers, 
software 
to 
cooperate in a common and open model. 

testers,  and  software  debuggers, 

However,  WebSD  does  not  include  any  specialized 
functionality  for  schedule  control,  which  motivates  our 
work presented in this paper. 

We  design  new  operations  and  add  into  the  WebSD 
model  such  that  the  distributed  software  development 
may  be  managed  with  automatic  assistance  in  schedule 
control.  We call the extended model as  SDot.  Inherited 
from  WebSD,  SDot  also  offers  a  common  platform  for 
various  roles 
the  distributed  software 
development,  and  SDot  is  also  appropriate  for  the 
management  of  distributed  software  development  in 
cloud  computing  environments. 
the 
application  of  SDot  to  a  practical  software  project  as  a 
case study to show the effectiveness of SDot in schedule 

  We  present 

involved 

in 

control  for  the  management  of  distributed  software 
development. 

This  paper  is  organized  as  follows.  The  next  section 
briefly  describes  the  WebSD  model.  Our  new  SDot 
model is presented in section 3. Application of SDot to a 
practical  case  is  described  in  section  4.  And  at  last  is  a 
brief conclusion. 

II.  THE WEBSD MODEL 

In this section, we briefly describe the WebSD model, 
which  is  a  web-based  management  model  of  distributed 
software development for cloud computing environments 
[6]. 

In the WebSD model, a software project of distributed 
development  is  described  as  a  well-designed  set  of 
modules, which are units of encapsulation. The life-cycle 
for  developing  a  module  in  a  software  system  is  defined 
by the state transition diagram shown in Fig. 1. 

Figure 1. The state transition diagram of the WebSD model 

 

 
As  an  example,  the  state  of  a  module  is  initially  A. 
After it is assigned to a group for programming, the state 
goes  to  B.    Once  the  assigned  group  accepts  the  job  of 
programming,  the  state  goes  to  C.    When  the  group 
reports  the  finish  of  programming,  the  state  goes  to  D. 
Then,  it  is  assigned  for  testing  and  the  state  goes  to  E. 
Once  the  assigned  group  accepts  the  job  of  testing,  the 
state  goes  to  F.    When  the  group  reports  the  finish  of 
testing and no bug is found, the state goes to G.  And then, 
the  project  manager  performs  the  integration  tests.    If  it 
passes  the  integration  tests,  the  state  goes  to  L  and  the 
development of the module is complete. 

Extended  from  the  definition  of  the  life-cycle  of 
developing a module, they define the status of a software 
project using distributed development as follows. 

Definition 

(Status  of  a  software  project  using 

distributed development, P) 

Given  a  module  set  M  of  k  modules  and  a  software 
project  consisting  of  the  k  modules,  the  status  of  the 
project P is defined as 

P = {pi|1 ≤ i ≤ k}, 

using  distributed  development,  we  may  derive  and  keep 
record  of 
software 
development in an official manner. 

the  progress  of  distributed 

III.  AUTOMATIC SCHEDULE CONTROL 

This  section  proposes  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development  for  cloud  computing 
environments.  We call the extended model as SDot. 

The  primary  operations  of  distributed  software 
development  modeled  in  SDot  are  listed  in  Fig.  2.    We 
briefly describe each operation as follows. 
1.1.  Assignp:  A  project  manager  assigns  the  job  of  programming  a 

module to a group. 

1.2.  Acceptp: A group accepts the job of programming a module. 
1.3.  Finishp: A group finishes the job of programming a module. 
1.4.  Rejectp: A group rejects the job of programming a module. 
1.5.  Withdrawp:  A  group  withdraws  the  acceptance  of  programming 

a module. 

1.6.  Expirep: The job of programming a module gets expired. 
1.7.  Extendp:  A  group  applies  for  an  extension  in  programming  a 

1.8.  Approvep:  A  project  manager  approves  the  extension  in 

where each pi is a pair ⟨ mi, si⟩ , mi ∈ M = {m1, ..., mk}, 
and  si  ∈  S  =  {A,  B,  C,  D,  E,  F,  G,  H,  I,  J,  K,  L}.             

module. 

programming a module. 

One  of  the  advantages  of  the  WebSD  model  is  that 
with  the  definition  of  the  status  of  a  software  project 

2.1.  Assignu:  A  project  manager  assigns  the  job  of  testing a  module 

to a group. 

©2014 Engineering and Technology Publishing

40

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

2.2.  Acceptu: A group accepts the job of testing a module. 
2.3.  Finishu: A group finishes the job of testing a module. 
2.4.  Rejectu: A group rejects the job of testing a module. 
2.5.  Withdrawu:  A  group  withdraws  the  acceptance  of  testing  a 

module. 

2.6.  Expireu: The job of testing a module gets expired. 
2.7.  Extendu: A group applies for an extension in testing a module. 
2.8.  Approveu: A project manager approves the extension in testing a 

module. 

3.6.  Expires: The job of integration testing for a module gets expired. 
3.7.  Extends:  A  group  applies  for  an  extension  in  integration  testing 

for a module. 

3.8.  Approves:  A  project  manager  approves  the  extension  in 

integration testing for a module. 

3.9.  Reports:  A  group  reports  bugs  after  integration  testing  for  a 

module. 

4.1.  Assignd:  A  project  manager  assigns  the  job  of  debugging  a 

module to a group. 

2.9.  Reportu: A group reports bugs after testing a module. 
3.1.  Assigns: A project manager assigns the job of integration testing 

for a module to a group. 

3.2.  Accepts:  A  group  accepts  the  job  of  integration  testing  for  a 

4.2.  Acceptd: A group accepts the job of debugging a module. 
4.3.  Finishd: A group finishes the job of debugging a module. 
4.4.  Rejectd: A group rejects the job of debugging a module. 
4.5.  Withdrawd:  A  group  withdraws  the  acceptance  of  debugging  a 

module. 

module. 

3.3.  Finishs:  A  group  finishes  the  job  of  integration  testing  for  a 

module. 

4.6.  Expired: The job of debugging a module gets expired. 
4.7.  Extendd:  A  group  applies  for  an  extension  in  debugging  a 

3.4.  Rejects:  A  group  rejects  the  job  of  integration  testing  for  a 

module. 

module. 

4.8.  Approved:  A  project  manager  approves  the  extension  in 

3.5.  Withdraws:  A  group  withdraws  the  acceptance  of  integration 

debugging a module. 

testing for a module. 

PHASE 

P1  

 Programming 

P2  

Unit Testing 

P3  

Integration Testing 

P4 

Debugging 

OPERATION 

Expirep 
Extendp 

1.1  Assignp 
1.2  Acceptp 
1.3 
Finishp 
1.4  Rejectp 
1.5  Withdrawp 
1.6 
1.7 
1.8  Approvep 
2.1.  Assignu 
2.2.  Acceptu 
2.3.  Finishu 
2.4.  Rejectu 
2.5.  Withdrawu 
2.6.  Expireu 
2.7.  Extendu 
2.8.  Approveu 
2.9.  Reportu 
3.1.  Assigns 
3.2.  Accepts 
3.3.  Finishs 
3.4.  Rejects 
3.5.  Withdraws 
3.6.  Expires 
3.7.  Extends 
3.8.  Approves 
3.9.  Reports 
4.1.  Assignd 
4.2.  Acceptd 
4.3.  Finishd 
4.4.  Rejectd 
4.5.  Withdrawd 
4.6.  Expired 
4.7.  Extendd 
4.8.  Approved 

Figure 2. Primary operations in distributed software development 

Extended  from  the  WebSD  model,  the  life-cycle  of  a 
module  in  the  distributed  software  development  is 
defined by a state transition diagram shown in Fig. 3. 

In the design of SDot, we note the following: 
 
 

SDot  is  so  flexible  that  it  allows  a  module  in  the 
software  be  developed  and  tested  by  a  group  at 
different locations. 
 

 

 

 

In  SDot,  a  group  in  the  globally  virtual  team  may 
get only the information involved with the group. 
In  SDot,  the  project  manager  has  the  freedom  of 
dynamic  adjustment  in  distributing  the  job  of 
programming,  testing,  or  debugging  a  module  to  a 
group of his/her choice. 
SDot  can  be  easily  applied  to  the  management  of 
practical  projects  with  distributed 
software 
development. 

©2014 Engineering and Technology Publishing

41

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

Figure 3. The state transition diagram of the SDot model 

 

IV.  APPLICATION OF SDOT TO A PRACTICAL PROJECT 

For  a  validation,  we  apply  the  SDot  model  to  a 
practical  project  called  ConsMan.   ConsMan  is  a  project 
of  distributed  software  development  for  building  a  web-
based  distributed  information  management  system.    The 
ConsMan  project  was  executed  between  2006  and  2007 
for  an  energy  and  power  company  in  Taiwan  that  our 
second  author  works  with.    Note  that  in  this  case,  the 
SDot model is applied after the project is closed, based on 
the  documentation  kept  during  the  execution  of  the 
project.  While  the  whole  details  of  ConsMan  are 
available,  simplification  and  adaption  are  applied  for  the 
purpose  of  clarity  in  presentation.    In  this  section,  we 
only show the top-level activities in executing ConsMan. 
The  ConsMan  project  with  three  top-level  modules  is 
developed by a virtual team consisting of five groups, of 
which  one  group  is  an  in-house  management  group  (g1: 
TWPCMan),  two  groups  are  outsourced  programming 
groups  of  agents  and  consultants  (g2:  TWAC,  and  g3: 
MLAC),  and  the  other  two  groups  are  off-site  testing 
groups (g4: TWPCN, and g5: TWPCS). 

Here,  we  briefly  describe  the  progress  in  developing 
the top-level modules as follows.    ConsMan has a global 
virtual  team  consisted  of  5  groups  (G  =  {g1,  g2,  g3,  g4, 
g5}), of which g1 is the project management group; g2 and 
g3 are the programming and debugging groups; g4 and g5 
are the testing groups.  The ConsMan project consists of 
3  top-level  modules  (M  =  {m1,  m2,  m3}),  which  are 
developed in a distributed way with the following steps: 
1)  On  day  d1,  g1  performs  Assignp(m1,  g2,  d2), 
Assignp(m2,  g3,  d2),  and  Assignp(m3,  g3,  d2).      g2 
performs  Rejectp(m1).    g3  performs  Acceptp(m2)  and 
Acceptp(m3). 

2)  On  day  d2,  g1  performs  Assignp(m1,  g2,  d3).    g2 
performs  Acceptp(m1).    g3  performs  Withdrawp(m3).  
The system automatically performs Expirep(m2). 

3)  On  day  d3,  g1  performs  Assignp(m2,  g2,  d4)  and 
Assignp(m3,  g3,  d4).    g2  performs  Finishp(m1)  and 
Acceptp(m2).   g3 performs Acceptp(m3). 

4)  On  day  d4,  g1  performs  Assignu(m1,  g5,  d5).    g3 
performs  Finishp(m2)  and  Finishp(m3).    g5  performs 
Acceptu(m1). 

5)  On  day  d5,  g1  performs  Assignu(m2,  g5,  d6)  and 
  g5  performs  Reportu(m1), 

Assignu(m3,  g5,  d6). 
Acceptu(m2), and Rejectu(m3). 

6)  On  day  d6,  g1  performs  Assignd(m1,  g5,  d8)  and 
Assignu(m3,  g4,  d7).    g4  performs  Rejectd(m1)  and 
Acceptu(m3).  g5 performs Extendu(m2, d8). 

7)  On  day  d7,  g1  performs  Assignd(m1,  g3,  d10)  and 
Approveu(m2,  d8).    g3  performs  Acceptd(m1).    g4 
performs Withdrawu(m2). 

8)  On  day  d8,  g1  performs  Assignu(m3,  g5,  d9).    g5 

performs Finishu(m2) and Acceptu(m3). 

9)  On day d9, g5 performs Finishu(m3). 
10)  On day d10, g3 performs Extendd(m1, d12). 
11)  On day d11, g1 performs Approved(m1, d12). 
12)  On day d12, g3 performs Finishd(m1). 
13)  On  day  d13,  g1  performs  Assignu(m1,  g5,  d14).    g5 

performs Acceptu(m1). 

14)  On day d14, g5 performs Finishu(m1). 
15)  On  day  d15,  g1  performs  Assigns(m1,  g4,  d22), 
Assigns(m2,  g4,  d22),  and  Assigns(m3,  g4,  d22).    g4 
performs Accepts(m1), Accepts(m2), and Accepts(m3). 

16)  On day d16, g4 performs Reports(m1). 
17)  On  day  d17,  g1  performs  Assignd(m1,  g3,  d18).    g3 

performs Acceptd(m1). 

18)  On day d18, g3 performs Finishd (m1). 
19)  On  day  d19,  g1  performs  Assignu(m1,  g5,  d20).    g5 

performs Acceptu(m1). 

20)  On day d20, g5 performs Finishu(m1). 
21)  On  day  d21,  g1  performs  Assigns(m1,  g4,  d22).    g4 

performs Accepts(m1). 

22)  On day d22, g4 performs Finishs(m1), Finishs(m2), and 

Finishs(m3). 

As such, the ConsMan project is complete on day d22.  

©2014 Engineering and Technology Publishing

42

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

The complete record of applying the SDot model to the 

top-level modules of ConsMan is shown in Fig. 4. 

Module 

States (d1) 

Operations 

States (d2) 

Operations 

States (d3) 

Operations 

States (d4) 

Operations 

States (d5) 

Operations 

States (d6) 

Operations 

States (d7) 

Operations 

States (d8) 

Operations 

States (d9) 
Operations 
States (d10) 
Operations 
States (d11) 
Operations 
States (d12) 
Operations 
States (d13) 

Operations 

States (d14) 
Operations 
States (d15) 

Operations 

States (d16) 
Operations 
States (d17) 

Operations 

States (d18) 
Operations 
States (d19) 

Operations 

States (d20) 
Operations 
States (d21) 

Operations 

States (d22) 
Operations 
States (final) 

m1 
A 

g1: Assignp(m1, g2, d2) 

g2: Rejectp(m1) 

A 

g1: Assignp(m1, g2, d3) 

g2: Acceptp(m1) 

C 

g2: Finishp(m1) 

E 

g1: Assignu(m1, g5, d5) 

g5: Acceptu(m1) 

G 

g5: Reportu(m1) 

I 

g1: Assignd(m1, g2, d7) 

g4: Rejectd(m1) 

I 

g1: Assignd(m1, g3, d10) 

g3: Acceptd(m1) 

K 

 

K 
 
K 

g3: Extendd(m1, d12) 

L 

g1: Approved(m1, d12) 

K 

g3: Finishd(m1) 

E 

g1: Assignu(m1, g5, d14) 

g5: Acceptu(m1) 

G 

g5: Finishu(m1) 

M 

m2 
A 

m3 
A 

g1: Assignp(m2, g2, d2) 

g3: Acceptp(m2) 

C 

g1: Assignp(m3, g3, d2) 

g3: Acceptp(m3) 

C 

S: Expirep(m2) 

g3: Withdrawp(m3) 

A 

g1: Assignp(m2, g2, d4) 

g2: Acceptp(m2) 

C 

A 

g1: Assignp(m3, g3, d4) 

g3: Acceptp(m3) 

C 

g3: Finishp(m2) 

g3: Finishp(m3) 

E 

g1: Assignu(m2, g5, d6) 

g5: Acceptu(m2) 

G 

g5: Extendu(m2, d8) 

H 

E 

g1: Assignu(m3, g5, d6) 

g5: Rejectu(m3) 

E 

g1: Assignu(m3, g4, d7) 

g4: Acceptu(m3) 

G 

g1: Approveu(m2, d8) 

g4: Withdrawu(m3) 

G 

g5: Finishu(m2) 

M 

 

M 

 

M 

 

M 

 

M 

 

M 

 

M 

E 

g1: Assignu(m3, g5, d9) 

g5: Acceptu(m3) 

G 

g5: Finishu(m3) 

M 

 

M 

 

M 

 

M 

 

M 

 

M 

g1: Assigns(m1, g4, d22) 

g4: Accepts(m1) 

g1: Assigns(m2, g4, d22) 

g4: Accepts(m2) 

g1: Assigns(m3, g4, d22) 

g4: Accepts(m3) 

O 

g4: Reports(m1) 

I 

g1: Assignd(m1, g3, d18) 

g3: Acceptd(m1) 

K 

g3: Finishd(m1) 

E 

g1: Assignu(m1, g5, d20) 

g5: Acceptu(m1) 

G 

g5: Finishu(m1) 

M 

g1: Assigns(m1, g4, d22) 

g4: Accepts(m1) 

O 

g4: Finishs(m1) 

Q 

O 
 
O 

 

O 
 
O 

 

O 
 
O 

 

O 

O 
 
O 

 

O 
 
O 

 

O 
 
O 

 

O 

g4: Finishs(m2) 

Q 

g4: Finishs(m3) 

Q 

Figure 4. Applying the SDot model to keep record of the progress in the ConsMan project 

©2014 Engineering and Technology Publishing

 

43

Journal of Industrial and Intelligent Information Vol. 2, No. 1, March 2014

[7]  V.  Matveev,  “Platform  as  a  service–new  opportunities  for 
software development companies,” Master’s thesis, Department of 
Information Technology, Lappeenranta University of Technology, 
Finland, May 2010. 

[8]  Y.  C.  Zhou,  X.  P.  Liu,  X.  N. Wang, L.  Xue,  X.  X.  Liang,  and  S. 
Liang,  “Business process centric platform-as-a-service  model  and 
technologies for cloud enabled industry solutions,” in Proc. Third 
IEEE  International  Conference  on  Cloud  Computing,  July  2010, 
pp. 534–537. 
J.  S.  Rellermeyer,  M.  Duller,  and  G.  Alonso,  “Engineering  the 
cloud  from  software  modules,”  in  Proc.  ICSE  Workshop  on 
Software Engineering Challenges of Cloud Computing, May 2009, 
pp. 32–37. 

[9] 

[10]  K.  A.  Johnston  and  K.  Rosin,  “Global  virtual  teams:  How  to 
manage  them,”  in  Proc.  International  Conference  on  Computer 
and Management, May 2011, pp. 1–4. 

 

Chung  Yung  received  PhD  degree  in  Computer 
Science  from  New  York  University  (USA)  in 
1999  and  BSc  degree  in  Computer  Science  and 
Information  Engineering  from  National  Chiao 
Tung  University  (Taiwan)  in  1988.    He  has  been 
with  the  Department  of  Computer  Science  and 
Information  Engineering  of  National  Dong  Hwa 
University  (Taiwan)  since  2000.    He  was  a  part-
time senior consultant and project manager within 
the  intelligent  digital  content  industry  between  2003  and  2007.    He  is 
currently  leading  Compiler  Technology  and  Application  Laboratory  in 
National Dong Hwa University.  His research interests include semantic 
methods of program analysis, optimizations for cloud software systems, 
compiler supported software engineering, and programming languages. 
 

Shao-Zong  Chen is currently with Taiwan Power 
Company as a senior software engineer since 2002.  
He  is  working  part-time  for  his  master  degree  in 
Computer Science and Information Engineering at 
Compiler and Technology  Application Laboratory 
of  National  Dong  Hwa  University,  Taiwan.    He 
received  BSc  degree  in  Computer  Science  and 
Information 
Tamkang 
University, Taiwan in 1992.  His research interests 
include software project management, program analysis and distributed 
software development in cloud computing environments.  
 
 

Engineering 

from 

Jen-Tsung Hsieh is working for a master degree in 
Computer  Science  and  Information  Engineering  in 
National  Dong  Hwa  University  (Taiwan).    He 
received  BSc  degree  in  Computer  Science  and 
Information  Engineering  from  University  of  Kang 
Ning  (Taiwan)  in  2007.    His  research  interests 
include  distributed  software  development  and 
efficient 
programming 
languages. 

implementation 

of 

V.  CONCLUSION 

In  this  paper,  we  present  an  extension  of  automatic 
schedule  control  to  the  WebSD  management  model  of 
distributed  software  development  for  cloud  computing 
environments.  We call the extended model as SDot.  We 
define  the  life-cycle  of  a  module  in  the  distributed 
software  development  using  a  state  transition  diagram. 
For  validation,  we  include  the  application  of  the  SDot 
model to the ConsMan project. 

We  are  aware  of  that  the  SDot  model  only  provides  a 
simple  and  clear  view  to  the  software  projects  of 
distributed development  for the project managers,  with a 
special  purpose  of  schedule  control.    For  a  sophisticated 
schedule  control  of  software  development,  the  managers 
are  suggested  to  refer  to  various  schedule  control 
techniques for software project management [1], [3]. 

ACKNOWLEDGMENT 

This work is supported in part by the National Science 
Council  under  grand  number  NSC  100-2218-E-259-002-
MY3. 

REFERENCES 

[1]  X. Wang, C. Wu, and L. Ma, “Software project schedule variance 
prediction  using  bayesian  network,”  in  Proc.  IEEE  International 
Conference on Advanced Management Science, vol. 2, July 2010, 
pp. 26–30. 

[2]  A. Piri, “Challenges of globally distributed software development 
analysis  of  problems  related  to  social  processes  and  group 
relations,”  in  Proc.  IEEE  International  Conference  on  Global 
Software Engineering, August 2008, pp. 264–268. 

[4] 

da  Silva,  C. Costa, A.

[3]  Y.  Sun  and  R.  Cui,  “Workload  point  system  based  on  project 
schedule  optimization,”  in  Proc.  International  Conference  on 
Management and Service Science, September 2009, pp. 1–4. 
F. Q. B. 
C. C. Franca,  and  R.  Prikladinicki, 
“Challenges  and  solutions  in  distributed  software  development 
project  management:  a  systematic  literature  review,”  in  Proc.  5th 
IEEE  International  Conference  on  Global  Software  Engineering, 
August 2010, pp. 87–96. 
I.  S.  Wiese  and  E.  H.  M.  Huzita,  “IMART:  An  Interoperability 
model 
software  development 
environments,”  in  Proc.  International  Conference  on  Global 
Software Engineering, October 2006, pp. 255–256. 

for  artifacts  of  distributed 

[5] 

[6]  C.  Yung,  S.-Z.  Chen,  S.-C.  Wu,  J.-T.  Hsieh,  and  K.-J.  Peng,  “A 
Web-based  model  of  distributed 
software  development 
management  for  cloud  computing  environments,”  GSTF  Journal 
of Computing, vol. 2, no. 2, pp. 1–7, June 2012. 

 

 

©2014 Engineering and Technology Publishing

44

