Telecommunications Systems manuscript No.
(will be inserted by the editor)

Model Checking Wireless Sensor Network Security
Protocols: TinySec + LEAP + TinyPK

Llanos Tobarra · Diego Cazorla · Fernando Cuartero · Gregorio D´ıaz ·
Emilia Cambronero

Received: date / Accepted: date

Abstract In this paper, a formal analysis of security
protocols in the ﬁeld of wireless sensor networks is pre-
sented. Three complementary protocols, TinySec, LEAP
and TinyPK, are modelled using the high-level formal
language HLPSL, and veriﬁed using the model checking
tool AVISPA, where two main security properties are
checked: authenticity and conﬁdentiality of messages.
As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In
both cases conﬁdentiality is compromised and an in-
truder may obtain conﬁdential data from a node in the
network. Two solutions to these attacks are proposed
in the paper.

Keywords Wireless sensor · model checking · security
protocols · AVISPA toolbox

1 Introduction

Wireless sensor network have been widely used in many
diﬀerent applications: monitoring building perimeters,
battleﬁeld situation data, human vital signs retrieving,
reports about malfunctions in a system, etc. These ap-
plications highlight the importance of security in wire-
less sensor networks. Thus, security has become a chal-
lenge in wireless sensor due to low capabilities of de-

This work has been supported by the Spanish government with
the project ”Application of Formal Methods to Web Services”,
with reference TIN2006-15578-C02-02, and the JCCM regional
project “Application of formal methods to the design and analysis
of Web Services and e-commerce ” (PAC06-0008-6995 )

Instituto de Investigaci´on en Inform´atica
Universidad de Castilla-La Mancha. Albacete, Spain.
E-mail:
emicp}@dsi.uclm.es

{mtobarra,

dcazorla,

fernando,

gregorio,

vices, in terms of computational power and energy con-
sumption, making it diﬃcult to use traditional security
protocols.

Two main problems related to security protocols
arise. Firstly, the overload that security protocols in-
troduce in messages should be reduced to a minimum.
Every bit the sensor sends consumes energy and, con-
sequently, reduces the life of the device. Secondly, low
computational power implies that special cryptographic
algorithms that require less powerful processors need to
be used. The combination of both problems lead us to a
situation where new approaches or solutions to security
protocols need to be considered. These new approaches
take into account basically two main goals: to reduce
the overhead that protocol imposes to messages, and
to provide reasonable protection while limiting use of
resources.

In order to design a secure network, several aspects
have to be considered [17]: Key establishment and trust
setup, secrecy and authentication, and privacy. Key es-
tablishment can be considered the base of the system;
a secure and eﬃcient key distribution mechanism is
needed for large scale sensor networks. Once every node
has its own keys, these are used to authenticate and en-
crypt (if needed) the messages they exchange. Several
protocols have been proposed in the literature related
to authentication and privacy [14,18], and key distribu-
tion [22,6,10]

In this paper we have focused on three of these pro-
tocols: TinySec [14] in the ﬁeld of authentication and
encryption, and LEAP [22] and TinyPK [21] in the ﬁeld
of key management. TinySec is a fully-implemented link
layer security architecture for wireless sensor networks
included in the oﬃcial TinyOS [13] release. LEAP is
a powerful keying mechanism that supports the estab-
lishment of four types of keys for each sensor node with

Telecommunications Systems manuscript No.
(will be inserted by the editor)

Model Checking Wireless Sensor Network Security
Protocols: TinySec + LEAP + TinyPK

Llanos Tobarra · Diego Cazorla · Fernando Cuartero · Gregorio D´ıaz ·
Emilia Cambronero

Received: date / Accepted: date

Abstract In this paper, a formal analysis of security
protocols in the ﬁeld of wireless sensor networks is pre-
sented. Three complementary protocols, TinySec, LEAP
and TinyPK, are modelled using the high-level formal
language HLPSL, and veriﬁed using the model checking
tool AVISPA, where two main security properties are
checked: authenticity and conﬁdentiality of messages.
As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In
both cases conﬁdentiality is compromised and an in-
truder may obtain conﬁdential data from a node in the
network. Two solutions to these attacks are proposed
in the paper.

Keywords Wireless sensor · model checking · security
protocols · AVISPA toolbox

1 Introduction

Wireless sensor network have been widely used in many
diﬀerent applications: monitoring building perimeters,
battleﬁeld situation data, human vital signs retrieving,
reports about malfunctions in a system, etc. These ap-
plications highlight the importance of security in wire-
less sensor networks. Thus, security has become a chal-
lenge in wireless sensor due to low capabilities of de-

This work has been supported by the Spanish government with
the project ”Application of Formal Methods to Web Services”,
with reference TIN2006-15578-C02-02, and the JCCM regional
project “Application of formal methods to the design and analysis
of Web Services and e-commerce ” (PAC06-0008-6995 )

Instituto de Investigaci´on en Inform´atica
Universidad de Castilla-La Mancha. Albacete, Spain.
E-mail:
emicp}@dsi.uclm.es

{mtobarra,

dcazorla,

fernando,

gregorio,

vices, in terms of computational power and energy con-
sumption, making it diﬃcult to use traditional security
protocols.

Two main problems related to security protocols
arise. Firstly, the overload that security protocols in-
troduce in messages should be reduced to a minimum.
Every bit the sensor sends consumes energy and, con-
sequently, reduces the life of the device. Secondly, low
computational power implies that special cryptographic
algorithms that require less powerful processors need to
be used. The combination of both problems lead us to a
situation where new approaches or solutions to security
protocols need to be considered. These new approaches
take into account basically two main goals: to reduce
the overhead that protocol imposes to messages, and
to provide reasonable protection while limiting use of
resources.

In order to design a secure network, several aspects
have to be considered [17]: Key establishment and trust
setup, secrecy and authentication, and privacy. Key es-
tablishment can be considered the base of the system;
a secure and eﬃcient key distribution mechanism is
needed for large scale sensor networks. Once every node
has its own keys, these are used to authenticate and en-
crypt (if needed) the messages they exchange. Several
protocols have been proposed in the literature related
to authentication and privacy [14,18], and key distribu-
tion [22,6,10]

In this paper we have focused on three of these pro-
tocols: TinySec [14] in the ﬁeld of authentication and
encryption, and LEAP [22] and TinyPK [21] in the ﬁeld
of key management. TinySec is a fully-implemented link
layer security architecture for wireless sensor networks
included in the oﬃcial TinyOS [13] release. LEAP is
a powerful keying mechanism that supports the estab-
lishment of four types of keys for each sensor node with

2

little intervention of the base station. One alternative to
LEAP is TinyPK [21], that is based on public key tech-
nologies adapted to sensor capabilities. A brief overview
of these protocols is given in Section 2.

In line with the development of security protocols,
some techniques have also been developed to model
a system and check its properties. One of the most
promising techniques in this line is model checking.
Model checking [8] is a formal method based technique
for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main
advantages of this technique is that it is automatic and
allows us to see if a system works as expected. In case
the system does not work properly, the model check-
ing tool provides a trace that leads to the source of the
error.

Model checking has become a key point in the design
of concurrent and distributed system because it allows
us to ensure the correctness of a design at the earliest
stage possible. Model checking has two main advan-
tages over two classical techniques such as simulation
and testing: i) we do not need to build a prototype of
the system, and ii) we are able to verify the system
against every single execution trace. The latter is very
important because using simulation or testing we can
only ﬁnd errors, but we cannot ensure that the whole
system behaves as expected (some errors may remain
hidden until the system is in production stage).

Some general purpose model checking tools have
been developed by diﬀerent research groups: Spin, UP-
PAAL, Murφ. These tools allow us to verify not only the
functional properties of a system (e.g. Spin), but also
the performance of a real-time system (e.g. UPPAAL).
Although we can use these general purpose tools in or-
der to verify security protocols, we consider that it is
preferable (and more intuitive) to use a tool devoted to
the veriﬁcation of security protocols. Among these tools
we can ﬁnd Casper/FDR2 toolbox [15] and AVISPA [1].
The use of model checking tools to verify security
protocols has been successful in the past in diﬀerent
areas such as Web Services [19,2,5], or Transport Layer
security protocols [16,20].

In this paper, we present a formal veriﬁcation of
wireless sensor security protocols using AVISPA (Au-
tomated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level
formal language HLPSL [7] for specifying protocols and
their security properties. Once we have speciﬁed the
model of the system, AVISPA translates it into an inter-
mediate format IF. This is the input of several backends
that are integrated into AVISPA framework: SATMC
OFMC, Cl-Atse and TA4SP. Besides, only one model
is speciﬁed although it can be analysed with the four

backends. AVISPA also oﬀers a graphical interface SPAN
[11] that helps in the specifying task.

Security in wireless networks is not an easy task due
to its broadcast nature. An intruder can overhear, inter-
cept messages, inject new messages or modify messages
in transit. This kind of intruder is called Dolev-Yao In-
truder [9]. The intruder implemented in AVISPA is a
Dolev-Yao intruder, which is appropriate to the analy-
sis of wireless security protocols.

The paper is organised as follows. In Section 2 a
brief overview of TinySec, LEAP and TinyPK is given.
Section 3 is devoted to the formal veriﬁcation of Tiny-
Sec, LEAP and TinyPK, where six scenarios have been
considered depending on the key distribution mecha-
nism used. Finally in Section 4 we give our conclusions
and future work.

2 TinySec, LEAP and TinyPK

TinySec [14] is a fully-implemented link layer security
architecture for wireless sensor networks. The design
of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight
design was made taking into account wireless sensor
networks characteristics, mainly limited computation
and communication capabilities, as well as low power
consumption. TinySec is part of the oﬃcial TinyOS [13]
release.

The main goals of TinySec are performance, usabil-
ity and security. Inside the security aspects, three main
goals are considered: access control, message integrity,
and conﬁdentiality. Outside the scope of TinySec is to
avoid replay attacks, which is left to higher layers of the
protocol stack.

TinySec considers two operations with application
layer data: authentication and semantically secure en-
cryption. TinySec authenticates a packet using a mes-
sage authentication code, CBC-MAC [4]. Semantically
secure encryption1 is made using an 8 byte initialisa-
tion vector (IV) and cipher block chaining (CBC) as
encryption scheme [3]. Taking into account both oper-
ations, two kinds of packets can be found: TinySec-AE,
that oﬀers authentication and encryption, and TinySec-
Auth, that oﬀers only authentication. A detailed view
of both kinds of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys
are needed. TinySec does not address the problem of
obtaining those keys; any particular keying mechanism
can be used in conjunction with TinySec. In this paper
we consider Localised Encryption and Authentication

1 Encrypting the same plaintext two times should give two dif-

ferent cipher-texts

Telecommunications Systems manuscript No.
(will be inserted by the editor)

Model Checking Wireless Sensor Network Security
Protocols: TinySec + LEAP + TinyPK

Llanos Tobarra · Diego Cazorla · Fernando Cuartero · Gregorio D´ıaz ·
Emilia Cambronero

Received: date / Accepted: date

Abstract In this paper, a formal analysis of security
protocols in the ﬁeld of wireless sensor networks is pre-
sented. Three complementary protocols, TinySec, LEAP
and TinyPK, are modelled using the high-level formal
language HLPSL, and veriﬁed using the model checking
tool AVISPA, where two main security properties are
checked: authenticity and conﬁdentiality of messages.
As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In
both cases conﬁdentiality is compromised and an in-
truder may obtain conﬁdential data from a node in the
network. Two solutions to these attacks are proposed
in the paper.

Keywords Wireless sensor · model checking · security
protocols · AVISPA toolbox

1 Introduction

Wireless sensor network have been widely used in many
diﬀerent applications: monitoring building perimeters,
battleﬁeld situation data, human vital signs retrieving,
reports about malfunctions in a system, etc. These ap-
plications highlight the importance of security in wire-
less sensor networks. Thus, security has become a chal-
lenge in wireless sensor due to low capabilities of de-

This work has been supported by the Spanish government with
the project ”Application of Formal Methods to Web Services”,
with reference TIN2006-15578-C02-02, and the JCCM regional
project “Application of formal methods to the design and analysis
of Web Services and e-commerce ” (PAC06-0008-6995 )

Instituto de Investigaci´on en Inform´atica
Universidad de Castilla-La Mancha. Albacete, Spain.
E-mail:
emicp}@dsi.uclm.es

{mtobarra,

dcazorla,

fernando,

gregorio,

vices, in terms of computational power and energy con-
sumption, making it diﬃcult to use traditional security
protocols.

Two main problems related to security protocols
arise. Firstly, the overload that security protocols in-
troduce in messages should be reduced to a minimum.
Every bit the sensor sends consumes energy and, con-
sequently, reduces the life of the device. Secondly, low
computational power implies that special cryptographic
algorithms that require less powerful processors need to
be used. The combination of both problems lead us to a
situation where new approaches or solutions to security
protocols need to be considered. These new approaches
take into account basically two main goals: to reduce
the overhead that protocol imposes to messages, and
to provide reasonable protection while limiting use of
resources.

In order to design a secure network, several aspects
have to be considered [17]: Key establishment and trust
setup, secrecy and authentication, and privacy. Key es-
tablishment can be considered the base of the system;
a secure and eﬃcient key distribution mechanism is
needed for large scale sensor networks. Once every node
has its own keys, these are used to authenticate and en-
crypt (if needed) the messages they exchange. Several
protocols have been proposed in the literature related
to authentication and privacy [14,18], and key distribu-
tion [22,6,10]

In this paper we have focused on three of these pro-
tocols: TinySec [14] in the ﬁeld of authentication and
encryption, and LEAP [22] and TinyPK [21] in the ﬁeld
of key management. TinySec is a fully-implemented link
layer security architecture for wireless sensor networks
included in the oﬃcial TinyOS [13] release. LEAP is
a powerful keying mechanism that supports the estab-
lishment of four types of keys for each sensor node with

2

little intervention of the base station. One alternative to
LEAP is TinyPK [21], that is based on public key tech-
nologies adapted to sensor capabilities. A brief overview
of these protocols is given in Section 2.

In line with the development of security protocols,
some techniques have also been developed to model
a system and check its properties. One of the most
promising techniques in this line is model checking.
Model checking [8] is a formal method based technique
for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main
advantages of this technique is that it is automatic and
allows us to see if a system works as expected. In case
the system does not work properly, the model check-
ing tool provides a trace that leads to the source of the
error.

Model checking has become a key point in the design
of concurrent and distributed system because it allows
us to ensure the correctness of a design at the earliest
stage possible. Model checking has two main advan-
tages over two classical techniques such as simulation
and testing: i) we do not need to build a prototype of
the system, and ii) we are able to verify the system
against every single execution trace. The latter is very
important because using simulation or testing we can
only ﬁnd errors, but we cannot ensure that the whole
system behaves as expected (some errors may remain
hidden until the system is in production stage).

Some general purpose model checking tools have
been developed by diﬀerent research groups: Spin, UP-
PAAL, Murφ. These tools allow us to verify not only the
functional properties of a system (e.g. Spin), but also
the performance of a real-time system (e.g. UPPAAL).
Although we can use these general purpose tools in or-
der to verify security protocols, we consider that it is
preferable (and more intuitive) to use a tool devoted to
the veriﬁcation of security protocols. Among these tools
we can ﬁnd Casper/FDR2 toolbox [15] and AVISPA [1].
The use of model checking tools to verify security
protocols has been successful in the past in diﬀerent
areas such as Web Services [19,2,5], or Transport Layer
security protocols [16,20].

In this paper, we present a formal veriﬁcation of
wireless sensor security protocols using AVISPA (Au-
tomated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level
formal language HLPSL [7] for specifying protocols and
their security properties. Once we have speciﬁed the
model of the system, AVISPA translates it into an inter-
mediate format IF. This is the input of several backends
that are integrated into AVISPA framework: SATMC
OFMC, Cl-Atse and TA4SP. Besides, only one model
is speciﬁed although it can be analysed with the four

backends. AVISPA also oﬀers a graphical interface SPAN
[11] that helps in the specifying task.

Security in wireless networks is not an easy task due
to its broadcast nature. An intruder can overhear, inter-
cept messages, inject new messages or modify messages
in transit. This kind of intruder is called Dolev-Yao In-
truder [9]. The intruder implemented in AVISPA is a
Dolev-Yao intruder, which is appropriate to the analy-
sis of wireless security protocols.

The paper is organised as follows. In Section 2 a
brief overview of TinySec, LEAP and TinyPK is given.
Section 3 is devoted to the formal veriﬁcation of Tiny-
Sec, LEAP and TinyPK, where six scenarios have been
considered depending on the key distribution mecha-
nism used. Finally in Section 4 we give our conclusions
and future work.

2 TinySec, LEAP and TinyPK

TinySec [14] is a fully-implemented link layer security
architecture for wireless sensor networks. The design
of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight
design was made taking into account wireless sensor
networks characteristics, mainly limited computation
and communication capabilities, as well as low power
consumption. TinySec is part of the oﬃcial TinyOS [13]
release.

The main goals of TinySec are performance, usabil-
ity and security. Inside the security aspects, three main
goals are considered: access control, message integrity,
and conﬁdentiality. Outside the scope of TinySec is to
avoid replay attacks, which is left to higher layers of the
protocol stack.

TinySec considers two operations with application
layer data: authentication and semantically secure en-
cryption. TinySec authenticates a packet using a mes-
sage authentication code, CBC-MAC [4]. Semantically
secure encryption1 is made using an 8 byte initialisa-
tion vector (IV) and cipher block chaining (CBC) as
encryption scheme [3]. Taking into account both oper-
ations, two kinds of packets can be found: TinySec-AE,
that oﬀers authentication and encryption, and TinySec-
Auth, that oﬀers only authentication. A detailed view
of both kinds of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys
are needed. TinySec does not address the problem of
obtaining those keys; any particular keying mechanism
can be used in conjunction with TinySec. In this paper
we consider Localised Encryption and Authentication

1 Encrypting the same plaintext two times should give two dif-

ferent cipher-texts

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

3

Fig. 1 TinySec packet formats: TinySec-AE and TinySec-Auth

Protocol (LEAP) [22] and TinyPK [21] as the keying
mechanism.

LEAP supports the establishment of four types of
keys for each sensor node: an individual key shared with
the base station, a pairwise key shared with another
sensor node, a cluster key shared with multiple neigh-
boring nodes, and a group key that is shared by all the
nodes in the network. One interesting feature of LEAP
is that it minimises the involvement of the base station.
Fig. 2 shows the four LEAP keying mechanisms.

TinyPK is also focused on supporting conﬁdential-
ity and authentication for wireless sensor networks. In
[21], a protocol is proposed to authenticate a third party
(e.g. another sensor network) by means of sensor motes
and asymmetric keys. It requires a small public key in-
frastructure. First, there should be a Certiﬁcation Au-
thority(CA) in the network, such as a base station,
which is an entity with a pair of public/private keys
trusted by all the network nodes. Each node in the
network knows the public CA before deployment. The
third party of the protocol should have its own pub-
lic/private key pair. The protocol operation is divided
into two parts: the external party authentication and
the node authentication. In the ﬁrst part, the external
party authenticates itself by means of a challenge. Af-
ter this phase, the node and the external party share
the network key and a nonce. In the second phase, the
node and the external party establish a new key pair
by means of Diﬃe-Hellman exchange. Each node has a
static Diﬃe-Hellman key, while the third party gener-
ates a ephemeral Diﬃe-Hellman key. A node credential
is also exchanged in order to authenticate the node.

3 Veriﬁcation of TinySec, LEAP and TinyPK

The combination of TinySec and LEAP, or TinySec
and TinyPK allows us to build a complete solution,
where LEAP or TinyPK are responsible for obtaining
the more convenient shared key at every moment, and
TinySec is responsible of the authentication and en-
cryption of messages exchanged between nodes. Thus,

we have considered six diﬀerent conﬁgurations of Tiny-
Sec, LEAP and TinyPK, depending on the key mecha-
nism used, and the kind and the situation of the nodes
that communicate with each other:

– Case A. Request from the base node to a normal
node using an individual key using messages TinySec-
AE.

– Case B. Request from the base node to a normal
node using an individual key using messages TinySec-
Auth.

– Case C. Communication between immediate neigh-

bouring nodes using a pairwise shared key.

– Case D. Communication between immediate neigh-

bouring nodes using a cluster key.

– Case E. Communication between non immediate neigh-

bouring nodes nodes using a cluster key.

– Case F. Communication between a network node

and third party with asymmetric TinyPK keys.

Throughout this analysis we will consider that be-
fore deployment, a node master key Km has been saved
inside every node in the network. We also adopt the
Dolev-Yao intruder model, where an intruder can over-
hear, intercept, alter, or inject any messages into the
radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3.
In this case a base node (BS) makes a request to a
normal node (Ni) which has an individual (unique) key
that it shares with the base station

The protocol for TinySec-AE packets using AVISPA

syntax is as follows:

1. BS → Ni: IV1.{(IV1 ⊕ Data1)}F (Km.Ni).

{M AC(IV1.Data1)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni).

{M AC(IV2.Data2)}H(Km.Ni)

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-
random functions that allow to calculate the encryption
key and the authentication key taking as parameters

Telecommunications Systems manuscript No.
(will be inserted by the editor)

Model Checking Wireless Sensor Network Security
Protocols: TinySec + LEAP + TinyPK

Llanos Tobarra · Diego Cazorla · Fernando Cuartero · Gregorio D´ıaz ·
Emilia Cambronero

Received: date / Accepted: date

Abstract In this paper, a formal analysis of security
protocols in the ﬁeld of wireless sensor networks is pre-
sented. Three complementary protocols, TinySec, LEAP
and TinyPK, are modelled using the high-level formal
language HLPSL, and veriﬁed using the model checking
tool AVISPA, where two main security properties are
checked: authenticity and conﬁdentiality of messages.
As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In
both cases conﬁdentiality is compromised and an in-
truder may obtain conﬁdential data from a node in the
network. Two solutions to these attacks are proposed
in the paper.

Keywords Wireless sensor · model checking · security
protocols · AVISPA toolbox

1 Introduction

Wireless sensor network have been widely used in many
diﬀerent applications: monitoring building perimeters,
battleﬁeld situation data, human vital signs retrieving,
reports about malfunctions in a system, etc. These ap-
plications highlight the importance of security in wire-
less sensor networks. Thus, security has become a chal-
lenge in wireless sensor due to low capabilities of de-

This work has been supported by the Spanish government with
the project ”Application of Formal Methods to Web Services”,
with reference TIN2006-15578-C02-02, and the JCCM regional
project “Application of formal methods to the design and analysis
of Web Services and e-commerce ” (PAC06-0008-6995 )

Instituto de Investigaci´on en Inform´atica
Universidad de Castilla-La Mancha. Albacete, Spain.
E-mail:
emicp}@dsi.uclm.es

{mtobarra,

dcazorla,

fernando,

gregorio,

vices, in terms of computational power and energy con-
sumption, making it diﬃcult to use traditional security
protocols.

Two main problems related to security protocols
arise. Firstly, the overload that security protocols in-
troduce in messages should be reduced to a minimum.
Every bit the sensor sends consumes energy and, con-
sequently, reduces the life of the device. Secondly, low
computational power implies that special cryptographic
algorithms that require less powerful processors need to
be used. The combination of both problems lead us to a
situation where new approaches or solutions to security
protocols need to be considered. These new approaches
take into account basically two main goals: to reduce
the overhead that protocol imposes to messages, and
to provide reasonable protection while limiting use of
resources.

In order to design a secure network, several aspects
have to be considered [17]: Key establishment and trust
setup, secrecy and authentication, and privacy. Key es-
tablishment can be considered the base of the system;
a secure and eﬃcient key distribution mechanism is
needed for large scale sensor networks. Once every node
has its own keys, these are used to authenticate and en-
crypt (if needed) the messages they exchange. Several
protocols have been proposed in the literature related
to authentication and privacy [14,18], and key distribu-
tion [22,6,10]

In this paper we have focused on three of these pro-
tocols: TinySec [14] in the ﬁeld of authentication and
encryption, and LEAP [22] and TinyPK [21] in the ﬁeld
of key management. TinySec is a fully-implemented link
layer security architecture for wireless sensor networks
included in the oﬃcial TinyOS [13] release. LEAP is
a powerful keying mechanism that supports the estab-
lishment of four types of keys for each sensor node with

2

little intervention of the base station. One alternative to
LEAP is TinyPK [21], that is based on public key tech-
nologies adapted to sensor capabilities. A brief overview
of these protocols is given in Section 2.

In line with the development of security protocols,
some techniques have also been developed to model
a system and check its properties. One of the most
promising techniques in this line is model checking.
Model checking [8] is a formal method based technique
for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main
advantages of this technique is that it is automatic and
allows us to see if a system works as expected. In case
the system does not work properly, the model check-
ing tool provides a trace that leads to the source of the
error.

Model checking has become a key point in the design
of concurrent and distributed system because it allows
us to ensure the correctness of a design at the earliest
stage possible. Model checking has two main advan-
tages over two classical techniques such as simulation
and testing: i) we do not need to build a prototype of
the system, and ii) we are able to verify the system
against every single execution trace. The latter is very
important because using simulation or testing we can
only ﬁnd errors, but we cannot ensure that the whole
system behaves as expected (some errors may remain
hidden until the system is in production stage).

Some general purpose model checking tools have
been developed by diﬀerent research groups: Spin, UP-
PAAL, Murφ. These tools allow us to verify not only the
functional properties of a system (e.g. Spin), but also
the performance of a real-time system (e.g. UPPAAL).
Although we can use these general purpose tools in or-
der to verify security protocols, we consider that it is
preferable (and more intuitive) to use a tool devoted to
the veriﬁcation of security protocols. Among these tools
we can ﬁnd Casper/FDR2 toolbox [15] and AVISPA [1].
The use of model checking tools to verify security
protocols has been successful in the past in diﬀerent
areas such as Web Services [19,2,5], or Transport Layer
security protocols [16,20].

In this paper, we present a formal veriﬁcation of
wireless sensor security protocols using AVISPA (Au-
tomated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level
formal language HLPSL [7] for specifying protocols and
their security properties. Once we have speciﬁed the
model of the system, AVISPA translates it into an inter-
mediate format IF. This is the input of several backends
that are integrated into AVISPA framework: SATMC
OFMC, Cl-Atse and TA4SP. Besides, only one model
is speciﬁed although it can be analysed with the four

backends. AVISPA also oﬀers a graphical interface SPAN
[11] that helps in the specifying task.

Security in wireless networks is not an easy task due
to its broadcast nature. An intruder can overhear, inter-
cept messages, inject new messages or modify messages
in transit. This kind of intruder is called Dolev-Yao In-
truder [9]. The intruder implemented in AVISPA is a
Dolev-Yao intruder, which is appropriate to the analy-
sis of wireless security protocols.

The paper is organised as follows. In Section 2 a
brief overview of TinySec, LEAP and TinyPK is given.
Section 3 is devoted to the formal veriﬁcation of Tiny-
Sec, LEAP and TinyPK, where six scenarios have been
considered depending on the key distribution mecha-
nism used. Finally in Section 4 we give our conclusions
and future work.

2 TinySec, LEAP and TinyPK

TinySec [14] is a fully-implemented link layer security
architecture for wireless sensor networks. The design
of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight
design was made taking into account wireless sensor
networks characteristics, mainly limited computation
and communication capabilities, as well as low power
consumption. TinySec is part of the oﬃcial TinyOS [13]
release.

The main goals of TinySec are performance, usabil-
ity and security. Inside the security aspects, three main
goals are considered: access control, message integrity,
and conﬁdentiality. Outside the scope of TinySec is to
avoid replay attacks, which is left to higher layers of the
protocol stack.

TinySec considers two operations with application
layer data: authentication and semantically secure en-
cryption. TinySec authenticates a packet using a mes-
sage authentication code, CBC-MAC [4]. Semantically
secure encryption1 is made using an 8 byte initialisa-
tion vector (IV) and cipher block chaining (CBC) as
encryption scheme [3]. Taking into account both oper-
ations, two kinds of packets can be found: TinySec-AE,
that oﬀers authentication and encryption, and TinySec-
Auth, that oﬀers only authentication. A detailed view
of both kinds of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys
are needed. TinySec does not address the problem of
obtaining those keys; any particular keying mechanism
can be used in conjunction with TinySec. In this paper
we consider Localised Encryption and Authentication

1 Encrypting the same plaintext two times should give two dif-

ferent cipher-texts

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

3

Fig. 1 TinySec packet formats: TinySec-AE and TinySec-Auth

Protocol (LEAP) [22] and TinyPK [21] as the keying
mechanism.

LEAP supports the establishment of four types of
keys for each sensor node: an individual key shared with
the base station, a pairwise key shared with another
sensor node, a cluster key shared with multiple neigh-
boring nodes, and a group key that is shared by all the
nodes in the network. One interesting feature of LEAP
is that it minimises the involvement of the base station.
Fig. 2 shows the four LEAP keying mechanisms.

TinyPK is also focused on supporting conﬁdential-
ity and authentication for wireless sensor networks. In
[21], a protocol is proposed to authenticate a third party
(e.g. another sensor network) by means of sensor motes
and asymmetric keys. It requires a small public key in-
frastructure. First, there should be a Certiﬁcation Au-
thority(CA) in the network, such as a base station,
which is an entity with a pair of public/private keys
trusted by all the network nodes. Each node in the
network knows the public CA before deployment. The
third party of the protocol should have its own pub-
lic/private key pair. The protocol operation is divided
into two parts: the external party authentication and
the node authentication. In the ﬁrst part, the external
party authenticates itself by means of a challenge. Af-
ter this phase, the node and the external party share
the network key and a nonce. In the second phase, the
node and the external party establish a new key pair
by means of Diﬃe-Hellman exchange. Each node has a
static Diﬃe-Hellman key, while the third party gener-
ates a ephemeral Diﬃe-Hellman key. A node credential
is also exchanged in order to authenticate the node.

3 Veriﬁcation of TinySec, LEAP and TinyPK

The combination of TinySec and LEAP, or TinySec
and TinyPK allows us to build a complete solution,
where LEAP or TinyPK are responsible for obtaining
the more convenient shared key at every moment, and
TinySec is responsible of the authentication and en-
cryption of messages exchanged between nodes. Thus,

we have considered six diﬀerent conﬁgurations of Tiny-
Sec, LEAP and TinyPK, depending on the key mecha-
nism used, and the kind and the situation of the nodes
that communicate with each other:

– Case A. Request from the base node to a normal
node using an individual key using messages TinySec-
AE.

– Case B. Request from the base node to a normal
node using an individual key using messages TinySec-
Auth.

– Case C. Communication between immediate neigh-

bouring nodes using a pairwise shared key.

– Case D. Communication between immediate neigh-

bouring nodes using a cluster key.

– Case E. Communication between non immediate neigh-

bouring nodes nodes using a cluster key.

– Case F. Communication between a network node

and third party with asymmetric TinyPK keys.

Throughout this analysis we will consider that be-
fore deployment, a node master key Km has been saved
inside every node in the network. We also adopt the
Dolev-Yao intruder model, where an intruder can over-
hear, intercept, alter, or inject any messages into the
radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3.
In this case a base node (BS) makes a request to a
normal node (Ni) which has an individual (unique) key
that it shares with the base station

The protocol for TinySec-AE packets using AVISPA

syntax is as follows:

1. BS → Ni: IV1.{(IV1 ⊕ Data1)}F (Km.Ni).

{M AC(IV1.Data1)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni).

{M AC(IV2.Data2)}H(Km.Ni)

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-
random functions that allow to calculate the encryption
key and the authentication key taking as parameters

4

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

K c

Ni

K c

Ni

K c

Ni

N2

N4

N3

KS

NV1

NV2

NV3

K c

Nc

K c

Nc

K c

Nc

NC

Fig. 2 LEAP keying mechanisms

the master key (Km) and the id of the node (Ni). Given
that AVISPA does not oﬀer arithmetic semantics, the
increase of the counter is represented by a function Suc,
such as Suc(0) represents 1, Suc(Suc(0)) represents 2
and so on.

BS

N1

N2

N3

Fig. 3 Sensor network: cases A and B.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node
Ni and the base station (BS) share the same value
for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to
prove that bilateral authentication is achieved by
using the MAC, and the integrity of the message is
guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and
Data2 are secret values shared between Ni and BS,
and they are not known by an intruder or third par-
ties.

The veriﬁcation with AVISPA ﬁnds only the replay
attack shown in Table 1, where IBS represents an in-
truder playing the role of the base station. Nevertheless,
as was said before, TinySec does not manage replay at-
tacks, which are left to higher layers of the protocol
stack. Apart from this attack, the protocol is secure,
even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in
the previous case (see Fig. 3), but we consider TinySec-
Auth messages instead of TinySec-AE messages. The
protocol for TinySec-AE packets using AVISPA syntax
is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1.

{M AC(Ni.AM1.Size1. Data1)}H(Km.Ni)

2. Ni → BS: BS.AM2.Size2.Data2.

{M AC(BS.AM2.Size2. Data2)}H(Km.Ni)

As we mentioned before, TinySec-Auth does not
provide any conﬁdentiality mechanisms. Thus, we can
only analyse the authentication of Data1 and Data2,
i.e., we can prove the bilateral authentication between
BS and Ni, by means of the MAC messages, and also
the integrity of messages. As in the previous case, we
have found a replay attack that we omit

Telecommunications Systems manuscript No.
(will be inserted by the editor)

Model Checking Wireless Sensor Network Security
Protocols: TinySec + LEAP + TinyPK

Llanos Tobarra · Diego Cazorla · Fernando Cuartero · Gregorio D´ıaz ·
Emilia Cambronero

Received: date / Accepted: date

Abstract In this paper, a formal analysis of security
protocols in the ﬁeld of wireless sensor networks is pre-
sented. Three complementary protocols, TinySec, LEAP
and TinyPK, are modelled using the high-level formal
language HLPSL, and veriﬁed using the model checking
tool AVISPA, where two main security properties are
checked: authenticity and conﬁdentiality of messages.
As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In
both cases conﬁdentiality is compromised and an in-
truder may obtain conﬁdential data from a node in the
network. Two solutions to these attacks are proposed
in the paper.

Keywords Wireless sensor · model checking · security
protocols · AVISPA toolbox

1 Introduction

Wireless sensor network have been widely used in many
diﬀerent applications: monitoring building perimeters,
battleﬁeld situation data, human vital signs retrieving,
reports about malfunctions in a system, etc. These ap-
plications highlight the importance of security in wire-
less sensor networks. Thus, security has become a chal-
lenge in wireless sensor due to low capabilities of de-

This work has been supported by the Spanish government with
the project ”Application of Formal Methods to Web Services”,
with reference TIN2006-15578-C02-02, and the JCCM regional
project “Application of formal methods to the design and analysis
of Web Services and e-commerce ” (PAC06-0008-6995 )

Instituto de Investigaci´on en Inform´atica
Universidad de Castilla-La Mancha. Albacete, Spain.
E-mail:
emicp}@dsi.uclm.es

{mtobarra,

dcazorla,

fernando,

gregorio,

vices, in terms of computational power and energy con-
sumption, making it diﬃcult to use traditional security
protocols.

Two main problems related to security protocols
arise. Firstly, the overload that security protocols in-
troduce in messages should be reduced to a minimum.
Every bit the sensor sends consumes energy and, con-
sequently, reduces the life of the device. Secondly, low
computational power implies that special cryptographic
algorithms that require less powerful processors need to
be used. The combination of both problems lead us to a
situation where new approaches or solutions to security
protocols need to be considered. These new approaches
take into account basically two main goals: to reduce
the overhead that protocol imposes to messages, and
to provide reasonable protection while limiting use of
resources.

In order to design a secure network, several aspects
have to be considered [17]: Key establishment and trust
setup, secrecy and authentication, and privacy. Key es-
tablishment can be considered the base of the system;
a secure and eﬃcient key distribution mechanism is
needed for large scale sensor networks. Once every node
has its own keys, these are used to authenticate and en-
crypt (if needed) the messages they exchange. Several
protocols have been proposed in the literature related
to authentication and privacy [14,18], and key distribu-
tion [22,6,10]

In this paper we have focused on three of these pro-
tocols: TinySec [14] in the ﬁeld of authentication and
encryption, and LEAP [22] and TinyPK [21] in the ﬁeld
of key management. TinySec is a fully-implemented link
layer security architecture for wireless sensor networks
included in the oﬃcial TinyOS [13] release. LEAP is
a powerful keying mechanism that supports the estab-
lishment of four types of keys for each sensor node with

2

little intervention of the base station. One alternative to
LEAP is TinyPK [21], that is based on public key tech-
nologies adapted to sensor capabilities. A brief overview
of these protocols is given in Section 2.

In line with the development of security protocols,
some techniques have also been developed to model
a system and check its properties. One of the most
promising techniques in this line is model checking.
Model checking [8] is a formal method based technique
for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main
advantages of this technique is that it is automatic and
allows us to see if a system works as expected. In case
the system does not work properly, the model check-
ing tool provides a trace that leads to the source of the
error.

Model checking has become a key point in the design
of concurrent and distributed system because it allows
us to ensure the correctness of a design at the earliest
stage possible. Model checking has two main advan-
tages over two classical techniques such as simulation
and testing: i) we do not need to build a prototype of
the system, and ii) we are able to verify the system
against every single execution trace. The latter is very
important because using simulation or testing we can
only ﬁnd errors, but we cannot ensure that the whole
system behaves as expected (some errors may remain
hidden until the system is in production stage).

Some general purpose model checking tools have
been developed by diﬀerent research groups: Spin, UP-
PAAL, Murφ. These tools allow us to verify not only the
functional properties of a system (e.g. Spin), but also
the performance of a real-time system (e.g. UPPAAL).
Although we can use these general purpose tools in or-
der to verify security protocols, we consider that it is
preferable (and more intuitive) to use a tool devoted to
the veriﬁcation of security protocols. Among these tools
we can ﬁnd Casper/FDR2 toolbox [15] and AVISPA [1].
The use of model checking tools to verify security
protocols has been successful in the past in diﬀerent
areas such as Web Services [19,2,5], or Transport Layer
security protocols [16,20].

In this paper, we present a formal veriﬁcation of
wireless sensor security protocols using AVISPA (Au-
tomated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level
formal language HLPSL [7] for specifying protocols and
their security properties. Once we have speciﬁed the
model of the system, AVISPA translates it into an inter-
mediate format IF. This is the input of several backends
that are integrated into AVISPA framework: SATMC
OFMC, Cl-Atse and TA4SP. Besides, only one model
is speciﬁed although it can be analysed with the four

backends. AVISPA also oﬀers a graphical interface SPAN
[11] that helps in the specifying task.

Security in wireless networks is not an easy task due
to its broadcast nature. An intruder can overhear, inter-
cept messages, inject new messages or modify messages
in transit. This kind of intruder is called Dolev-Yao In-
truder [9]. The intruder implemented in AVISPA is a
Dolev-Yao intruder, which is appropriate to the analy-
sis of wireless security protocols.

The paper is organised as follows. In Section 2 a
brief overview of TinySec, LEAP and TinyPK is given.
Section 3 is devoted to the formal veriﬁcation of Tiny-
Sec, LEAP and TinyPK, where six scenarios have been
considered depending on the key distribution mecha-
nism used. Finally in Section 4 we give our conclusions
and future work.

2 TinySec, LEAP and TinyPK

TinySec [14] is a fully-implemented link layer security
architecture for wireless sensor networks. The design
of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight
design was made taking into account wireless sensor
networks characteristics, mainly limited computation
and communication capabilities, as well as low power
consumption. TinySec is part of the oﬃcial TinyOS [13]
release.

The main goals of TinySec are performance, usabil-
ity and security. Inside the security aspects, three main
goals are considered: access control, message integrity,
and conﬁdentiality. Outside the scope of TinySec is to
avoid replay attacks, which is left to higher layers of the
protocol stack.

TinySec considers two operations with application
layer data: authentication and semantically secure en-
cryption. TinySec authenticates a packet using a mes-
sage authentication code, CBC-MAC [4]. Semantically
secure encryption1 is made using an 8 byte initialisa-
tion vector (IV) and cipher block chaining (CBC) as
encryption scheme [3]. Taking into account both oper-
ations, two kinds of packets can be found: TinySec-AE,
that oﬀers authentication and encryption, and TinySec-
Auth, that oﬀers only authentication. A detailed view
of both kinds of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys
are needed. TinySec does not address the problem of
obtaining those keys; any particular keying mechanism
can be used in conjunction with TinySec. In this paper
we consider Localised Encryption and Authentication

1 Encrypting the same plaintext two times should give two dif-

ferent cipher-texts

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

3

Fig. 1 TinySec packet formats: TinySec-AE and TinySec-Auth

Protocol (LEAP) [22] and TinyPK [21] as the keying
mechanism.

LEAP supports the establishment of four types of
keys for each sensor node: an individual key shared with
the base station, a pairwise key shared with another
sensor node, a cluster key shared with multiple neigh-
boring nodes, and a group key that is shared by all the
nodes in the network. One interesting feature of LEAP
is that it minimises the involvement of the base station.
Fig. 2 shows the four LEAP keying mechanisms.

TinyPK is also focused on supporting conﬁdential-
ity and authentication for wireless sensor networks. In
[21], a protocol is proposed to authenticate a third party
(e.g. another sensor network) by means of sensor motes
and asymmetric keys. It requires a small public key in-
frastructure. First, there should be a Certiﬁcation Au-
thority(CA) in the network, such as a base station,
which is an entity with a pair of public/private keys
trusted by all the network nodes. Each node in the
network knows the public CA before deployment. The
third party of the protocol should have its own pub-
lic/private key pair. The protocol operation is divided
into two parts: the external party authentication and
the node authentication. In the ﬁrst part, the external
party authenticates itself by means of a challenge. Af-
ter this phase, the node and the external party share
the network key and a nonce. In the second phase, the
node and the external party establish a new key pair
by means of Diﬃe-Hellman exchange. Each node has a
static Diﬃe-Hellman key, while the third party gener-
ates a ephemeral Diﬃe-Hellman key. A node credential
is also exchanged in order to authenticate the node.

3 Veriﬁcation of TinySec, LEAP and TinyPK

The combination of TinySec and LEAP, or TinySec
and TinyPK allows us to build a complete solution,
where LEAP or TinyPK are responsible for obtaining
the more convenient shared key at every moment, and
TinySec is responsible of the authentication and en-
cryption of messages exchanged between nodes. Thus,

we have considered six diﬀerent conﬁgurations of Tiny-
Sec, LEAP and TinyPK, depending on the key mecha-
nism used, and the kind and the situation of the nodes
that communicate with each other:

– Case A. Request from the base node to a normal
node using an individual key using messages TinySec-
AE.

– Case B. Request from the base node to a normal
node using an individual key using messages TinySec-
Auth.

– Case C. Communication between immediate neigh-

bouring nodes using a pairwise shared key.

– Case D. Communication between immediate neigh-

bouring nodes using a cluster key.

– Case E. Communication between non immediate neigh-

bouring nodes nodes using a cluster key.

– Case F. Communication between a network node

and third party with asymmetric TinyPK keys.

Throughout this analysis we will consider that be-
fore deployment, a node master key Km has been saved
inside every node in the network. We also adopt the
Dolev-Yao intruder model, where an intruder can over-
hear, intercept, alter, or inject any messages into the
radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3.
In this case a base node (BS) makes a request to a
normal node (Ni) which has an individual (unique) key
that it shares with the base station

The protocol for TinySec-AE packets using AVISPA

syntax is as follows:

1. BS → Ni: IV1.{(IV1 ⊕ Data1)}F (Km.Ni).

{M AC(IV1.Data1)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni).

{M AC(IV2.Data2)}H(Km.Ni)

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-
random functions that allow to calculate the encryption
key and the authentication key taking as parameters

4

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

K c

Ni

K c

Ni

K c

Ni

N2

N4

N3

KS

NV1

NV2

NV3

K c

Nc

K c

Nc

K c

Nc

NC

Fig. 2 LEAP keying mechanisms

the master key (Km) and the id of the node (Ni). Given
that AVISPA does not oﬀer arithmetic semantics, the
increase of the counter is represented by a function Suc,
such as Suc(0) represents 1, Suc(Suc(0)) represents 2
and so on.

BS

N1

N2

N3

Fig. 3 Sensor network: cases A and B.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node
Ni and the base station (BS) share the same value
for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to
prove that bilateral authentication is achieved by
using the MAC, and the integrity of the message is
guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and
Data2 are secret values shared between Ni and BS,
and they are not known by an intruder or third par-
ties.

The veriﬁcation with AVISPA ﬁnds only the replay
attack shown in Table 1, where IBS represents an in-
truder playing the role of the base station. Nevertheless,
as was said before, TinySec does not manage replay at-
tacks, which are left to higher layers of the protocol
stack. Apart from this attack, the protocol is secure,
even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in
the previous case (see Fig. 3), but we consider TinySec-
Auth messages instead of TinySec-AE messages. The
protocol for TinySec-AE packets using AVISPA syntax
is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1.

{M AC(Ni.AM1.Size1. Data1)}H(Km.Ni)

2. Ni → BS: BS.AM2.Size2.Data2.

{M AC(BS.AM2.Size2. Data2)}H(Km.Ni)

As we mentioned before, TinySec-Auth does not
provide any conﬁdentiality mechanisms. Thus, we can
only analyse the authentication of Data1 and Data2,
i.e., we can prove the bilateral authentication between
BS and Ni, by means of the MAC messages, and also
the integrity of messages. As in the previous case, we
have found a replay attack that we omit

5

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km .N1). {M AC(IV1.Data1)}H(Km .N1)

where IV1 = N1.AM1.Size1.BS.0

2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km .N1). {M AC(IV2.Data2)}H(Km .N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km .N1). {M AC(IV1.Data1)}H(Km .N1)

where IV1 = N1.AM1.Size1.BS.0

2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km .N1). {M AC(IV3.Data3)}H(Km .N1)

where IV3 = BS.AM3.Size3.N1.Suc(0)

Table 1 Case A. Replay attack

Case C. In this case a node (N1) shares a pairwise key
with each of its immediate neighbours (N2 and N3).
The network conﬁguration is shown in Fig. 4.

N1

N3

N2

Fig. 4 Sensor network: cases C and D

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1 and
B represents one of its neighbours (N2 or N3):

1. A → B : A, N onceA
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}K ′

AB

where K ′
4. B → A : IV2.{(IV2

AB = H(H(Km.B).A)

⊕ DataB)}KAB .

{M AC(IV2.DataB)}K ′

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

The properties we have to analyse are the following:

– Authentication of N onceA, DataA and DataB. i.e.,
nodes A and B share the same value for N onceA,
DataA and DataB and both execute the same ses-
sion of the protocol.

– Conﬁdentiality of DataB, i.e., DataB is a secret
value shared between A and B, and remains un-
known to an intruder or third parties.

In this case AVISPA ﬁnds a man-in-the-middle at-
tack (see Table 2), where IA represents the intruder
playing the role of node A, IB2 represents the intruder
playing the role of node B, B1 represents node B com-
municating with the intruder, and B2 represents node
B communicating with A:

First the intruder, playing the role of A, starts the
protocol with B (denoted B1), and sends a false nonce,
which is answered by B (B1). Then, A starts a session
with B (B2) but this message is intercepted by the in-
truder (IB2 ) which modiﬁes the message and sends to
B (B2) the identity of a false node Nx and the nonce of
A. Node B (B2) sends the answer of the last message to
A, and A responds with a request of data (Data2) to B
(B2). Again, the request is intercepted by the intruder
who redirects the message to B (B1). At this moment,
B (B1) thinks that it has received a correct request from
A, and then it sends DataB to the intruder playing the
role of A (IA)

Finally we can conclude that B1 has exchanged in-
formation (Data2) with the intruder, and B2 thinks
that it has talked to a node Nx that does not exist. A
solution to this attack consists in authenticate not only
the answer from B in message 2 but also the message
1 sent from A. The modiﬁed version of the protocol is:

1. A → B : A.N onceA.

M AC(A.N onceA)H(Km,A)

2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}K ′

AB

where K ′
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB .

AB = H(H(Km.B).A)

{M AC(IV2.DataB)}K ′

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

Case D. Sensor network conﬁguration is shown in Fig. 4.
In this case a node (N1) shares a cluster key with each
of its immediate neighbours (N2 and N3).

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1, B rep-
resents one of its neighbours (N2 or N3), and Kc is the
cluster key:

Telecommunications Systems manuscript No.
(will be inserted by the editor)

Model Checking Wireless Sensor Network Security
Protocols: TinySec + LEAP + TinyPK

Llanos Tobarra · Diego Cazorla · Fernando Cuartero · Gregorio D´ıaz ·
Emilia Cambronero

Received: date / Accepted: date

Abstract In this paper, a formal analysis of security
protocols in the ﬁeld of wireless sensor networks is pre-
sented. Three complementary protocols, TinySec, LEAP
and TinyPK, are modelled using the high-level formal
language HLPSL, and veriﬁed using the model checking
tool AVISPA, where two main security properties are
checked: authenticity and conﬁdentiality of messages.
As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In
both cases conﬁdentiality is compromised and an in-
truder may obtain conﬁdential data from a node in the
network. Two solutions to these attacks are proposed
in the paper.

Keywords Wireless sensor · model checking · security
protocols · AVISPA toolbox

1 Introduction

Wireless sensor network have been widely used in many
diﬀerent applications: monitoring building perimeters,
battleﬁeld situation data, human vital signs retrieving,
reports about malfunctions in a system, etc. These ap-
plications highlight the importance of security in wire-
less sensor networks. Thus, security has become a chal-
lenge in wireless sensor due to low capabilities of de-

This work has been supported by the Spanish government with
the project ”Application of Formal Methods to Web Services”,
with reference TIN2006-15578-C02-02, and the JCCM regional
project “Application of formal methods to the design and analysis
of Web Services and e-commerce ” (PAC06-0008-6995 )

Instituto de Investigaci´on en Inform´atica
Universidad de Castilla-La Mancha. Albacete, Spain.
E-mail:
emicp}@dsi.uclm.es

{mtobarra,

dcazorla,

fernando,

gregorio,

vices, in terms of computational power and energy con-
sumption, making it diﬃcult to use traditional security
protocols.

Two main problems related to security protocols
arise. Firstly, the overload that security protocols in-
troduce in messages should be reduced to a minimum.
Every bit the sensor sends consumes energy and, con-
sequently, reduces the life of the device. Secondly, low
computational power implies that special cryptographic
algorithms that require less powerful processors need to
be used. The combination of both problems lead us to a
situation where new approaches or solutions to security
protocols need to be considered. These new approaches
take into account basically two main goals: to reduce
the overhead that protocol imposes to messages, and
to provide reasonable protection while limiting use of
resources.

In order to design a secure network, several aspects
have to be considered [17]: Key establishment and trust
setup, secrecy and authentication, and privacy. Key es-
tablishment can be considered the base of the system;
a secure and eﬃcient key distribution mechanism is
needed for large scale sensor networks. Once every node
has its own keys, these are used to authenticate and en-
crypt (if needed) the messages they exchange. Several
protocols have been proposed in the literature related
to authentication and privacy [14,18], and key distribu-
tion [22,6,10]

In this paper we have focused on three of these pro-
tocols: TinySec [14] in the ﬁeld of authentication and
encryption, and LEAP [22] and TinyPK [21] in the ﬁeld
of key management. TinySec is a fully-implemented link
layer security architecture for wireless sensor networks
included in the oﬃcial TinyOS [13] release. LEAP is
a powerful keying mechanism that supports the estab-
lishment of four types of keys for each sensor node with

2

little intervention of the base station. One alternative to
LEAP is TinyPK [21], that is based on public key tech-
nologies adapted to sensor capabilities. A brief overview
of these protocols is given in Section 2.

In line with the development of security protocols,
some techniques have also been developed to model
a system and check its properties. One of the most
promising techniques in this line is model checking.
Model checking [8] is a formal method based technique
for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main
advantages of this technique is that it is automatic and
allows us to see if a system works as expected. In case
the system does not work properly, the model check-
ing tool provides a trace that leads to the source of the
error.

Model checking has become a key point in the design
of concurrent and distributed system because it allows
us to ensure the correctness of a design at the earliest
stage possible. Model checking has two main advan-
tages over two classical techniques such as simulation
and testing: i) we do not need to build a prototype of
the system, and ii) we are able to verify the system
against every single execution trace. The latter is very
important because using simulation or testing we can
only ﬁnd errors, but we cannot ensure that the whole
system behaves as expected (some errors may remain
hidden until the system is in production stage).

Some general purpose model checking tools have
been developed by diﬀerent research groups: Spin, UP-
PAAL, Murφ. These tools allow us to verify not only the
functional properties of a system (e.g. Spin), but also
the performance of a real-time system (e.g. UPPAAL).
Although we can use these general purpose tools in or-
der to verify security protocols, we consider that it is
preferable (and more intuitive) to use a tool devoted to
the veriﬁcation of security protocols. Among these tools
we can ﬁnd Casper/FDR2 toolbox [15] and AVISPA [1].
The use of model checking tools to verify security
protocols has been successful in the past in diﬀerent
areas such as Web Services [19,2,5], or Transport Layer
security protocols [16,20].

In this paper, we present a formal veriﬁcation of
wireless sensor security protocols using AVISPA (Au-
tomated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level
formal language HLPSL [7] for specifying protocols and
their security properties. Once we have speciﬁed the
model of the system, AVISPA translates it into an inter-
mediate format IF. This is the input of several backends
that are integrated into AVISPA framework: SATMC
OFMC, Cl-Atse and TA4SP. Besides, only one model
is speciﬁed although it can be analysed with the four

backends. AVISPA also oﬀers a graphical interface SPAN
[11] that helps in the specifying task.

Security in wireless networks is not an easy task due
to its broadcast nature. An intruder can overhear, inter-
cept messages, inject new messages or modify messages
in transit. This kind of intruder is called Dolev-Yao In-
truder [9]. The intruder implemented in AVISPA is a
Dolev-Yao intruder, which is appropriate to the analy-
sis of wireless security protocols.

The paper is organised as follows. In Section 2 a
brief overview of TinySec, LEAP and TinyPK is given.
Section 3 is devoted to the formal veriﬁcation of Tiny-
Sec, LEAP and TinyPK, where six scenarios have been
considered depending on the key distribution mecha-
nism used. Finally in Section 4 we give our conclusions
and future work.

2 TinySec, LEAP and TinyPK

TinySec [14] is a fully-implemented link layer security
architecture for wireless sensor networks. The design
of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight
design was made taking into account wireless sensor
networks characteristics, mainly limited computation
and communication capabilities, as well as low power
consumption. TinySec is part of the oﬃcial TinyOS [13]
release.

The main goals of TinySec are performance, usabil-
ity and security. Inside the security aspects, three main
goals are considered: access control, message integrity,
and conﬁdentiality. Outside the scope of TinySec is to
avoid replay attacks, which is left to higher layers of the
protocol stack.

TinySec considers two operations with application
layer data: authentication and semantically secure en-
cryption. TinySec authenticates a packet using a mes-
sage authentication code, CBC-MAC [4]. Semantically
secure encryption1 is made using an 8 byte initialisa-
tion vector (IV) and cipher block chaining (CBC) as
encryption scheme [3]. Taking into account both oper-
ations, two kinds of packets can be found: TinySec-AE,
that oﬀers authentication and encryption, and TinySec-
Auth, that oﬀers only authentication. A detailed view
of both kinds of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys
are needed. TinySec does not address the problem of
obtaining those keys; any particular keying mechanism
can be used in conjunction with TinySec. In this paper
we consider Localised Encryption and Authentication

1 Encrypting the same plaintext two times should give two dif-

ferent cipher-texts

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

3

Fig. 1 TinySec packet formats: TinySec-AE and TinySec-Auth

Protocol (LEAP) [22] and TinyPK [21] as the keying
mechanism.

LEAP supports the establishment of four types of
keys for each sensor node: an individual key shared with
the base station, a pairwise key shared with another
sensor node, a cluster key shared with multiple neigh-
boring nodes, and a group key that is shared by all the
nodes in the network. One interesting feature of LEAP
is that it minimises the involvement of the base station.
Fig. 2 shows the four LEAP keying mechanisms.

TinyPK is also focused on supporting conﬁdential-
ity and authentication for wireless sensor networks. In
[21], a protocol is proposed to authenticate a third party
(e.g. another sensor network) by means of sensor motes
and asymmetric keys. It requires a small public key in-
frastructure. First, there should be a Certiﬁcation Au-
thority(CA) in the network, such as a base station,
which is an entity with a pair of public/private keys
trusted by all the network nodes. Each node in the
network knows the public CA before deployment. The
third party of the protocol should have its own pub-
lic/private key pair. The protocol operation is divided
into two parts: the external party authentication and
the node authentication. In the ﬁrst part, the external
party authenticates itself by means of a challenge. Af-
ter this phase, the node and the external party share
the network key and a nonce. In the second phase, the
node and the external party establish a new key pair
by means of Diﬃe-Hellman exchange. Each node has a
static Diﬃe-Hellman key, while the third party gener-
ates a ephemeral Diﬃe-Hellman key. A node credential
is also exchanged in order to authenticate the node.

3 Veriﬁcation of TinySec, LEAP and TinyPK

The combination of TinySec and LEAP, or TinySec
and TinyPK allows us to build a complete solution,
where LEAP or TinyPK are responsible for obtaining
the more convenient shared key at every moment, and
TinySec is responsible of the authentication and en-
cryption of messages exchanged between nodes. Thus,

we have considered six diﬀerent conﬁgurations of Tiny-
Sec, LEAP and TinyPK, depending on the key mecha-
nism used, and the kind and the situation of the nodes
that communicate with each other:

– Case A. Request from the base node to a normal
node using an individual key using messages TinySec-
AE.

– Case B. Request from the base node to a normal
node using an individual key using messages TinySec-
Auth.

– Case C. Communication between immediate neigh-

bouring nodes using a pairwise shared key.

– Case D. Communication between immediate neigh-

bouring nodes using a cluster key.

– Case E. Communication between non immediate neigh-

bouring nodes nodes using a cluster key.

– Case F. Communication between a network node

and third party with asymmetric TinyPK keys.

Throughout this analysis we will consider that be-
fore deployment, a node master key Km has been saved
inside every node in the network. We also adopt the
Dolev-Yao intruder model, where an intruder can over-
hear, intercept, alter, or inject any messages into the
radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3.
In this case a base node (BS) makes a request to a
normal node (Ni) which has an individual (unique) key
that it shares with the base station

The protocol for TinySec-AE packets using AVISPA

syntax is as follows:

1. BS → Ni: IV1.{(IV1 ⊕ Data1)}F (Km.Ni).

{M AC(IV1.Data1)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni).

{M AC(IV2.Data2)}H(Km.Ni)

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-
random functions that allow to calculate the encryption
key and the authentication key taking as parameters

4

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

K c

Ni

K c

Ni

K c

Ni

N2

N4

N3

KS

NV1

NV2

NV3

K c

Nc

K c

Nc

K c

Nc

NC

Fig. 2 LEAP keying mechanisms

the master key (Km) and the id of the node (Ni). Given
that AVISPA does not oﬀer arithmetic semantics, the
increase of the counter is represented by a function Suc,
such as Suc(0) represents 1, Suc(Suc(0)) represents 2
and so on.

BS

N1

N2

N3

Fig. 3 Sensor network: cases A and B.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node
Ni and the base station (BS) share the same value
for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to
prove that bilateral authentication is achieved by
using the MAC, and the integrity of the message is
guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and
Data2 are secret values shared between Ni and BS,
and they are not known by an intruder or third par-
ties.

The veriﬁcation with AVISPA ﬁnds only the replay
attack shown in Table 1, where IBS represents an in-
truder playing the role of the base station. Nevertheless,
as was said before, TinySec does not manage replay at-
tacks, which are left to higher layers of the protocol
stack. Apart from this attack, the protocol is secure,
even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in
the previous case (see Fig. 3), but we consider TinySec-
Auth messages instead of TinySec-AE messages. The
protocol for TinySec-AE packets using AVISPA syntax
is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1.

{M AC(Ni.AM1.Size1. Data1)}H(Km.Ni)

2. Ni → BS: BS.AM2.Size2.Data2.

{M AC(BS.AM2.Size2. Data2)}H(Km.Ni)

As we mentioned before, TinySec-Auth does not
provide any conﬁdentiality mechanisms. Thus, we can
only analyse the authentication of Data1 and Data2,
i.e., we can prove the bilateral authentication between
BS and Ni, by means of the MAC messages, and also
the integrity of messages. As in the previous case, we
have found a replay attack that we omit

5

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km .N1). {M AC(IV1.Data1)}H(Km .N1)

where IV1 = N1.AM1.Size1.BS.0

2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km .N1). {M AC(IV2.Data2)}H(Km .N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km .N1). {M AC(IV1.Data1)}H(Km .N1)

where IV1 = N1.AM1.Size1.BS.0

2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km .N1). {M AC(IV3.Data3)}H(Km .N1)

where IV3 = BS.AM3.Size3.N1.Suc(0)

Table 1 Case A. Replay attack

Case C. In this case a node (N1) shares a pairwise key
with each of its immediate neighbours (N2 and N3).
The network conﬁguration is shown in Fig. 4.

N1

N3

N2

Fig. 4 Sensor network: cases C and D

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1 and
B represents one of its neighbours (N2 or N3):

1. A → B : A, N onceA
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}K ′

AB

where K ′
4. B → A : IV2.{(IV2

AB = H(H(Km.B).A)

⊕ DataB)}KAB .

{M AC(IV2.DataB)}K ′

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

The properties we have to analyse are the following:

– Authentication of N onceA, DataA and DataB. i.e.,
nodes A and B share the same value for N onceA,
DataA and DataB and both execute the same ses-
sion of the protocol.

– Conﬁdentiality of DataB, i.e., DataB is a secret
value shared between A and B, and remains un-
known to an intruder or third parties.

In this case AVISPA ﬁnds a man-in-the-middle at-
tack (see Table 2), where IA represents the intruder
playing the role of node A, IB2 represents the intruder
playing the role of node B, B1 represents node B com-
municating with the intruder, and B2 represents node
B communicating with A:

First the intruder, playing the role of A, starts the
protocol with B (denoted B1), and sends a false nonce,
which is answered by B (B1). Then, A starts a session
with B (B2) but this message is intercepted by the in-
truder (IB2 ) which modiﬁes the message and sends to
B (B2) the identity of a false node Nx and the nonce of
A. Node B (B2) sends the answer of the last message to
A, and A responds with a request of data (Data2) to B
(B2). Again, the request is intercepted by the intruder
who redirects the message to B (B1). At this moment,
B (B1) thinks that it has received a correct request from
A, and then it sends DataB to the intruder playing the
role of A (IA)

Finally we can conclude that B1 has exchanged in-
formation (Data2) with the intruder, and B2 thinks
that it has talked to a node Nx that does not exist. A
solution to this attack consists in authenticate not only
the answer from B in message 2 but also the message
1 sent from A. The modiﬁed version of the protocol is:

1. A → B : A.N onceA.

M AC(A.N onceA)H(Km,A)

2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}K ′

AB

where K ′
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB .

AB = H(H(Km.B).A)

{M AC(IV2.DataB)}K ′

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

Case D. Sensor network conﬁguration is shown in Fig. 4.
In this case a node (N1) shares a cluster key with each
of its immediate neighbours (N2 and N3).

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1, B rep-
resents one of its neighbours (N2 or N3), and Kc is the
cluster key:

6

1. IA → B1 : A, N onceI

2. B1 → IA : B.{M AC(N onceI .B)}H(Km .B)

1. A → IB2 : A, N onceA

2. IA → B2 : Nx.N onceA

2. B2 → A : B.{M AC(N onceA.B)}H(Km .B)

3. A → IB2 : B.AM1.Size1.DataA. {M AC(B.AM1.Size1.DataA)}K ′

AB

3. IA → B1 : B.AM1.Size1.DataA. {M AC(B.AM1.Size1.DataA)}K ′

AB

4. B1 → IA : A.AM2.Size2.B.Counter. {(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K ′

AB

Table 2 Case C. Man-in-the-middle attack

1. A → B : B.AM1.Size1.A.Counter.

{(IV1
{M AC(IV1.Kc)}K ′

⊕

AB

Kc)}KAB .

where IV1 = B.AM1.Size1.A.Counter,
KAB = F (F (Km.B).A) and
K ′

AB = H(H(Km.B).A)

2. B → A : BS.AM2.Size2.done.

{M AC(BS.AM2.Size2.done)}H(Kc)

3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}H(Kc)

4. B → A : IV2.{(IV2 ⊕ DataB)}F (Kc).

{M AC(IV2.DataB)}H(Kc)

where IV2 = A.AM2.Size2.B.Suc(Counter)

The properties we have to analyse are the following:

– Authentication of Kc, DataA and DataB. i.e., nodes
A and B share the same value for Kc, DataA and
DataB and both execute the same session of the
protocol.

– Conﬁdentiality of DataB and Kc, i.e., DataB and
Kc are secret values shared between A and B, and
they remain unknown to an intruder or third par-
ties.

After analysing the protocol with AVISPA, an inter-
esting attack based on types was found (see Table 3).
In this attack the intruder intercepts the message sent
from B to A in step 2. In step 3, the intruder sends the
intercepted message back to B as if were a true request
from A to B. B takes the message as a request an mis-
understands the label done as it was DataA. In step 4,
B sends DataB to the intruder.

This is a type ﬂaw attack, i.e., type checking has not
been done and a constant label has been interpreted as a
variable data. One solution to this attack has been pro-
posed by Heather et al. in [12] which basically consists
of tagging each ﬁeld with information about its type,
although this solution could not be adequate in wire-
less sensor networks because it adds some extra bits of
information into each message. In real implementations

of the protocol, programmers should take into account
this type ﬂaw attack and do type checking in order to
avoid a possible attack. In any case, this kind of attack
can be a problem because network bandwidth could be
saturated and there is a consumption of resources in
the node.

Case E. Sensor network conﬁguration is shown in Fig. 5.
In this case a node (e.g. N1) shares a cluster key with
non immediate neighbouring nodes (e.g. N4 and N5).

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1, B rep-
resents a non neighbour node (N4 or N5), Ni represents
a neighbour node (N2 and N3):

Q. A → Ni : A, B
R. Ni → A : A.AM1.Size1.Ni.

{M AC(A.AM1.Size1.Ni)}K ′

ANi

1 . A → Ni : IV2.F (SKi, 0).

{(IV2 ⊕ SKi)}KANi
{M AC(IV2.SKi.F (SKi, 0))}K ′

.

ANi
where IV2 = Ni.AM2.Size2.A.Counter

2 . Ni → B : IV3.F (SKi, 0).

{(IV3 ⊕ SKi)}KNiB .
{M AC(IV3.SKi.F (SKi, 0))}K ′

Ni B

where IV3 = B.AM3.Size3.Ni.Counter
When B has every SKi
D. B → A : A.AM4.Size4.done.

{M AC(A.AM4.Size4.done)}Sk

where Sk = Sk1 ⊕ . . . ⊕ Skn

AVISPA only ﬁnds a replay attack, that we do not
consider. Apart from this attack, the protocol is secure.

Case F. In this case, a third party EP establishes an
authenticated communication channel with a sensor net-
work. The ﬁrst three messages are intended to authen-
ticate the third party to the node, while the three last
messages are for authenticating the sensor mote with
the third party.

Telecommunications Systems manuscript No.
(will be inserted by the editor)

Model Checking Wireless Sensor Network Security
Protocols: TinySec + LEAP + TinyPK

Llanos Tobarra · Diego Cazorla · Fernando Cuartero · Gregorio D´ıaz ·
Emilia Cambronero

Received: date / Accepted: date

Abstract In this paper, a formal analysis of security
protocols in the ﬁeld of wireless sensor networks is pre-
sented. Three complementary protocols, TinySec, LEAP
and TinyPK, are modelled using the high-level formal
language HLPSL, and veriﬁed using the model checking
tool AVISPA, where two main security properties are
checked: authenticity and conﬁdentiality of messages.
As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In
both cases conﬁdentiality is compromised and an in-
truder may obtain conﬁdential data from a node in the
network. Two solutions to these attacks are proposed
in the paper.

Keywords Wireless sensor · model checking · security
protocols · AVISPA toolbox

1 Introduction

Wireless sensor network have been widely used in many
diﬀerent applications: monitoring building perimeters,
battleﬁeld situation data, human vital signs retrieving,
reports about malfunctions in a system, etc. These ap-
plications highlight the importance of security in wire-
less sensor networks. Thus, security has become a chal-
lenge in wireless sensor due to low capabilities of de-

This work has been supported by the Spanish government with
the project ”Application of Formal Methods to Web Services”,
with reference TIN2006-15578-C02-02, and the JCCM regional
project “Application of formal methods to the design and analysis
of Web Services and e-commerce ” (PAC06-0008-6995 )

Instituto de Investigaci´on en Inform´atica
Universidad de Castilla-La Mancha. Albacete, Spain.
E-mail:
emicp}@dsi.uclm.es

{mtobarra,

dcazorla,

fernando,

gregorio,

vices, in terms of computational power and energy con-
sumption, making it diﬃcult to use traditional security
protocols.

Two main problems related to security protocols
arise. Firstly, the overload that security protocols in-
troduce in messages should be reduced to a minimum.
Every bit the sensor sends consumes energy and, con-
sequently, reduces the life of the device. Secondly, low
computational power implies that special cryptographic
algorithms that require less powerful processors need to
be used. The combination of both problems lead us to a
situation where new approaches or solutions to security
protocols need to be considered. These new approaches
take into account basically two main goals: to reduce
the overhead that protocol imposes to messages, and
to provide reasonable protection while limiting use of
resources.

In order to design a secure network, several aspects
have to be considered [17]: Key establishment and trust
setup, secrecy and authentication, and privacy. Key es-
tablishment can be considered the base of the system;
a secure and eﬃcient key distribution mechanism is
needed for large scale sensor networks. Once every node
has its own keys, these are used to authenticate and en-
crypt (if needed) the messages they exchange. Several
protocols have been proposed in the literature related
to authentication and privacy [14,18], and key distribu-
tion [22,6,10]

In this paper we have focused on three of these pro-
tocols: TinySec [14] in the ﬁeld of authentication and
encryption, and LEAP [22] and TinyPK [21] in the ﬁeld
of key management. TinySec is a fully-implemented link
layer security architecture for wireless sensor networks
included in the oﬃcial TinyOS [13] release. LEAP is
a powerful keying mechanism that supports the estab-
lishment of four types of keys for each sensor node with

2

little intervention of the base station. One alternative to
LEAP is TinyPK [21], that is based on public key tech-
nologies adapted to sensor capabilities. A brief overview
of these protocols is given in Section 2.

In line with the development of security protocols,
some techniques have also been developed to model
a system and check its properties. One of the most
promising techniques in this line is model checking.
Model checking [8] is a formal method based technique
for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main
advantages of this technique is that it is automatic and
allows us to see if a system works as expected. In case
the system does not work properly, the model check-
ing tool provides a trace that leads to the source of the
error.

Model checking has become a key point in the design
of concurrent and distributed system because it allows
us to ensure the correctness of a design at the earliest
stage possible. Model checking has two main advan-
tages over two classical techniques such as simulation
and testing: i) we do not need to build a prototype of
the system, and ii) we are able to verify the system
against every single execution trace. The latter is very
important because using simulation or testing we can
only ﬁnd errors, but we cannot ensure that the whole
system behaves as expected (some errors may remain
hidden until the system is in production stage).

Some general purpose model checking tools have
been developed by diﬀerent research groups: Spin, UP-
PAAL, Murφ. These tools allow us to verify not only the
functional properties of a system (e.g. Spin), but also
the performance of a real-time system (e.g. UPPAAL).
Although we can use these general purpose tools in or-
der to verify security protocols, we consider that it is
preferable (and more intuitive) to use a tool devoted to
the veriﬁcation of security protocols. Among these tools
we can ﬁnd Casper/FDR2 toolbox [15] and AVISPA [1].
The use of model checking tools to verify security
protocols has been successful in the past in diﬀerent
areas such as Web Services [19,2,5], or Transport Layer
security protocols [16,20].

In this paper, we present a formal veriﬁcation of
wireless sensor security protocols using AVISPA (Au-
tomated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level
formal language HLPSL [7] for specifying protocols and
their security properties. Once we have speciﬁed the
model of the system, AVISPA translates it into an inter-
mediate format IF. This is the input of several backends
that are integrated into AVISPA framework: SATMC
OFMC, Cl-Atse and TA4SP. Besides, only one model
is speciﬁed although it can be analysed with the four

backends. AVISPA also oﬀers a graphical interface SPAN
[11] that helps in the specifying task.

Security in wireless networks is not an easy task due
to its broadcast nature. An intruder can overhear, inter-
cept messages, inject new messages or modify messages
in transit. This kind of intruder is called Dolev-Yao In-
truder [9]. The intruder implemented in AVISPA is a
Dolev-Yao intruder, which is appropriate to the analy-
sis of wireless security protocols.

The paper is organised as follows. In Section 2 a
brief overview of TinySec, LEAP and TinyPK is given.
Section 3 is devoted to the formal veriﬁcation of Tiny-
Sec, LEAP and TinyPK, where six scenarios have been
considered depending on the key distribution mecha-
nism used. Finally in Section 4 we give our conclusions
and future work.

2 TinySec, LEAP and TinyPK

TinySec [14] is a fully-implemented link layer security
architecture for wireless sensor networks. The design
of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight
design was made taking into account wireless sensor
networks characteristics, mainly limited computation
and communication capabilities, as well as low power
consumption. TinySec is part of the oﬃcial TinyOS [13]
release.

The main goals of TinySec are performance, usabil-
ity and security. Inside the security aspects, three main
goals are considered: access control, message integrity,
and conﬁdentiality. Outside the scope of TinySec is to
avoid replay attacks, which is left to higher layers of the
protocol stack.

TinySec considers two operations with application
layer data: authentication and semantically secure en-
cryption. TinySec authenticates a packet using a mes-
sage authentication code, CBC-MAC [4]. Semantically
secure encryption1 is made using an 8 byte initialisa-
tion vector (IV) and cipher block chaining (CBC) as
encryption scheme [3]. Taking into account both oper-
ations, two kinds of packets can be found: TinySec-AE,
that oﬀers authentication and encryption, and TinySec-
Auth, that oﬀers only authentication. A detailed view
of both kinds of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys
are needed. TinySec does not address the problem of
obtaining those keys; any particular keying mechanism
can be used in conjunction with TinySec. In this paper
we consider Localised Encryption and Authentication

1 Encrypting the same plaintext two times should give two dif-

ferent cipher-texts

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

3

Fig. 1 TinySec packet formats: TinySec-AE and TinySec-Auth

Protocol (LEAP) [22] and TinyPK [21] as the keying
mechanism.

LEAP supports the establishment of four types of
keys for each sensor node: an individual key shared with
the base station, a pairwise key shared with another
sensor node, a cluster key shared with multiple neigh-
boring nodes, and a group key that is shared by all the
nodes in the network. One interesting feature of LEAP
is that it minimises the involvement of the base station.
Fig. 2 shows the four LEAP keying mechanisms.

TinyPK is also focused on supporting conﬁdential-
ity and authentication for wireless sensor networks. In
[21], a protocol is proposed to authenticate a third party
(e.g. another sensor network) by means of sensor motes
and asymmetric keys. It requires a small public key in-
frastructure. First, there should be a Certiﬁcation Au-
thority(CA) in the network, such as a base station,
which is an entity with a pair of public/private keys
trusted by all the network nodes. Each node in the
network knows the public CA before deployment. The
third party of the protocol should have its own pub-
lic/private key pair. The protocol operation is divided
into two parts: the external party authentication and
the node authentication. In the ﬁrst part, the external
party authenticates itself by means of a challenge. Af-
ter this phase, the node and the external party share
the network key and a nonce. In the second phase, the
node and the external party establish a new key pair
by means of Diﬃe-Hellman exchange. Each node has a
static Diﬃe-Hellman key, while the third party gener-
ates a ephemeral Diﬃe-Hellman key. A node credential
is also exchanged in order to authenticate the node.

3 Veriﬁcation of TinySec, LEAP and TinyPK

The combination of TinySec and LEAP, or TinySec
and TinyPK allows us to build a complete solution,
where LEAP or TinyPK are responsible for obtaining
the more convenient shared key at every moment, and
TinySec is responsible of the authentication and en-
cryption of messages exchanged between nodes. Thus,

we have considered six diﬀerent conﬁgurations of Tiny-
Sec, LEAP and TinyPK, depending on the key mecha-
nism used, and the kind and the situation of the nodes
that communicate with each other:

– Case A. Request from the base node to a normal
node using an individual key using messages TinySec-
AE.

– Case B. Request from the base node to a normal
node using an individual key using messages TinySec-
Auth.

– Case C. Communication between immediate neigh-

bouring nodes using a pairwise shared key.

– Case D. Communication between immediate neigh-

bouring nodes using a cluster key.

– Case E. Communication between non immediate neigh-

bouring nodes nodes using a cluster key.

– Case F. Communication between a network node

and third party with asymmetric TinyPK keys.

Throughout this analysis we will consider that be-
fore deployment, a node master key Km has been saved
inside every node in the network. We also adopt the
Dolev-Yao intruder model, where an intruder can over-
hear, intercept, alter, or inject any messages into the
radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3.
In this case a base node (BS) makes a request to a
normal node (Ni) which has an individual (unique) key
that it shares with the base station

The protocol for TinySec-AE packets using AVISPA

syntax is as follows:

1. BS → Ni: IV1.{(IV1 ⊕ Data1)}F (Km.Ni).

{M AC(IV1.Data1)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni).

{M AC(IV2.Data2)}H(Km.Ni)

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-
random functions that allow to calculate the encryption
key and the authentication key taking as parameters

4

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

K c

Ni

K c

Ni

K c

Ni

N2

N4

N3

KS

NV1

NV2

NV3

K c

Nc

K c

Nc

K c

Nc

NC

Fig. 2 LEAP keying mechanisms

the master key (Km) and the id of the node (Ni). Given
that AVISPA does not oﬀer arithmetic semantics, the
increase of the counter is represented by a function Suc,
such as Suc(0) represents 1, Suc(Suc(0)) represents 2
and so on.

BS

N1

N2

N3

Fig. 3 Sensor network: cases A and B.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node
Ni and the base station (BS) share the same value
for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to
prove that bilateral authentication is achieved by
using the MAC, and the integrity of the message is
guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and
Data2 are secret values shared between Ni and BS,
and they are not known by an intruder or third par-
ties.

The veriﬁcation with AVISPA ﬁnds only the replay
attack shown in Table 1, where IBS represents an in-
truder playing the role of the base station. Nevertheless,
as was said before, TinySec does not manage replay at-
tacks, which are left to higher layers of the protocol
stack. Apart from this attack, the protocol is secure,
even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in
the previous case (see Fig. 3), but we consider TinySec-
Auth messages instead of TinySec-AE messages. The
protocol for TinySec-AE packets using AVISPA syntax
is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1.

{M AC(Ni.AM1.Size1. Data1)}H(Km.Ni)

2. Ni → BS: BS.AM2.Size2.Data2.

{M AC(BS.AM2.Size2. Data2)}H(Km.Ni)

As we mentioned before, TinySec-Auth does not
provide any conﬁdentiality mechanisms. Thus, we can
only analyse the authentication of Data1 and Data2,
i.e., we can prove the bilateral authentication between
BS and Ni, by means of the MAC messages, and also
the integrity of messages. As in the previous case, we
have found a replay attack that we omit

5

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km .N1). {M AC(IV1.Data1)}H(Km .N1)

where IV1 = N1.AM1.Size1.BS.0

2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km .N1). {M AC(IV2.Data2)}H(Km .N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km .N1). {M AC(IV1.Data1)}H(Km .N1)

where IV1 = N1.AM1.Size1.BS.0

2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km .N1). {M AC(IV3.Data3)}H(Km .N1)

where IV3 = BS.AM3.Size3.N1.Suc(0)

Table 1 Case A. Replay attack

Case C. In this case a node (N1) shares a pairwise key
with each of its immediate neighbours (N2 and N3).
The network conﬁguration is shown in Fig. 4.

N1

N3

N2

Fig. 4 Sensor network: cases C and D

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1 and
B represents one of its neighbours (N2 or N3):

1. A → B : A, N onceA
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}K ′

AB

where K ′
4. B → A : IV2.{(IV2

AB = H(H(Km.B).A)

⊕ DataB)}KAB .

{M AC(IV2.DataB)}K ′

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

The properties we have to analyse are the following:

– Authentication of N onceA, DataA and DataB. i.e.,
nodes A and B share the same value for N onceA,
DataA and DataB and both execute the same ses-
sion of the protocol.

– Conﬁdentiality of DataB, i.e., DataB is a secret
value shared between A and B, and remains un-
known to an intruder or third parties.

In this case AVISPA ﬁnds a man-in-the-middle at-
tack (see Table 2), where IA represents the intruder
playing the role of node A, IB2 represents the intruder
playing the role of node B, B1 represents node B com-
municating with the intruder, and B2 represents node
B communicating with A:

First the intruder, playing the role of A, starts the
protocol with B (denoted B1), and sends a false nonce,
which is answered by B (B1). Then, A starts a session
with B (B2) but this message is intercepted by the in-
truder (IB2 ) which modiﬁes the message and sends to
B (B2) the identity of a false node Nx and the nonce of
A. Node B (B2) sends the answer of the last message to
A, and A responds with a request of data (Data2) to B
(B2). Again, the request is intercepted by the intruder
who redirects the message to B (B1). At this moment,
B (B1) thinks that it has received a correct request from
A, and then it sends DataB to the intruder playing the
role of A (IA)

Finally we can conclude that B1 has exchanged in-
formation (Data2) with the intruder, and B2 thinks
that it has talked to a node Nx that does not exist. A
solution to this attack consists in authenticate not only
the answer from B in message 2 but also the message
1 sent from A. The modiﬁed version of the protocol is:

1. A → B : A.N onceA.

M AC(A.N onceA)H(Km,A)

2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}K ′

AB

where K ′
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB .

AB = H(H(Km.B).A)

{M AC(IV2.DataB)}K ′

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

Case D. Sensor network conﬁguration is shown in Fig. 4.
In this case a node (N1) shares a cluster key with each
of its immediate neighbours (N2 and N3).

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1, B rep-
resents one of its neighbours (N2 or N3), and Kc is the
cluster key:

6

1. IA → B1 : A, N onceI

2. B1 → IA : B.{M AC(N onceI .B)}H(Km .B)

1. A → IB2 : A, N onceA

2. IA → B2 : Nx.N onceA

2. B2 → A : B.{M AC(N onceA.B)}H(Km .B)

3. A → IB2 : B.AM1.Size1.DataA. {M AC(B.AM1.Size1.DataA)}K ′

AB

3. IA → B1 : B.AM1.Size1.DataA. {M AC(B.AM1.Size1.DataA)}K ′

AB

4. B1 → IA : A.AM2.Size2.B.Counter. {(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K ′

AB

Table 2 Case C. Man-in-the-middle attack

1. A → B : B.AM1.Size1.A.Counter.

{(IV1
{M AC(IV1.Kc)}K ′

⊕

AB

Kc)}KAB .

where IV1 = B.AM1.Size1.A.Counter,
KAB = F (F (Km.B).A) and
K ′

AB = H(H(Km.B).A)

2. B → A : BS.AM2.Size2.done.

{M AC(BS.AM2.Size2.done)}H(Kc)

3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}H(Kc)

4. B → A : IV2.{(IV2 ⊕ DataB)}F (Kc).

{M AC(IV2.DataB)}H(Kc)

where IV2 = A.AM2.Size2.B.Suc(Counter)

The properties we have to analyse are the following:

– Authentication of Kc, DataA and DataB. i.e., nodes
A and B share the same value for Kc, DataA and
DataB and both execute the same session of the
protocol.

– Conﬁdentiality of DataB and Kc, i.e., DataB and
Kc are secret values shared between A and B, and
they remain unknown to an intruder or third par-
ties.

After analysing the protocol with AVISPA, an inter-
esting attack based on types was found (see Table 3).
In this attack the intruder intercepts the message sent
from B to A in step 2. In step 3, the intruder sends the
intercepted message back to B as if were a true request
from A to B. B takes the message as a request an mis-
understands the label done as it was DataA. In step 4,
B sends DataB to the intruder.

This is a type ﬂaw attack, i.e., type checking has not
been done and a constant label has been interpreted as a
variable data. One solution to this attack has been pro-
posed by Heather et al. in [12] which basically consists
of tagging each ﬁeld with information about its type,
although this solution could not be adequate in wire-
less sensor networks because it adds some extra bits of
information into each message. In real implementations

of the protocol, programmers should take into account
this type ﬂaw attack and do type checking in order to
avoid a possible attack. In any case, this kind of attack
can be a problem because network bandwidth could be
saturated and there is a consumption of resources in
the node.

Case E. Sensor network conﬁguration is shown in Fig. 5.
In this case a node (e.g. N1) shares a cluster key with
non immediate neighbouring nodes (e.g. N4 and N5).

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1, B rep-
resents a non neighbour node (N4 or N5), Ni represents
a neighbour node (N2 and N3):

Q. A → Ni : A, B
R. Ni → A : A.AM1.Size1.Ni.

{M AC(A.AM1.Size1.Ni)}K ′

ANi

1 . A → Ni : IV2.F (SKi, 0).

{(IV2 ⊕ SKi)}KANi
{M AC(IV2.SKi.F (SKi, 0))}K ′

.

ANi
where IV2 = Ni.AM2.Size2.A.Counter

2 . Ni → B : IV3.F (SKi, 0).

{(IV3 ⊕ SKi)}KNiB .
{M AC(IV3.SKi.F (SKi, 0))}K ′

Ni B

where IV3 = B.AM3.Size3.Ni.Counter
When B has every SKi
D. B → A : A.AM4.Size4.done.

{M AC(A.AM4.Size4.done)}Sk

where Sk = Sk1 ⊕ . . . ⊕ Skn

AVISPA only ﬁnds a replay attack, that we do not
consider. Apart from this attack, the protocol is secure.

Case F. In this case, a third party EP establishes an
authenticated communication channel with a sensor net-
work. The ﬁrst three messages are intended to authen-
ticate the third party to the node, while the three last
messages are for authenticating the sensor mote with
the third party.

7

1. A → B : B.AM1.Size1.A.Counter. {(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K ′

AB

where IV1 = B.AM1.Size1.A.Counter

KAB = F (F (Km.B).A) and
K ′

AB = H(H(Km.B).A)

2. B → IA : BS.AM2.Size2.done. {M AC(BS.AM2.Size2.done)}H(Kc)

3. IA → B : BS.AM2.Size2.done. {M AC(BS.AM2.Size2.done)}H(Kc)

4. B → IA : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

where IV2 = A.AM2.Size2.B.Suc(Counter)

Table 3 Case D. Type ﬂaw attack

N1

N3

N2

N4

N5

Fig. 5 Sensor Network: Case E

The protocol for TinySec-AE and TinySec-Auth pack-

ets in combination with TinyPK using AVISPA syntax
is as follows:

1A. EP → Ni : IV1. {xor(IV1, P Kep)}P Kca
where IV1 = Size1.EP.0.N once
2A. EP → Ni : {M AC(IV1.N once. P Kep)}inv(P Kep)
3A. Ni → EP : IV2.N once.{xor(IV2, Km)}P Kep .

{M AC(IV2.N once.Km)}P Kep

where IV2 = EP.Size2.N.Suc(0)
1B. EP → Ni : IV3.N once.

{xor(IV1, DHdym)}F (Km,EP )

where IV3 = Size3.EP.Suc(Suc(0)).N once
2B. EP → Ni : {M AC(IV3.N once.DHdym)}H(Km,EP )
3B. Ni → EP : IV4.Credential.

{M AC(N once)}DH(DHstatic,DHdym).
{M AC(IV4.Credential)}H(Km,N )

where IV4 = EP.Size4.N.Suc(Suc(Suc(0)))
and Credendtial = {N }inv(P Kca)

the ﬁrst two messages. If it trusts EP, it answers back
the challenge message including the network key Km.
After EP receives message 3A, the third party is au-
thenticated. Then the sensor node is authenticated.

The third party EP sends another challenge mes-
sage, including the previous phase nonce. It also gen-
erates ephemeral Diﬃe-Hellman key DHdym that is
added to the challenge message. Each node has a static
Diﬃe-Hellman key DHstatic that is pre-loaded in the
node before its deployment. Thus, after the two chal-
lenge messages, if the sensor node checks the message
authentication code successfully, it generates a new Diﬃe-
Hellman key DH(DHdym, DHstatic). In the challenge
response, it includes its credentials and the nonce signed
with the new key.

AVISPA only ﬁnds a man-in-the-middle attack. In
this attack, a sensor node and the third party execute a
run of the protocol, but this run is not ﬁnished because
the intruder deletes the last message. Then, the intruder
replays the third party messages to the same sensor
node. As the challenge node is computed by means of a
timing function, the sensor node should be able to de-
tect that messages are replayed. Thus, we do not con-
sider this attack feasible. Apart from this attack, the
protocol is secure.

4 Conclusions and Future Work

Initially, we assume that the third party EP knows
the corresponding public key P Kca of the network Cer-
tiﬁcation Authority (CA), and that it also has its own
public key P Kep. The TinyPK proposal assumes that
these key pairs are RSA keys.

The messages 1A and 2A are the same challenge
message but, due to the size of the keys, the challenge
message needs to be split in two TinySec messages. The
challenge messages include a challenge nonce and the
public key of the third party. The sensor node checks
the message authentication code as soon as it receives

In this paper we have presented a formal approach
to the security analysis of wireless sensor networks by
means of a model checking tool called AVISPA. Several
models of the network have been considered depending
on the relative position and roles of the nodes. Three
wireless sensor security protocols have been considered
in order to build a complete solution: TinySec, which is
in charge of the authentication and encryption of mes-
sages; LEAP, which covers the key distribution mecha-
nism and TinyPK, which allows to establish an authen-
ticated conversation with an external third party.

Telecommunications Systems manuscript No.
(will be inserted by the editor)

Model Checking Wireless Sensor Network Security
Protocols: TinySec + LEAP + TinyPK

Llanos Tobarra · Diego Cazorla · Fernando Cuartero · Gregorio D´ıaz ·
Emilia Cambronero

Received: date / Accepted: date

Abstract In this paper, a formal analysis of security
protocols in the ﬁeld of wireless sensor networks is pre-
sented. Three complementary protocols, TinySec, LEAP
and TinyPK, are modelled using the high-level formal
language HLPSL, and veriﬁed using the model checking
tool AVISPA, where two main security properties are
checked: authenticity and conﬁdentiality of messages.
As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In
both cases conﬁdentiality is compromised and an in-
truder may obtain conﬁdential data from a node in the
network. Two solutions to these attacks are proposed
in the paper.

Keywords Wireless sensor · model checking · security
protocols · AVISPA toolbox

1 Introduction

Wireless sensor network have been widely used in many
diﬀerent applications: monitoring building perimeters,
battleﬁeld situation data, human vital signs retrieving,
reports about malfunctions in a system, etc. These ap-
plications highlight the importance of security in wire-
less sensor networks. Thus, security has become a chal-
lenge in wireless sensor due to low capabilities of de-

This work has been supported by the Spanish government with
the project ”Application of Formal Methods to Web Services”,
with reference TIN2006-15578-C02-02, and the JCCM regional
project “Application of formal methods to the design and analysis
of Web Services and e-commerce ” (PAC06-0008-6995 )

Instituto de Investigaci´on en Inform´atica
Universidad de Castilla-La Mancha. Albacete, Spain.
E-mail:
emicp}@dsi.uclm.es

{mtobarra,

dcazorla,

fernando,

gregorio,

vices, in terms of computational power and energy con-
sumption, making it diﬃcult to use traditional security
protocols.

Two main problems related to security protocols
arise. Firstly, the overload that security protocols in-
troduce in messages should be reduced to a minimum.
Every bit the sensor sends consumes energy and, con-
sequently, reduces the life of the device. Secondly, low
computational power implies that special cryptographic
algorithms that require less powerful processors need to
be used. The combination of both problems lead us to a
situation where new approaches or solutions to security
protocols need to be considered. These new approaches
take into account basically two main goals: to reduce
the overhead that protocol imposes to messages, and
to provide reasonable protection while limiting use of
resources.

In order to design a secure network, several aspects
have to be considered [17]: Key establishment and trust
setup, secrecy and authentication, and privacy. Key es-
tablishment can be considered the base of the system;
a secure and eﬃcient key distribution mechanism is
needed for large scale sensor networks. Once every node
has its own keys, these are used to authenticate and en-
crypt (if needed) the messages they exchange. Several
protocols have been proposed in the literature related
to authentication and privacy [14,18], and key distribu-
tion [22,6,10]

In this paper we have focused on three of these pro-
tocols: TinySec [14] in the ﬁeld of authentication and
encryption, and LEAP [22] and TinyPK [21] in the ﬁeld
of key management. TinySec is a fully-implemented link
layer security architecture for wireless sensor networks
included in the oﬃcial TinyOS [13] release. LEAP is
a powerful keying mechanism that supports the estab-
lishment of four types of keys for each sensor node with

2

little intervention of the base station. One alternative to
LEAP is TinyPK [21], that is based on public key tech-
nologies adapted to sensor capabilities. A brief overview
of these protocols is given in Section 2.

In line with the development of security protocols,
some techniques have also been developed to model
a system and check its properties. One of the most
promising techniques in this line is model checking.
Model checking [8] is a formal method based technique
for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main
advantages of this technique is that it is automatic and
allows us to see if a system works as expected. In case
the system does not work properly, the model check-
ing tool provides a trace that leads to the source of the
error.

Model checking has become a key point in the design
of concurrent and distributed system because it allows
us to ensure the correctness of a design at the earliest
stage possible. Model checking has two main advan-
tages over two classical techniques such as simulation
and testing: i) we do not need to build a prototype of
the system, and ii) we are able to verify the system
against every single execution trace. The latter is very
important because using simulation or testing we can
only ﬁnd errors, but we cannot ensure that the whole
system behaves as expected (some errors may remain
hidden until the system is in production stage).

Some general purpose model checking tools have
been developed by diﬀerent research groups: Spin, UP-
PAAL, Murφ. These tools allow us to verify not only the
functional properties of a system (e.g. Spin), but also
the performance of a real-time system (e.g. UPPAAL).
Although we can use these general purpose tools in or-
der to verify security protocols, we consider that it is
preferable (and more intuitive) to use a tool devoted to
the veriﬁcation of security protocols. Among these tools
we can ﬁnd Casper/FDR2 toolbox [15] and AVISPA [1].
The use of model checking tools to verify security
protocols has been successful in the past in diﬀerent
areas such as Web Services [19,2,5], or Transport Layer
security protocols [16,20].

In this paper, we present a formal veriﬁcation of
wireless sensor security protocols using AVISPA (Au-
tomated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level
formal language HLPSL [7] for specifying protocols and
their security properties. Once we have speciﬁed the
model of the system, AVISPA translates it into an inter-
mediate format IF. This is the input of several backends
that are integrated into AVISPA framework: SATMC
OFMC, Cl-Atse and TA4SP. Besides, only one model
is speciﬁed although it can be analysed with the four

backends. AVISPA also oﬀers a graphical interface SPAN
[11] that helps in the specifying task.

Security in wireless networks is not an easy task due
to its broadcast nature. An intruder can overhear, inter-
cept messages, inject new messages or modify messages
in transit. This kind of intruder is called Dolev-Yao In-
truder [9]. The intruder implemented in AVISPA is a
Dolev-Yao intruder, which is appropriate to the analy-
sis of wireless security protocols.

The paper is organised as follows. In Section 2 a
brief overview of TinySec, LEAP and TinyPK is given.
Section 3 is devoted to the formal veriﬁcation of Tiny-
Sec, LEAP and TinyPK, where six scenarios have been
considered depending on the key distribution mecha-
nism used. Finally in Section 4 we give our conclusions
and future work.

2 TinySec, LEAP and TinyPK

TinySec [14] is a fully-implemented link layer security
architecture for wireless sensor networks. The design
of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight
design was made taking into account wireless sensor
networks characteristics, mainly limited computation
and communication capabilities, as well as low power
consumption. TinySec is part of the oﬃcial TinyOS [13]
release.

The main goals of TinySec are performance, usabil-
ity and security. Inside the security aspects, three main
goals are considered: access control, message integrity,
and conﬁdentiality. Outside the scope of TinySec is to
avoid replay attacks, which is left to higher layers of the
protocol stack.

TinySec considers two operations with application
layer data: authentication and semantically secure en-
cryption. TinySec authenticates a packet using a mes-
sage authentication code, CBC-MAC [4]. Semantically
secure encryption1 is made using an 8 byte initialisa-
tion vector (IV) and cipher block chaining (CBC) as
encryption scheme [3]. Taking into account both oper-
ations, two kinds of packets can be found: TinySec-AE,
that oﬀers authentication and encryption, and TinySec-
Auth, that oﬀers only authentication. A detailed view
of both kinds of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys
are needed. TinySec does not address the problem of
obtaining those keys; any particular keying mechanism
can be used in conjunction with TinySec. In this paper
we consider Localised Encryption and Authentication

1 Encrypting the same plaintext two times should give two dif-

ferent cipher-texts

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

3

Fig. 1 TinySec packet formats: TinySec-AE and TinySec-Auth

Protocol (LEAP) [22] and TinyPK [21] as the keying
mechanism.

LEAP supports the establishment of four types of
keys for each sensor node: an individual key shared with
the base station, a pairwise key shared with another
sensor node, a cluster key shared with multiple neigh-
boring nodes, and a group key that is shared by all the
nodes in the network. One interesting feature of LEAP
is that it minimises the involvement of the base station.
Fig. 2 shows the four LEAP keying mechanisms.

TinyPK is also focused on supporting conﬁdential-
ity and authentication for wireless sensor networks. In
[21], a protocol is proposed to authenticate a third party
(e.g. another sensor network) by means of sensor motes
and asymmetric keys. It requires a small public key in-
frastructure. First, there should be a Certiﬁcation Au-
thority(CA) in the network, such as a base station,
which is an entity with a pair of public/private keys
trusted by all the network nodes. Each node in the
network knows the public CA before deployment. The
third party of the protocol should have its own pub-
lic/private key pair. The protocol operation is divided
into two parts: the external party authentication and
the node authentication. In the ﬁrst part, the external
party authenticates itself by means of a challenge. Af-
ter this phase, the node and the external party share
the network key and a nonce. In the second phase, the
node and the external party establish a new key pair
by means of Diﬃe-Hellman exchange. Each node has a
static Diﬃe-Hellman key, while the third party gener-
ates a ephemeral Diﬃe-Hellman key. A node credential
is also exchanged in order to authenticate the node.

3 Veriﬁcation of TinySec, LEAP and TinyPK

The combination of TinySec and LEAP, or TinySec
and TinyPK allows us to build a complete solution,
where LEAP or TinyPK are responsible for obtaining
the more convenient shared key at every moment, and
TinySec is responsible of the authentication and en-
cryption of messages exchanged between nodes. Thus,

we have considered six diﬀerent conﬁgurations of Tiny-
Sec, LEAP and TinyPK, depending on the key mecha-
nism used, and the kind and the situation of the nodes
that communicate with each other:

– Case A. Request from the base node to a normal
node using an individual key using messages TinySec-
AE.

– Case B. Request from the base node to a normal
node using an individual key using messages TinySec-
Auth.

– Case C. Communication between immediate neigh-

bouring nodes using a pairwise shared key.

– Case D. Communication between immediate neigh-

bouring nodes using a cluster key.

– Case E. Communication between non immediate neigh-

bouring nodes nodes using a cluster key.

– Case F. Communication between a network node

and third party with asymmetric TinyPK keys.

Throughout this analysis we will consider that be-
fore deployment, a node master key Km has been saved
inside every node in the network. We also adopt the
Dolev-Yao intruder model, where an intruder can over-
hear, intercept, alter, or inject any messages into the
radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3.
In this case a base node (BS) makes a request to a
normal node (Ni) which has an individual (unique) key
that it shares with the base station

The protocol for TinySec-AE packets using AVISPA

syntax is as follows:

1. BS → Ni: IV1.{(IV1 ⊕ Data1)}F (Km.Ni).

{M AC(IV1.Data1)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni).

{M AC(IV2.Data2)}H(Km.Ni)

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-
random functions that allow to calculate the encryption
key and the authentication key taking as parameters

4

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

K c

Ni

K c

Ni

K c

Ni

N2

N4

N3

KS

NV1

NV2

NV3

K c

Nc

K c

Nc

K c

Nc

NC

Fig. 2 LEAP keying mechanisms

the master key (Km) and the id of the node (Ni). Given
that AVISPA does not oﬀer arithmetic semantics, the
increase of the counter is represented by a function Suc,
such as Suc(0) represents 1, Suc(Suc(0)) represents 2
and so on.

BS

N1

N2

N3

Fig. 3 Sensor network: cases A and B.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node
Ni and the base station (BS) share the same value
for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to
prove that bilateral authentication is achieved by
using the MAC, and the integrity of the message is
guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and
Data2 are secret values shared between Ni and BS,
and they are not known by an intruder or third par-
ties.

The veriﬁcation with AVISPA ﬁnds only the replay
attack shown in Table 1, where IBS represents an in-
truder playing the role of the base station. Nevertheless,
as was said before, TinySec does not manage replay at-
tacks, which are left to higher layers of the protocol
stack. Apart from this attack, the protocol is secure,
even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in
the previous case (see Fig. 3), but we consider TinySec-
Auth messages instead of TinySec-AE messages. The
protocol for TinySec-AE packets using AVISPA syntax
is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1.

{M AC(Ni.AM1.Size1. Data1)}H(Km.Ni)

2. Ni → BS: BS.AM2.Size2.Data2.

{M AC(BS.AM2.Size2. Data2)}H(Km.Ni)

As we mentioned before, TinySec-Auth does not
provide any conﬁdentiality mechanisms. Thus, we can
only analyse the authentication of Data1 and Data2,
i.e., we can prove the bilateral authentication between
BS and Ni, by means of the MAC messages, and also
the integrity of messages. As in the previous case, we
have found a replay attack that we omit

5

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km .N1). {M AC(IV1.Data1)}H(Km .N1)

where IV1 = N1.AM1.Size1.BS.0

2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km .N1). {M AC(IV2.Data2)}H(Km .N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km .N1). {M AC(IV1.Data1)}H(Km .N1)

where IV1 = N1.AM1.Size1.BS.0

2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km .N1). {M AC(IV3.Data3)}H(Km .N1)

where IV3 = BS.AM3.Size3.N1.Suc(0)

Table 1 Case A. Replay attack

Case C. In this case a node (N1) shares a pairwise key
with each of its immediate neighbours (N2 and N3).
The network conﬁguration is shown in Fig. 4.

N1

N3

N2

Fig. 4 Sensor network: cases C and D

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1 and
B represents one of its neighbours (N2 or N3):

1. A → B : A, N onceA
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}K ′

AB

where K ′
4. B → A : IV2.{(IV2

AB = H(H(Km.B).A)

⊕ DataB)}KAB .

{M AC(IV2.DataB)}K ′

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

The properties we have to analyse are the following:

– Authentication of N onceA, DataA and DataB. i.e.,
nodes A and B share the same value for N onceA,
DataA and DataB and both execute the same ses-
sion of the protocol.

– Conﬁdentiality of DataB, i.e., DataB is a secret
value shared between A and B, and remains un-
known to an intruder or third parties.

In this case AVISPA ﬁnds a man-in-the-middle at-
tack (see Table 2), where IA represents the intruder
playing the role of node A, IB2 represents the intruder
playing the role of node B, B1 represents node B com-
municating with the intruder, and B2 represents node
B communicating with A:

First the intruder, playing the role of A, starts the
protocol with B (denoted B1), and sends a false nonce,
which is answered by B (B1). Then, A starts a session
with B (B2) but this message is intercepted by the in-
truder (IB2 ) which modiﬁes the message and sends to
B (B2) the identity of a false node Nx and the nonce of
A. Node B (B2) sends the answer of the last message to
A, and A responds with a request of data (Data2) to B
(B2). Again, the request is intercepted by the intruder
who redirects the message to B (B1). At this moment,
B (B1) thinks that it has received a correct request from
A, and then it sends DataB to the intruder playing the
role of A (IA)

Finally we can conclude that B1 has exchanged in-
formation (Data2) with the intruder, and B2 thinks
that it has talked to a node Nx that does not exist. A
solution to this attack consists in authenticate not only
the answer from B in message 2 but also the message
1 sent from A. The modiﬁed version of the protocol is:

1. A → B : A.N onceA.

M AC(A.N onceA)H(Km,A)

2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}K ′

AB

where K ′
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB .

AB = H(H(Km.B).A)

{M AC(IV2.DataB)}K ′

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

Case D. Sensor network conﬁguration is shown in Fig. 4.
In this case a node (N1) shares a cluster key with each
of its immediate neighbours (N2 and N3).

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1, B rep-
resents one of its neighbours (N2 or N3), and Kc is the
cluster key:

6

1. IA → B1 : A, N onceI

2. B1 → IA : B.{M AC(N onceI .B)}H(Km .B)

1. A → IB2 : A, N onceA

2. IA → B2 : Nx.N onceA

2. B2 → A : B.{M AC(N onceA.B)}H(Km .B)

3. A → IB2 : B.AM1.Size1.DataA. {M AC(B.AM1.Size1.DataA)}K ′

AB

3. IA → B1 : B.AM1.Size1.DataA. {M AC(B.AM1.Size1.DataA)}K ′

AB

4. B1 → IA : A.AM2.Size2.B.Counter. {(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K ′

AB

Table 2 Case C. Man-in-the-middle attack

1. A → B : B.AM1.Size1.A.Counter.

{(IV1
{M AC(IV1.Kc)}K ′

⊕

AB

Kc)}KAB .

where IV1 = B.AM1.Size1.A.Counter,
KAB = F (F (Km.B).A) and
K ′

AB = H(H(Km.B).A)

2. B → A : BS.AM2.Size2.done.

{M AC(BS.AM2.Size2.done)}H(Kc)

3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}H(Kc)

4. B → A : IV2.{(IV2 ⊕ DataB)}F (Kc).

{M AC(IV2.DataB)}H(Kc)

where IV2 = A.AM2.Size2.B.Suc(Counter)

The properties we have to analyse are the following:

– Authentication of Kc, DataA and DataB. i.e., nodes
A and B share the same value for Kc, DataA and
DataB and both execute the same session of the
protocol.

– Conﬁdentiality of DataB and Kc, i.e., DataB and
Kc are secret values shared between A and B, and
they remain unknown to an intruder or third par-
ties.

After analysing the protocol with AVISPA, an inter-
esting attack based on types was found (see Table 3).
In this attack the intruder intercepts the message sent
from B to A in step 2. In step 3, the intruder sends the
intercepted message back to B as if were a true request
from A to B. B takes the message as a request an mis-
understands the label done as it was DataA. In step 4,
B sends DataB to the intruder.

This is a type ﬂaw attack, i.e., type checking has not
been done and a constant label has been interpreted as a
variable data. One solution to this attack has been pro-
posed by Heather et al. in [12] which basically consists
of tagging each ﬁeld with information about its type,
although this solution could not be adequate in wire-
less sensor networks because it adds some extra bits of
information into each message. In real implementations

of the protocol, programmers should take into account
this type ﬂaw attack and do type checking in order to
avoid a possible attack. In any case, this kind of attack
can be a problem because network bandwidth could be
saturated and there is a consumption of resources in
the node.

Case E. Sensor network conﬁguration is shown in Fig. 5.
In this case a node (e.g. N1) shares a cluster key with
non immediate neighbouring nodes (e.g. N4 and N5).

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1, B rep-
resents a non neighbour node (N4 or N5), Ni represents
a neighbour node (N2 and N3):

Q. A → Ni : A, B
R. Ni → A : A.AM1.Size1.Ni.

{M AC(A.AM1.Size1.Ni)}K ′

ANi

1 . A → Ni : IV2.F (SKi, 0).

{(IV2 ⊕ SKi)}KANi
{M AC(IV2.SKi.F (SKi, 0))}K ′

.

ANi
where IV2 = Ni.AM2.Size2.A.Counter

2 . Ni → B : IV3.F (SKi, 0).

{(IV3 ⊕ SKi)}KNiB .
{M AC(IV3.SKi.F (SKi, 0))}K ′

Ni B

where IV3 = B.AM3.Size3.Ni.Counter
When B has every SKi
D. B → A : A.AM4.Size4.done.

{M AC(A.AM4.Size4.done)}Sk

where Sk = Sk1 ⊕ . . . ⊕ Skn

AVISPA only ﬁnds a replay attack, that we do not
consider. Apart from this attack, the protocol is secure.

Case F. In this case, a third party EP establishes an
authenticated communication channel with a sensor net-
work. The ﬁrst three messages are intended to authen-
ticate the third party to the node, while the three last
messages are for authenticating the sensor mote with
the third party.

7

1. A → B : B.AM1.Size1.A.Counter. {(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K ′

AB

where IV1 = B.AM1.Size1.A.Counter

KAB = F (F (Km.B).A) and
K ′

AB = H(H(Km.B).A)

2. B → IA : BS.AM2.Size2.done. {M AC(BS.AM2.Size2.done)}H(Kc)

3. IA → B : BS.AM2.Size2.done. {M AC(BS.AM2.Size2.done)}H(Kc)

4. B → IA : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

where IV2 = A.AM2.Size2.B.Suc(Counter)

Table 3 Case D. Type ﬂaw attack

N1

N3

N2

N4

N5

Fig. 5 Sensor Network: Case E

The protocol for TinySec-AE and TinySec-Auth pack-

ets in combination with TinyPK using AVISPA syntax
is as follows:

1A. EP → Ni : IV1. {xor(IV1, P Kep)}P Kca
where IV1 = Size1.EP.0.N once
2A. EP → Ni : {M AC(IV1.N once. P Kep)}inv(P Kep)
3A. Ni → EP : IV2.N once.{xor(IV2, Km)}P Kep .

{M AC(IV2.N once.Km)}P Kep

where IV2 = EP.Size2.N.Suc(0)
1B. EP → Ni : IV3.N once.

{xor(IV1, DHdym)}F (Km,EP )

where IV3 = Size3.EP.Suc(Suc(0)).N once
2B. EP → Ni : {M AC(IV3.N once.DHdym)}H(Km,EP )
3B. Ni → EP : IV4.Credential.

{M AC(N once)}DH(DHstatic,DHdym).
{M AC(IV4.Credential)}H(Km,N )

where IV4 = EP.Size4.N.Suc(Suc(Suc(0)))
and Credendtial = {N }inv(P Kca)

the ﬁrst two messages. If it trusts EP, it answers back
the challenge message including the network key Km.
After EP receives message 3A, the third party is au-
thenticated. Then the sensor node is authenticated.

The third party EP sends another challenge mes-
sage, including the previous phase nonce. It also gen-
erates ephemeral Diﬃe-Hellman key DHdym that is
added to the challenge message. Each node has a static
Diﬃe-Hellman key DHstatic that is pre-loaded in the
node before its deployment. Thus, after the two chal-
lenge messages, if the sensor node checks the message
authentication code successfully, it generates a new Diﬃe-
Hellman key DH(DHdym, DHstatic). In the challenge
response, it includes its credentials and the nonce signed
with the new key.

AVISPA only ﬁnds a man-in-the-middle attack. In
this attack, a sensor node and the third party execute a
run of the protocol, but this run is not ﬁnished because
the intruder deletes the last message. Then, the intruder
replays the third party messages to the same sensor
node. As the challenge node is computed by means of a
timing function, the sensor node should be able to de-
tect that messages are replayed. Thus, we do not con-
sider this attack feasible. Apart from this attack, the
protocol is secure.

4 Conclusions and Future Work

Initially, we assume that the third party EP knows
the corresponding public key P Kca of the network Cer-
tiﬁcation Authority (CA), and that it also has its own
public key P Kep. The TinyPK proposal assumes that
these key pairs are RSA keys.

The messages 1A and 2A are the same challenge
message but, due to the size of the keys, the challenge
message needs to be split in two TinySec messages. The
challenge messages include a challenge nonce and the
public key of the third party. The sensor node checks
the message authentication code as soon as it receives

In this paper we have presented a formal approach
to the security analysis of wireless sensor networks by
means of a model checking tool called AVISPA. Several
models of the network have been considered depending
on the relative position and roles of the nodes. Three
wireless sensor security protocols have been considered
in order to build a complete solution: TinySec, which is
in charge of the authentication and encryption of mes-
sages; LEAP, which covers the key distribution mecha-
nism and TinyPK, which allows to establish an authen-
ticated conversation with an external third party.

8

The six models we have presented have been anal-
ysed with AVISPA, and we have obtained the following
results:

Case A. Request from the base node to a normal node
using an individual key using messages TinySec-AE.
The veriﬁcation with AVISPA ﬁnds only a replay attack
where an intruder may play the role of the base station.
Nevertheless, TinySec does not manage replay attacks,
which are left to higher layers of the protocol stack.
Apart from this attack, the protocol is secure,

Case B. Request from the base node to a normal node
using an individual key using messages TinySec-Auth.
As in the previous case, AVISPA ﬁnds only a replay
attack. Under our previous assumptions about replay
attacks, we can consider that the protocol is secure,

Case C. Communication between immediate neighbour
nodes using a pairwise shared key. In this case AVISPA
ﬁnds a man-in-the-middle attack where the intruder
may play at the same time the role of two nodes in
order to obtain real information from one of them. Con-
sequently, conﬁdentiality is lost. A solution to this at-
tack is proposed and consists in authenticate the ﬁrst
message sent from the initiator (node A).

Case D. Communication between immediate neighbour
nodes using a cluster key. In this case a type ﬂaw at-
tack is found. As in the previous case, the intruder can
obtain real data from one of the nodes, and therefore
conﬁdentiality is lost. A solution to this kind of attack
has been proposed in [12]; nevertheless this solution is
not adequate in wireless sensor networks because it in-
creases the overload of security protocols in messages.

Case E. Communication between non immediate neigh-
bour nodes using a cluster key. In this case, apart from
a replay attack, the protocol is secure.

Case F.Communication between a network node and
third party with asymmetric TinyPK keys . This case
is also secure.

Our future work is concerned with extending our
analysis to other security protocols for wireless sen-
sor networks intended to secure routing with time con-
straints like µTESLA [18]. We are also interested in
building a more accurate intruder model taking into
account wireless sensor network capabilities and con-
straints.

References

1. Armando, A., Basin, D.A., Boichut, Y., Chevalier, Y.,
Compagna, L., Cu´ellar, J., Drielsma, P.H., H´eam, P.C.,
Kouchnarenko, O., Mantovani, J., M¨odersheim, S., von Ohe-
imb, D., Rusinowitch, M., Santiago, J., Turuani, M., Vigan`o,
L., Vigneron, L.: The AVISPA tool for the automated val-
idation of internet security protocols and applications.
In:
K. Etessami, S.K. Rajamani (eds.) CAV, Lecture Notes in
Computer Science, vol. 3576, pp. 281–285. Springer (2005)

2. Backes, M., M¨odersheim, S., Pﬁtzmann, B., Vigan`o, L.:
Symbolic and cryptographic analysis of the secure WS-
ReliableMessaging scenario.
In: L. Aceto, A. Ing´olfsd´ottir
(eds.) FoSSaCS, Lecture Notes in Computer Science, vol.
3921, pp. 428–445. Springer (2006)

3. Bellare, M., Desai, A., Jokipii, E., Rogaway, P.: A concrete
security treatment of symmetric encryption. In: Proceedings
of 38th Annual Symposium on Foundations of Computer Sci-
ence, pp. 394–403. IEEE (1997)

4. Bellare, M., Kilian, J., Rogaway, P.: The security of the ci-
pher block chaining message authentication code. J. Comput.
Syst. Sci. 61(3), 362–399 (2000)

5. Bhargavan, K., Fournet, C., Gordon, A.D.: Verifying policy-
based security for web services. In: V. Atluri, B. Pﬁtzmann,
P.D. McDaniel (eds.) ACM Conference on Computer and
Communications Security, pp. 268–277. ACM (2004)

6. Chan, H., Perrig, A., Song, D.X.: Random key predistribu-
tion schemes for sensor networks. In: IEEE Symposium on
Security and Privacy, p. 197. IEEE Computer Society (2003)
7. Chevalier, Y., Compagna, L., Cu´ellar, J., Drielsma, P.H.,
Mantovani, J., M¨odersheim, S., Vigneron, L.: A high
level protocol speciﬁcation language for industrial security-
sensitive protocols. In: Proceedings of Workshop on Speciﬁ-
cation and Automated Processing of Security Requirements
(SAPS), pp. 193–205 (2004)

8. Clarke, E.M., Grumberg, O., Peled, D.A.: Model Checking.

The MIT Press (1999)

9. Dolev, D., Yao, A.C.C.: On the security of public key proto-

cols. In: FOCS, pp. 350–357. IEEE (1981)

10. Eschenauer, L., Gligor, V.: A key-management scheme for
distributed sensor networks. In: V. Atluri (ed.) ACM Confer-
ence on Computer and Communications Security, pp. 41–47.
ACM (2002)

11. Glouche, Y., Genet, T., Heen, O., Courtay, O.: A security
protocol animator tool for AVISPA. In: ARTIST2 Workshop
on Security Speciﬁcation and Veriﬁcation of Embedded Sys-
tems. Pisa (2006)

12. Heather, J., Lowe, G., Schneider, S.: How to prevent type ﬂaw
attacks on security protocols. Journal of Computer Security
11(2), 217–244 (2003)

13. Hill, J., Szewczyk, R., Woo, A., Hollar, S., Culler, D.E., Pis-
ter, K.S.J.: System architecture directions for networked sen-
sors. In: Inter. Conf. on Architectural Support for Program-
ming Languages and Operating Systems, ASPLOS, pp. 93–
104 (2000)

14. Karlof, C., Sastry, N., Wagner, D.: TinySec: a link layer secu-
rity architecture for wireless sensor networks. In: Proceedings
of the 2nd International Conference on Embedded Networked
Sensor Systems, SenSys 2004, Baltimore, MD, USA, Novem-
ber 3-5, 2004, pp. 162–175. ACM (2004)

15. Lowe, G.: Casper: A compiler for the analysis of security
protocols. Journal of Computer Security 6(1-2), 53–84 (1998)
16. Mitchell, J.C.: Finite-state analysis of security protocols. In:
A.J. Hu, M.Y. Vardi (eds.) CAV, Lecture Notes in Computer
Science, vol. 1427, pp. 71–76. Springer (1998)

17. Perrig, A., Stankovic, J.A., Wagner, D.: Security in wireless

sensor networks. Commun. ACM 47(6), 53–57 (2004)

Telecommunications Systems manuscript No.
(will be inserted by the editor)

Model Checking Wireless Sensor Network Security
Protocols: TinySec + LEAP + TinyPK

Llanos Tobarra · Diego Cazorla · Fernando Cuartero · Gregorio D´ıaz ·
Emilia Cambronero

Received: date / Accepted: date

Abstract In this paper, a formal analysis of security
protocols in the ﬁeld of wireless sensor networks is pre-
sented. Three complementary protocols, TinySec, LEAP
and TinyPK, are modelled using the high-level formal
language HLPSL, and veriﬁed using the model checking
tool AVISPA, where two main security properties are
checked: authenticity and conﬁdentiality of messages.
As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In
both cases conﬁdentiality is compromised and an in-
truder may obtain conﬁdential data from a node in the
network. Two solutions to these attacks are proposed
in the paper.

Keywords Wireless sensor · model checking · security
protocols · AVISPA toolbox

1 Introduction

Wireless sensor network have been widely used in many
diﬀerent applications: monitoring building perimeters,
battleﬁeld situation data, human vital signs retrieving,
reports about malfunctions in a system, etc. These ap-
plications highlight the importance of security in wire-
less sensor networks. Thus, security has become a chal-
lenge in wireless sensor due to low capabilities of de-

This work has been supported by the Spanish government with
the project ”Application of Formal Methods to Web Services”,
with reference TIN2006-15578-C02-02, and the JCCM regional
project “Application of formal methods to the design and analysis
of Web Services and e-commerce ” (PAC06-0008-6995 )

Instituto de Investigaci´on en Inform´atica
Universidad de Castilla-La Mancha. Albacete, Spain.
E-mail:
emicp}@dsi.uclm.es

{mtobarra,

dcazorla,

fernando,

gregorio,

vices, in terms of computational power and energy con-
sumption, making it diﬃcult to use traditional security
protocols.

Two main problems related to security protocols
arise. Firstly, the overload that security protocols in-
troduce in messages should be reduced to a minimum.
Every bit the sensor sends consumes energy and, con-
sequently, reduces the life of the device. Secondly, low
computational power implies that special cryptographic
algorithms that require less powerful processors need to
be used. The combination of both problems lead us to a
situation where new approaches or solutions to security
protocols need to be considered. These new approaches
take into account basically two main goals: to reduce
the overhead that protocol imposes to messages, and
to provide reasonable protection while limiting use of
resources.

In order to design a secure network, several aspects
have to be considered [17]: Key establishment and trust
setup, secrecy and authentication, and privacy. Key es-
tablishment can be considered the base of the system;
a secure and eﬃcient key distribution mechanism is
needed for large scale sensor networks. Once every node
has its own keys, these are used to authenticate and en-
crypt (if needed) the messages they exchange. Several
protocols have been proposed in the literature related
to authentication and privacy [14,18], and key distribu-
tion [22,6,10]

In this paper we have focused on three of these pro-
tocols: TinySec [14] in the ﬁeld of authentication and
encryption, and LEAP [22] and TinyPK [21] in the ﬁeld
of key management. TinySec is a fully-implemented link
layer security architecture for wireless sensor networks
included in the oﬃcial TinyOS [13] release. LEAP is
a powerful keying mechanism that supports the estab-
lishment of four types of keys for each sensor node with

2

little intervention of the base station. One alternative to
LEAP is TinyPK [21], that is based on public key tech-
nologies adapted to sensor capabilities. A brief overview
of these protocols is given in Section 2.

In line with the development of security protocols,
some techniques have also been developed to model
a system and check its properties. One of the most
promising techniques in this line is model checking.
Model checking [8] is a formal method based technique
for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main
advantages of this technique is that it is automatic and
allows us to see if a system works as expected. In case
the system does not work properly, the model check-
ing tool provides a trace that leads to the source of the
error.

Model checking has become a key point in the design
of concurrent and distributed system because it allows
us to ensure the correctness of a design at the earliest
stage possible. Model checking has two main advan-
tages over two classical techniques such as simulation
and testing: i) we do not need to build a prototype of
the system, and ii) we are able to verify the system
against every single execution trace. The latter is very
important because using simulation or testing we can
only ﬁnd errors, but we cannot ensure that the whole
system behaves as expected (some errors may remain
hidden until the system is in production stage).

Some general purpose model checking tools have
been developed by diﬀerent research groups: Spin, UP-
PAAL, Murφ. These tools allow us to verify not only the
functional properties of a system (e.g. Spin), but also
the performance of a real-time system (e.g. UPPAAL).
Although we can use these general purpose tools in or-
der to verify security protocols, we consider that it is
preferable (and more intuitive) to use a tool devoted to
the veriﬁcation of security protocols. Among these tools
we can ﬁnd Casper/FDR2 toolbox [15] and AVISPA [1].
The use of model checking tools to verify security
protocols has been successful in the past in diﬀerent
areas such as Web Services [19,2,5], or Transport Layer
security protocols [16,20].

In this paper, we present a formal veriﬁcation of
wireless sensor security protocols using AVISPA (Au-
tomated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level
formal language HLPSL [7] for specifying protocols and
their security properties. Once we have speciﬁed the
model of the system, AVISPA translates it into an inter-
mediate format IF. This is the input of several backends
that are integrated into AVISPA framework: SATMC
OFMC, Cl-Atse and TA4SP. Besides, only one model
is speciﬁed although it can be analysed with the four

backends. AVISPA also oﬀers a graphical interface SPAN
[11] that helps in the specifying task.

Security in wireless networks is not an easy task due
to its broadcast nature. An intruder can overhear, inter-
cept messages, inject new messages or modify messages
in transit. This kind of intruder is called Dolev-Yao In-
truder [9]. The intruder implemented in AVISPA is a
Dolev-Yao intruder, which is appropriate to the analy-
sis of wireless security protocols.

The paper is organised as follows. In Section 2 a
brief overview of TinySec, LEAP and TinyPK is given.
Section 3 is devoted to the formal veriﬁcation of Tiny-
Sec, LEAP and TinyPK, where six scenarios have been
considered depending on the key distribution mecha-
nism used. Finally in Section 4 we give our conclusions
and future work.

2 TinySec, LEAP and TinyPK

TinySec [14] is a fully-implemented link layer security
architecture for wireless sensor networks. The design
of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight
design was made taking into account wireless sensor
networks characteristics, mainly limited computation
and communication capabilities, as well as low power
consumption. TinySec is part of the oﬃcial TinyOS [13]
release.

The main goals of TinySec are performance, usabil-
ity and security. Inside the security aspects, three main
goals are considered: access control, message integrity,
and conﬁdentiality. Outside the scope of TinySec is to
avoid replay attacks, which is left to higher layers of the
protocol stack.

TinySec considers two operations with application
layer data: authentication and semantically secure en-
cryption. TinySec authenticates a packet using a mes-
sage authentication code, CBC-MAC [4]. Semantically
secure encryption1 is made using an 8 byte initialisa-
tion vector (IV) and cipher block chaining (CBC) as
encryption scheme [3]. Taking into account both oper-
ations, two kinds of packets can be found: TinySec-AE,
that oﬀers authentication and encryption, and TinySec-
Auth, that oﬀers only authentication. A detailed view
of both kinds of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys
are needed. TinySec does not address the problem of
obtaining those keys; any particular keying mechanism
can be used in conjunction with TinySec. In this paper
we consider Localised Encryption and Authentication

1 Encrypting the same plaintext two times should give two dif-

ferent cipher-texts

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

3

Fig. 1 TinySec packet formats: TinySec-AE and TinySec-Auth

Protocol (LEAP) [22] and TinyPK [21] as the keying
mechanism.

LEAP supports the establishment of four types of
keys for each sensor node: an individual key shared with
the base station, a pairwise key shared with another
sensor node, a cluster key shared with multiple neigh-
boring nodes, and a group key that is shared by all the
nodes in the network. One interesting feature of LEAP
is that it minimises the involvement of the base station.
Fig. 2 shows the four LEAP keying mechanisms.

TinyPK is also focused on supporting conﬁdential-
ity and authentication for wireless sensor networks. In
[21], a protocol is proposed to authenticate a third party
(e.g. another sensor network) by means of sensor motes
and asymmetric keys. It requires a small public key in-
frastructure. First, there should be a Certiﬁcation Au-
thority(CA) in the network, such as a base station,
which is an entity with a pair of public/private keys
trusted by all the network nodes. Each node in the
network knows the public CA before deployment. The
third party of the protocol should have its own pub-
lic/private key pair. The protocol operation is divided
into two parts: the external party authentication and
the node authentication. In the ﬁrst part, the external
party authenticates itself by means of a challenge. Af-
ter this phase, the node and the external party share
the network key and a nonce. In the second phase, the
node and the external party establish a new key pair
by means of Diﬃe-Hellman exchange. Each node has a
static Diﬃe-Hellman key, while the third party gener-
ates a ephemeral Diﬃe-Hellman key. A node credential
is also exchanged in order to authenticate the node.

3 Veriﬁcation of TinySec, LEAP and TinyPK

The combination of TinySec and LEAP, or TinySec
and TinyPK allows us to build a complete solution,
where LEAP or TinyPK are responsible for obtaining
the more convenient shared key at every moment, and
TinySec is responsible of the authentication and en-
cryption of messages exchanged between nodes. Thus,

we have considered six diﬀerent conﬁgurations of Tiny-
Sec, LEAP and TinyPK, depending on the key mecha-
nism used, and the kind and the situation of the nodes
that communicate with each other:

– Case A. Request from the base node to a normal
node using an individual key using messages TinySec-
AE.

– Case B. Request from the base node to a normal
node using an individual key using messages TinySec-
Auth.

– Case C. Communication between immediate neigh-

bouring nodes using a pairwise shared key.

– Case D. Communication between immediate neigh-

bouring nodes using a cluster key.

– Case E. Communication between non immediate neigh-

bouring nodes nodes using a cluster key.

– Case F. Communication between a network node

and third party with asymmetric TinyPK keys.

Throughout this analysis we will consider that be-
fore deployment, a node master key Km has been saved
inside every node in the network. We also adopt the
Dolev-Yao intruder model, where an intruder can over-
hear, intercept, alter, or inject any messages into the
radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3.
In this case a base node (BS) makes a request to a
normal node (Ni) which has an individual (unique) key
that it shares with the base station

The protocol for TinySec-AE packets using AVISPA

syntax is as follows:

1. BS → Ni: IV1.{(IV1 ⊕ Data1)}F (Km.Ni).

{M AC(IV1.Data1)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni).

{M AC(IV2.Data2)}H(Km.Ni)

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-
random functions that allow to calculate the encryption
key and the authentication key taking as parameters

4

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

K c

Ni

K c

Ni

K c

Ni

N2

N4

N3

KS

NV1

NV2

NV3

K c

Nc

K c

Nc

K c

Nc

NC

Fig. 2 LEAP keying mechanisms

the master key (Km) and the id of the node (Ni). Given
that AVISPA does not oﬀer arithmetic semantics, the
increase of the counter is represented by a function Suc,
such as Suc(0) represents 1, Suc(Suc(0)) represents 2
and so on.

BS

N1

N2

N3

Fig. 3 Sensor network: cases A and B.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node
Ni and the base station (BS) share the same value
for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to
prove that bilateral authentication is achieved by
using the MAC, and the integrity of the message is
guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and
Data2 are secret values shared between Ni and BS,
and they are not known by an intruder or third par-
ties.

The veriﬁcation with AVISPA ﬁnds only the replay
attack shown in Table 1, where IBS represents an in-
truder playing the role of the base station. Nevertheless,
as was said before, TinySec does not manage replay at-
tacks, which are left to higher layers of the protocol
stack. Apart from this attack, the protocol is secure,
even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in
the previous case (see Fig. 3), but we consider TinySec-
Auth messages instead of TinySec-AE messages. The
protocol for TinySec-AE packets using AVISPA syntax
is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1.

{M AC(Ni.AM1.Size1. Data1)}H(Km.Ni)

2. Ni → BS: BS.AM2.Size2.Data2.

{M AC(BS.AM2.Size2. Data2)}H(Km.Ni)

As we mentioned before, TinySec-Auth does not
provide any conﬁdentiality mechanisms. Thus, we can
only analyse the authentication of Data1 and Data2,
i.e., we can prove the bilateral authentication between
BS and Ni, by means of the MAC messages, and also
the integrity of messages. As in the previous case, we
have found a replay attack that we omit

5

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km .N1). {M AC(IV1.Data1)}H(Km .N1)

where IV1 = N1.AM1.Size1.BS.0

2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km .N1). {M AC(IV2.Data2)}H(Km .N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km .N1). {M AC(IV1.Data1)}H(Km .N1)

where IV1 = N1.AM1.Size1.BS.0

2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km .N1). {M AC(IV3.Data3)}H(Km .N1)

where IV3 = BS.AM3.Size3.N1.Suc(0)

Table 1 Case A. Replay attack

Case C. In this case a node (N1) shares a pairwise key
with each of its immediate neighbours (N2 and N3).
The network conﬁguration is shown in Fig. 4.

N1

N3

N2

Fig. 4 Sensor network: cases C and D

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1 and
B represents one of its neighbours (N2 or N3):

1. A → B : A, N onceA
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}K ′

AB

where K ′
4. B → A : IV2.{(IV2

AB = H(H(Km.B).A)

⊕ DataB)}KAB .

{M AC(IV2.DataB)}K ′

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

The properties we have to analyse are the following:

– Authentication of N onceA, DataA and DataB. i.e.,
nodes A and B share the same value for N onceA,
DataA and DataB and both execute the same ses-
sion of the protocol.

– Conﬁdentiality of DataB, i.e., DataB is a secret
value shared between A and B, and remains un-
known to an intruder or third parties.

In this case AVISPA ﬁnds a man-in-the-middle at-
tack (see Table 2), where IA represents the intruder
playing the role of node A, IB2 represents the intruder
playing the role of node B, B1 represents node B com-
municating with the intruder, and B2 represents node
B communicating with A:

First the intruder, playing the role of A, starts the
protocol with B (denoted B1), and sends a false nonce,
which is answered by B (B1). Then, A starts a session
with B (B2) but this message is intercepted by the in-
truder (IB2 ) which modiﬁes the message and sends to
B (B2) the identity of a false node Nx and the nonce of
A. Node B (B2) sends the answer of the last message to
A, and A responds with a request of data (Data2) to B
(B2). Again, the request is intercepted by the intruder
who redirects the message to B (B1). At this moment,
B (B1) thinks that it has received a correct request from
A, and then it sends DataB to the intruder playing the
role of A (IA)

Finally we can conclude that B1 has exchanged in-
formation (Data2) with the intruder, and B2 thinks
that it has talked to a node Nx that does not exist. A
solution to this attack consists in authenticate not only
the answer from B in message 2 but also the message
1 sent from A. The modiﬁed version of the protocol is:

1. A → B : A.N onceA.

M AC(A.N onceA)H(Km,A)

2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}K ′

AB

where K ′
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB .

AB = H(H(Km.B).A)

{M AC(IV2.DataB)}K ′

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

Case D. Sensor network conﬁguration is shown in Fig. 4.
In this case a node (N1) shares a cluster key with each
of its immediate neighbours (N2 and N3).

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1, B rep-
resents one of its neighbours (N2 or N3), and Kc is the
cluster key:

6

1. IA → B1 : A, N onceI

2. B1 → IA : B.{M AC(N onceI .B)}H(Km .B)

1. A → IB2 : A, N onceA

2. IA → B2 : Nx.N onceA

2. B2 → A : B.{M AC(N onceA.B)}H(Km .B)

3. A → IB2 : B.AM1.Size1.DataA. {M AC(B.AM1.Size1.DataA)}K ′

AB

3. IA → B1 : B.AM1.Size1.DataA. {M AC(B.AM1.Size1.DataA)}K ′

AB

4. B1 → IA : A.AM2.Size2.B.Counter. {(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K ′

AB

Table 2 Case C. Man-in-the-middle attack

1. A → B : B.AM1.Size1.A.Counter.

{(IV1
{M AC(IV1.Kc)}K ′

⊕

AB

Kc)}KAB .

where IV1 = B.AM1.Size1.A.Counter,
KAB = F (F (Km.B).A) and
K ′

AB = H(H(Km.B).A)

2. B → A : BS.AM2.Size2.done.

{M AC(BS.AM2.Size2.done)}H(Kc)

3. A → B : B.AM1.Size1.DataA.

{M AC(B.AM1.Size1.DataA)}H(Kc)

4. B → A : IV2.{(IV2 ⊕ DataB)}F (Kc).

{M AC(IV2.DataB)}H(Kc)

where IV2 = A.AM2.Size2.B.Suc(Counter)

The properties we have to analyse are the following:

– Authentication of Kc, DataA and DataB. i.e., nodes
A and B share the same value for Kc, DataA and
DataB and both execute the same session of the
protocol.

– Conﬁdentiality of DataB and Kc, i.e., DataB and
Kc are secret values shared between A and B, and
they remain unknown to an intruder or third par-
ties.

After analysing the protocol with AVISPA, an inter-
esting attack based on types was found (see Table 3).
In this attack the intruder intercepts the message sent
from B to A in step 2. In step 3, the intruder sends the
intercepted message back to B as if were a true request
from A to B. B takes the message as a request an mis-
understands the label done as it was DataA. In step 4,
B sends DataB to the intruder.

This is a type ﬂaw attack, i.e., type checking has not
been done and a constant label has been interpreted as a
variable data. One solution to this attack has been pro-
posed by Heather et al. in [12] which basically consists
of tagging each ﬁeld with information about its type,
although this solution could not be adequate in wire-
less sensor networks because it adds some extra bits of
information into each message. In real implementations

of the protocol, programmers should take into account
this type ﬂaw attack and do type checking in order to
avoid a possible attack. In any case, this kind of attack
can be a problem because network bandwidth could be
saturated and there is a consumption of resources in
the node.

Case E. Sensor network conﬁguration is shown in Fig. 5.
In this case a node (e.g. N1) shares a cluster key with
non immediate neighbouring nodes (e.g. N4 and N5).

The protocol for TinySec-AE packets using AVISPA
syntax is as follows, where A represents node N1, B rep-
resents a non neighbour node (N4 or N5), Ni represents
a neighbour node (N2 and N3):

Q. A → Ni : A, B
R. Ni → A : A.AM1.Size1.Ni.

{M AC(A.AM1.Size1.Ni)}K ′

ANi

1 . A → Ni : IV2.F (SKi, 0).

{(IV2 ⊕ SKi)}KANi
{M AC(IV2.SKi.F (SKi, 0))}K ′

.

ANi
where IV2 = Ni.AM2.Size2.A.Counter

2 . Ni → B : IV3.F (SKi, 0).

{(IV3 ⊕ SKi)}KNiB .
{M AC(IV3.SKi.F (SKi, 0))}K ′

Ni B

where IV3 = B.AM3.Size3.Ni.Counter
When B has every SKi
D. B → A : A.AM4.Size4.done.

{M AC(A.AM4.Size4.done)}Sk

where Sk = Sk1 ⊕ . . . ⊕ Skn

AVISPA only ﬁnds a replay attack, that we do not
consider. Apart from this attack, the protocol is secure.

Case F. In this case, a third party EP establishes an
authenticated communication channel with a sensor net-
work. The ﬁrst three messages are intended to authen-
ticate the third party to the node, while the three last
messages are for authenticating the sensor mote with
the third party.

7

1. A → B : B.AM1.Size1.A.Counter. {(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K ′

AB

where IV1 = B.AM1.Size1.A.Counter

KAB = F (F (Km.B).A) and
K ′

AB = H(H(Km.B).A)

2. B → IA : BS.AM2.Size2.done. {M AC(BS.AM2.Size2.done)}H(Kc)

3. IA → B : BS.AM2.Size2.done. {M AC(BS.AM2.Size2.done)}H(Kc)

4. B → IA : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

where IV2 = A.AM2.Size2.B.Suc(Counter)

Table 3 Case D. Type ﬂaw attack

N1

N3

N2

N4

N5

Fig. 5 Sensor Network: Case E

The protocol for TinySec-AE and TinySec-Auth pack-

ets in combination with TinyPK using AVISPA syntax
is as follows:

1A. EP → Ni : IV1. {xor(IV1, P Kep)}P Kca
where IV1 = Size1.EP.0.N once
2A. EP → Ni : {M AC(IV1.N once. P Kep)}inv(P Kep)
3A. Ni → EP : IV2.N once.{xor(IV2, Km)}P Kep .

{M AC(IV2.N once.Km)}P Kep

where IV2 = EP.Size2.N.Suc(0)
1B. EP → Ni : IV3.N once.

{xor(IV1, DHdym)}F (Km,EP )

where IV3 = Size3.EP.Suc(Suc(0)).N once
2B. EP → Ni : {M AC(IV3.N once.DHdym)}H(Km,EP )
3B. Ni → EP : IV4.Credential.

{M AC(N once)}DH(DHstatic,DHdym).
{M AC(IV4.Credential)}H(Km,N )

where IV4 = EP.Size4.N.Suc(Suc(Suc(0)))
and Credendtial = {N }inv(P Kca)

the ﬁrst two messages. If it trusts EP, it answers back
the challenge message including the network key Km.
After EP receives message 3A, the third party is au-
thenticated. Then the sensor node is authenticated.

The third party EP sends another challenge mes-
sage, including the previous phase nonce. It also gen-
erates ephemeral Diﬃe-Hellman key DHdym that is
added to the challenge message. Each node has a static
Diﬃe-Hellman key DHstatic that is pre-loaded in the
node before its deployment. Thus, after the two chal-
lenge messages, if the sensor node checks the message
authentication code successfully, it generates a new Diﬃe-
Hellman key DH(DHdym, DHstatic). In the challenge
response, it includes its credentials and the nonce signed
with the new key.

AVISPA only ﬁnds a man-in-the-middle attack. In
this attack, a sensor node and the third party execute a
run of the protocol, but this run is not ﬁnished because
the intruder deletes the last message. Then, the intruder
replays the third party messages to the same sensor
node. As the challenge node is computed by means of a
timing function, the sensor node should be able to de-
tect that messages are replayed. Thus, we do not con-
sider this attack feasible. Apart from this attack, the
protocol is secure.

4 Conclusions and Future Work

Initially, we assume that the third party EP knows
the corresponding public key P Kca of the network Cer-
tiﬁcation Authority (CA), and that it also has its own
public key P Kep. The TinyPK proposal assumes that
these key pairs are RSA keys.

The messages 1A and 2A are the same challenge
message but, due to the size of the keys, the challenge
message needs to be split in two TinySec messages. The
challenge messages include a challenge nonce and the
public key of the third party. The sensor node checks
the message authentication code as soon as it receives

In this paper we have presented a formal approach
to the security analysis of wireless sensor networks by
means of a model checking tool called AVISPA. Several
models of the network have been considered depending
on the relative position and roles of the nodes. Three
wireless sensor security protocols have been considered
in order to build a complete solution: TinySec, which is
in charge of the authentication and encryption of mes-
sages; LEAP, which covers the key distribution mecha-
nism and TinyPK, which allows to establish an authen-
ticated conversation with an external third party.

8

The six models we have presented have been anal-
ysed with AVISPA, and we have obtained the following
results:

Case A. Request from the base node to a normal node
using an individual key using messages TinySec-AE.
The veriﬁcation with AVISPA ﬁnds only a replay attack
where an intruder may play the role of the base station.
Nevertheless, TinySec does not manage replay attacks,
which are left to higher layers of the protocol stack.
Apart from this attack, the protocol is secure,

Case B. Request from the base node to a normal node
using an individual key using messages TinySec-Auth.
As in the previous case, AVISPA ﬁnds only a replay
attack. Under our previous assumptions about replay
attacks, we can consider that the protocol is secure,

Case C. Communication between immediate neighbour
nodes using a pairwise shared key. In this case AVISPA
ﬁnds a man-in-the-middle attack where the intruder
may play at the same time the role of two nodes in
order to obtain real information from one of them. Con-
sequently, conﬁdentiality is lost. A solution to this at-
tack is proposed and consists in authenticate the ﬁrst
message sent from the initiator (node A).

Case D. Communication between immediate neighbour
nodes using a cluster key. In this case a type ﬂaw at-
tack is found. As in the previous case, the intruder can
obtain real data from one of the nodes, and therefore
conﬁdentiality is lost. A solution to this kind of attack
has been proposed in [12]; nevertheless this solution is
not adequate in wireless sensor networks because it in-
creases the overload of security protocols in messages.

Case E. Communication between non immediate neigh-
bour nodes using a cluster key. In this case, apart from
a replay attack, the protocol is secure.

Case F.Communication between a network node and
third party with asymmetric TinyPK keys . This case
is also secure.

Our future work is concerned with extending our
analysis to other security protocols for wireless sen-
sor networks intended to secure routing with time con-
straints like µTESLA [18]. We are also interested in
building a more accurate intruder model taking into
account wireless sensor network capabilities and con-
straints.

References

1. Armando, A., Basin, D.A., Boichut, Y., Chevalier, Y.,
Compagna, L., Cu´ellar, J., Drielsma, P.H., H´eam, P.C.,
Kouchnarenko, O., Mantovani, J., M¨odersheim, S., von Ohe-
imb, D., Rusinowitch, M., Santiago, J., Turuani, M., Vigan`o,
L., Vigneron, L.: The AVISPA tool for the automated val-
idation of internet security protocols and applications.
In:
K. Etessami, S.K. Rajamani (eds.) CAV, Lecture Notes in
Computer Science, vol. 3576, pp. 281–285. Springer (2005)

2. Backes, M., M¨odersheim, S., Pﬁtzmann, B., Vigan`o, L.:
Symbolic and cryptographic analysis of the secure WS-
ReliableMessaging scenario.
In: L. Aceto, A. Ing´olfsd´ottir
(eds.) FoSSaCS, Lecture Notes in Computer Science, vol.
3921, pp. 428–445. Springer (2006)

3. Bellare, M., Desai, A., Jokipii, E., Rogaway, P.: A concrete
security treatment of symmetric encryption. In: Proceedings
of 38th Annual Symposium on Foundations of Computer Sci-
ence, pp. 394–403. IEEE (1997)

4. Bellare, M., Kilian, J., Rogaway, P.: The security of the ci-
pher block chaining message authentication code. J. Comput.
Syst. Sci. 61(3), 362–399 (2000)

5. Bhargavan, K., Fournet, C., Gordon, A.D.: Verifying policy-
based security for web services. In: V. Atluri, B. Pﬁtzmann,
P.D. McDaniel (eds.) ACM Conference on Computer and
Communications Security, pp. 268–277. ACM (2004)

6. Chan, H., Perrig, A., Song, D.X.: Random key predistribu-
tion schemes for sensor networks. In: IEEE Symposium on
Security and Privacy, p. 197. IEEE Computer Society (2003)
7. Chevalier, Y., Compagna, L., Cu´ellar, J., Drielsma, P.H.,
Mantovani, J., M¨odersheim, S., Vigneron, L.: A high
level protocol speciﬁcation language for industrial security-
sensitive protocols. In: Proceedings of Workshop on Speciﬁ-
cation and Automated Processing of Security Requirements
(SAPS), pp. 193–205 (2004)

8. Clarke, E.M., Grumberg, O., Peled, D.A.: Model Checking.

The MIT Press (1999)

9. Dolev, D., Yao, A.C.C.: On the security of public key proto-

cols. In: FOCS, pp. 350–357. IEEE (1981)

10. Eschenauer, L., Gligor, V.: A key-management scheme for
distributed sensor networks. In: V. Atluri (ed.) ACM Confer-
ence on Computer and Communications Security, pp. 41–47.
ACM (2002)

11. Glouche, Y., Genet, T., Heen, O., Courtay, O.: A security
protocol animator tool for AVISPA. In: ARTIST2 Workshop
on Security Speciﬁcation and Veriﬁcation of Embedded Sys-
tems. Pisa (2006)

12. Heather, J., Lowe, G., Schneider, S.: How to prevent type ﬂaw
attacks on security protocols. Journal of Computer Security
11(2), 217–244 (2003)

13. Hill, J., Szewczyk, R., Woo, A., Hollar, S., Culler, D.E., Pis-
ter, K.S.J.: System architecture directions for networked sen-
sors. In: Inter. Conf. on Architectural Support for Program-
ming Languages and Operating Systems, ASPLOS, pp. 93–
104 (2000)

14. Karlof, C., Sastry, N., Wagner, D.: TinySec: a link layer secu-
rity architecture for wireless sensor networks. In: Proceedings
of the 2nd International Conference on Embedded Networked
Sensor Systems, SenSys 2004, Baltimore, MD, USA, Novem-
ber 3-5, 2004, pp. 162–175. ACM (2004)

15. Lowe, G.: Casper: A compiler for the analysis of security
protocols. Journal of Computer Security 6(1-2), 53–84 (1998)
16. Mitchell, J.C.: Finite-state analysis of security protocols. In:
A.J. Hu, M.Y. Vardi (eds.) CAV, Lecture Notes in Computer
Science, vol. 1427, pp. 71–76. Springer (1998)

17. Perrig, A., Stankovic, J.A., Wagner, D.: Security in wireless

sensor networks. Commun. ACM 47(6), 53–57 (2004)

9

18. Perrig, A., Szewczyk, R., Tygar, J.D., Wen, V., Culler, D.E.:
SPINS: Security protocols for sensor networks. Wireless Net-
works 8(5), 521–534 (2002)

19. Tobarra, M.L., Cazorla, D., Cuartero, F., Diaz, G.: Appli-
cation of formal methods to the analysis of web services
security.
In: M. Bravetti, L. Kloul, G. Zavattaro (eds.)
EPEW/WS-FM, Lecture Notes in Computer Science, vol.
3670, pp. 215–229. Springer (2005)

20. Tobarra, M.L., Cazorla, D., Cuartero, F., Diaz, G.: Formal
veriﬁcation of TLS handshake and extensions for wireless
networks.
In: Proc. of IADIS International Conference on
Applied Computing (AC’06), pp. 57–64. IADIS Press, San
Sebastian, Spain (2006)

21. Watro, R., Kong, D., Cuti, S.F., Gardiner, C., Lynn, C.,
Kruus, P.: Tinypk: securing sensor networks with pub-
lic key technology.
In: SASN ’04: Proceedings of the
2nd ACM workshop on Security of ad hoc and sen-
sor networks, pp. 59–64. ACM Press, New York, NY,
USA (2004).
URL
http://portal.acm.org/citation.cfm?id=1029113

DOI 10.1145/1029102.1029113.

22. Zhu, S., Setia, S., Jajodia, S.: LEAP: eﬃcient security mech-
anisms for large-scale distributed sensor networks. In: S. Ja-
jodia, V. Atluri, T. Jaeger (eds.) ACM Conference on Com-
puter and Communications Security, pp. 62–72. ACM (2003)

