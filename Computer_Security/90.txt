Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

In order to design a secure network, several aspects have to be considered [?]:
Key establishment and trust setup, secrecy and authentication, and privacy. Key
establishment can be considered the base of the system; a secure and eﬃcient
key distribution mechanism is needed for large scale sensor networks. Once every
node has its own keys, these are used to authenticate and encrypt (if needed) the
messages they exchange. Several protocols have been proposed in the literature
related to authentication and privacy [?,?], and key distribution [?,?,?]

In this paper we have focus in two of these protocols: TinySec [?] in the ﬁeld
of authentication and encryption, and LEAP [?] in the ﬁeld of key management.
TinySec is a fully-implemented link layer security architecture for wireless sensor
networks included in the oﬃcial TinyOS [?] release. LEAP is a powerful keying
mechanism that supports the establishment of four types of keys for each sen-
sor node with little intervention of the base station. A brief overview of these
protocols is given in Section 2.

In line with the development of security protocols, some techniques have also
been developed to model a system and check properties on it. One of the most
promising techniques in this line is model checking. Model checking [?] is a formal
methods based technique for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main advantages of this technique
is that it is automatic and allows us to see if a system works as expected. In
case the system does not work properly, the model checking tool provides a trace
that leads to the source of the error.

Model checking has become a key point in the design of concurrent and
distributed system because it allows us to ensure the correctness of a design at
the earliest stage possible. Model checking has two main advantages over two
classical techniques such as simulation and testing: i) we do not need to build a
prototype of the system, and ii) we are able to verify the system against every
single execution trace. The latter is very important because using simulation or
testing we can only ﬁnd errors, but we cannot ensure that the whole system
behaves as expected (some errors may remain hidden until the system is in
production stage).

Some general purpose model checking tools have been developed by diﬀerent
research groups: Spin, UPPAAL, Murφ. These tools allow us to verify not only
the functional properties of a system (e.g. Spin), but also the performance of
a real-time system (e.g. UPPAAL). Although we can use these general purpose
tools in order to verify security protocols, we consider that it is preferable (and
more intuitive) to use a tool devoted to the veriﬁcation of security protocols.
Among these tools we can ﬁnd Casper/FDR2 toolbox [?] and AVISPA [?].

The use of model checking tools to verify security protocols has been suc-
cessful in the past in diﬀerent areas such as Web Services [?,?,?], or Transport
Layer security protocols [?,?].

In this paper, we present a formal veriﬁcation of wireless sensor security pro-
tocols using AVISPA (Automated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level formal language HLPSL
[?] for specifying protocols and their security properties. Once we have speciﬁed

2

Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

In order to design a secure network, several aspects have to be considered [?]:
Key establishment and trust setup, secrecy and authentication, and privacy. Key
establishment can be considered the base of the system; a secure and eﬃcient
key distribution mechanism is needed for large scale sensor networks. Once every
node has its own keys, these are used to authenticate and encrypt (if needed) the
messages they exchange. Several protocols have been proposed in the literature
related to authentication and privacy [?,?], and key distribution [?,?,?]

In this paper we have focus in two of these protocols: TinySec [?] in the ﬁeld
of authentication and encryption, and LEAP [?] in the ﬁeld of key management.
TinySec is a fully-implemented link layer security architecture for wireless sensor
networks included in the oﬃcial TinyOS [?] release. LEAP is a powerful keying
mechanism that supports the establishment of four types of keys for each sen-
sor node with little intervention of the base station. A brief overview of these
protocols is given in Section 2.

In line with the development of security protocols, some techniques have also
been developed to model a system and check properties on it. One of the most
promising techniques in this line is model checking. Model checking [?] is a formal
methods based technique for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main advantages of this technique
is that it is automatic and allows us to see if a system works as expected. In
case the system does not work properly, the model checking tool provides a trace
that leads to the source of the error.

Model checking has become a key point in the design of concurrent and
distributed system because it allows us to ensure the correctness of a design at
the earliest stage possible. Model checking has two main advantages over two
classical techniques such as simulation and testing: i) we do not need to build a
prototype of the system, and ii) we are able to verify the system against every
single execution trace. The latter is very important because using simulation or
testing we can only ﬁnd errors, but we cannot ensure that the whole system
behaves as expected (some errors may remain hidden until the system is in
production stage).

Some general purpose model checking tools have been developed by diﬀerent
research groups: Spin, UPPAAL, Murφ. These tools allow us to verify not only
the functional properties of a system (e.g. Spin), but also the performance of
a real-time system (e.g. UPPAAL). Although we can use these general purpose
tools in order to verify security protocols, we consider that it is preferable (and
more intuitive) to use a tool devoted to the veriﬁcation of security protocols.
Among these tools we can ﬁnd Casper/FDR2 toolbox [?] and AVISPA [?].

The use of model checking tools to verify security protocols has been suc-
cessful in the past in diﬀerent areas such as Web Services [?,?,?], or Transport
Layer security protocols [?,?].

In this paper, we present a formal veriﬁcation of wireless sensor security pro-
tocols using AVISPA (Automated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level formal language HLPSL
[?] for specifying protocols and their security properties. Once we have speciﬁed

2

the model of the system, AVISPA translates it into an intermediate format IF.
This is the input of several backends that are integrated into AVISPA frame-
work: SATMC OFMC, Cl-Atse and TA4SP. Besides, only one model is speciﬁed
although it can be analysed with the four backends. AVISPA also oﬀers a graph-
ical interface SPAN [?] that helps in the specifying task.

Security in wireless networks is not an easy task due to its broadcast nature.
An intruder can overhear, intercept messages, inject new messages or modify
messages in transit. This kind of intruder is called Dolev-Yao Intruder [?]. The
intruder implemented in AVISPA is a Dolev-Yao intruder, which is appropriate
to analyse wireless security protocols.

The paper is organised as follows. In Section 2 a brief overview of TinySec
and LEAP is given. Section 3 is devoted to the formal veriﬁcation of TinySec
and LEAP, where four scenarios have been considered depending on the key
distribution mechanism used. Finally in Section 4 we give our conclusions and
future work.

2 TinySec + LEAP

TinySec [?] is a fully-implemented link layer security architecture for wireless
sensor networks. The design of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight design was made taking
into account wireless sensor networks particularities, mainly limited computation
and communication capabilities, as well as low power consumption. TinySec is
part of the oﬃcial TinyOS [?] release.

The main goals of TinySec are performance, usability and security. Inside
the security aspects, three main goals are considered: access control, message
integrity, and conﬁdentiality. Outside the scope of TinySec is to avoid replay
attacks, which is left to higher layers of the protocol stack.

TinySec considers two operations with application layer data: authentica-
tion and semantically secure encryption. TinySec authenticates a packet using a
message authentication code, CBC-MAC [?]. Semantically secure encryption1 is
made using an 8 byte initialisation vector (IV) and cipher block chaining (CBC)
as encryption scheme [?]. Taking into account both operations, two kinds of
packets can be found: TinySec-AE, that oﬀers authentication and encryption,
and TinySec-Auth, that oﬀers only authentication. A detailed view of both kinds
of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys are needed. TinySec does
not address the problem of obtaining those keys; any particular keying mecha-
nism can be used in conjunction with TinySec. In this paper we consider Local-
ized Encryption and Authentication Protocol (LEAP) [?] as the keying mech-
anism. LEAP supports the establishment of four types of keys for each sensor
node: an individual key shared with the base station, a pairwise key shared with
another sensor node, a cluster key shared with multiple neighboring nodes, and a

1 Encrypting the same plaintext two times should give two diﬀerent cipher-texts

3

Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

In order to design a secure network, several aspects have to be considered [?]:
Key establishment and trust setup, secrecy and authentication, and privacy. Key
establishment can be considered the base of the system; a secure and eﬃcient
key distribution mechanism is needed for large scale sensor networks. Once every
node has its own keys, these are used to authenticate and encrypt (if needed) the
messages they exchange. Several protocols have been proposed in the literature
related to authentication and privacy [?,?], and key distribution [?,?,?]

In this paper we have focus in two of these protocols: TinySec [?] in the ﬁeld
of authentication and encryption, and LEAP [?] in the ﬁeld of key management.
TinySec is a fully-implemented link layer security architecture for wireless sensor
networks included in the oﬃcial TinyOS [?] release. LEAP is a powerful keying
mechanism that supports the establishment of four types of keys for each sen-
sor node with little intervention of the base station. A brief overview of these
protocols is given in Section 2.

In line with the development of security protocols, some techniques have also
been developed to model a system and check properties on it. One of the most
promising techniques in this line is model checking. Model checking [?] is a formal
methods based technique for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main advantages of this technique
is that it is automatic and allows us to see if a system works as expected. In
case the system does not work properly, the model checking tool provides a trace
that leads to the source of the error.

Model checking has become a key point in the design of concurrent and
distributed system because it allows us to ensure the correctness of a design at
the earliest stage possible. Model checking has two main advantages over two
classical techniques such as simulation and testing: i) we do not need to build a
prototype of the system, and ii) we are able to verify the system against every
single execution trace. The latter is very important because using simulation or
testing we can only ﬁnd errors, but we cannot ensure that the whole system
behaves as expected (some errors may remain hidden until the system is in
production stage).

Some general purpose model checking tools have been developed by diﬀerent
research groups: Spin, UPPAAL, Murφ. These tools allow us to verify not only
the functional properties of a system (e.g. Spin), but also the performance of
a real-time system (e.g. UPPAAL). Although we can use these general purpose
tools in order to verify security protocols, we consider that it is preferable (and
more intuitive) to use a tool devoted to the veriﬁcation of security protocols.
Among these tools we can ﬁnd Casper/FDR2 toolbox [?] and AVISPA [?].

The use of model checking tools to verify security protocols has been suc-
cessful in the past in diﬀerent areas such as Web Services [?,?,?], or Transport
Layer security protocols [?,?].

In this paper, we present a formal veriﬁcation of wireless sensor security pro-
tocols using AVISPA (Automated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level formal language HLPSL
[?] for specifying protocols and their security properties. Once we have speciﬁed

2

the model of the system, AVISPA translates it into an intermediate format IF.
This is the input of several backends that are integrated into AVISPA frame-
work: SATMC OFMC, Cl-Atse and TA4SP. Besides, only one model is speciﬁed
although it can be analysed with the four backends. AVISPA also oﬀers a graph-
ical interface SPAN [?] that helps in the specifying task.

Security in wireless networks is not an easy task due to its broadcast nature.
An intruder can overhear, intercept messages, inject new messages or modify
messages in transit. This kind of intruder is called Dolev-Yao Intruder [?]. The
intruder implemented in AVISPA is a Dolev-Yao intruder, which is appropriate
to analyse wireless security protocols.

The paper is organised as follows. In Section 2 a brief overview of TinySec
and LEAP is given. Section 3 is devoted to the formal veriﬁcation of TinySec
and LEAP, where four scenarios have been considered depending on the key
distribution mechanism used. Finally in Section 4 we give our conclusions and
future work.

2 TinySec + LEAP

TinySec [?] is a fully-implemented link layer security architecture for wireless
sensor networks. The design of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight design was made taking
into account wireless sensor networks particularities, mainly limited computation
and communication capabilities, as well as low power consumption. TinySec is
part of the oﬃcial TinyOS [?] release.

The main goals of TinySec are performance, usability and security. Inside
the security aspects, three main goals are considered: access control, message
integrity, and conﬁdentiality. Outside the scope of TinySec is to avoid replay
attacks, which is left to higher layers of the protocol stack.

TinySec considers two operations with application layer data: authentica-
tion and semantically secure encryption. TinySec authenticates a packet using a
message authentication code, CBC-MAC [?]. Semantically secure encryption1 is
made using an 8 byte initialisation vector (IV) and cipher block chaining (CBC)
as encryption scheme [?]. Taking into account both operations, two kinds of
packets can be found: TinySec-AE, that oﬀers authentication and encryption,
and TinySec-Auth, that oﬀers only authentication. A detailed view of both kinds
of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys are needed. TinySec does
not address the problem of obtaining those keys; any particular keying mecha-
nism can be used in conjunction with TinySec. In this paper we consider Local-
ized Encryption and Authentication Protocol (LEAP) [?] as the keying mech-
anism. LEAP supports the establishment of four types of keys for each sensor
node: an individual key shared with the base station, a pairwise key shared with
another sensor node, a cluster key shared with multiple neighboring nodes, and a

1 Encrypting the same plaintext two times should give two diﬀerent cipher-texts

3

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

Fig. 1. TinySec packet formats: TinySec-AE and TinySec-Auth

group key that is shared by all the nodes in the network. One interesting feature
of LEAP is that it minimises the involvement of the base station. Fig. 2 shows
the four LEAP keying mechanisms.

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

Kc

Ni

Kc

Ni

Kc

Ni

N2

N4

N3

KS

NV1

NV2

NV3

Kc

Nc

Kc

Nc

Kc

Nc

NC

Fig. 2. LEAP keying mechanisms

4

Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

In order to design a secure network, several aspects have to be considered [?]:
Key establishment and trust setup, secrecy and authentication, and privacy. Key
establishment can be considered the base of the system; a secure and eﬃcient
key distribution mechanism is needed for large scale sensor networks. Once every
node has its own keys, these are used to authenticate and encrypt (if needed) the
messages they exchange. Several protocols have been proposed in the literature
related to authentication and privacy [?,?], and key distribution [?,?,?]

In this paper we have focus in two of these protocols: TinySec [?] in the ﬁeld
of authentication and encryption, and LEAP [?] in the ﬁeld of key management.
TinySec is a fully-implemented link layer security architecture for wireless sensor
networks included in the oﬃcial TinyOS [?] release. LEAP is a powerful keying
mechanism that supports the establishment of four types of keys for each sen-
sor node with little intervention of the base station. A brief overview of these
protocols is given in Section 2.

In line with the development of security protocols, some techniques have also
been developed to model a system and check properties on it. One of the most
promising techniques in this line is model checking. Model checking [?] is a formal
methods based technique for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main advantages of this technique
is that it is automatic and allows us to see if a system works as expected. In
case the system does not work properly, the model checking tool provides a trace
that leads to the source of the error.

Model checking has become a key point in the design of concurrent and
distributed system because it allows us to ensure the correctness of a design at
the earliest stage possible. Model checking has two main advantages over two
classical techniques such as simulation and testing: i) we do not need to build a
prototype of the system, and ii) we are able to verify the system against every
single execution trace. The latter is very important because using simulation or
testing we can only ﬁnd errors, but we cannot ensure that the whole system
behaves as expected (some errors may remain hidden until the system is in
production stage).

Some general purpose model checking tools have been developed by diﬀerent
research groups: Spin, UPPAAL, Murφ. These tools allow us to verify not only
the functional properties of a system (e.g. Spin), but also the performance of
a real-time system (e.g. UPPAAL). Although we can use these general purpose
tools in order to verify security protocols, we consider that it is preferable (and
more intuitive) to use a tool devoted to the veriﬁcation of security protocols.
Among these tools we can ﬁnd Casper/FDR2 toolbox [?] and AVISPA [?].

The use of model checking tools to verify security protocols has been suc-
cessful in the past in diﬀerent areas such as Web Services [?,?,?], or Transport
Layer security protocols [?,?].

In this paper, we present a formal veriﬁcation of wireless sensor security pro-
tocols using AVISPA (Automated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level formal language HLPSL
[?] for specifying protocols and their security properties. Once we have speciﬁed

2

the model of the system, AVISPA translates it into an intermediate format IF.
This is the input of several backends that are integrated into AVISPA frame-
work: SATMC OFMC, Cl-Atse and TA4SP. Besides, only one model is speciﬁed
although it can be analysed with the four backends. AVISPA also oﬀers a graph-
ical interface SPAN [?] that helps in the specifying task.

Security in wireless networks is not an easy task due to its broadcast nature.
An intruder can overhear, intercept messages, inject new messages or modify
messages in transit. This kind of intruder is called Dolev-Yao Intruder [?]. The
intruder implemented in AVISPA is a Dolev-Yao intruder, which is appropriate
to analyse wireless security protocols.

The paper is organised as follows. In Section 2 a brief overview of TinySec
and LEAP is given. Section 3 is devoted to the formal veriﬁcation of TinySec
and LEAP, where four scenarios have been considered depending on the key
distribution mechanism used. Finally in Section 4 we give our conclusions and
future work.

2 TinySec + LEAP

TinySec [?] is a fully-implemented link layer security architecture for wireless
sensor networks. The design of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight design was made taking
into account wireless sensor networks particularities, mainly limited computation
and communication capabilities, as well as low power consumption. TinySec is
part of the oﬃcial TinyOS [?] release.

The main goals of TinySec are performance, usability and security. Inside
the security aspects, three main goals are considered: access control, message
integrity, and conﬁdentiality. Outside the scope of TinySec is to avoid replay
attacks, which is left to higher layers of the protocol stack.

TinySec considers two operations with application layer data: authentica-
tion and semantically secure encryption. TinySec authenticates a packet using a
message authentication code, CBC-MAC [?]. Semantically secure encryption1 is
made using an 8 byte initialisation vector (IV) and cipher block chaining (CBC)
as encryption scheme [?]. Taking into account both operations, two kinds of
packets can be found: TinySec-AE, that oﬀers authentication and encryption,
and TinySec-Auth, that oﬀers only authentication. A detailed view of both kinds
of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys are needed. TinySec does
not address the problem of obtaining those keys; any particular keying mecha-
nism can be used in conjunction with TinySec. In this paper we consider Local-
ized Encryption and Authentication Protocol (LEAP) [?] as the keying mech-
anism. LEAP supports the establishment of four types of keys for each sensor
node: an individual key shared with the base station, a pairwise key shared with
another sensor node, a cluster key shared with multiple neighboring nodes, and a

1 Encrypting the same plaintext two times should give two diﬀerent cipher-texts

3

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

Fig. 1. TinySec packet formats: TinySec-AE and TinySec-Auth

group key that is shared by all the nodes in the network. One interesting feature
of LEAP is that it minimises the involvement of the base station. Fig. 2 shows
the four LEAP keying mechanisms.

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

Kc

Ni

Kc

Ni

Kc

Ni

N2

N4

N3

KS

NV1

NV2

NV3

Kc

Nc

Kc

Nc

Kc

Nc

NC

Fig. 2. LEAP keying mechanisms

4

3 Veriﬁcation of TinySec + LEAP

The combination of TinySec and LEAP allows us to build a complete solution,
where LEAP is responsible of obtaining the more convenient shared key at every
moment, and TinySec is responsible of the authentication and encryption of
messages exchanged between nodes. Thus, we have considered four diﬀerent
conﬁgurations of TinySec and LEAP, depending on the key mechanism used,
and the kind and the situation of the nodes that communicate with each other:

– Case A. Request from the base node to a normal node using an individual

– Case B. Request from the base node to a normal node using an individual

key using messages TinySec-AE.

key using messages TinySec-Auth.

– Case C. Communication between immediate neighbouring nodes using a

– Case D. Communication between immediate neighbouring nodes using a

– Case E. Communication between non immediate neighbouring nodes nodes

pairwise shared key.

cluster key.

using a cluster key.

During all these analysis we will consider that before deployment, a node
master key Km has been saved inside every node in the network. We also adopt
the Dolev-Yao intruder model, where an intruder can overhear, intercept, alter,
or inject any messages into the radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3. In this case a base node
(BS) makes a request to a normal node (Ni) which has an individual (unique)
key that it shares with the base station

BS

N1

N2

N3

Fig. 3. Sensor network: cases A and B.

The protocol for TinySec-AE packets using Avispa syntax is as follows:
1. BS → Ni: IV1{(IV1 ⊕ Data1)}F (Km.Ni). {M AC(IV1.Data1)}H(Km.Ni)
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni). {M AC(IV2.Data2)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-random functions that allow
to calculate the encryption key and the authentication key taking as parameters
the master key (Km) and the id of the node (Ni). Due to Avispa does not oﬀer

5

Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

In order to design a secure network, several aspects have to be considered [?]:
Key establishment and trust setup, secrecy and authentication, and privacy. Key
establishment can be considered the base of the system; a secure and eﬃcient
key distribution mechanism is needed for large scale sensor networks. Once every
node has its own keys, these are used to authenticate and encrypt (if needed) the
messages they exchange. Several protocols have been proposed in the literature
related to authentication and privacy [?,?], and key distribution [?,?,?]

In this paper we have focus in two of these protocols: TinySec [?] in the ﬁeld
of authentication and encryption, and LEAP [?] in the ﬁeld of key management.
TinySec is a fully-implemented link layer security architecture for wireless sensor
networks included in the oﬃcial TinyOS [?] release. LEAP is a powerful keying
mechanism that supports the establishment of four types of keys for each sen-
sor node with little intervention of the base station. A brief overview of these
protocols is given in Section 2.

In line with the development of security protocols, some techniques have also
been developed to model a system and check properties on it. One of the most
promising techniques in this line is model checking. Model checking [?] is a formal
methods based technique for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main advantages of this technique
is that it is automatic and allows us to see if a system works as expected. In
case the system does not work properly, the model checking tool provides a trace
that leads to the source of the error.

Model checking has become a key point in the design of concurrent and
distributed system because it allows us to ensure the correctness of a design at
the earliest stage possible. Model checking has two main advantages over two
classical techniques such as simulation and testing: i) we do not need to build a
prototype of the system, and ii) we are able to verify the system against every
single execution trace. The latter is very important because using simulation or
testing we can only ﬁnd errors, but we cannot ensure that the whole system
behaves as expected (some errors may remain hidden until the system is in
production stage).

Some general purpose model checking tools have been developed by diﬀerent
research groups: Spin, UPPAAL, Murφ. These tools allow us to verify not only
the functional properties of a system (e.g. Spin), but also the performance of
a real-time system (e.g. UPPAAL). Although we can use these general purpose
tools in order to verify security protocols, we consider that it is preferable (and
more intuitive) to use a tool devoted to the veriﬁcation of security protocols.
Among these tools we can ﬁnd Casper/FDR2 toolbox [?] and AVISPA [?].

The use of model checking tools to verify security protocols has been suc-
cessful in the past in diﬀerent areas such as Web Services [?,?,?], or Transport
Layer security protocols [?,?].

In this paper, we present a formal veriﬁcation of wireless sensor security pro-
tocols using AVISPA (Automated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level formal language HLPSL
[?] for specifying protocols and their security properties. Once we have speciﬁed

2

the model of the system, AVISPA translates it into an intermediate format IF.
This is the input of several backends that are integrated into AVISPA frame-
work: SATMC OFMC, Cl-Atse and TA4SP. Besides, only one model is speciﬁed
although it can be analysed with the four backends. AVISPA also oﬀers a graph-
ical interface SPAN [?] that helps in the specifying task.

Security in wireless networks is not an easy task due to its broadcast nature.
An intruder can overhear, intercept messages, inject new messages or modify
messages in transit. This kind of intruder is called Dolev-Yao Intruder [?]. The
intruder implemented in AVISPA is a Dolev-Yao intruder, which is appropriate
to analyse wireless security protocols.

The paper is organised as follows. In Section 2 a brief overview of TinySec
and LEAP is given. Section 3 is devoted to the formal veriﬁcation of TinySec
and LEAP, where four scenarios have been considered depending on the key
distribution mechanism used. Finally in Section 4 we give our conclusions and
future work.

2 TinySec + LEAP

TinySec [?] is a fully-implemented link layer security architecture for wireless
sensor networks. The design of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight design was made taking
into account wireless sensor networks particularities, mainly limited computation
and communication capabilities, as well as low power consumption. TinySec is
part of the oﬃcial TinyOS [?] release.

The main goals of TinySec are performance, usability and security. Inside
the security aspects, three main goals are considered: access control, message
integrity, and conﬁdentiality. Outside the scope of TinySec is to avoid replay
attacks, which is left to higher layers of the protocol stack.

TinySec considers two operations with application layer data: authentica-
tion and semantically secure encryption. TinySec authenticates a packet using a
message authentication code, CBC-MAC [?]. Semantically secure encryption1 is
made using an 8 byte initialisation vector (IV) and cipher block chaining (CBC)
as encryption scheme [?]. Taking into account both operations, two kinds of
packets can be found: TinySec-AE, that oﬀers authentication and encryption,
and TinySec-Auth, that oﬀers only authentication. A detailed view of both kinds
of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys are needed. TinySec does
not address the problem of obtaining those keys; any particular keying mecha-
nism can be used in conjunction with TinySec. In this paper we consider Local-
ized Encryption and Authentication Protocol (LEAP) [?] as the keying mech-
anism. LEAP supports the establishment of four types of keys for each sensor
node: an individual key shared with the base station, a pairwise key shared with
another sensor node, a cluster key shared with multiple neighboring nodes, and a

1 Encrypting the same plaintext two times should give two diﬀerent cipher-texts

3

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

Fig. 1. TinySec packet formats: TinySec-AE and TinySec-Auth

group key that is shared by all the nodes in the network. One interesting feature
of LEAP is that it minimises the involvement of the base station. Fig. 2 shows
the four LEAP keying mechanisms.

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

Kc

Ni

Kc

Ni

Kc

Ni

N2

N4

N3

KS

NV1

NV2

NV3

Kc

Nc

Kc

Nc

Kc

Nc

NC

Fig. 2. LEAP keying mechanisms

4

3 Veriﬁcation of TinySec + LEAP

The combination of TinySec and LEAP allows us to build a complete solution,
where LEAP is responsible of obtaining the more convenient shared key at every
moment, and TinySec is responsible of the authentication and encryption of
messages exchanged between nodes. Thus, we have considered four diﬀerent
conﬁgurations of TinySec and LEAP, depending on the key mechanism used,
and the kind and the situation of the nodes that communicate with each other:

– Case A. Request from the base node to a normal node using an individual

– Case B. Request from the base node to a normal node using an individual

key using messages TinySec-AE.

key using messages TinySec-Auth.

– Case C. Communication between immediate neighbouring nodes using a

– Case D. Communication between immediate neighbouring nodes using a

– Case E. Communication between non immediate neighbouring nodes nodes

pairwise shared key.

cluster key.

using a cluster key.

During all these analysis we will consider that before deployment, a node
master key Km has been saved inside every node in the network. We also adopt
the Dolev-Yao intruder model, where an intruder can overhear, intercept, alter,
or inject any messages into the radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3. In this case a base node
(BS) makes a request to a normal node (Ni) which has an individual (unique)
key that it shares with the base station

BS

N1

N2

N3

Fig. 3. Sensor network: cases A and B.

The protocol for TinySec-AE packets using Avispa syntax is as follows:
1. BS → Ni: IV1{(IV1 ⊕ Data1)}F (Km.Ni). {M AC(IV1.Data1)}H(Km.Ni)
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni). {M AC(IV2.Data2)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-random functions that allow
to calculate the encryption key and the authentication key taking as parameters
the master key (Km) and the id of the node (Ni). Due to Avispa does not oﬀer

5

arithmetic semantics, the increase of the counter is represented by a function
Suc, such as Suc(0) represents 1, Suc(Suc(0) represents 2 and so on.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node Ni and the base station
(BS) share the same value for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to proof that bilateral au-
thentication is achieved by using the MAC, and the integrity of the message
is guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and Data2 are secret values
shared between Ni and BS, and they are not known by an intruder or third
parties.

The veriﬁcation with Avispa ﬁnds only the following replay attack, where

IBS represents an intruder playing the role of the base station:

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km.N1). {M AC(IV2.Data2)}H(Km.N1)
1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km.N1). {M AC(IV3.Data3)}H(Km.N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

where IV1 = N1.AM1.Size1.BS.0

where IV1 = N1.AM1.Size1.BS.0

where IV3 = BS.AM3.Size3.N1.Suc(0)

Nevertheless, as was said before, TinySec does not manage replay attacks,
which are left to higher layers of the protocol stack. Apart from this attack, the
protocol is secure, even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in the previous case (see Fig.
3), but we consider TinySec-Auth messages instead of TinySec-AE messages.
The protocol for TinySec-AE packets using Avispa syntax is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1. {M AC(Ni.AM1.Size1.Data1)}H(Km.Ni)
2. Ni → BS: BS.AM2.Size2.Data2. {M AC(BS.AM2.Size2.Data2)}H(Km.Ni)
As we mentioned before, TinySec-Auth does not provide any conﬁdentiality
mechanisms. Thus, we can only analyse the authentication of Data1 and Data2,
i.e., we can proof the bilateral authentication between BS and Ni, by means of
the MAC messages, and also the integrity of messages. As in the previous case,
we have found a replay attack that we omit

Case C. The network conﬁguration is shown in Fig. 4. In this case a node (N1)
shares a pairwise key with each of its immediate neighbours (N2 and N3). The
protocol for TinySec-AE packets using Avispa syntax is as follows, where A rep-
resents node N1 and B represents one of its neighbours (N2 or N3):

6

Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

In order to design a secure network, several aspects have to be considered [?]:
Key establishment and trust setup, secrecy and authentication, and privacy. Key
establishment can be considered the base of the system; a secure and eﬃcient
key distribution mechanism is needed for large scale sensor networks. Once every
node has its own keys, these are used to authenticate and encrypt (if needed) the
messages they exchange. Several protocols have been proposed in the literature
related to authentication and privacy [?,?], and key distribution [?,?,?]

In this paper we have focus in two of these protocols: TinySec [?] in the ﬁeld
of authentication and encryption, and LEAP [?] in the ﬁeld of key management.
TinySec is a fully-implemented link layer security architecture for wireless sensor
networks included in the oﬃcial TinyOS [?] release. LEAP is a powerful keying
mechanism that supports the establishment of four types of keys for each sen-
sor node with little intervention of the base station. A brief overview of these
protocols is given in Section 2.

In line with the development of security protocols, some techniques have also
been developed to model a system and check properties on it. One of the most
promising techniques in this line is model checking. Model checking [?] is a formal
methods based technique for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main advantages of this technique
is that it is automatic and allows us to see if a system works as expected. In
case the system does not work properly, the model checking tool provides a trace
that leads to the source of the error.

Model checking has become a key point in the design of concurrent and
distributed system because it allows us to ensure the correctness of a design at
the earliest stage possible. Model checking has two main advantages over two
classical techniques such as simulation and testing: i) we do not need to build a
prototype of the system, and ii) we are able to verify the system against every
single execution trace. The latter is very important because using simulation or
testing we can only ﬁnd errors, but we cannot ensure that the whole system
behaves as expected (some errors may remain hidden until the system is in
production stage).

Some general purpose model checking tools have been developed by diﬀerent
research groups: Spin, UPPAAL, Murφ. These tools allow us to verify not only
the functional properties of a system (e.g. Spin), but also the performance of
a real-time system (e.g. UPPAAL). Although we can use these general purpose
tools in order to verify security protocols, we consider that it is preferable (and
more intuitive) to use a tool devoted to the veriﬁcation of security protocols.
Among these tools we can ﬁnd Casper/FDR2 toolbox [?] and AVISPA [?].

The use of model checking tools to verify security protocols has been suc-
cessful in the past in diﬀerent areas such as Web Services [?,?,?], or Transport
Layer security protocols [?,?].

In this paper, we present a formal veriﬁcation of wireless sensor security pro-
tocols using AVISPA (Automated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level formal language HLPSL
[?] for specifying protocols and their security properties. Once we have speciﬁed

2

the model of the system, AVISPA translates it into an intermediate format IF.
This is the input of several backends that are integrated into AVISPA frame-
work: SATMC OFMC, Cl-Atse and TA4SP. Besides, only one model is speciﬁed
although it can be analysed with the four backends. AVISPA also oﬀers a graph-
ical interface SPAN [?] that helps in the specifying task.

Security in wireless networks is not an easy task due to its broadcast nature.
An intruder can overhear, intercept messages, inject new messages or modify
messages in transit. This kind of intruder is called Dolev-Yao Intruder [?]. The
intruder implemented in AVISPA is a Dolev-Yao intruder, which is appropriate
to analyse wireless security protocols.

The paper is organised as follows. In Section 2 a brief overview of TinySec
and LEAP is given. Section 3 is devoted to the formal veriﬁcation of TinySec
and LEAP, where four scenarios have been considered depending on the key
distribution mechanism used. Finally in Section 4 we give our conclusions and
future work.

2 TinySec + LEAP

TinySec [?] is a fully-implemented link layer security architecture for wireless
sensor networks. The design of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight design was made taking
into account wireless sensor networks particularities, mainly limited computation
and communication capabilities, as well as low power consumption. TinySec is
part of the oﬃcial TinyOS [?] release.

The main goals of TinySec are performance, usability and security. Inside
the security aspects, three main goals are considered: access control, message
integrity, and conﬁdentiality. Outside the scope of TinySec is to avoid replay
attacks, which is left to higher layers of the protocol stack.

TinySec considers two operations with application layer data: authentica-
tion and semantically secure encryption. TinySec authenticates a packet using a
message authentication code, CBC-MAC [?]. Semantically secure encryption1 is
made using an 8 byte initialisation vector (IV) and cipher block chaining (CBC)
as encryption scheme [?]. Taking into account both operations, two kinds of
packets can be found: TinySec-AE, that oﬀers authentication and encryption,
and TinySec-Auth, that oﬀers only authentication. A detailed view of both kinds
of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys are needed. TinySec does
not address the problem of obtaining those keys; any particular keying mecha-
nism can be used in conjunction with TinySec. In this paper we consider Local-
ized Encryption and Authentication Protocol (LEAP) [?] as the keying mech-
anism. LEAP supports the establishment of four types of keys for each sensor
node: an individual key shared with the base station, a pairwise key shared with
another sensor node, a cluster key shared with multiple neighboring nodes, and a

1 Encrypting the same plaintext two times should give two diﬀerent cipher-texts

3

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

Fig. 1. TinySec packet formats: TinySec-AE and TinySec-Auth

group key that is shared by all the nodes in the network. One interesting feature
of LEAP is that it minimises the involvement of the base station. Fig. 2 shows
the four LEAP keying mechanisms.

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

Kc

Ni

Kc

Ni

Kc

Ni

N2

N4

N3

KS

NV1

NV2

NV3

Kc

Nc

Kc

Nc

Kc

Nc

NC

Fig. 2. LEAP keying mechanisms

4

3 Veriﬁcation of TinySec + LEAP

The combination of TinySec and LEAP allows us to build a complete solution,
where LEAP is responsible of obtaining the more convenient shared key at every
moment, and TinySec is responsible of the authentication and encryption of
messages exchanged between nodes. Thus, we have considered four diﬀerent
conﬁgurations of TinySec and LEAP, depending on the key mechanism used,
and the kind and the situation of the nodes that communicate with each other:

– Case A. Request from the base node to a normal node using an individual

– Case B. Request from the base node to a normal node using an individual

key using messages TinySec-AE.

key using messages TinySec-Auth.

– Case C. Communication between immediate neighbouring nodes using a

– Case D. Communication between immediate neighbouring nodes using a

– Case E. Communication between non immediate neighbouring nodes nodes

pairwise shared key.

cluster key.

using a cluster key.

During all these analysis we will consider that before deployment, a node
master key Km has been saved inside every node in the network. We also adopt
the Dolev-Yao intruder model, where an intruder can overhear, intercept, alter,
or inject any messages into the radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3. In this case a base node
(BS) makes a request to a normal node (Ni) which has an individual (unique)
key that it shares with the base station

BS

N1

N2

N3

Fig. 3. Sensor network: cases A and B.

The protocol for TinySec-AE packets using Avispa syntax is as follows:
1. BS → Ni: IV1{(IV1 ⊕ Data1)}F (Km.Ni). {M AC(IV1.Data1)}H(Km.Ni)
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni). {M AC(IV2.Data2)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-random functions that allow
to calculate the encryption key and the authentication key taking as parameters
the master key (Km) and the id of the node (Ni). Due to Avispa does not oﬀer

5

arithmetic semantics, the increase of the counter is represented by a function
Suc, such as Suc(0) represents 1, Suc(Suc(0) represents 2 and so on.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node Ni and the base station
(BS) share the same value for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to proof that bilateral au-
thentication is achieved by using the MAC, and the integrity of the message
is guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and Data2 are secret values
shared between Ni and BS, and they are not known by an intruder or third
parties.

The veriﬁcation with Avispa ﬁnds only the following replay attack, where

IBS represents an intruder playing the role of the base station:

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km.N1). {M AC(IV2.Data2)}H(Km.N1)
1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km.N1). {M AC(IV3.Data3)}H(Km.N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

where IV1 = N1.AM1.Size1.BS.0

where IV1 = N1.AM1.Size1.BS.0

where IV3 = BS.AM3.Size3.N1.Suc(0)

Nevertheless, as was said before, TinySec does not manage replay attacks,
which are left to higher layers of the protocol stack. Apart from this attack, the
protocol is secure, even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in the previous case (see Fig.
3), but we consider TinySec-Auth messages instead of TinySec-AE messages.
The protocol for TinySec-AE packets using Avispa syntax is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1. {M AC(Ni.AM1.Size1.Data1)}H(Km.Ni)
2. Ni → BS: BS.AM2.Size2.Data2. {M AC(BS.AM2.Size2.Data2)}H(Km.Ni)
As we mentioned before, TinySec-Auth does not provide any conﬁdentiality
mechanisms. Thus, we can only analyse the authentication of Data1 and Data2,
i.e., we can proof the bilateral authentication between BS and Ni, by means of
the MAC messages, and also the integrity of messages. As in the previous case,
we have found a replay attack that we omit

Case C. The network conﬁguration is shown in Fig. 4. In this case a node (N1)
shares a pairwise key with each of its immediate neighbours (N2 and N3). The
protocol for TinySec-AE packets using Avispa syntax is as follows, where A rep-
resents node N1 and B represents one of its neighbours (N2 or N3):

6

1. A → B : A, N onceA
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K0

AB = H(H(Km.B).A)

where K0

AB

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

N1

N3

N2

Fig. 4. Sensor network: cases C and D

The properties we have to analyse are the following:

– Authentication of N onceA, DataA and DataB. i.e., nodes A and B share
the same value for N onceA, DataA and DataB and both execute the same
session of the protocol.

– Conﬁdentiality of DataB, i.e., DataB is a secret value shared between A and

B, and remains unknown to an intruder or third parties.
In this case Avispa ﬁnds a man-in-the-middle attack, where IA represents
the intruder playing the role of node A, IB2 represents the intruder playing the
role of node B, B1 represents node B communicating with the intruder, and B2
represents node B communicating with A:

1. IA → B1 : A, N onceI
2. B1 → IA : B.{M AC(N onceI .B)}H(Km.B)
1. A → IB2 : A, N onceA
2. IA → B2 : Nx.N onceA
2. B2 → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → IB2 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
3. IA → B1 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B1 → IA : A.AM2.Size2.B.Counter.{(IV2 ⊕ DataB)}KAB .

AB

AB

{M AC(IV2.DataB)}K0

AB

First the intruder, playing the role of A, starts the protocol with B (denoted
B1), and sends a false nonce, which is answered by B (B1). Then, A starts
a session with B (B2) but this message is intercepted by the intruder (IB2)
which modiﬁes the message and sends to B (B2) the identity of a false node Nx
and the nonce of A. Node B (B2) sends the answer of the last message to A,
and A responds with a request of data (Data2) to B (B2). Again, the request
is intercepted by the intruder who redirects the message to B (B1). At this
moment, B (B1) thinks that it has received a correct request from A, and then
it sends DataB to the intruder playing the role of A (IA)

7

Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

In order to design a secure network, several aspects have to be considered [?]:
Key establishment and trust setup, secrecy and authentication, and privacy. Key
establishment can be considered the base of the system; a secure and eﬃcient
key distribution mechanism is needed for large scale sensor networks. Once every
node has its own keys, these are used to authenticate and encrypt (if needed) the
messages they exchange. Several protocols have been proposed in the literature
related to authentication and privacy [?,?], and key distribution [?,?,?]

In this paper we have focus in two of these protocols: TinySec [?] in the ﬁeld
of authentication and encryption, and LEAP [?] in the ﬁeld of key management.
TinySec is a fully-implemented link layer security architecture for wireless sensor
networks included in the oﬃcial TinyOS [?] release. LEAP is a powerful keying
mechanism that supports the establishment of four types of keys for each sen-
sor node with little intervention of the base station. A brief overview of these
protocols is given in Section 2.

In line with the development of security protocols, some techniques have also
been developed to model a system and check properties on it. One of the most
promising techniques in this line is model checking. Model checking [?] is a formal
methods based technique for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main advantages of this technique
is that it is automatic and allows us to see if a system works as expected. In
case the system does not work properly, the model checking tool provides a trace
that leads to the source of the error.

Model checking has become a key point in the design of concurrent and
distributed system because it allows us to ensure the correctness of a design at
the earliest stage possible. Model checking has two main advantages over two
classical techniques such as simulation and testing: i) we do not need to build a
prototype of the system, and ii) we are able to verify the system against every
single execution trace. The latter is very important because using simulation or
testing we can only ﬁnd errors, but we cannot ensure that the whole system
behaves as expected (some errors may remain hidden until the system is in
production stage).

Some general purpose model checking tools have been developed by diﬀerent
research groups: Spin, UPPAAL, Murφ. These tools allow us to verify not only
the functional properties of a system (e.g. Spin), but also the performance of
a real-time system (e.g. UPPAAL). Although we can use these general purpose
tools in order to verify security protocols, we consider that it is preferable (and
more intuitive) to use a tool devoted to the veriﬁcation of security protocols.
Among these tools we can ﬁnd Casper/FDR2 toolbox [?] and AVISPA [?].

The use of model checking tools to verify security protocols has been suc-
cessful in the past in diﬀerent areas such as Web Services [?,?,?], or Transport
Layer security protocols [?,?].

In this paper, we present a formal veriﬁcation of wireless sensor security pro-
tocols using AVISPA (Automated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level formal language HLPSL
[?] for specifying protocols and their security properties. Once we have speciﬁed

2

the model of the system, AVISPA translates it into an intermediate format IF.
This is the input of several backends that are integrated into AVISPA frame-
work: SATMC OFMC, Cl-Atse and TA4SP. Besides, only one model is speciﬁed
although it can be analysed with the four backends. AVISPA also oﬀers a graph-
ical interface SPAN [?] that helps in the specifying task.

Security in wireless networks is not an easy task due to its broadcast nature.
An intruder can overhear, intercept messages, inject new messages or modify
messages in transit. This kind of intruder is called Dolev-Yao Intruder [?]. The
intruder implemented in AVISPA is a Dolev-Yao intruder, which is appropriate
to analyse wireless security protocols.

The paper is organised as follows. In Section 2 a brief overview of TinySec
and LEAP is given. Section 3 is devoted to the formal veriﬁcation of TinySec
and LEAP, where four scenarios have been considered depending on the key
distribution mechanism used. Finally in Section 4 we give our conclusions and
future work.

2 TinySec + LEAP

TinySec [?] is a fully-implemented link layer security architecture for wireless
sensor networks. The design of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight design was made taking
into account wireless sensor networks particularities, mainly limited computation
and communication capabilities, as well as low power consumption. TinySec is
part of the oﬃcial TinyOS [?] release.

The main goals of TinySec are performance, usability and security. Inside
the security aspects, three main goals are considered: access control, message
integrity, and conﬁdentiality. Outside the scope of TinySec is to avoid replay
attacks, which is left to higher layers of the protocol stack.

TinySec considers two operations with application layer data: authentica-
tion and semantically secure encryption. TinySec authenticates a packet using a
message authentication code, CBC-MAC [?]. Semantically secure encryption1 is
made using an 8 byte initialisation vector (IV) and cipher block chaining (CBC)
as encryption scheme [?]. Taking into account both operations, two kinds of
packets can be found: TinySec-AE, that oﬀers authentication and encryption,
and TinySec-Auth, that oﬀers only authentication. A detailed view of both kinds
of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys are needed. TinySec does
not address the problem of obtaining those keys; any particular keying mecha-
nism can be used in conjunction with TinySec. In this paper we consider Local-
ized Encryption and Authentication Protocol (LEAP) [?] as the keying mech-
anism. LEAP supports the establishment of four types of keys for each sensor
node: an individual key shared with the base station, a pairwise key shared with
another sensor node, a cluster key shared with multiple neighboring nodes, and a

1 Encrypting the same plaintext two times should give two diﬀerent cipher-texts

3

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

Fig. 1. TinySec packet formats: TinySec-AE and TinySec-Auth

group key that is shared by all the nodes in the network. One interesting feature
of LEAP is that it minimises the involvement of the base station. Fig. 2 shows
the four LEAP keying mechanisms.

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

Kc

Ni

Kc

Ni

Kc

Ni

N2

N4

N3

KS

NV1

NV2

NV3

Kc

Nc

Kc

Nc

Kc

Nc

NC

Fig. 2. LEAP keying mechanisms

4

3 Veriﬁcation of TinySec + LEAP

The combination of TinySec and LEAP allows us to build a complete solution,
where LEAP is responsible of obtaining the more convenient shared key at every
moment, and TinySec is responsible of the authentication and encryption of
messages exchanged between nodes. Thus, we have considered four diﬀerent
conﬁgurations of TinySec and LEAP, depending on the key mechanism used,
and the kind and the situation of the nodes that communicate with each other:

– Case A. Request from the base node to a normal node using an individual

– Case B. Request from the base node to a normal node using an individual

key using messages TinySec-AE.

key using messages TinySec-Auth.

– Case C. Communication between immediate neighbouring nodes using a

– Case D. Communication between immediate neighbouring nodes using a

– Case E. Communication between non immediate neighbouring nodes nodes

pairwise shared key.

cluster key.

using a cluster key.

During all these analysis we will consider that before deployment, a node
master key Km has been saved inside every node in the network. We also adopt
the Dolev-Yao intruder model, where an intruder can overhear, intercept, alter,
or inject any messages into the radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3. In this case a base node
(BS) makes a request to a normal node (Ni) which has an individual (unique)
key that it shares with the base station

BS

N1

N2

N3

Fig. 3. Sensor network: cases A and B.

The protocol for TinySec-AE packets using Avispa syntax is as follows:
1. BS → Ni: IV1{(IV1 ⊕ Data1)}F (Km.Ni). {M AC(IV1.Data1)}H(Km.Ni)
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni). {M AC(IV2.Data2)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-random functions that allow
to calculate the encryption key and the authentication key taking as parameters
the master key (Km) and the id of the node (Ni). Due to Avispa does not oﬀer

5

arithmetic semantics, the increase of the counter is represented by a function
Suc, such as Suc(0) represents 1, Suc(Suc(0) represents 2 and so on.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node Ni and the base station
(BS) share the same value for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to proof that bilateral au-
thentication is achieved by using the MAC, and the integrity of the message
is guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and Data2 are secret values
shared between Ni and BS, and they are not known by an intruder or third
parties.

The veriﬁcation with Avispa ﬁnds only the following replay attack, where

IBS represents an intruder playing the role of the base station:

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km.N1). {M AC(IV2.Data2)}H(Km.N1)
1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km.N1). {M AC(IV3.Data3)}H(Km.N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

where IV1 = N1.AM1.Size1.BS.0

where IV1 = N1.AM1.Size1.BS.0

where IV3 = BS.AM3.Size3.N1.Suc(0)

Nevertheless, as was said before, TinySec does not manage replay attacks,
which are left to higher layers of the protocol stack. Apart from this attack, the
protocol is secure, even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in the previous case (see Fig.
3), but we consider TinySec-Auth messages instead of TinySec-AE messages.
The protocol for TinySec-AE packets using Avispa syntax is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1. {M AC(Ni.AM1.Size1.Data1)}H(Km.Ni)
2. Ni → BS: BS.AM2.Size2.Data2. {M AC(BS.AM2.Size2.Data2)}H(Km.Ni)
As we mentioned before, TinySec-Auth does not provide any conﬁdentiality
mechanisms. Thus, we can only analyse the authentication of Data1 and Data2,
i.e., we can proof the bilateral authentication between BS and Ni, by means of
the MAC messages, and also the integrity of messages. As in the previous case,
we have found a replay attack that we omit

Case C. The network conﬁguration is shown in Fig. 4. In this case a node (N1)
shares a pairwise key with each of its immediate neighbours (N2 and N3). The
protocol for TinySec-AE packets using Avispa syntax is as follows, where A rep-
resents node N1 and B represents one of its neighbours (N2 or N3):

6

1. A → B : A, N onceA
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K0

AB = H(H(Km.B).A)

where K0

AB

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

N1

N3

N2

Fig. 4. Sensor network: cases C and D

The properties we have to analyse are the following:

– Authentication of N onceA, DataA and DataB. i.e., nodes A and B share
the same value for N onceA, DataA and DataB and both execute the same
session of the protocol.

– Conﬁdentiality of DataB, i.e., DataB is a secret value shared between A and

B, and remains unknown to an intruder or third parties.
In this case Avispa ﬁnds a man-in-the-middle attack, where IA represents
the intruder playing the role of node A, IB2 represents the intruder playing the
role of node B, B1 represents node B communicating with the intruder, and B2
represents node B communicating with A:

1. IA → B1 : A, N onceI
2. B1 → IA : B.{M AC(N onceI .B)}H(Km.B)
1. A → IB2 : A, N onceA
2. IA → B2 : Nx.N onceA
2. B2 → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → IB2 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
3. IA → B1 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B1 → IA : A.AM2.Size2.B.Counter.{(IV2 ⊕ DataB)}KAB .

AB

AB

{M AC(IV2.DataB)}K0

AB

First the intruder, playing the role of A, starts the protocol with B (denoted
B1), and sends a false nonce, which is answered by B (B1). Then, A starts
a session with B (B2) but this message is intercepted by the intruder (IB2)
which modiﬁes the message and sends to B (B2) the identity of a false node Nx
and the nonce of A. Node B (B2) sends the answer of the last message to A,
and A responds with a request of data (Data2) to B (B2). Again, the request
is intercepted by the intruder who redirects the message to B (B1). At this
moment, B (B1) thinks that it has received a correct request from A, and then
it sends DataB to the intruder playing the role of A (IA)

7

At the end we conclude that B1 has exchanged information (Data2) with
the intruder, and B2 thinks that it has talked to a node Nx that does not exist.
A solution to this attack consists in authenticate no only the answer from B
in message 2 but also the message 1 sent from A. The modiﬁed version of the
protocol is:

1. A → B : A.N onceA.M AC(A.N onceA)H(Km,A)
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K0

AB = H(H(Km.B).A)

where K0

AB

AB

where IV2 = A.AM2.Size2.B.Counter y KAB = F (F (Km.N2).N1)

Case D. Sensor network conﬁguration is shown in Fig. 4. In this case a node
(N1) shares a cluster key with each of its immediate neighbours (N2 and N3).
The protocol for TinySec-AE packets using Avispa syntax is as follows, where
A represents node N1, B represents one of its neighbours (N2 or N3), and Kc is
the cluster key:

1. A → B : B.AM1.Size1.A.Counter.{(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K0
where IV1 = B.AM1.Size1.A.Counter, KAB = F (F (Km.B).A) and
K0

AB = H(H(Km.B).A)

2. B → A : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}H(Kc)
4. B → A : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

AB

where IV2 = A.AM2.Size2.B.Suc(Counter)

The properties we have to analyse are the following:

– Authentication of Kc, DataA and DataB. i.e., nodes A and B share the same
value for Kc, DataA and DataB and both execute the same session of the
protocol.

– Conﬁdentiality of DataB and Kc, i.e., DataB and Kc are secret values shared
between A and B, and they remain unknown to an intruder or third parties.
After analysing the protocol with Avispa, an interesting attack based on

types was found:

1. A → B : B.AM1.Size1.A.Counter.{(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K0

AB

where IV1 = B.AM1.Size1.A.Counter,
KAB = F (F (Km.B).A) and K0

2. B → IA : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
3. IA → B : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
4. B → IA : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

AB = H(H(Km.B).A)

where IV2 = A.AM2.Size2.B.Suc(Counter)

In this attack the intruder intercepts the message sent from B to A in step
2. In step 3, the intruder sends the intercepted message back to B as if was a
true request from A to B. B takes the message as a request an misunderstands
the label done as it was DataA. In step 4, B sends DataB to the intruder.

8

Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

In order to design a secure network, several aspects have to be considered [?]:
Key establishment and trust setup, secrecy and authentication, and privacy. Key
establishment can be considered the base of the system; a secure and eﬃcient
key distribution mechanism is needed for large scale sensor networks. Once every
node has its own keys, these are used to authenticate and encrypt (if needed) the
messages they exchange. Several protocols have been proposed in the literature
related to authentication and privacy [?,?], and key distribution [?,?,?]

In this paper we have focus in two of these protocols: TinySec [?] in the ﬁeld
of authentication and encryption, and LEAP [?] in the ﬁeld of key management.
TinySec is a fully-implemented link layer security architecture for wireless sensor
networks included in the oﬃcial TinyOS [?] release. LEAP is a powerful keying
mechanism that supports the establishment of four types of keys for each sen-
sor node with little intervention of the base station. A brief overview of these
protocols is given in Section 2.

In line with the development of security protocols, some techniques have also
been developed to model a system and check properties on it. One of the most
promising techniques in this line is model checking. Model checking [?] is a formal
methods based technique for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main advantages of this technique
is that it is automatic and allows us to see if a system works as expected. In
case the system does not work properly, the model checking tool provides a trace
that leads to the source of the error.

Model checking has become a key point in the design of concurrent and
distributed system because it allows us to ensure the correctness of a design at
the earliest stage possible. Model checking has two main advantages over two
classical techniques such as simulation and testing: i) we do not need to build a
prototype of the system, and ii) we are able to verify the system against every
single execution trace. The latter is very important because using simulation or
testing we can only ﬁnd errors, but we cannot ensure that the whole system
behaves as expected (some errors may remain hidden until the system is in
production stage).

Some general purpose model checking tools have been developed by diﬀerent
research groups: Spin, UPPAAL, Murφ. These tools allow us to verify not only
the functional properties of a system (e.g. Spin), but also the performance of
a real-time system (e.g. UPPAAL). Although we can use these general purpose
tools in order to verify security protocols, we consider that it is preferable (and
more intuitive) to use a tool devoted to the veriﬁcation of security protocols.
Among these tools we can ﬁnd Casper/FDR2 toolbox [?] and AVISPA [?].

The use of model checking tools to verify security protocols has been suc-
cessful in the past in diﬀerent areas such as Web Services [?,?,?], or Transport
Layer security protocols [?,?].

In this paper, we present a formal veriﬁcation of wireless sensor security pro-
tocols using AVISPA (Automated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level formal language HLPSL
[?] for specifying protocols and their security properties. Once we have speciﬁed

2

the model of the system, AVISPA translates it into an intermediate format IF.
This is the input of several backends that are integrated into AVISPA frame-
work: SATMC OFMC, Cl-Atse and TA4SP. Besides, only one model is speciﬁed
although it can be analysed with the four backends. AVISPA also oﬀers a graph-
ical interface SPAN [?] that helps in the specifying task.

Security in wireless networks is not an easy task due to its broadcast nature.
An intruder can overhear, intercept messages, inject new messages or modify
messages in transit. This kind of intruder is called Dolev-Yao Intruder [?]. The
intruder implemented in AVISPA is a Dolev-Yao intruder, which is appropriate
to analyse wireless security protocols.

The paper is organised as follows. In Section 2 a brief overview of TinySec
and LEAP is given. Section 3 is devoted to the formal veriﬁcation of TinySec
and LEAP, where four scenarios have been considered depending on the key
distribution mechanism used. Finally in Section 4 we give our conclusions and
future work.

2 TinySec + LEAP

TinySec [?] is a fully-implemented link layer security architecture for wireless
sensor networks. The design of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight design was made taking
into account wireless sensor networks particularities, mainly limited computation
and communication capabilities, as well as low power consumption. TinySec is
part of the oﬃcial TinyOS [?] release.

The main goals of TinySec are performance, usability and security. Inside
the security aspects, three main goals are considered: access control, message
integrity, and conﬁdentiality. Outside the scope of TinySec is to avoid replay
attacks, which is left to higher layers of the protocol stack.

TinySec considers two operations with application layer data: authentica-
tion and semantically secure encryption. TinySec authenticates a packet using a
message authentication code, CBC-MAC [?]. Semantically secure encryption1 is
made using an 8 byte initialisation vector (IV) and cipher block chaining (CBC)
as encryption scheme [?]. Taking into account both operations, two kinds of
packets can be found: TinySec-AE, that oﬀers authentication and encryption,
and TinySec-Auth, that oﬀers only authentication. A detailed view of both kinds
of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys are needed. TinySec does
not address the problem of obtaining those keys; any particular keying mecha-
nism can be used in conjunction with TinySec. In this paper we consider Local-
ized Encryption and Authentication Protocol (LEAP) [?] as the keying mech-
anism. LEAP supports the establishment of four types of keys for each sensor
node: an individual key shared with the base station, a pairwise key shared with
another sensor node, a cluster key shared with multiple neighboring nodes, and a

1 Encrypting the same plaintext two times should give two diﬀerent cipher-texts

3

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

Fig. 1. TinySec packet formats: TinySec-AE and TinySec-Auth

group key that is shared by all the nodes in the network. One interesting feature
of LEAP is that it minimises the involvement of the base station. Fig. 2 shows
the four LEAP keying mechanisms.

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

Kc

Ni

Kc

Ni

Kc

Ni

N2

N4

N3

KS

NV1

NV2

NV3

Kc

Nc

Kc

Nc

Kc

Nc

NC

Fig. 2. LEAP keying mechanisms

4

3 Veriﬁcation of TinySec + LEAP

The combination of TinySec and LEAP allows us to build a complete solution,
where LEAP is responsible of obtaining the more convenient shared key at every
moment, and TinySec is responsible of the authentication and encryption of
messages exchanged between nodes. Thus, we have considered four diﬀerent
conﬁgurations of TinySec and LEAP, depending on the key mechanism used,
and the kind and the situation of the nodes that communicate with each other:

– Case A. Request from the base node to a normal node using an individual

– Case B. Request from the base node to a normal node using an individual

key using messages TinySec-AE.

key using messages TinySec-Auth.

– Case C. Communication between immediate neighbouring nodes using a

– Case D. Communication between immediate neighbouring nodes using a

– Case E. Communication between non immediate neighbouring nodes nodes

pairwise shared key.

cluster key.

using a cluster key.

During all these analysis we will consider that before deployment, a node
master key Km has been saved inside every node in the network. We also adopt
the Dolev-Yao intruder model, where an intruder can overhear, intercept, alter,
or inject any messages into the radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3. In this case a base node
(BS) makes a request to a normal node (Ni) which has an individual (unique)
key that it shares with the base station

BS

N1

N2

N3

Fig. 3. Sensor network: cases A and B.

The protocol for TinySec-AE packets using Avispa syntax is as follows:
1. BS → Ni: IV1{(IV1 ⊕ Data1)}F (Km.Ni). {M AC(IV1.Data1)}H(Km.Ni)
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni). {M AC(IV2.Data2)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-random functions that allow
to calculate the encryption key and the authentication key taking as parameters
the master key (Km) and the id of the node (Ni). Due to Avispa does not oﬀer

5

arithmetic semantics, the increase of the counter is represented by a function
Suc, such as Suc(0) represents 1, Suc(Suc(0) represents 2 and so on.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node Ni and the base station
(BS) share the same value for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to proof that bilateral au-
thentication is achieved by using the MAC, and the integrity of the message
is guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and Data2 are secret values
shared between Ni and BS, and they are not known by an intruder or third
parties.

The veriﬁcation with Avispa ﬁnds only the following replay attack, where

IBS represents an intruder playing the role of the base station:

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km.N1). {M AC(IV2.Data2)}H(Km.N1)
1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km.N1). {M AC(IV3.Data3)}H(Km.N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

where IV1 = N1.AM1.Size1.BS.0

where IV1 = N1.AM1.Size1.BS.0

where IV3 = BS.AM3.Size3.N1.Suc(0)

Nevertheless, as was said before, TinySec does not manage replay attacks,
which are left to higher layers of the protocol stack. Apart from this attack, the
protocol is secure, even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in the previous case (see Fig.
3), but we consider TinySec-Auth messages instead of TinySec-AE messages.
The protocol for TinySec-AE packets using Avispa syntax is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1. {M AC(Ni.AM1.Size1.Data1)}H(Km.Ni)
2. Ni → BS: BS.AM2.Size2.Data2. {M AC(BS.AM2.Size2.Data2)}H(Km.Ni)
As we mentioned before, TinySec-Auth does not provide any conﬁdentiality
mechanisms. Thus, we can only analyse the authentication of Data1 and Data2,
i.e., we can proof the bilateral authentication between BS and Ni, by means of
the MAC messages, and also the integrity of messages. As in the previous case,
we have found a replay attack that we omit

Case C. The network conﬁguration is shown in Fig. 4. In this case a node (N1)
shares a pairwise key with each of its immediate neighbours (N2 and N3). The
protocol for TinySec-AE packets using Avispa syntax is as follows, where A rep-
resents node N1 and B represents one of its neighbours (N2 or N3):

6

1. A → B : A, N onceA
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K0

AB = H(H(Km.B).A)

where K0

AB

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

N1

N3

N2

Fig. 4. Sensor network: cases C and D

The properties we have to analyse are the following:

– Authentication of N onceA, DataA and DataB. i.e., nodes A and B share
the same value for N onceA, DataA and DataB and both execute the same
session of the protocol.

– Conﬁdentiality of DataB, i.e., DataB is a secret value shared between A and

B, and remains unknown to an intruder or third parties.
In this case Avispa ﬁnds a man-in-the-middle attack, where IA represents
the intruder playing the role of node A, IB2 represents the intruder playing the
role of node B, B1 represents node B communicating with the intruder, and B2
represents node B communicating with A:

1. IA → B1 : A, N onceI
2. B1 → IA : B.{M AC(N onceI .B)}H(Km.B)
1. A → IB2 : A, N onceA
2. IA → B2 : Nx.N onceA
2. B2 → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → IB2 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
3. IA → B1 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B1 → IA : A.AM2.Size2.B.Counter.{(IV2 ⊕ DataB)}KAB .

AB

AB

{M AC(IV2.DataB)}K0

AB

First the intruder, playing the role of A, starts the protocol with B (denoted
B1), and sends a false nonce, which is answered by B (B1). Then, A starts
a session with B (B2) but this message is intercepted by the intruder (IB2)
which modiﬁes the message and sends to B (B2) the identity of a false node Nx
and the nonce of A. Node B (B2) sends the answer of the last message to A,
and A responds with a request of data (Data2) to B (B2). Again, the request
is intercepted by the intruder who redirects the message to B (B1). At this
moment, B (B1) thinks that it has received a correct request from A, and then
it sends DataB to the intruder playing the role of A (IA)

7

At the end we conclude that B1 has exchanged information (Data2) with
the intruder, and B2 thinks that it has talked to a node Nx that does not exist.
A solution to this attack consists in authenticate no only the answer from B
in message 2 but also the message 1 sent from A. The modiﬁed version of the
protocol is:

1. A → B : A.N onceA.M AC(A.N onceA)H(Km,A)
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K0

AB = H(H(Km.B).A)

where K0

AB

AB

where IV2 = A.AM2.Size2.B.Counter y KAB = F (F (Km.N2).N1)

Case D. Sensor network conﬁguration is shown in Fig. 4. In this case a node
(N1) shares a cluster key with each of its immediate neighbours (N2 and N3).
The protocol for TinySec-AE packets using Avispa syntax is as follows, where
A represents node N1, B represents one of its neighbours (N2 or N3), and Kc is
the cluster key:

1. A → B : B.AM1.Size1.A.Counter.{(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K0
where IV1 = B.AM1.Size1.A.Counter, KAB = F (F (Km.B).A) and
K0

AB = H(H(Km.B).A)

2. B → A : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}H(Kc)
4. B → A : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

AB

where IV2 = A.AM2.Size2.B.Suc(Counter)

The properties we have to analyse are the following:

– Authentication of Kc, DataA and DataB. i.e., nodes A and B share the same
value for Kc, DataA and DataB and both execute the same session of the
protocol.

– Conﬁdentiality of DataB and Kc, i.e., DataB and Kc are secret values shared
between A and B, and they remain unknown to an intruder or third parties.
After analysing the protocol with Avispa, an interesting attack based on

types was found:

1. A → B : B.AM1.Size1.A.Counter.{(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K0

AB

where IV1 = B.AM1.Size1.A.Counter,
KAB = F (F (Km.B).A) and K0

2. B → IA : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
3. IA → B : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
4. B → IA : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

AB = H(H(Km.B).A)

where IV2 = A.AM2.Size2.B.Suc(Counter)

In this attack the intruder intercepts the message sent from B to A in step
2. In step 3, the intruder sends the intercepted message back to B as if was a
true request from A to B. B takes the message as a request an misunderstands
the label done as it was DataA. In step 4, B sends DataB to the intruder.

8

This is a type ﬂaw attack, i.e., type checking has not be done and a constant
label has been interpreted as a variable data. One solution to this attack has been
proposed by Heather et al. in [?] which basically consists in tagging each ﬁeld
with information about its type, although this solution could not be adequate
in wireless sensor networks because it adds some extra bits of information into
each message. In real implementations of the protocol, programmers should take
into account this type ﬂaw attack and do type checking in order to avoid a
possible attack. In any case, this kind of attack can be a problem because network
bandwidth could be saturated and there is a consumption of resources in the
node.

Case E. Sensor network conﬁguration is shown in Fig. 5. In this case a node
(e.g. N1) shares a cluster key with non immediate neighbouring nodes (e.g. N4
and N5).

N1

N3

N2

N4

N5

Fig. 5. Sensor Network: Case E

The protocol for TinySec-AE packets using Avispa syntax is as follows, where
A represents node N1, B represents a non neighbour node (N4 or N5), Ni rep-
resents a neighbour node (N2 and N3):

Q. A → Ni : A, B
R. Ni → A : A.AM1.Size1.Ni.{M AC(A.AM1.Size1.Ni)}K0
1 . A → Ni : IV2.F (SKi, 0).{(IV2 ⊕ SKi)}KANi
. {M AC(IV2.SKi.F (SKi, 0))}K0
where IV2 = Ni.AM2.Size2.A.Counter
2 . Ni → B : IV3.F (SKi, 0).{(IV3 ⊕ SKi)}KNiB . {M AC(IV3.SKi.F (SKi, 0))}K0

ANi

ANi

NiB

D. B → A : A.AM4.Size4.done{M AC(A.AM4.Size4.done)}Sk

where IV3 = B.AM3.Size3.Ni.Counter
When B has every SKi
where Sk = Sk1 ⊕ . . . ⊕ Skn

Avispa only ﬁnds a replay attack, that we do not consider. Apart from this

attack, the protocol is secure.

4 Conclusions and Future Work

In this paper we have presented a formal approach to the security analysis of
wireless sensor networks by means of a model checking tool called Avispa. Sev-

9

Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

In order to design a secure network, several aspects have to be considered [?]:
Key establishment and trust setup, secrecy and authentication, and privacy. Key
establishment can be considered the base of the system; a secure and eﬃcient
key distribution mechanism is needed for large scale sensor networks. Once every
node has its own keys, these are used to authenticate and encrypt (if needed) the
messages they exchange. Several protocols have been proposed in the literature
related to authentication and privacy [?,?], and key distribution [?,?,?]

In this paper we have focus in two of these protocols: TinySec [?] in the ﬁeld
of authentication and encryption, and LEAP [?] in the ﬁeld of key management.
TinySec is a fully-implemented link layer security architecture for wireless sensor
networks included in the oﬃcial TinyOS [?] release. LEAP is a powerful keying
mechanism that supports the establishment of four types of keys for each sen-
sor node with little intervention of the base station. A brief overview of these
protocols is given in Section 2.

In line with the development of security protocols, some techniques have also
been developed to model a system and check properties on it. One of the most
promising techniques in this line is model checking. Model checking [?] is a formal
methods based technique for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main advantages of this technique
is that it is automatic and allows us to see if a system works as expected. In
case the system does not work properly, the model checking tool provides a trace
that leads to the source of the error.

Model checking has become a key point in the design of concurrent and
distributed system because it allows us to ensure the correctness of a design at
the earliest stage possible. Model checking has two main advantages over two
classical techniques such as simulation and testing: i) we do not need to build a
prototype of the system, and ii) we are able to verify the system against every
single execution trace. The latter is very important because using simulation or
testing we can only ﬁnd errors, but we cannot ensure that the whole system
behaves as expected (some errors may remain hidden until the system is in
production stage).

Some general purpose model checking tools have been developed by diﬀerent
research groups: Spin, UPPAAL, Murφ. These tools allow us to verify not only
the functional properties of a system (e.g. Spin), but also the performance of
a real-time system (e.g. UPPAAL). Although we can use these general purpose
tools in order to verify security protocols, we consider that it is preferable (and
more intuitive) to use a tool devoted to the veriﬁcation of security protocols.
Among these tools we can ﬁnd Casper/FDR2 toolbox [?] and AVISPA [?].

The use of model checking tools to verify security protocols has been suc-
cessful in the past in diﬀerent areas such as Web Services [?,?,?], or Transport
Layer security protocols [?,?].

In this paper, we present a formal veriﬁcation of wireless sensor security pro-
tocols using AVISPA (Automated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level formal language HLPSL
[?] for specifying protocols and their security properties. Once we have speciﬁed

2

the model of the system, AVISPA translates it into an intermediate format IF.
This is the input of several backends that are integrated into AVISPA frame-
work: SATMC OFMC, Cl-Atse and TA4SP. Besides, only one model is speciﬁed
although it can be analysed with the four backends. AVISPA also oﬀers a graph-
ical interface SPAN [?] that helps in the specifying task.

Security in wireless networks is not an easy task due to its broadcast nature.
An intruder can overhear, intercept messages, inject new messages or modify
messages in transit. This kind of intruder is called Dolev-Yao Intruder [?]. The
intruder implemented in AVISPA is a Dolev-Yao intruder, which is appropriate
to analyse wireless security protocols.

The paper is organised as follows. In Section 2 a brief overview of TinySec
and LEAP is given. Section 3 is devoted to the formal veriﬁcation of TinySec
and LEAP, where four scenarios have been considered depending on the key
distribution mechanism used. Finally in Section 4 we give our conclusions and
future work.

2 TinySec + LEAP

TinySec [?] is a fully-implemented link layer security architecture for wireless
sensor networks. The design of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight design was made taking
into account wireless sensor networks particularities, mainly limited computation
and communication capabilities, as well as low power consumption. TinySec is
part of the oﬃcial TinyOS [?] release.

The main goals of TinySec are performance, usability and security. Inside
the security aspects, three main goals are considered: access control, message
integrity, and conﬁdentiality. Outside the scope of TinySec is to avoid replay
attacks, which is left to higher layers of the protocol stack.

TinySec considers two operations with application layer data: authentica-
tion and semantically secure encryption. TinySec authenticates a packet using a
message authentication code, CBC-MAC [?]. Semantically secure encryption1 is
made using an 8 byte initialisation vector (IV) and cipher block chaining (CBC)
as encryption scheme [?]. Taking into account both operations, two kinds of
packets can be found: TinySec-AE, that oﬀers authentication and encryption,
and TinySec-Auth, that oﬀers only authentication. A detailed view of both kinds
of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys are needed. TinySec does
not address the problem of obtaining those keys; any particular keying mecha-
nism can be used in conjunction with TinySec. In this paper we consider Local-
ized Encryption and Authentication Protocol (LEAP) [?] as the keying mech-
anism. LEAP supports the establishment of four types of keys for each sensor
node: an individual key shared with the base station, a pairwise key shared with
another sensor node, a cluster key shared with multiple neighboring nodes, and a

1 Encrypting the same plaintext two times should give two diﬀerent cipher-texts

3

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

Fig. 1. TinySec packet formats: TinySec-AE and TinySec-Auth

group key that is shared by all the nodes in the network. One interesting feature
of LEAP is that it minimises the involvement of the base station. Fig. 2 shows
the four LEAP keying mechanisms.

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

Kc

Ni

Kc

Ni

Kc

Ni

N2

N4

N3

KS

NV1

NV2

NV3

Kc

Nc

Kc

Nc

Kc

Nc

NC

Fig. 2. LEAP keying mechanisms

4

3 Veriﬁcation of TinySec + LEAP

The combination of TinySec and LEAP allows us to build a complete solution,
where LEAP is responsible of obtaining the more convenient shared key at every
moment, and TinySec is responsible of the authentication and encryption of
messages exchanged between nodes. Thus, we have considered four diﬀerent
conﬁgurations of TinySec and LEAP, depending on the key mechanism used,
and the kind and the situation of the nodes that communicate with each other:

– Case A. Request from the base node to a normal node using an individual

– Case B. Request from the base node to a normal node using an individual

key using messages TinySec-AE.

key using messages TinySec-Auth.

– Case C. Communication between immediate neighbouring nodes using a

– Case D. Communication between immediate neighbouring nodes using a

– Case E. Communication between non immediate neighbouring nodes nodes

pairwise shared key.

cluster key.

using a cluster key.

During all these analysis we will consider that before deployment, a node
master key Km has been saved inside every node in the network. We also adopt
the Dolev-Yao intruder model, where an intruder can overhear, intercept, alter,
or inject any messages into the radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3. In this case a base node
(BS) makes a request to a normal node (Ni) which has an individual (unique)
key that it shares with the base station

BS

N1

N2

N3

Fig. 3. Sensor network: cases A and B.

The protocol for TinySec-AE packets using Avispa syntax is as follows:
1. BS → Ni: IV1{(IV1 ⊕ Data1)}F (Km.Ni). {M AC(IV1.Data1)}H(Km.Ni)
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni). {M AC(IV2.Data2)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-random functions that allow
to calculate the encryption key and the authentication key taking as parameters
the master key (Km) and the id of the node (Ni). Due to Avispa does not oﬀer

5

arithmetic semantics, the increase of the counter is represented by a function
Suc, such as Suc(0) represents 1, Suc(Suc(0) represents 2 and so on.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node Ni and the base station
(BS) share the same value for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to proof that bilateral au-
thentication is achieved by using the MAC, and the integrity of the message
is guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and Data2 are secret values
shared between Ni and BS, and they are not known by an intruder or third
parties.

The veriﬁcation with Avispa ﬁnds only the following replay attack, where

IBS represents an intruder playing the role of the base station:

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km.N1). {M AC(IV2.Data2)}H(Km.N1)
1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km.N1). {M AC(IV3.Data3)}H(Km.N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

where IV1 = N1.AM1.Size1.BS.0

where IV1 = N1.AM1.Size1.BS.0

where IV3 = BS.AM3.Size3.N1.Suc(0)

Nevertheless, as was said before, TinySec does not manage replay attacks,
which are left to higher layers of the protocol stack. Apart from this attack, the
protocol is secure, even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in the previous case (see Fig.
3), but we consider TinySec-Auth messages instead of TinySec-AE messages.
The protocol for TinySec-AE packets using Avispa syntax is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1. {M AC(Ni.AM1.Size1.Data1)}H(Km.Ni)
2. Ni → BS: BS.AM2.Size2.Data2. {M AC(BS.AM2.Size2.Data2)}H(Km.Ni)
As we mentioned before, TinySec-Auth does not provide any conﬁdentiality
mechanisms. Thus, we can only analyse the authentication of Data1 and Data2,
i.e., we can proof the bilateral authentication between BS and Ni, by means of
the MAC messages, and also the integrity of messages. As in the previous case,
we have found a replay attack that we omit

Case C. The network conﬁguration is shown in Fig. 4. In this case a node (N1)
shares a pairwise key with each of its immediate neighbours (N2 and N3). The
protocol for TinySec-AE packets using Avispa syntax is as follows, where A rep-
resents node N1 and B represents one of its neighbours (N2 or N3):

6

1. A → B : A, N onceA
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K0

AB = H(H(Km.B).A)

where K0

AB

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

N1

N3

N2

Fig. 4. Sensor network: cases C and D

The properties we have to analyse are the following:

– Authentication of N onceA, DataA and DataB. i.e., nodes A and B share
the same value for N onceA, DataA and DataB and both execute the same
session of the protocol.

– Conﬁdentiality of DataB, i.e., DataB is a secret value shared between A and

B, and remains unknown to an intruder or third parties.
In this case Avispa ﬁnds a man-in-the-middle attack, where IA represents
the intruder playing the role of node A, IB2 represents the intruder playing the
role of node B, B1 represents node B communicating with the intruder, and B2
represents node B communicating with A:

1. IA → B1 : A, N onceI
2. B1 → IA : B.{M AC(N onceI .B)}H(Km.B)
1. A → IB2 : A, N onceA
2. IA → B2 : Nx.N onceA
2. B2 → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → IB2 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
3. IA → B1 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B1 → IA : A.AM2.Size2.B.Counter.{(IV2 ⊕ DataB)}KAB .

AB

AB

{M AC(IV2.DataB)}K0

AB

First the intruder, playing the role of A, starts the protocol with B (denoted
B1), and sends a false nonce, which is answered by B (B1). Then, A starts
a session with B (B2) but this message is intercepted by the intruder (IB2)
which modiﬁes the message and sends to B (B2) the identity of a false node Nx
and the nonce of A. Node B (B2) sends the answer of the last message to A,
and A responds with a request of data (Data2) to B (B2). Again, the request
is intercepted by the intruder who redirects the message to B (B1). At this
moment, B (B1) thinks that it has received a correct request from A, and then
it sends DataB to the intruder playing the role of A (IA)

7

At the end we conclude that B1 has exchanged information (Data2) with
the intruder, and B2 thinks that it has talked to a node Nx that does not exist.
A solution to this attack consists in authenticate no only the answer from B
in message 2 but also the message 1 sent from A. The modiﬁed version of the
protocol is:

1. A → B : A.N onceA.M AC(A.N onceA)H(Km,A)
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K0

AB = H(H(Km.B).A)

where K0

AB

AB

where IV2 = A.AM2.Size2.B.Counter y KAB = F (F (Km.N2).N1)

Case D. Sensor network conﬁguration is shown in Fig. 4. In this case a node
(N1) shares a cluster key with each of its immediate neighbours (N2 and N3).
The protocol for TinySec-AE packets using Avispa syntax is as follows, where
A represents node N1, B represents one of its neighbours (N2 or N3), and Kc is
the cluster key:

1. A → B : B.AM1.Size1.A.Counter.{(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K0
where IV1 = B.AM1.Size1.A.Counter, KAB = F (F (Km.B).A) and
K0

AB = H(H(Km.B).A)

2. B → A : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}H(Kc)
4. B → A : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

AB

where IV2 = A.AM2.Size2.B.Suc(Counter)

The properties we have to analyse are the following:

– Authentication of Kc, DataA and DataB. i.e., nodes A and B share the same
value for Kc, DataA and DataB and both execute the same session of the
protocol.

– Conﬁdentiality of DataB and Kc, i.e., DataB and Kc are secret values shared
between A and B, and they remain unknown to an intruder or third parties.
After analysing the protocol with Avispa, an interesting attack based on

types was found:

1. A → B : B.AM1.Size1.A.Counter.{(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K0

AB

where IV1 = B.AM1.Size1.A.Counter,
KAB = F (F (Km.B).A) and K0

2. B → IA : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
3. IA → B : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
4. B → IA : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

AB = H(H(Km.B).A)

where IV2 = A.AM2.Size2.B.Suc(Counter)

In this attack the intruder intercepts the message sent from B to A in step
2. In step 3, the intruder sends the intercepted message back to B as if was a
true request from A to B. B takes the message as a request an misunderstands
the label done as it was DataA. In step 4, B sends DataB to the intruder.

8

This is a type ﬂaw attack, i.e., type checking has not be done and a constant
label has been interpreted as a variable data. One solution to this attack has been
proposed by Heather et al. in [?] which basically consists in tagging each ﬁeld
with information about its type, although this solution could not be adequate
in wireless sensor networks because it adds some extra bits of information into
each message. In real implementations of the protocol, programmers should take
into account this type ﬂaw attack and do type checking in order to avoid a
possible attack. In any case, this kind of attack can be a problem because network
bandwidth could be saturated and there is a consumption of resources in the
node.

Case E. Sensor network conﬁguration is shown in Fig. 5. In this case a node
(e.g. N1) shares a cluster key with non immediate neighbouring nodes (e.g. N4
and N5).

N1

N3

N2

N4

N5

Fig. 5. Sensor Network: Case E

The protocol for TinySec-AE packets using Avispa syntax is as follows, where
A represents node N1, B represents a non neighbour node (N4 or N5), Ni rep-
resents a neighbour node (N2 and N3):

Q. A → Ni : A, B
R. Ni → A : A.AM1.Size1.Ni.{M AC(A.AM1.Size1.Ni)}K0
1 . A → Ni : IV2.F (SKi, 0).{(IV2 ⊕ SKi)}KANi
. {M AC(IV2.SKi.F (SKi, 0))}K0
where IV2 = Ni.AM2.Size2.A.Counter
2 . Ni → B : IV3.F (SKi, 0).{(IV3 ⊕ SKi)}KNiB . {M AC(IV3.SKi.F (SKi, 0))}K0

ANi

ANi

NiB

D. B → A : A.AM4.Size4.done{M AC(A.AM4.Size4.done)}Sk

where IV3 = B.AM3.Size3.Ni.Counter
When B has every SKi
where Sk = Sk1 ⊕ . . . ⊕ Skn

Avispa only ﬁnds a replay attack, that we do not consider. Apart from this

attack, the protocol is secure.

4 Conclusions and Future Work

In this paper we have presented a formal approach to the security analysis of
wireless sensor networks by means of a model checking tool called Avispa. Sev-

9

eral models of the network have been considered depending on the relative po-
sition and roles of the nodes. Two wireless sensor security protocols have been
considered in order to build a complete solution: TinySec, who is in charge of
the authentication and encryption of messages, and LEAP, who covers the key
distribution mechanism.

The ﬁve models we have presented have been analysed with Avispa, and we

have obtained the following results:

Case A. Request from the base node to a normal node using an individual key
using messages TinySec-AE. The veriﬁcation with Avispa ﬁnds only a replay
attack where an intruder may play the role of the base station. Nevertheless,
TinySec does not manage replay attacks, which are left to higher layers of the
protocol stack. Apart from this attack, the protocol is secure,

Case B. Request from the base node to a normal node using an individual key
using messages TinySec-Auth. As in the previous case, Avispa ﬁnds only a replay
attack. Under our previous assumptions about replay attacks, we can consider
that the protocol is secure,

Case C. Communication between immediate neighbour nodes using a pairwise
shared key. In this case Avispa ﬁnds a man-in-the-middle attack where the
intruder may play at the same time the role of two nodes in order to obtain real
information from one of them. Consequently, conﬁdentiality is lost. A solution to
this attack is proposed and consists in authenticate the ﬁrst message sent from
the initiator (node A).

Case D. Communication between immediate neighbour nodes using a cluster key.
In this case a type ﬂaw attack is found. As in the previous case, the intruder can
obtain real data from one of the nodes, and therefore conﬁdentiality is lost. A
solution to this kind of attack has been proposed in [?]; nevertheless this solution
is not adequate in wireless sensor networks because increases the overload of
security protocols in messages.

Case E. Communication between non immediate neighbour nodes using a cluster
key. In this case, apart from a replay attack, the protocol is secure.

Our future work is concerned with extending our analysis to other security
protocols for wireless sensor networks such as SNEP, µTESLA (both deﬁned in
[?]), and MiniSec [?]. Also we are interested in the analysis of TinySec with other
distribution key protocols such as LEAP+[?] and TinyPK [?].

References

1. Perrig, A., Stankovic, J.A., Wagner, D.: Security in wireless sensor networks.

Commun. ACM 47 (2004) 53–57

10

Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

In order to design a secure network, several aspects have to be considered [?]:
Key establishment and trust setup, secrecy and authentication, and privacy. Key
establishment can be considered the base of the system; a secure and eﬃcient
key distribution mechanism is needed for large scale sensor networks. Once every
node has its own keys, these are used to authenticate and encrypt (if needed) the
messages they exchange. Several protocols have been proposed in the literature
related to authentication and privacy [?,?], and key distribution [?,?,?]

In this paper we have focus in two of these protocols: TinySec [?] in the ﬁeld
of authentication and encryption, and LEAP [?] in the ﬁeld of key management.
TinySec is a fully-implemented link layer security architecture for wireless sensor
networks included in the oﬃcial TinyOS [?] release. LEAP is a powerful keying
mechanism that supports the establishment of four types of keys for each sen-
sor node with little intervention of the base station. A brief overview of these
protocols is given in Section 2.

In line with the development of security protocols, some techniques have also
been developed to model a system and check properties on it. One of the most
promising techniques in this line is model checking. Model checking [?] is a formal
methods based technique for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main advantages of this technique
is that it is automatic and allows us to see if a system works as expected. In
case the system does not work properly, the model checking tool provides a trace
that leads to the source of the error.

Model checking has become a key point in the design of concurrent and
distributed system because it allows us to ensure the correctness of a design at
the earliest stage possible. Model checking has two main advantages over two
classical techniques such as simulation and testing: i) we do not need to build a
prototype of the system, and ii) we are able to verify the system against every
single execution trace. The latter is very important because using simulation or
testing we can only ﬁnd errors, but we cannot ensure that the whole system
behaves as expected (some errors may remain hidden until the system is in
production stage).

Some general purpose model checking tools have been developed by diﬀerent
research groups: Spin, UPPAAL, Murφ. These tools allow us to verify not only
the functional properties of a system (e.g. Spin), but also the performance of
a real-time system (e.g. UPPAAL). Although we can use these general purpose
tools in order to verify security protocols, we consider that it is preferable (and
more intuitive) to use a tool devoted to the veriﬁcation of security protocols.
Among these tools we can ﬁnd Casper/FDR2 toolbox [?] and AVISPA [?].

The use of model checking tools to verify security protocols has been suc-
cessful in the past in diﬀerent areas such as Web Services [?,?,?], or Transport
Layer security protocols [?,?].

In this paper, we present a formal veriﬁcation of wireless sensor security pro-
tocols using AVISPA (Automated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level formal language HLPSL
[?] for specifying protocols and their security properties. Once we have speciﬁed

2

the model of the system, AVISPA translates it into an intermediate format IF.
This is the input of several backends that are integrated into AVISPA frame-
work: SATMC OFMC, Cl-Atse and TA4SP. Besides, only one model is speciﬁed
although it can be analysed with the four backends. AVISPA also oﬀers a graph-
ical interface SPAN [?] that helps in the specifying task.

Security in wireless networks is not an easy task due to its broadcast nature.
An intruder can overhear, intercept messages, inject new messages or modify
messages in transit. This kind of intruder is called Dolev-Yao Intruder [?]. The
intruder implemented in AVISPA is a Dolev-Yao intruder, which is appropriate
to analyse wireless security protocols.

The paper is organised as follows. In Section 2 a brief overview of TinySec
and LEAP is given. Section 3 is devoted to the formal veriﬁcation of TinySec
and LEAP, where four scenarios have been considered depending on the key
distribution mechanism used. Finally in Section 4 we give our conclusions and
future work.

2 TinySec + LEAP

TinySec [?] is a fully-implemented link layer security architecture for wireless
sensor networks. The design of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight design was made taking
into account wireless sensor networks particularities, mainly limited computation
and communication capabilities, as well as low power consumption. TinySec is
part of the oﬃcial TinyOS [?] release.

The main goals of TinySec are performance, usability and security. Inside
the security aspects, three main goals are considered: access control, message
integrity, and conﬁdentiality. Outside the scope of TinySec is to avoid replay
attacks, which is left to higher layers of the protocol stack.

TinySec considers two operations with application layer data: authentica-
tion and semantically secure encryption. TinySec authenticates a packet using a
message authentication code, CBC-MAC [?]. Semantically secure encryption1 is
made using an 8 byte initialisation vector (IV) and cipher block chaining (CBC)
as encryption scheme [?]. Taking into account both operations, two kinds of
packets can be found: TinySec-AE, that oﬀers authentication and encryption,
and TinySec-Auth, that oﬀers only authentication. A detailed view of both kinds
of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys are needed. TinySec does
not address the problem of obtaining those keys; any particular keying mecha-
nism can be used in conjunction with TinySec. In this paper we consider Local-
ized Encryption and Authentication Protocol (LEAP) [?] as the keying mech-
anism. LEAP supports the establishment of four types of keys for each sensor
node: an individual key shared with the base station, a pairwise key shared with
another sensor node, a cluster key shared with multiple neighboring nodes, and a

1 Encrypting the same plaintext two times should give two diﬀerent cipher-texts

3

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

Fig. 1. TinySec packet formats: TinySec-AE and TinySec-Auth

group key that is shared by all the nodes in the network. One interesting feature
of LEAP is that it minimises the involvement of the base station. Fig. 2 shows
the four LEAP keying mechanisms.

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

Kc

Ni

Kc

Ni

Kc

Ni

N2

N4

N3

KS

NV1

NV2

NV3

Kc

Nc

Kc

Nc

Kc

Nc

NC

Fig. 2. LEAP keying mechanisms

4

3 Veriﬁcation of TinySec + LEAP

The combination of TinySec and LEAP allows us to build a complete solution,
where LEAP is responsible of obtaining the more convenient shared key at every
moment, and TinySec is responsible of the authentication and encryption of
messages exchanged between nodes. Thus, we have considered four diﬀerent
conﬁgurations of TinySec and LEAP, depending on the key mechanism used,
and the kind and the situation of the nodes that communicate with each other:

– Case A. Request from the base node to a normal node using an individual

– Case B. Request from the base node to a normal node using an individual

key using messages TinySec-AE.

key using messages TinySec-Auth.

– Case C. Communication between immediate neighbouring nodes using a

– Case D. Communication between immediate neighbouring nodes using a

– Case E. Communication between non immediate neighbouring nodes nodes

pairwise shared key.

cluster key.

using a cluster key.

During all these analysis we will consider that before deployment, a node
master key Km has been saved inside every node in the network. We also adopt
the Dolev-Yao intruder model, where an intruder can overhear, intercept, alter,
or inject any messages into the radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3. In this case a base node
(BS) makes a request to a normal node (Ni) which has an individual (unique)
key that it shares with the base station

BS

N1

N2

N3

Fig. 3. Sensor network: cases A and B.

The protocol for TinySec-AE packets using Avispa syntax is as follows:
1. BS → Ni: IV1{(IV1 ⊕ Data1)}F (Km.Ni). {M AC(IV1.Data1)}H(Km.Ni)
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni). {M AC(IV2.Data2)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-random functions that allow
to calculate the encryption key and the authentication key taking as parameters
the master key (Km) and the id of the node (Ni). Due to Avispa does not oﬀer

5

arithmetic semantics, the increase of the counter is represented by a function
Suc, such as Suc(0) represents 1, Suc(Suc(0) represents 2 and so on.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node Ni and the base station
(BS) share the same value for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to proof that bilateral au-
thentication is achieved by using the MAC, and the integrity of the message
is guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and Data2 are secret values
shared between Ni and BS, and they are not known by an intruder or third
parties.

The veriﬁcation with Avispa ﬁnds only the following replay attack, where

IBS represents an intruder playing the role of the base station:

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km.N1). {M AC(IV2.Data2)}H(Km.N1)
1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km.N1). {M AC(IV3.Data3)}H(Km.N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

where IV1 = N1.AM1.Size1.BS.0

where IV1 = N1.AM1.Size1.BS.0

where IV3 = BS.AM3.Size3.N1.Suc(0)

Nevertheless, as was said before, TinySec does not manage replay attacks,
which are left to higher layers of the protocol stack. Apart from this attack, the
protocol is secure, even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in the previous case (see Fig.
3), but we consider TinySec-Auth messages instead of TinySec-AE messages.
The protocol for TinySec-AE packets using Avispa syntax is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1. {M AC(Ni.AM1.Size1.Data1)}H(Km.Ni)
2. Ni → BS: BS.AM2.Size2.Data2. {M AC(BS.AM2.Size2.Data2)}H(Km.Ni)
As we mentioned before, TinySec-Auth does not provide any conﬁdentiality
mechanisms. Thus, we can only analyse the authentication of Data1 and Data2,
i.e., we can proof the bilateral authentication between BS and Ni, by means of
the MAC messages, and also the integrity of messages. As in the previous case,
we have found a replay attack that we omit

Case C. The network conﬁguration is shown in Fig. 4. In this case a node (N1)
shares a pairwise key with each of its immediate neighbours (N2 and N3). The
protocol for TinySec-AE packets using Avispa syntax is as follows, where A rep-
resents node N1 and B represents one of its neighbours (N2 or N3):

6

1. A → B : A, N onceA
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K0

AB = H(H(Km.B).A)

where K0

AB

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

N1

N3

N2

Fig. 4. Sensor network: cases C and D

The properties we have to analyse are the following:

– Authentication of N onceA, DataA and DataB. i.e., nodes A and B share
the same value for N onceA, DataA and DataB and both execute the same
session of the protocol.

– Conﬁdentiality of DataB, i.e., DataB is a secret value shared between A and

B, and remains unknown to an intruder or third parties.
In this case Avispa ﬁnds a man-in-the-middle attack, where IA represents
the intruder playing the role of node A, IB2 represents the intruder playing the
role of node B, B1 represents node B communicating with the intruder, and B2
represents node B communicating with A:

1. IA → B1 : A, N onceI
2. B1 → IA : B.{M AC(N onceI .B)}H(Km.B)
1. A → IB2 : A, N onceA
2. IA → B2 : Nx.N onceA
2. B2 → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → IB2 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
3. IA → B1 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B1 → IA : A.AM2.Size2.B.Counter.{(IV2 ⊕ DataB)}KAB .

AB

AB

{M AC(IV2.DataB)}K0

AB

First the intruder, playing the role of A, starts the protocol with B (denoted
B1), and sends a false nonce, which is answered by B (B1). Then, A starts
a session with B (B2) but this message is intercepted by the intruder (IB2)
which modiﬁes the message and sends to B (B2) the identity of a false node Nx
and the nonce of A. Node B (B2) sends the answer of the last message to A,
and A responds with a request of data (Data2) to B (B2). Again, the request
is intercepted by the intruder who redirects the message to B (B1). At this
moment, B (B1) thinks that it has received a correct request from A, and then
it sends DataB to the intruder playing the role of A (IA)

7

At the end we conclude that B1 has exchanged information (Data2) with
the intruder, and B2 thinks that it has talked to a node Nx that does not exist.
A solution to this attack consists in authenticate no only the answer from B
in message 2 but also the message 1 sent from A. The modiﬁed version of the
protocol is:

1. A → B : A.N onceA.M AC(A.N onceA)H(Km,A)
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K0

AB = H(H(Km.B).A)

where K0

AB

AB

where IV2 = A.AM2.Size2.B.Counter y KAB = F (F (Km.N2).N1)

Case D. Sensor network conﬁguration is shown in Fig. 4. In this case a node
(N1) shares a cluster key with each of its immediate neighbours (N2 and N3).
The protocol for TinySec-AE packets using Avispa syntax is as follows, where
A represents node N1, B represents one of its neighbours (N2 or N3), and Kc is
the cluster key:

1. A → B : B.AM1.Size1.A.Counter.{(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K0
where IV1 = B.AM1.Size1.A.Counter, KAB = F (F (Km.B).A) and
K0

AB = H(H(Km.B).A)

2. B → A : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}H(Kc)
4. B → A : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

AB

where IV2 = A.AM2.Size2.B.Suc(Counter)

The properties we have to analyse are the following:

– Authentication of Kc, DataA and DataB. i.e., nodes A and B share the same
value for Kc, DataA and DataB and both execute the same session of the
protocol.

– Conﬁdentiality of DataB and Kc, i.e., DataB and Kc are secret values shared
between A and B, and they remain unknown to an intruder or third parties.
After analysing the protocol with Avispa, an interesting attack based on

types was found:

1. A → B : B.AM1.Size1.A.Counter.{(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K0

AB

where IV1 = B.AM1.Size1.A.Counter,
KAB = F (F (Km.B).A) and K0

2. B → IA : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
3. IA → B : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
4. B → IA : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

AB = H(H(Km.B).A)

where IV2 = A.AM2.Size2.B.Suc(Counter)

In this attack the intruder intercepts the message sent from B to A in step
2. In step 3, the intruder sends the intercepted message back to B as if was a
true request from A to B. B takes the message as a request an misunderstands
the label done as it was DataA. In step 4, B sends DataB to the intruder.

8

This is a type ﬂaw attack, i.e., type checking has not be done and a constant
label has been interpreted as a variable data. One solution to this attack has been
proposed by Heather et al. in [?] which basically consists in tagging each ﬁeld
with information about its type, although this solution could not be adequate
in wireless sensor networks because it adds some extra bits of information into
each message. In real implementations of the protocol, programmers should take
into account this type ﬂaw attack and do type checking in order to avoid a
possible attack. In any case, this kind of attack can be a problem because network
bandwidth could be saturated and there is a consumption of resources in the
node.

Case E. Sensor network conﬁguration is shown in Fig. 5. In this case a node
(e.g. N1) shares a cluster key with non immediate neighbouring nodes (e.g. N4
and N5).

N1

N3

N2

N4

N5

Fig. 5. Sensor Network: Case E

The protocol for TinySec-AE packets using Avispa syntax is as follows, where
A represents node N1, B represents a non neighbour node (N4 or N5), Ni rep-
resents a neighbour node (N2 and N3):

Q. A → Ni : A, B
R. Ni → A : A.AM1.Size1.Ni.{M AC(A.AM1.Size1.Ni)}K0
1 . A → Ni : IV2.F (SKi, 0).{(IV2 ⊕ SKi)}KANi
. {M AC(IV2.SKi.F (SKi, 0))}K0
where IV2 = Ni.AM2.Size2.A.Counter
2 . Ni → B : IV3.F (SKi, 0).{(IV3 ⊕ SKi)}KNiB . {M AC(IV3.SKi.F (SKi, 0))}K0

ANi

ANi

NiB

D. B → A : A.AM4.Size4.done{M AC(A.AM4.Size4.done)}Sk

where IV3 = B.AM3.Size3.Ni.Counter
When B has every SKi
where Sk = Sk1 ⊕ . . . ⊕ Skn

Avispa only ﬁnds a replay attack, that we do not consider. Apart from this

attack, the protocol is secure.

4 Conclusions and Future Work

In this paper we have presented a formal approach to the security analysis of
wireless sensor networks by means of a model checking tool called Avispa. Sev-

9

eral models of the network have been considered depending on the relative po-
sition and roles of the nodes. Two wireless sensor security protocols have been
considered in order to build a complete solution: TinySec, who is in charge of
the authentication and encryption of messages, and LEAP, who covers the key
distribution mechanism.

The ﬁve models we have presented have been analysed with Avispa, and we

have obtained the following results:

Case A. Request from the base node to a normal node using an individual key
using messages TinySec-AE. The veriﬁcation with Avispa ﬁnds only a replay
attack where an intruder may play the role of the base station. Nevertheless,
TinySec does not manage replay attacks, which are left to higher layers of the
protocol stack. Apart from this attack, the protocol is secure,

Case B. Request from the base node to a normal node using an individual key
using messages TinySec-Auth. As in the previous case, Avispa ﬁnds only a replay
attack. Under our previous assumptions about replay attacks, we can consider
that the protocol is secure,

Case C. Communication between immediate neighbour nodes using a pairwise
shared key. In this case Avispa ﬁnds a man-in-the-middle attack where the
intruder may play at the same time the role of two nodes in order to obtain real
information from one of them. Consequently, conﬁdentiality is lost. A solution to
this attack is proposed and consists in authenticate the ﬁrst message sent from
the initiator (node A).

Case D. Communication between immediate neighbour nodes using a cluster key.
In this case a type ﬂaw attack is found. As in the previous case, the intruder can
obtain real data from one of the nodes, and therefore conﬁdentiality is lost. A
solution to this kind of attack has been proposed in [?]; nevertheless this solution
is not adequate in wireless sensor networks because increases the overload of
security protocols in messages.

Case E. Communication between non immediate neighbour nodes using a cluster
key. In this case, apart from a replay attack, the protocol is secure.

Our future work is concerned with extending our analysis to other security
protocols for wireless sensor networks such as SNEP, µTESLA (both deﬁned in
[?]), and MiniSec [?]. Also we are interested in the analysis of TinySec with other
distribution key protocols such as LEAP+[?] and TinyPK [?].

References

1. Perrig, A., Stankovic, J.A., Wagner, D.: Security in wireless sensor networks.

Commun. ACM 47 (2004) 53–57

10

2. Karlof, C., Sastry, N., Wagner, D.: TinySec: a link layer security architecture for
wireless sensor networks. In: Proceedings of the 2nd International Conference on
Embedded Networked Sensor Systems, SenSys 2004, Baltimore, MD, USA, Novem-
ber 3-5, 2004, ACM (2004) 162–175

3. Perrig, A., Szewczyk, R., Tygar, J.D., Wen, V., Culler, D.E.: SPINS: Security

protocols for sensor networks. Wireless Networks 8 (2002) 521–534

4. Zhu, S., Setia, S., Jajodia, S.: LEAP: eﬃcient security mechanisms for large-scale
In Jajodia, S., Atluri, V., Jaeger, T., eds.: ACM

distributed sensor networks.
Conference on Computer and Communications Security, ACM (2003) 62–72

5. Chan, H., Perrig, A., Song, D.X.: Random key predistribution schemes for sensor
networks. In: IEEE Symposium on Security and Privacy, IEEE Computer Society
(2003) 197

6. Eschenauer, L., Gligor, V.: A key-management scheme for distributed sensor net-
In Atluri, V., ed.: ACM Conference on Computer and Communications

works.
Security, ACM (2002) 41–47

7. Hill, J., Szewczyk, R., Woo, A., Hollar, S., Culler, D.E., Pister, K.S.J.: System
architecture directions for networked sensors.
In: Inter. Conf. on Architectural
Support for Programming Languages and Operating Systems, ASPLOS. (2000)
93–104

8. Clarke, E.M., Grumberg, O., Peled, D.A.: Model Checking. The MIT Press (1999)
9. Lowe, G.: Casper: A compiler for the analysis of security protocols. Journal of

Computer Security 6 (1998) 53–84

10. Armando, A., Basin, D.A., Boichut, Y., Chevalier, Y., Compagna, L., Cu´ellar, J.,
Drielsma, P.H., H´eam, P.C., Kouchnarenko, O., Mantovani, J., M¨odersheim, S., von
Oheimb, D., Rusinowitch, M., Santiago, J., Turuani, M., Vigan`o, L., Vigneron, L.:
The AVISPA tool for the automated validation of internet security protocols and
applications. In Etessami, K., Rajamani, S.K., eds.: CAV. Volume 3576 of Lecture
Notes in Computer Science., Springer (2005) 281–285

11. Tobarra, M.L., Cazorla, D., Cuartero, F., Diaz, G.: Application of formal methods
to the analysis of web services security.
In Bravetti, M., Kloul, L., Zavattaro,
G., eds.: EPEW/WS-FM. Volume 3670 of Lecture Notes in Computer Science.,
Springer (2005) 215–229

12. Backes, M., M¨odersheim, S., Pﬁtzmann, B., Vigan`o, L.: Symbolic and cryp-
tographic analysis of the secure WS-ReliableMessaging scenario.
In Aceto, L.,
Ing´olfsd´ottir, A., eds.: FoSSaCS. Volume 3921 of Lecture Notes in Computer Sci-
ence., Springer (2006) 428–445

13. Bhargavan, K., Fournet, C., Gordon, A.D.: Verifying policy-based security for web
services. In Atluri, V., Pﬁtzmann, B., McDaniel, P.D., eds.: ACM Conference on
Computer and Communications Security, ACM (2004) 268–277

14. Mitchell, J.C.: Finite-state analysis of security protocols. In Hu, A.J., Vardi, M.Y.,
eds.: CAV. Volume 1427 of Lecture Notes in Computer Science., Springer (1998)
71–76

15. Tobarra, M.L., Cazorla, D., Cuartero, F., Diaz, G.: Formal veriﬁcation of TLS
handshake and extensions for wireless networks. In: Proc. of IADIS International
Conference on Applied Computing (AC’06), San Sebastian, Spain, IADIS Press
(2006) 57–64

16. Chevalier, Y., Compagna, L., Cu´ellar, J., Drielsma, P.H., Mantovani, J., M¨oder-
sheim, S., Vigneron, L.: A high level protocol speciﬁcation language for industrial
security-sensitive protocols.
In: Proceedings of Workshop on Speciﬁcation and
Automated Processing of Security Requirements (SAPS). (2004) 193–205

11

Model Checking Wireless Sensor Network

Security Protocols: TinySec + LEAP ?

Llanos Tobarra, Diego Cazorla, Fernando Cuartero, Gregorio D´ıaz, and Emilia

Cambronero

Escuela Polit´ecnica Superior de Albacete

Universidad de Castilla-La Mancha. 02071 Albacete, Spain.

{mtobarra, dcazorla, fernando, gregorio,emicp}@dsi.uclm.es

Abstract. In this paper, a formal analysis of security protocols in the
ﬁeld of wireless sensor networks is presented. Two complementary pro-
tocols, TinySec and LEAP, are modelled using the high-level formal lan-
guage HLPSL, and veriﬁed using the model checking tool Avispa, where
two main security properties are checked: authenticity and conﬁdential-
ity of messages. As a result of this analysis, two attacks have been found:
a man-in-the-middle- attack and a type ﬂaw attack. In both cases conﬁ-
dentiality is compromised and an intruder may obtain conﬁdential data
from a node in the network. Two solutions to these attacks are proposed
in the paper.

Keywords:Wireless sensor, model checking, security protocols, avispa
toolbox

1 Introduction

Security has become a challenge in wireless sensor networks. Low capabilities of
devices, in terms of computational power and energy consumption, make diﬃcult
using traditional security protocols.

Two main problems related to security protocols arise. Firstly, the overload
that security protocols introduce in messages should be reduced at a minimum;
every bit the sensor sends consumes energy and, consequently, reduces the life
of the device. Secondly, low computational power implies that special crypto-
graphic algorithms that require less powerful processors need to be used. The
combination of both problems lead us to a situation where new approaches or
solutions to security protocols need to be considered. These new approaches take
into account basically two main goals: reduce the overhead that protocol imposes
to messages, and provide reasonable protection while limiting use of resources.

? This work has been supported by the spanish government with the project ”Appli-
cation of Formal Methods to Web Services”, with reference TIN2006-15578-C02-02,
and the JCCM regional project “Application of formal methods to the design and
analysis of Web Services and e-commerce ” (PAC06-0008-6995 )

In order to design a secure network, several aspects have to be considered [?]:
Key establishment and trust setup, secrecy and authentication, and privacy. Key
establishment can be considered the base of the system; a secure and eﬃcient
key distribution mechanism is needed for large scale sensor networks. Once every
node has its own keys, these are used to authenticate and encrypt (if needed) the
messages they exchange. Several protocols have been proposed in the literature
related to authentication and privacy [?,?], and key distribution [?,?,?]

In this paper we have focus in two of these protocols: TinySec [?] in the ﬁeld
of authentication and encryption, and LEAP [?] in the ﬁeld of key management.
TinySec is a fully-implemented link layer security architecture for wireless sensor
networks included in the oﬃcial TinyOS [?] release. LEAP is a powerful keying
mechanism that supports the establishment of four types of keys for each sen-
sor node with little intervention of the base station. A brief overview of these
protocols is given in Section 2.

In line with the development of security protocols, some techniques have also
been developed to model a system and check properties on it. One of the most
promising techniques in this line is model checking. Model checking [?] is a formal
methods based technique for verifying ﬁnite-state-concurrent systems, and has
been implemented in several tools. One of the main advantages of this technique
is that it is automatic and allows us to see if a system works as expected. In
case the system does not work properly, the model checking tool provides a trace
that leads to the source of the error.

Model checking has become a key point in the design of concurrent and
distributed system because it allows us to ensure the correctness of a design at
the earliest stage possible. Model checking has two main advantages over two
classical techniques such as simulation and testing: i) we do not need to build a
prototype of the system, and ii) we are able to verify the system against every
single execution trace. The latter is very important because using simulation or
testing we can only ﬁnd errors, but we cannot ensure that the whole system
behaves as expected (some errors may remain hidden until the system is in
production stage).

Some general purpose model checking tools have been developed by diﬀerent
research groups: Spin, UPPAAL, Murφ. These tools allow us to verify not only
the functional properties of a system (e.g. Spin), but also the performance of
a real-time system (e.g. UPPAAL). Although we can use these general purpose
tools in order to verify security protocols, we consider that it is preferable (and
more intuitive) to use a tool devoted to the veriﬁcation of security protocols.
Among these tools we can ﬁnd Casper/FDR2 toolbox [?] and AVISPA [?].

The use of model checking tools to verify security protocols has been suc-
cessful in the past in diﬀerent areas such as Web Services [?,?,?], or Transport
Layer security protocols [?,?].

In this paper, we present a formal veriﬁcation of wireless sensor security pro-
tocols using AVISPA (Automated Validation of Internet Security Protocol an
Applications) framework. AVISPA provides a high-level formal language HLPSL
[?] for specifying protocols and their security properties. Once we have speciﬁed

2

the model of the system, AVISPA translates it into an intermediate format IF.
This is the input of several backends that are integrated into AVISPA frame-
work: SATMC OFMC, Cl-Atse and TA4SP. Besides, only one model is speciﬁed
although it can be analysed with the four backends. AVISPA also oﬀers a graph-
ical interface SPAN [?] that helps in the specifying task.

Security in wireless networks is not an easy task due to its broadcast nature.
An intruder can overhear, intercept messages, inject new messages or modify
messages in transit. This kind of intruder is called Dolev-Yao Intruder [?]. The
intruder implemented in AVISPA is a Dolev-Yao intruder, which is appropriate
to analyse wireless security protocols.

The paper is organised as follows. In Section 2 a brief overview of TinySec
and LEAP is given. Section 3 is devoted to the formal veriﬁcation of TinySec
and LEAP, where four scenarios have been considered depending on the key
distribution mechanism used. Finally in Section 4 we give our conclusions and
future work.

2 TinySec + LEAP

TinySec [?] is a fully-implemented link layer security architecture for wireless
sensor networks. The design of TinySec was based on existing security primitives
proven to be secure. Using these primitives, a lightweight design was made taking
into account wireless sensor networks particularities, mainly limited computation
and communication capabilities, as well as low power consumption. TinySec is
part of the oﬃcial TinyOS [?] release.

The main goals of TinySec are performance, usability and security. Inside
the security aspects, three main goals are considered: access control, message
integrity, and conﬁdentiality. Outside the scope of TinySec is to avoid replay
attacks, which is left to higher layers of the protocol stack.

TinySec considers two operations with application layer data: authentica-
tion and semantically secure encryption. TinySec authenticates a packet using a
message authentication code, CBC-MAC [?]. Semantically secure encryption1 is
made using an 8 byte initialisation vector (IV) and cipher block chaining (CBC)
as encryption scheme [?]. Taking into account both operations, two kinds of
packets can be found: TinySec-AE, that oﬀers authentication and encryption,
and TinySec-Auth, that oﬀers only authentication. A detailed view of both kinds
of packets is shown in Fig. 1.

In order to encrypt and decrypt data, shared keys are needed. TinySec does
not address the problem of obtaining those keys; any particular keying mecha-
nism can be used in conjunction with TinySec. In this paper we consider Local-
ized Encryption and Authentication Protocol (LEAP) [?] as the keying mech-
anism. LEAP supports the establishment of four types of keys for each sensor
node: an individual key shared with the base station, a pairwise key shared with
another sensor node, a cluster key shared with multiple neighboring nodes, and a

1 Encrypting the same plaintext two times should give two diﬀerent cipher-texts

3

TinySec-AE packet

Dst(2) AM(1)

l(1)

Src(2) Ctr(2)

Payload(0..29)

MAC(4)

TinySec-Auth packet

Dst(2) AM(1)

l(1)

Payload(0..29)

MAC(4)

Fig. 1. TinySec packet formats: TinySec-AE and TinySec-Auth

group key that is shared by all the nodes in the network. One interesting feature
of LEAP is that it minimises the involvement of the base station. Fig. 2 shows
the four LEAP keying mechanisms.

Individual key

Pairwise shared key

BS

Km
N1

Km
N2

Km
N3

N1

N2

N3

BS

Km
N1

Ni

KNiNV1

KNiNV2

KNiNV3

NV1

NV2

NV3

Group key

Cluster key

BS

KG

N1

BS

Km
N1

Ni

KG

KG

KG

Kc

Ni

Kc

Ni

Kc

Ni

N2

N4

N3

KS

NV1

NV2

NV3

Kc

Nc

Kc

Nc

Kc

Nc

NC

Fig. 2. LEAP keying mechanisms

4

3 Veriﬁcation of TinySec + LEAP

The combination of TinySec and LEAP allows us to build a complete solution,
where LEAP is responsible of obtaining the more convenient shared key at every
moment, and TinySec is responsible of the authentication and encryption of
messages exchanged between nodes. Thus, we have considered four diﬀerent
conﬁgurations of TinySec and LEAP, depending on the key mechanism used,
and the kind and the situation of the nodes that communicate with each other:

– Case A. Request from the base node to a normal node using an individual

– Case B. Request from the base node to a normal node using an individual

key using messages TinySec-AE.

key using messages TinySec-Auth.

– Case C. Communication between immediate neighbouring nodes using a

– Case D. Communication between immediate neighbouring nodes using a

– Case E. Communication between non immediate neighbouring nodes nodes

pairwise shared key.

cluster key.

using a cluster key.

During all these analysis we will consider that before deployment, a node
master key Km has been saved inside every node in the network. We also adopt
the Dolev-Yao intruder model, where an intruder can overhear, intercept, alter,
or inject any messages into the radio communication channel.

Case A. The network conﬁguration is shown in Fig. 3. In this case a base node
(BS) makes a request to a normal node (Ni) which has an individual (unique)
key that it shares with the base station

BS

N1

N2

N3

Fig. 3. Sensor network: cases A and B.

The protocol for TinySec-AE packets using Avispa syntax is as follows:
1. BS → Ni: IV1{(IV1 ⊕ Data1)}F (Km.Ni). {M AC(IV1.Data1)}H(Km.Ni)
2. Ni → BS: IV2.{(IV2 ⊕ Data2)}F (Km.Ni). {M AC(IV2.Data2)}H(Km.Ni)

where IV1 = Ni.AM1.Size1.BS.Counter

where IV2 = BS.AM2.Size2.Ni.Suc(Counter)

In this protocol, functions F and H are pseudo-random functions that allow
to calculate the encryption key and the authentication key taking as parameters
the master key (Km) and the id of the node (Ni). Due to Avispa does not oﬀer

5

arithmetic semantics, the increase of the counter is represented by a function
Suc, such as Suc(0) represents 1, Suc(Suc(0) represents 2 and so on.

The properties we have to analyse are the following:

– Authentication of Data1 and Data2. i.e., the node Ni and the base station
(BS) share the same value for Data1 and Data2 and both execute the same
session of the protocol. This property allows us to proof that bilateral au-
thentication is achieved by using the MAC, and the integrity of the message
is guarantied.

– Conﬁdentiality of Data1 and Data2, i.e., Data1 and Data2 are secret values
shared between Ni and BS, and they are not known by an intruder or third
parties.

The veriﬁcation with Avispa ﬁnds only the following replay attack, where

IBS represents an intruder playing the role of the base station:

1. BS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV2.{(IV2 ⊕ Data2)}F (Km.N1). {M AC(IV2.Data2)}H(Km.N1)
1. IBS → N1 : IV1.{(IV1 ⊕ Data1)}F (Km.N1). {M AC(IV1.Data1)}H(Km.N1)
2. N1 → BS : IV3.{(IV3 ⊕ Data3)}F (Km.N1). {M AC(IV3.Data3)}H(Km.N1)

where IV2 = BS.AM2.Size2.N1.Suc(0)

where IV1 = N1.AM1.Size1.BS.0

where IV1 = N1.AM1.Size1.BS.0

where IV3 = BS.AM3.Size3.N1.Suc(0)

Nevertheless, as was said before, TinySec does not manage replay attacks,
which are left to higher layers of the protocol stack. Apart from this attack, the
protocol is secure, even when a node is compromised by the intruder.

Case B. In this case we use the same scenario than in the previous case (see Fig.
3), but we consider TinySec-Auth messages instead of TinySec-AE messages.
The protocol for TinySec-AE packets using Avispa syntax is as follows:

1. BS → Ni: Ni.AM1.Size1.Data1. {M AC(Ni.AM1.Size1.Data1)}H(Km.Ni)
2. Ni → BS: BS.AM2.Size2.Data2. {M AC(BS.AM2.Size2.Data2)}H(Km.Ni)
As we mentioned before, TinySec-Auth does not provide any conﬁdentiality
mechanisms. Thus, we can only analyse the authentication of Data1 and Data2,
i.e., we can proof the bilateral authentication between BS and Ni, by means of
the MAC messages, and also the integrity of messages. As in the previous case,
we have found a replay attack that we omit

Case C. The network conﬁguration is shown in Fig. 4. In this case a node (N1)
shares a pairwise key with each of its immediate neighbours (N2 and N3). The
protocol for TinySec-AE packets using Avispa syntax is as follows, where A rep-
resents node N1 and B represents one of its neighbours (N2 or N3):

6

1. A → B : A, N onceA
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K0

AB = H(H(Km.B).A)

where K0

AB

AB

where IV2 = A.AM2.Size2.B.Counter
and KAB = F (F (Km.N2).N1)

N1

N3

N2

Fig. 4. Sensor network: cases C and D

The properties we have to analyse are the following:

– Authentication of N onceA, DataA and DataB. i.e., nodes A and B share
the same value for N onceA, DataA and DataB and both execute the same
session of the protocol.

– Conﬁdentiality of DataB, i.e., DataB is a secret value shared between A and

B, and remains unknown to an intruder or third parties.
In this case Avispa ﬁnds a man-in-the-middle attack, where IA represents
the intruder playing the role of node A, IB2 represents the intruder playing the
role of node B, B1 represents node B communicating with the intruder, and B2
represents node B communicating with A:

1. IA → B1 : A, N onceI
2. B1 → IA : B.{M AC(N onceI .B)}H(Km.B)
1. A → IB2 : A, N onceA
2. IA → B2 : Nx.N onceA
2. B2 → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → IB2 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
3. IA → B1 : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B1 → IA : A.AM2.Size2.B.Counter.{(IV2 ⊕ DataB)}KAB .

AB

AB

{M AC(IV2.DataB)}K0

AB

First the intruder, playing the role of A, starts the protocol with B (denoted
B1), and sends a false nonce, which is answered by B (B1). Then, A starts
a session with B (B2) but this message is intercepted by the intruder (IB2)
which modiﬁes the message and sends to B (B2) the identity of a false node Nx
and the nonce of A. Node B (B2) sends the answer of the last message to A,
and A responds with a request of data (Data2) to B (B2). Again, the request
is intercepted by the intruder who redirects the message to B (B1). At this
moment, B (B1) thinks that it has received a correct request from A, and then
it sends DataB to the intruder playing the role of A (IA)

7

At the end we conclude that B1 has exchanged information (Data2) with
the intruder, and B2 thinks that it has talked to a node Nx that does not exist.
A solution to this attack consists in authenticate no only the answer from B
in message 2 but also the message 1 sent from A. The modiﬁed version of the
protocol is:

1. A → B : A.N onceA.M AC(A.N onceA)H(Km,A)
2. B → A : B.{M AC(N onceA.B)}H(Km.B)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}K0
4. B → A : IV2.{(IV2 ⊕ DataB)}KAB . {M AC(IV2.DataB)}K0

AB = H(H(Km.B).A)

where K0

AB

AB

where IV2 = A.AM2.Size2.B.Counter y KAB = F (F (Km.N2).N1)

Case D. Sensor network conﬁguration is shown in Fig. 4. In this case a node
(N1) shares a cluster key with each of its immediate neighbours (N2 and N3).
The protocol for TinySec-AE packets using Avispa syntax is as follows, where
A represents node N1, B represents one of its neighbours (N2 or N3), and Kc is
the cluster key:

1. A → B : B.AM1.Size1.A.Counter.{(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K0
where IV1 = B.AM1.Size1.A.Counter, KAB = F (F (Km.B).A) and
K0

AB = H(H(Km.B).A)

2. B → A : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
3. A → B : B.AM1.Size1.DataA.{M AC(B.AM1.Size1.DataA)}H(Kc)
4. B → A : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

AB

where IV2 = A.AM2.Size2.B.Suc(Counter)

The properties we have to analyse are the following:

– Authentication of Kc, DataA and DataB. i.e., nodes A and B share the same
value for Kc, DataA and DataB and both execute the same session of the
protocol.

– Conﬁdentiality of DataB and Kc, i.e., DataB and Kc are secret values shared
between A and B, and they remain unknown to an intruder or third parties.
After analysing the protocol with Avispa, an interesting attack based on

types was found:

1. A → B : B.AM1.Size1.A.Counter.{(IV1 ⊕ Kc)}KAB . {M AC(IV1.Kc)}K0

AB

where IV1 = B.AM1.Size1.A.Counter,
KAB = F (F (Km.B).A) and K0

2. B → IA : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
3. IA → B : BS.AM2.Size2.done.{M AC(BS.AM2.Size2.done)}H(Kc)
4. B → IA : IV2.{(IV2 ⊕ DataB)}F (Kc). {M AC(IV2.DataB)}H(Kc)

AB = H(H(Km.B).A)

where IV2 = A.AM2.Size2.B.Suc(Counter)

In this attack the intruder intercepts the message sent from B to A in step
2. In step 3, the intruder sends the intercepted message back to B as if was a
true request from A to B. B takes the message as a request an misunderstands
the label done as it was DataA. In step 4, B sends DataB to the intruder.

8

This is a type ﬂaw attack, i.e., type checking has not be done and a constant
label has been interpreted as a variable data. One solution to this attack has been
proposed by Heather et al. in [?] which basically consists in tagging each ﬁeld
with information about its type, although this solution could not be adequate
in wireless sensor networks because it adds some extra bits of information into
each message. In real implementations of the protocol, programmers should take
into account this type ﬂaw attack and do type checking in order to avoid a
possible attack. In any case, this kind of attack can be a problem because network
bandwidth could be saturated and there is a consumption of resources in the
node.

Case E. Sensor network conﬁguration is shown in Fig. 5. In this case a node
(e.g. N1) shares a cluster key with non immediate neighbouring nodes (e.g. N4
and N5).

N1

N3

N2

N4

N5

Fig. 5. Sensor Network: Case E

The protocol for TinySec-AE packets using Avispa syntax is as follows, where
A represents node N1, B represents a non neighbour node (N4 or N5), Ni rep-
resents a neighbour node (N2 and N3):

Q. A → Ni : A, B
R. Ni → A : A.AM1.Size1.Ni.{M AC(A.AM1.Size1.Ni)}K0
1 . A → Ni : IV2.F (SKi, 0).{(IV2 ⊕ SKi)}KANi
. {M AC(IV2.SKi.F (SKi, 0))}K0
where IV2 = Ni.AM2.Size2.A.Counter
2 . Ni → B : IV3.F (SKi, 0).{(IV3 ⊕ SKi)}KNiB . {M AC(IV3.SKi.F (SKi, 0))}K0

ANi

ANi

NiB

D. B → A : A.AM4.Size4.done{M AC(A.AM4.Size4.done)}Sk

where IV3 = B.AM3.Size3.Ni.Counter
When B has every SKi
where Sk = Sk1 ⊕ . . . ⊕ Skn

Avispa only ﬁnds a replay attack, that we do not consider. Apart from this

attack, the protocol is secure.

4 Conclusions and Future Work

In this paper we have presented a formal approach to the security analysis of
wireless sensor networks by means of a model checking tool called Avispa. Sev-

9

eral models of the network have been considered depending on the relative po-
sition and roles of the nodes. Two wireless sensor security protocols have been
considered in order to build a complete solution: TinySec, who is in charge of
the authentication and encryption of messages, and LEAP, who covers the key
distribution mechanism.

The ﬁve models we have presented have been analysed with Avispa, and we

have obtained the following results:

Case A. Request from the base node to a normal node using an individual key
using messages TinySec-AE. The veriﬁcation with Avispa ﬁnds only a replay
attack where an intruder may play the role of the base station. Nevertheless,
TinySec does not manage replay attacks, which are left to higher layers of the
protocol stack. Apart from this attack, the protocol is secure,

Case B. Request from the base node to a normal node using an individual key
using messages TinySec-Auth. As in the previous case, Avispa ﬁnds only a replay
attack. Under our previous assumptions about replay attacks, we can consider
that the protocol is secure,

Case C. Communication between immediate neighbour nodes using a pairwise
shared key. In this case Avispa ﬁnds a man-in-the-middle attack where the
intruder may play at the same time the role of two nodes in order to obtain real
information from one of them. Consequently, conﬁdentiality is lost. A solution to
this attack is proposed and consists in authenticate the ﬁrst message sent from
the initiator (node A).

Case D. Communication between immediate neighbour nodes using a cluster key.
In this case a type ﬂaw attack is found. As in the previous case, the intruder can
obtain real data from one of the nodes, and therefore conﬁdentiality is lost. A
solution to this kind of attack has been proposed in [?]; nevertheless this solution
is not adequate in wireless sensor networks because increases the overload of
security protocols in messages.

Case E. Communication between non immediate neighbour nodes using a cluster
key. In this case, apart from a replay attack, the protocol is secure.

Our future work is concerned with extending our analysis to other security
protocols for wireless sensor networks such as SNEP, µTESLA (both deﬁned in
[?]), and MiniSec [?]. Also we are interested in the analysis of TinySec with other
distribution key protocols such as LEAP+[?] and TinyPK [?].

References

1. Perrig, A., Stankovic, J.A., Wagner, D.: Security in wireless sensor networks.

Commun. ACM 47 (2004) 53–57

10

2. Karlof, C., Sastry, N., Wagner, D.: TinySec: a link layer security architecture for
wireless sensor networks. In: Proceedings of the 2nd International Conference on
Embedded Networked Sensor Systems, SenSys 2004, Baltimore, MD, USA, Novem-
ber 3-5, 2004, ACM (2004) 162–175

3. Perrig, A., Szewczyk, R., Tygar, J.D., Wen, V., Culler, D.E.: SPINS: Security

protocols for sensor networks. Wireless Networks 8 (2002) 521–534

4. Zhu, S., Setia, S., Jajodia, S.: LEAP: eﬃcient security mechanisms for large-scale
In Jajodia, S., Atluri, V., Jaeger, T., eds.: ACM

distributed sensor networks.
Conference on Computer and Communications Security, ACM (2003) 62–72

5. Chan, H., Perrig, A., Song, D.X.: Random key predistribution schemes for sensor
networks. In: IEEE Symposium on Security and Privacy, IEEE Computer Society
(2003) 197

6. Eschenauer, L., Gligor, V.: A key-management scheme for distributed sensor net-
In Atluri, V., ed.: ACM Conference on Computer and Communications

works.
Security, ACM (2002) 41–47

7. Hill, J., Szewczyk, R., Woo, A., Hollar, S., Culler, D.E., Pister, K.S.J.: System
architecture directions for networked sensors.
In: Inter. Conf. on Architectural
Support for Programming Languages and Operating Systems, ASPLOS. (2000)
93–104

8. Clarke, E.M., Grumberg, O., Peled, D.A.: Model Checking. The MIT Press (1999)
9. Lowe, G.: Casper: A compiler for the analysis of security protocols. Journal of

Computer Security 6 (1998) 53–84

10. Armando, A., Basin, D.A., Boichut, Y., Chevalier, Y., Compagna, L., Cu´ellar, J.,
Drielsma, P.H., H´eam, P.C., Kouchnarenko, O., Mantovani, J., M¨odersheim, S., von
Oheimb, D., Rusinowitch, M., Santiago, J., Turuani, M., Vigan`o, L., Vigneron, L.:
The AVISPA tool for the automated validation of internet security protocols and
applications. In Etessami, K., Rajamani, S.K., eds.: CAV. Volume 3576 of Lecture
Notes in Computer Science., Springer (2005) 281–285

11. Tobarra, M.L., Cazorla, D., Cuartero, F., Diaz, G.: Application of formal methods
to the analysis of web services security.
In Bravetti, M., Kloul, L., Zavattaro,
G., eds.: EPEW/WS-FM. Volume 3670 of Lecture Notes in Computer Science.,
Springer (2005) 215–229

12. Backes, M., M¨odersheim, S., Pﬁtzmann, B., Vigan`o, L.: Symbolic and cryp-
tographic analysis of the secure WS-ReliableMessaging scenario.
In Aceto, L.,
Ing´olfsd´ottir, A., eds.: FoSSaCS. Volume 3921 of Lecture Notes in Computer Sci-
ence., Springer (2006) 428–445

13. Bhargavan, K., Fournet, C., Gordon, A.D.: Verifying policy-based security for web
services. In Atluri, V., Pﬁtzmann, B., McDaniel, P.D., eds.: ACM Conference on
Computer and Communications Security, ACM (2004) 268–277

14. Mitchell, J.C.: Finite-state analysis of security protocols. In Hu, A.J., Vardi, M.Y.,
eds.: CAV. Volume 1427 of Lecture Notes in Computer Science., Springer (1998)
71–76

15. Tobarra, M.L., Cazorla, D., Cuartero, F., Diaz, G.: Formal veriﬁcation of TLS
handshake and extensions for wireless networks. In: Proc. of IADIS International
Conference on Applied Computing (AC’06), San Sebastian, Spain, IADIS Press
(2006) 57–64

16. Chevalier, Y., Compagna, L., Cu´ellar, J., Drielsma, P.H., Mantovani, J., M¨oder-
sheim, S., Vigneron, L.: A high level protocol speciﬁcation language for industrial
security-sensitive protocols.
In: Proceedings of Workshop on Speciﬁcation and
Automated Processing of Security Requirements (SAPS). (2004) 193–205

11

17. Glouche, Y., Genet, T., Heen, O., Courtay, O.: A security protocol animator tool
for AVISPA. In: ARTIST2 Workshop on Security Speciﬁcation and Veriﬁcation of
Embedded Systems, Pisa (2006)

18. Dolev, D., Yao, A.C.C.: On the security of public key protocols. In: FOCS, IEEE

(1981) 350–357

19. Bellare, M., Kilian, J., Rogaway, P.: The security of the cipher block chaining

message authentication code. J. Comput. Syst. Sci. 61 (2000) 362–399

20. Bellare, M., Desai, A., Jokipii, E., Rogaway, P.: A concrete security treatment of
symmetric encryption. In: Proceedings of 38th Annual Symposium on Foundations
of Computer Science, IEEE (1997) 394–403

21. Heather, J., Lowe, G., Schneider, S.: How to prevent type ﬂaw attacks on security

protocols. Journal of Computer Security 11 (2003) 217–244

22. Mark Luk, Ghita Mezzour, A.P., Gligor, V.: Minisec: A secure sensor network
communication architecture. In: Proceedings of IEEE International Conference on
Information Processing in Sensor Networks (IPSN). (2007)

23. Zhu, S., Setia, S., Jajodia, S.: LEAP : Eﬃcient security mechanisms for large-scale
distributed sensor networks. ACM Transactions on Sensor Networks 2 (2006) 500–
528

24. Watro, R.J., Kong, D., Cuti, S.f., Gardiner, C., Lynn, C., Kruus, P.: TinyPK:
In Setia, S., Swarup, V.,

securing sensor networks with public key technology.
eds.: SASN, ACM (2004) 59–64

12

