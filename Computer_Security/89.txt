A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

Table 3 Structural Congruence

if Ah˜vi def= P ∧ | ˜x |=| ˜v |

if v1 . . . vn ‘r v
if

6 ∃ v. v1 . . . vn ‘r v

if v1 6= v2

n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[P ]ν
n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[Q]ν
n[[v = v]P ; Q]ν ≡ n[P ]ν
n[[v1 = v2]P ; Q]ν ≡ n[Q]ν
n[Ah˜vi]ν ≡ n[{v/x}P ]ν
M | N ≡ N | M
(M | N ) | M0 ≡ M | (N | M0)
M | 0 ≡ M
M ≡ M
M ≡ N implies N ≡ M
M ≡ M0 ∧ M0 ≡ M00 implies M ≡ M00
M ≡ N implies M | M0 ≡ N | M0 , for all M0

(Struct DedT)
(Struct DedF)
(Struct Then)
(Struct Else)

(Struct Rec)
(Struct Par Comm)
(Struct Par Assoc)
(Struct Zero Par)
(Struct Reﬂ)
(Struct Symm)
(Struct Trans)
(Struct Ctx Par)

3 Time properties

Proposition 2 formalises the deterministic nature of time passing: a network can
reach at most one new state by executing the action σ.

Proposition 2 (Time Determinism). Let M be a well-formed network. If M
M0 and M

σ−−_ M00 then M0 ≡ M00

σ−−_

The maximal progress property [13] says that processes communicate as soon

as a possibility of communication arises.
Proposition 3 (Maximal Progress). Let M be a well-formed network. If M ≡
m[!hvi.P ]ν | N then M

σ−−_ M0 for no network M0.

Patience guarantees that a process will wait indeﬁnitely until it can communi-
cate [13]. In our setting, this means that if no transmissions can start then it must
be possible to execute a σ-action to let time pass.

Proposition 4 (Patience). Let M ≡ Q

i∈I mi[Pi]νi be a well-formed network,
such that for all i ∈ I it holds that mi[Pi]νi 6≡ mi[!hvi.Qi]νi, then there is a network
N such that M

σ−−_ N.

4 Labelled Transition Semantics

In Table 4, we provide a Labelled Transition System (LTS) for our calculus. In
rule (Snd) a sender dispatches its message to its neighbours ν, and then continues
as P . In the label m!v.ν the set ν contains the neighbours of m which may receive
the message v. In rule (Rcv) a receiver gets a message coming from a neighbour
node m, and then evolves into process P , where all the occurrences of the vari-
able x are replaced with the value v. If no message is received in the current time
interval, the node n will continue with process Q, according to the rule (σ-Rcv).

5

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

Table 3 Structural Congruence

if Ah˜vi def= P ∧ | ˜x |=| ˜v |

if v1 . . . vn ‘r v
if

6 ∃ v. v1 . . . vn ‘r v

if v1 6= v2

n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[P ]ν
n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[Q]ν
n[[v = v]P ; Q]ν ≡ n[P ]ν
n[[v1 = v2]P ; Q]ν ≡ n[Q]ν
n[Ah˜vi]ν ≡ n[{v/x}P ]ν
M | N ≡ N | M
(M | N ) | M0 ≡ M | (N | M0)
M | 0 ≡ M
M ≡ M
M ≡ N implies N ≡ M
M ≡ M0 ∧ M0 ≡ M00 implies M ≡ M00
M ≡ N implies M | M0 ≡ N | M0 , for all M0

(Struct DedT)
(Struct DedF)
(Struct Then)
(Struct Else)

(Struct Rec)
(Struct Par Comm)
(Struct Par Assoc)
(Struct Zero Par)
(Struct Reﬂ)
(Struct Symm)
(Struct Trans)
(Struct Ctx Par)

3 Time properties

Proposition 2 formalises the deterministic nature of time passing: a network can
reach at most one new state by executing the action σ.

Proposition 2 (Time Determinism). Let M be a well-formed network. If M
M0 and M

σ−−_ M00 then M0 ≡ M00

σ−−_

The maximal progress property [13] says that processes communicate as soon

as a possibility of communication arises.
Proposition 3 (Maximal Progress). Let M be a well-formed network. If M ≡
m[!hvi.P ]ν | N then M

σ−−_ M0 for no network M0.

Patience guarantees that a process will wait indeﬁnitely until it can communi-
cate [13]. In our setting, this means that if no transmissions can start then it must
be possible to execute a σ-action to let time pass.

Proposition 4 (Patience). Let M ≡ Q

i∈I mi[Pi]νi be a well-formed network,
such that for all i ∈ I it holds that mi[Pi]νi 6≡ mi[!hvi.Qi]νi, then there is a network
N such that M

σ−−_ N.

4 Labelled Transition Semantics

In Table 4, we provide a Labelled Transition System (LTS) for our calculus. In
rule (Snd) a sender dispatches its message to its neighbours ν, and then continues
as P . In the label m!v.ν the set ν contains the neighbours of m which may receive
the message v. In rule (Rcv) a receiver gets a message coming from a neighbour
node m, and then evolves into process P , where all the occurrences of the vari-
able x are replaced with the value v. If no message is received in the current time
interval, the node n will continue with process Q, according to the rule (σ-Rcv).

5

Table 4 LTS - Transmission, internal actions, and time passing
m ∈ ν

−
−−−−−−→ m[P ]ν

(Snd)

m[!hvi.P ]ν m!vBν
m /∈ nds(M )
m?v−−−−→ M
M

(RcvEnb)

(Rcv)

(RcvPar)

n[b?(x).PcQ]ν m?v−−−−→ n[{v/x}P ]ν
m?v−−−−→ N0

M

m?v−−−−→ M0 N
M | N
ν0 := ν\nds(N )

m?v−−−−→ M0 | N0

M

(Bcast)

m!vBν
−−−−−−→ M0 N

m?v−−−−→ N0
m!vBν0
−−−−−−−→ M0 | N0

M | N

(Tau)

(σ-nil)

τ−−→ m[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ n[nil]ν

n[nil]ν

(σ-Rcv)

(σ-Par)

−
n[b?(x).PcQ]ν
σ−−→ M0 N
M | N

M

σ−−→ M0 | N0

σ−−→ n[Q]ν
σ−−→ N0

(TauPar)

M
M | N

(Delay)

n[σ.P ]ν

τ−−→ M0
τ−−→ M0 | N
−
σ−−→ n[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ 0

(σ-Tau)

(σ-0)

0

σ−−→ m[Q]ν

In rule (RcvPar) we model the composition of two networks receiving the same
message from the same transmitter. Rule (RcvEnb) says that every node can syn-
chronise with an external transmitter m. This rule, together with rule (RcvPar),
serves to model message loss. Rule (Bcast) models the propagation of messages on
the broadcast channel. Note that in rule (Bcast) we loose track of those neighbours
of m that are in N. Rule (Tau) models local computations. Rule (TauPar) serves
to propagate internal computations on parallel components. The remaining rules
model the passage of time. Rule (Delay) model the delay of a time unit. Rules
(σ-nil) and (σ-0) are straightforward. Rules (σ-Rcv) models timeout on receivers.
Similarly, (σ-Tau) models timeout on internal activities. Rule (σ-Par) models time
synchronisation between parallel components. Rules (Bcast) and (TauPar) have their
symmetric counterpart.

In Table 5 we report the obvious rules for nodes containing matching, recursion
and deduction processes (we recall that only guarded recursion is allowed). In the
sequel, we use the metavariable λ to range over the labels: m!v.ν, m?v, τ, and σ.

The LTS-based semantics is consistent with the reduction semantics.

τ−−→≡ M0 or M

m!vBν
−−−−−−→≡ M0, for some m, v, ν.

Theorem 1 (Harmony Theorem).

– If M _ M0 then either M

σ−−_ M0 then M

m!vBν
−−−−−−→ M0 or M
σ−−→ M0 then M

– If M
– If M
– If M

σ−−→≡ M0.

τ−−→ M0 then M _ M0.
σ−−_ M0.

6

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

Table 3 Structural Congruence

if Ah˜vi def= P ∧ | ˜x |=| ˜v |

if v1 . . . vn ‘r v
if

6 ∃ v. v1 . . . vn ‘r v

if v1 6= v2

n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[P ]ν
n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[Q]ν
n[[v = v]P ; Q]ν ≡ n[P ]ν
n[[v1 = v2]P ; Q]ν ≡ n[Q]ν
n[Ah˜vi]ν ≡ n[{v/x}P ]ν
M | N ≡ N | M
(M | N ) | M0 ≡ M | (N | M0)
M | 0 ≡ M
M ≡ M
M ≡ N implies N ≡ M
M ≡ M0 ∧ M0 ≡ M00 implies M ≡ M00
M ≡ N implies M | M0 ≡ N | M0 , for all M0

(Struct DedT)
(Struct DedF)
(Struct Then)
(Struct Else)

(Struct Rec)
(Struct Par Comm)
(Struct Par Assoc)
(Struct Zero Par)
(Struct Reﬂ)
(Struct Symm)
(Struct Trans)
(Struct Ctx Par)

3 Time properties

Proposition 2 formalises the deterministic nature of time passing: a network can
reach at most one new state by executing the action σ.

Proposition 2 (Time Determinism). Let M be a well-formed network. If M
M0 and M

σ−−_ M00 then M0 ≡ M00

σ−−_

The maximal progress property [13] says that processes communicate as soon

as a possibility of communication arises.
Proposition 3 (Maximal Progress). Let M be a well-formed network. If M ≡
m[!hvi.P ]ν | N then M

σ−−_ M0 for no network M0.

Patience guarantees that a process will wait indeﬁnitely until it can communi-
cate [13]. In our setting, this means that if no transmissions can start then it must
be possible to execute a σ-action to let time pass.

Proposition 4 (Patience). Let M ≡ Q

i∈I mi[Pi]νi be a well-formed network,
such that for all i ∈ I it holds that mi[Pi]νi 6≡ mi[!hvi.Qi]νi, then there is a network
N such that M

σ−−_ N.

4 Labelled Transition Semantics

In Table 4, we provide a Labelled Transition System (LTS) for our calculus. In
rule (Snd) a sender dispatches its message to its neighbours ν, and then continues
as P . In the label m!v.ν the set ν contains the neighbours of m which may receive
the message v. In rule (Rcv) a receiver gets a message coming from a neighbour
node m, and then evolves into process P , where all the occurrences of the vari-
able x are replaced with the value v. If no message is received in the current time
interval, the node n will continue with process Q, according to the rule (σ-Rcv).

5

Table 4 LTS - Transmission, internal actions, and time passing
m ∈ ν

−
−−−−−−→ m[P ]ν

(Snd)

m[!hvi.P ]ν m!vBν
m /∈ nds(M )
m?v−−−−→ M
M

(RcvEnb)

(Rcv)

(RcvPar)

n[b?(x).PcQ]ν m?v−−−−→ n[{v/x}P ]ν
m?v−−−−→ N0

M

m?v−−−−→ M0 N
M | N
ν0 := ν\nds(N )

m?v−−−−→ M0 | N0

M

(Bcast)

m!vBν
−−−−−−→ M0 N

m?v−−−−→ N0
m!vBν0
−−−−−−−→ M0 | N0

M | N

(Tau)

(σ-nil)

τ−−→ m[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ n[nil]ν

n[nil]ν

(σ-Rcv)

(σ-Par)

−
n[b?(x).PcQ]ν
σ−−→ M0 N
M | N

M

σ−−→ M0 | N0

σ−−→ n[Q]ν
σ−−→ N0

(TauPar)

M
M | N

(Delay)

n[σ.P ]ν

τ−−→ M0
τ−−→ M0 | N
−
σ−−→ n[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ 0

(σ-Tau)

(σ-0)

0

σ−−→ m[Q]ν

In rule (RcvPar) we model the composition of two networks receiving the same
message from the same transmitter. Rule (RcvEnb) says that every node can syn-
chronise with an external transmitter m. This rule, together with rule (RcvPar),
serves to model message loss. Rule (Bcast) models the propagation of messages on
the broadcast channel. Note that in rule (Bcast) we loose track of those neighbours
of m that are in N. Rule (Tau) models local computations. Rule (TauPar) serves
to propagate internal computations on parallel components. The remaining rules
model the passage of time. Rule (Delay) model the delay of a time unit. Rules
(σ-nil) and (σ-0) are straightforward. Rules (σ-Rcv) models timeout on receivers.
Similarly, (σ-Tau) models timeout on internal activities. Rule (σ-Par) models time
synchronisation between parallel components. Rules (Bcast) and (TauPar) have their
symmetric counterpart.

In Table 5 we report the obvious rules for nodes containing matching, recursion
and deduction processes (we recall that only guarded recursion is allowed). In the
sequel, we use the metavariable λ to range over the labels: m!v.ν, m?v, τ, and σ.

The LTS-based semantics is consistent with the reduction semantics.

τ−−→≡ M0 or M

m!vBν
−−−−−−→≡ M0, for some m, v, ν.

Theorem 1 (Harmony Theorem).

– If M _ M0 then either M

σ−−_ M0 then M

m!vBν
−−−−−−→ M0 or M
σ−−→ M0 then M

– If M
– If M
– If M

σ−−→≡ M0.

τ−−→ M0 then M _ M0.
σ−−_ M0.

6

Table 5 LTS - Matching, recursion and deduction

(Then)

n[P ]ν

λ−−→ n[P 0]ν

n[[v = v]P ; Q]ν

λ−−→ n[P 0]ν

(Else)

λ−−→ n[Q0]ν
n[Q]ν
n[[v1 = v2]P ; Q]ν

v1 6= v2
λ−−→ n[Q0]ν

(Rec)

n[{˜v/˜x}P ]ν

λ−−→ n[P 0]ν H(˜x) def= P

n[Hh˜vi]ν

λ−−→ n[P 0]ν

(Dtt)

n[{v/x}P ]ν λ−−→ n[P 0]ν v1 . . . vn ‘r v
n[[v1 . . . vn ‘r x]P ; Q]ν
λ−−→ n[P 0]ν

(Dﬀ)

n[Q]ν λ−−→ n[Q0]ν
n[[v1 . . . vn ‘r x]P ; Q]ν

6 ∃ v. v1 . . . vn ‘r v
λ−−→ n[Q0]ν

4.1 Behavioural Semantics

We use our LTS to deﬁne a standard notion of timed labelled bisimilarity. In general,
a bisimulation describes how two terms (in our case networks) can mimic each other
actions. Since we are focusing on weak equivalences we have to distinguish between
transmissions which may be observed and transmissions which may not be observed
by the environment. Thus, we extend the set of rules of Table 4 with the following
two rules:

(Shh)

M

m!v.∅−−−−−→ M0
τ−−→ M0
M

M

(Obs)

m!v.ν

−−−−−−→ M0
M

!v.ν−−−−→ M0

ν 6= ∅

Rule (Shh) models transmissions that cannot be observed because none of the poten-
tial receivers is in the environment. Rule (Obs) models a transmission of a message
v that can be received (and hence observed) by those nodes of the environment
contained in ν. The name of the transmitter is removed as in real networks the
identity of the transmitter can only be ensured by using appropriate authentica-
tion protocols. Notice that in a derivation tree the rule (Obs) can only be applied
at top-level.
In the rest of the paper, the metavariable α ranges over the following actions:
!v.ν, m?v, τ, and σ. We adopt the standard notation for weak transitions: =⇒
ˆα==⇒
denotes the reﬂexive and transitive closure of
denotes =⇒ if α = τ and α==⇒ otherwise.
Deﬁnition 2 (Bi-similarity). A relation R over well-formed networks is a simu-
lation if M R N implies that whenever M
α−−→ M0 there is N0 such that N ˆα==⇒ N0
and M0 R N0. A relation R is called bisimulation if both R and its converse are
simulations. We say that M and N are similar, written M . N if there is a simu-
lation R such that M R N. We say that M and N are bisimilar, written M ≈ N,
if there is a bisimulation R such that M R N.
Our notions of similarity and bisimilarity between networks are congruence, as they
are preserved by parallel composition. We only report the result for bisimilarity.
Theorem 2 (≈ is a congruence). Let M and N be two well-formed networks
such that M ≈ N. Then M | O ≈ N | O for all networks O such that M | O and
N | O are well-formed.

α==⇒ denotes =⇒ α−−→ =⇒;

τ−−→;

7

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

Table 3 Structural Congruence

if Ah˜vi def= P ∧ | ˜x |=| ˜v |

if v1 . . . vn ‘r v
if

6 ∃ v. v1 . . . vn ‘r v

if v1 6= v2

n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[P ]ν
n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[Q]ν
n[[v = v]P ; Q]ν ≡ n[P ]ν
n[[v1 = v2]P ; Q]ν ≡ n[Q]ν
n[Ah˜vi]ν ≡ n[{v/x}P ]ν
M | N ≡ N | M
(M | N ) | M0 ≡ M | (N | M0)
M | 0 ≡ M
M ≡ M
M ≡ N implies N ≡ M
M ≡ M0 ∧ M0 ≡ M00 implies M ≡ M00
M ≡ N implies M | M0 ≡ N | M0 , for all M0

(Struct DedT)
(Struct DedF)
(Struct Then)
(Struct Else)

(Struct Rec)
(Struct Par Comm)
(Struct Par Assoc)
(Struct Zero Par)
(Struct Reﬂ)
(Struct Symm)
(Struct Trans)
(Struct Ctx Par)

3 Time properties

Proposition 2 formalises the deterministic nature of time passing: a network can
reach at most one new state by executing the action σ.

Proposition 2 (Time Determinism). Let M be a well-formed network. If M
M0 and M

σ−−_ M00 then M0 ≡ M00

σ−−_

The maximal progress property [13] says that processes communicate as soon

as a possibility of communication arises.
Proposition 3 (Maximal Progress). Let M be a well-formed network. If M ≡
m[!hvi.P ]ν | N then M

σ−−_ M0 for no network M0.

Patience guarantees that a process will wait indeﬁnitely until it can communi-
cate [13]. In our setting, this means that if no transmissions can start then it must
be possible to execute a σ-action to let time pass.

Proposition 4 (Patience). Let M ≡ Q

i∈I mi[Pi]νi be a well-formed network,
such that for all i ∈ I it holds that mi[Pi]νi 6≡ mi[!hvi.Qi]νi, then there is a network
N such that M

σ−−_ N.

4 Labelled Transition Semantics

In Table 4, we provide a Labelled Transition System (LTS) for our calculus. In
rule (Snd) a sender dispatches its message to its neighbours ν, and then continues
as P . In the label m!v.ν the set ν contains the neighbours of m which may receive
the message v. In rule (Rcv) a receiver gets a message coming from a neighbour
node m, and then evolves into process P , where all the occurrences of the vari-
able x are replaced with the value v. If no message is received in the current time
interval, the node n will continue with process Q, according to the rule (σ-Rcv).

5

Table 4 LTS - Transmission, internal actions, and time passing
m ∈ ν

−
−−−−−−→ m[P ]ν

(Snd)

m[!hvi.P ]ν m!vBν
m /∈ nds(M )
m?v−−−−→ M
M

(RcvEnb)

(Rcv)

(RcvPar)

n[b?(x).PcQ]ν m?v−−−−→ n[{v/x}P ]ν
m?v−−−−→ N0

M

m?v−−−−→ M0 N
M | N
ν0 := ν\nds(N )

m?v−−−−→ M0 | N0

M

(Bcast)

m!vBν
−−−−−−→ M0 N

m?v−−−−→ N0
m!vBν0
−−−−−−−→ M0 | N0

M | N

(Tau)

(σ-nil)

τ−−→ m[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ n[nil]ν

n[nil]ν

(σ-Rcv)

(σ-Par)

−
n[b?(x).PcQ]ν
σ−−→ M0 N
M | N

M

σ−−→ M0 | N0

σ−−→ n[Q]ν
σ−−→ N0

(TauPar)

M
M | N

(Delay)

n[σ.P ]ν

τ−−→ M0
τ−−→ M0 | N
−
σ−−→ n[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ 0

(σ-Tau)

(σ-0)

0

σ−−→ m[Q]ν

In rule (RcvPar) we model the composition of two networks receiving the same
message from the same transmitter. Rule (RcvEnb) says that every node can syn-
chronise with an external transmitter m. This rule, together with rule (RcvPar),
serves to model message loss. Rule (Bcast) models the propagation of messages on
the broadcast channel. Note that in rule (Bcast) we loose track of those neighbours
of m that are in N. Rule (Tau) models local computations. Rule (TauPar) serves
to propagate internal computations on parallel components. The remaining rules
model the passage of time. Rule (Delay) model the delay of a time unit. Rules
(σ-nil) and (σ-0) are straightforward. Rules (σ-Rcv) models timeout on receivers.
Similarly, (σ-Tau) models timeout on internal activities. Rule (σ-Par) models time
synchronisation between parallel components. Rules (Bcast) and (TauPar) have their
symmetric counterpart.

In Table 5 we report the obvious rules for nodes containing matching, recursion
and deduction processes (we recall that only guarded recursion is allowed). In the
sequel, we use the metavariable λ to range over the labels: m!v.ν, m?v, τ, and σ.

The LTS-based semantics is consistent with the reduction semantics.

τ−−→≡ M0 or M

m!vBν
−−−−−−→≡ M0, for some m, v, ν.

Theorem 1 (Harmony Theorem).

– If M _ M0 then either M

σ−−_ M0 then M

m!vBν
−−−−−−→ M0 or M
σ−−→ M0 then M

– If M
– If M
– If M

σ−−→≡ M0.

τ−−→ M0 then M _ M0.
σ−−_ M0.

6

Table 5 LTS - Matching, recursion and deduction

(Then)

n[P ]ν

λ−−→ n[P 0]ν

n[[v = v]P ; Q]ν

λ−−→ n[P 0]ν

(Else)

λ−−→ n[Q0]ν
n[Q]ν
n[[v1 = v2]P ; Q]ν

v1 6= v2
λ−−→ n[Q0]ν

(Rec)

n[{˜v/˜x}P ]ν

λ−−→ n[P 0]ν H(˜x) def= P

n[Hh˜vi]ν

λ−−→ n[P 0]ν

(Dtt)

n[{v/x}P ]ν λ−−→ n[P 0]ν v1 . . . vn ‘r v
n[[v1 . . . vn ‘r x]P ; Q]ν
λ−−→ n[P 0]ν

(Dﬀ)

n[Q]ν λ−−→ n[Q0]ν
n[[v1 . . . vn ‘r x]P ; Q]ν

6 ∃ v. v1 . . . vn ‘r v
λ−−→ n[Q0]ν

4.1 Behavioural Semantics

We use our LTS to deﬁne a standard notion of timed labelled bisimilarity. In general,
a bisimulation describes how two terms (in our case networks) can mimic each other
actions. Since we are focusing on weak equivalences we have to distinguish between
transmissions which may be observed and transmissions which may not be observed
by the environment. Thus, we extend the set of rules of Table 4 with the following
two rules:

(Shh)

M

m!v.∅−−−−−→ M0
τ−−→ M0
M

M

(Obs)

m!v.ν

−−−−−−→ M0
M

!v.ν−−−−→ M0

ν 6= ∅

Rule (Shh) models transmissions that cannot be observed because none of the poten-
tial receivers is in the environment. Rule (Obs) models a transmission of a message
v that can be received (and hence observed) by those nodes of the environment
contained in ν. The name of the transmitter is removed as in real networks the
identity of the transmitter can only be ensured by using appropriate authentica-
tion protocols. Notice that in a derivation tree the rule (Obs) can only be applied
at top-level.
In the rest of the paper, the metavariable α ranges over the following actions:
!v.ν, m?v, τ, and σ. We adopt the standard notation for weak transitions: =⇒
ˆα==⇒
denotes the reﬂexive and transitive closure of
denotes =⇒ if α = τ and α==⇒ otherwise.
Deﬁnition 2 (Bi-similarity). A relation R over well-formed networks is a simu-
lation if M R N implies that whenever M
α−−→ M0 there is N0 such that N ˆα==⇒ N0
and M0 R N0. A relation R is called bisimulation if both R and its converse are
simulations. We say that M and N are similar, written M . N if there is a simu-
lation R such that M R N. We say that M and N are bisimilar, written M ≈ N,
if there is a bisimulation R such that M R N.
Our notions of similarity and bisimilarity between networks are congruence, as they
are preserved by parallel composition. We only report the result for bisimilarity.
Theorem 2 (≈ is a congruence). Let M and N be two well-formed networks
such that M ≈ N. Then M | O ≈ N | O for all networks O such that M | O and
N | O are well-formed.

α==⇒ denotes =⇒ α−−→ =⇒;

τ−−→;

7

5 A Framework for the Analysis of Wireless Network

Security Protocols

In order to perform a security analysis of wireless network security protocols, we
adapt a general schema for the deﬁnition of timed security properties, called Timed
Generalized Non-Deducibility on Compositions (tGNDC ) [10], a real-time general-
isation of Generalised Non-Deducibility on Compositions (GNDC ) [17]. The main
idea is the following: a system M is tGN DC α
/ if and only if for every attacker ATT
the composition of the system M with ATT satisﬁes the timed speciﬁcation α(M),
with respect the timed behavioural relation /. The preorder / that we will be using
in the following analysis is the similarity relation .. An attacker is a network, with
some constrains on the data known initially, which tries to attack a protocol by
stealing and faking information transmitted on the communication channel. Given
a network M, we call ID(M) the set of messages (closed values) that appears in
M.1 In our setting, a generic attacker of a network M is a collection of nodes in
the environment of M, with current knowledge Φ:

n∈Env(M ) n[Pn]nds(M ) s.t. ID(Pn) ⊆ D(Φ) for all n.

AT T (Φ, M) def= Q

Deﬁnition 3 (tGNDC). Let M be a network, Φ0 the initial knowledge of the
attacker, and α a function between networks deﬁning the property speciﬁcation for
M as the network α(M). We say that M is tGN DC α. if and only if it holds that
M | AT T (Φ0, M) . α(M).

In order to prove that a network is tGN DC α., we need a timed notion of term
stability [10]. Intuitively, a network M is said to be time-dependent stable if the
attacker cannot increase its knowledge when M runs in the space of a time interval.
This requires the notion of execution trace. A trace is a sequence of labelled transi-
tions, that we will denote in the standard way. If A is sequence of labels α1α2 . . . αn,
we write M A==⇒ M0 to mean M =⇒ α1−−−→ =⇒ ··· =⇒ αn−−−→ =⇒ M0. Let #σ(A) be the
number of occurrences of σ actions in the sequence A.

Deﬁnition 4. We say that a network M is time-dependent stable wrt a sequence
of knowledges {Φj}j≥0, if whenever M | AT T (Φ0, M) A==⇒ M0 | AT T (Φ0, M0) and
#σ(A) = i, then D(Φ0) ⊆ D(Φi).

When two or more networks are time-dependent stable with respect a certain
sequence of knowledges {Φj}j≥0, and they enjoy a certain tGNDC property, then
the following compositionality property holds.
Proposition 5. Let {Φj}j≥0 be a sequence of knowledges, and {Mr}1≤r≤n a set
of time-dependent stable subnetworks, with respect to {Φi}i≥0, such that Mr ∈
, for 1≤r≤n. It follows that:
tGN DC αr(Mr)
1. M1 | . . . | Mn is time-dependent stable;
2. M1 | . . . | Mn ∈ tGN DC α1(M1)|...|αn(Mn)

.

.

.

1 This function can be easily deﬁned along the lines of [10].

8

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

Table 3 Structural Congruence

if Ah˜vi def= P ∧ | ˜x |=| ˜v |

if v1 . . . vn ‘r v
if

6 ∃ v. v1 . . . vn ‘r v

if v1 6= v2

n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[P ]ν
n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[Q]ν
n[[v = v]P ; Q]ν ≡ n[P ]ν
n[[v1 = v2]P ; Q]ν ≡ n[Q]ν
n[Ah˜vi]ν ≡ n[{v/x}P ]ν
M | N ≡ N | M
(M | N ) | M0 ≡ M | (N | M0)
M | 0 ≡ M
M ≡ M
M ≡ N implies N ≡ M
M ≡ M0 ∧ M0 ≡ M00 implies M ≡ M00
M ≡ N implies M | M0 ≡ N | M0 , for all M0

(Struct DedT)
(Struct DedF)
(Struct Then)
(Struct Else)

(Struct Rec)
(Struct Par Comm)
(Struct Par Assoc)
(Struct Zero Par)
(Struct Reﬂ)
(Struct Symm)
(Struct Trans)
(Struct Ctx Par)

3 Time properties

Proposition 2 formalises the deterministic nature of time passing: a network can
reach at most one new state by executing the action σ.

Proposition 2 (Time Determinism). Let M be a well-formed network. If M
M0 and M

σ−−_ M00 then M0 ≡ M00

σ−−_

The maximal progress property [13] says that processes communicate as soon

as a possibility of communication arises.
Proposition 3 (Maximal Progress). Let M be a well-formed network. If M ≡
m[!hvi.P ]ν | N then M

σ−−_ M0 for no network M0.

Patience guarantees that a process will wait indeﬁnitely until it can communi-
cate [13]. In our setting, this means that if no transmissions can start then it must
be possible to execute a σ-action to let time pass.

Proposition 4 (Patience). Let M ≡ Q

i∈I mi[Pi]νi be a well-formed network,
such that for all i ∈ I it holds that mi[Pi]νi 6≡ mi[!hvi.Qi]νi, then there is a network
N such that M

σ−−_ N.

4 Labelled Transition Semantics

In Table 4, we provide a Labelled Transition System (LTS) for our calculus. In
rule (Snd) a sender dispatches its message to its neighbours ν, and then continues
as P . In the label m!v.ν the set ν contains the neighbours of m which may receive
the message v. In rule (Rcv) a receiver gets a message coming from a neighbour
node m, and then evolves into process P , where all the occurrences of the vari-
able x are replaced with the value v. If no message is received in the current time
interval, the node n will continue with process Q, according to the rule (σ-Rcv).

5

Table 4 LTS - Transmission, internal actions, and time passing
m ∈ ν

−
−−−−−−→ m[P ]ν

(Snd)

m[!hvi.P ]ν m!vBν
m /∈ nds(M )
m?v−−−−→ M
M

(RcvEnb)

(Rcv)

(RcvPar)

n[b?(x).PcQ]ν m?v−−−−→ n[{v/x}P ]ν
m?v−−−−→ N0

M

m?v−−−−→ M0 N
M | N
ν0 := ν\nds(N )

m?v−−−−→ M0 | N0

M

(Bcast)

m!vBν
−−−−−−→ M0 N

m?v−−−−→ N0
m!vBν0
−−−−−−−→ M0 | N0

M | N

(Tau)

(σ-nil)

τ−−→ m[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ n[nil]ν

n[nil]ν

(σ-Rcv)

(σ-Par)

−
n[b?(x).PcQ]ν
σ−−→ M0 N
M | N

M

σ−−→ M0 | N0

σ−−→ n[Q]ν
σ−−→ N0

(TauPar)

M
M | N

(Delay)

n[σ.P ]ν

τ−−→ M0
τ−−→ M0 | N
−
σ−−→ n[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ 0

(σ-Tau)

(σ-0)

0

σ−−→ m[Q]ν

In rule (RcvPar) we model the composition of two networks receiving the same
message from the same transmitter. Rule (RcvEnb) says that every node can syn-
chronise with an external transmitter m. This rule, together with rule (RcvPar),
serves to model message loss. Rule (Bcast) models the propagation of messages on
the broadcast channel. Note that in rule (Bcast) we loose track of those neighbours
of m that are in N. Rule (Tau) models local computations. Rule (TauPar) serves
to propagate internal computations on parallel components. The remaining rules
model the passage of time. Rule (Delay) model the delay of a time unit. Rules
(σ-nil) and (σ-0) are straightforward. Rules (σ-Rcv) models timeout on receivers.
Similarly, (σ-Tau) models timeout on internal activities. Rule (σ-Par) models time
synchronisation between parallel components. Rules (Bcast) and (TauPar) have their
symmetric counterpart.

In Table 5 we report the obvious rules for nodes containing matching, recursion
and deduction processes (we recall that only guarded recursion is allowed). In the
sequel, we use the metavariable λ to range over the labels: m!v.ν, m?v, τ, and σ.

The LTS-based semantics is consistent with the reduction semantics.

τ−−→≡ M0 or M

m!vBν
−−−−−−→≡ M0, for some m, v, ν.

Theorem 1 (Harmony Theorem).

– If M _ M0 then either M

σ−−_ M0 then M

m!vBν
−−−−−−→ M0 or M
σ−−→ M0 then M

– If M
– If M
– If M

σ−−→≡ M0.

τ−−→ M0 then M _ M0.
σ−−_ M0.

6

Table 5 LTS - Matching, recursion and deduction

(Then)

n[P ]ν

λ−−→ n[P 0]ν

n[[v = v]P ; Q]ν

λ−−→ n[P 0]ν

(Else)

λ−−→ n[Q0]ν
n[Q]ν
n[[v1 = v2]P ; Q]ν

v1 6= v2
λ−−→ n[Q0]ν

(Rec)

n[{˜v/˜x}P ]ν

λ−−→ n[P 0]ν H(˜x) def= P

n[Hh˜vi]ν

λ−−→ n[P 0]ν

(Dtt)

n[{v/x}P ]ν λ−−→ n[P 0]ν v1 . . . vn ‘r v
n[[v1 . . . vn ‘r x]P ; Q]ν
λ−−→ n[P 0]ν

(Dﬀ)

n[Q]ν λ−−→ n[Q0]ν
n[[v1 . . . vn ‘r x]P ; Q]ν

6 ∃ v. v1 . . . vn ‘r v
λ−−→ n[Q0]ν

4.1 Behavioural Semantics

We use our LTS to deﬁne a standard notion of timed labelled bisimilarity. In general,
a bisimulation describes how two terms (in our case networks) can mimic each other
actions. Since we are focusing on weak equivalences we have to distinguish between
transmissions which may be observed and transmissions which may not be observed
by the environment. Thus, we extend the set of rules of Table 4 with the following
two rules:

(Shh)

M

m!v.∅−−−−−→ M0
τ−−→ M0
M

M

(Obs)

m!v.ν

−−−−−−→ M0
M

!v.ν−−−−→ M0

ν 6= ∅

Rule (Shh) models transmissions that cannot be observed because none of the poten-
tial receivers is in the environment. Rule (Obs) models a transmission of a message
v that can be received (and hence observed) by those nodes of the environment
contained in ν. The name of the transmitter is removed as in real networks the
identity of the transmitter can only be ensured by using appropriate authentica-
tion protocols. Notice that in a derivation tree the rule (Obs) can only be applied
at top-level.
In the rest of the paper, the metavariable α ranges over the following actions:
!v.ν, m?v, τ, and σ. We adopt the standard notation for weak transitions: =⇒
ˆα==⇒
denotes the reﬂexive and transitive closure of
denotes =⇒ if α = τ and α==⇒ otherwise.
Deﬁnition 2 (Bi-similarity). A relation R over well-formed networks is a simu-
lation if M R N implies that whenever M
α−−→ M0 there is N0 such that N ˆα==⇒ N0
and M0 R N0. A relation R is called bisimulation if both R and its converse are
simulations. We say that M and N are similar, written M . N if there is a simu-
lation R such that M R N. We say that M and N are bisimilar, written M ≈ N,
if there is a bisimulation R such that M R N.
Our notions of similarity and bisimilarity between networks are congruence, as they
are preserved by parallel composition. We only report the result for bisimilarity.
Theorem 2 (≈ is a congruence). Let M and N be two well-formed networks
such that M ≈ N. Then M | O ≈ N | O for all networks O such that M | O and
N | O are well-formed.

α==⇒ denotes =⇒ α−−→ =⇒;

τ−−→;

7

5 A Framework for the Analysis of Wireless Network

Security Protocols

In order to perform a security analysis of wireless network security protocols, we
adapt a general schema for the deﬁnition of timed security properties, called Timed
Generalized Non-Deducibility on Compositions (tGNDC ) [10], a real-time general-
isation of Generalised Non-Deducibility on Compositions (GNDC ) [17]. The main
idea is the following: a system M is tGN DC α
/ if and only if for every attacker ATT
the composition of the system M with ATT satisﬁes the timed speciﬁcation α(M),
with respect the timed behavioural relation /. The preorder / that we will be using
in the following analysis is the similarity relation .. An attacker is a network, with
some constrains on the data known initially, which tries to attack a protocol by
stealing and faking information transmitted on the communication channel. Given
a network M, we call ID(M) the set of messages (closed values) that appears in
M.1 In our setting, a generic attacker of a network M is a collection of nodes in
the environment of M, with current knowledge Φ:

n∈Env(M ) n[Pn]nds(M ) s.t. ID(Pn) ⊆ D(Φ) for all n.

AT T (Φ, M) def= Q

Deﬁnition 3 (tGNDC). Let M be a network, Φ0 the initial knowledge of the
attacker, and α a function between networks deﬁning the property speciﬁcation for
M as the network α(M). We say that M is tGN DC α. if and only if it holds that
M | AT T (Φ0, M) . α(M).

In order to prove that a network is tGN DC α., we need a timed notion of term
stability [10]. Intuitively, a network M is said to be time-dependent stable if the
attacker cannot increase its knowledge when M runs in the space of a time interval.
This requires the notion of execution trace. A trace is a sequence of labelled transi-
tions, that we will denote in the standard way. If A is sequence of labels α1α2 . . . αn,
we write M A==⇒ M0 to mean M =⇒ α1−−−→ =⇒ ··· =⇒ αn−−−→ =⇒ M0. Let #σ(A) be the
number of occurrences of σ actions in the sequence A.

Deﬁnition 4. We say that a network M is time-dependent stable wrt a sequence
of knowledges {Φj}j≥0, if whenever M | AT T (Φ0, M) A==⇒ M0 | AT T (Φ0, M0) and
#σ(A) = i, then D(Φ0) ⊆ D(Φi).

When two or more networks are time-dependent stable with respect a certain
sequence of knowledges {Φj}j≥0, and they enjoy a certain tGNDC property, then
the following compositionality property holds.
Proposition 5. Let {Φj}j≥0 be a sequence of knowledges, and {Mr}1≤r≤n a set
of time-dependent stable subnetworks, with respect to {Φi}i≥0, such that Mr ∈
, for 1≤r≤n. It follows that:
tGN DC αr(Mr)
1. M1 | . . . | Mn is time-dependent stable;
2. M1 | . . . | Mn ∈ tGN DC α1(M1)|...|αn(Mn)

.

.

.

1 This function can be easily deﬁned along the lines of [10].

8

As in [10], we formalise two useful timed properties for security protocols in
terms of use tGN DC α
/ : timed integrity, which guarantees that only fresh packets are
authenticated, and timed agreement, for which agreement must be reached within a
certain deadline, otherwise authentications does not hold. More precisely, a protocol
is said to enjoy the timed integrity property if, whenever a packet p is authenticated
during the time interval i, then this packet was sent at most i − δ time intervals
before. A protocol is said to enjoy the timed agreement property if, whenever a
responder n has completed a run of the protocol, apparently with an initiator m,
then the latter has initiated the protocol, apparently with the former, at most δ
time intervals before, and the two agents agreed on a set of data d.

6 The µTESLA protocol

The µTESLA protocol was designed by Perrig et al. [14] to provide authenti-
cated broadcast for sensor networks. µTESLA calculates the Message Authenti-
cation Code (MAC) for every packet pi that it is transmitted by using a diﬀerent
key ki. These keys are generated with a public one-way function F such that, if
k0, k1, . . . , kn are the keys used in the transmission, F (ki) = ki−1, for 1 ≤ i ≤ n.
The transmission time is split into time intervals and each key is tied to one of
them. In each time interval one or more packets are deployed by the sender, each
one containing the payload and the MAC calculated with the key bound to that in-
terval. When a new interval starts, the key tied to the previous interval is disclosed
to all receivers, so that they can authenticate all the packets previously received.
Sender and receivers are loosely time synchronised on the key disclosure time to
prevent malicious nodes to forge packets with modiﬁed payloads. Nodes discard
packets containing MACs calculated with already disclosed keys, as those packets
could come from an attacker. This key-chain mechanism together with the one-way
function F , provides two major advantages: (i) it allows to calculate lost keys by
simply applying F to the last received key, as many times as necessary; (ii) every
node can authenticate the most recent key ki by means of the last received key kl
(stored in the node memory) and the function F ; once authenticated, ki replaces
kl in the node memory. The protocol works under the assumption that all nodes
share an initial key k0, before the protocol starts.

In Table 6 we provide a speciﬁcation of the µTESLA protocol in tcryptoCWS.
Besides the deduction rules for dealing with pairs, we require a deduction rule to
build MACs: v1 v2 ‘mac mac(v1, v2). Our encoding contains a few simpliﬁcations
with respect to the original protocol. First of all, there is only one packet sent per
time interval, and the sender dispatches one packet and one key alternately. This
yields a simpler and easier to read model. Second, our speciﬁcation does not account
for bootstrapping new receivers on the ﬂy.

Let us proceed with the description of our encoding. We essentially deﬁne two
i , where i is the index number of
kinds of processes: senders, Si, and receivers, Rkl
the current key, and kl is the last authenticated key. Since, we bind one packet with
one key, i also refers to the index number of packets. So, a network starting the
protocol can be represented as:

µTESLA def= m[S1]νm | n1[Rk0

1 ]νn1 | . . . | nk[Rk0

1 ]νnk

9

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

Table 3 Structural Congruence

if Ah˜vi def= P ∧ | ˜x |=| ˜v |

if v1 . . . vn ‘r v
if

6 ∃ v. v1 . . . vn ‘r v

if v1 6= v2

n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[P ]ν
n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[Q]ν
n[[v = v]P ; Q]ν ≡ n[P ]ν
n[[v1 = v2]P ; Q]ν ≡ n[Q]ν
n[Ah˜vi]ν ≡ n[{v/x}P ]ν
M | N ≡ N | M
(M | N ) | M0 ≡ M | (N | M0)
M | 0 ≡ M
M ≡ M
M ≡ N implies N ≡ M
M ≡ M0 ∧ M0 ≡ M00 implies M ≡ M00
M ≡ N implies M | M0 ≡ N | M0 , for all M0

(Struct DedT)
(Struct DedF)
(Struct Then)
(Struct Else)

(Struct Rec)
(Struct Par Comm)
(Struct Par Assoc)
(Struct Zero Par)
(Struct Reﬂ)
(Struct Symm)
(Struct Trans)
(Struct Ctx Par)

3 Time properties

Proposition 2 formalises the deterministic nature of time passing: a network can
reach at most one new state by executing the action σ.

Proposition 2 (Time Determinism). Let M be a well-formed network. If M
M0 and M

σ−−_ M00 then M0 ≡ M00

σ−−_

The maximal progress property [13] says that processes communicate as soon

as a possibility of communication arises.
Proposition 3 (Maximal Progress). Let M be a well-formed network. If M ≡
m[!hvi.P ]ν | N then M

σ−−_ M0 for no network M0.

Patience guarantees that a process will wait indeﬁnitely until it can communi-
cate [13]. In our setting, this means that if no transmissions can start then it must
be possible to execute a σ-action to let time pass.

Proposition 4 (Patience). Let M ≡ Q

i∈I mi[Pi]νi be a well-formed network,
such that for all i ∈ I it holds that mi[Pi]νi 6≡ mi[!hvi.Qi]νi, then there is a network
N such that M

σ−−_ N.

4 Labelled Transition Semantics

In Table 4, we provide a Labelled Transition System (LTS) for our calculus. In
rule (Snd) a sender dispatches its message to its neighbours ν, and then continues
as P . In the label m!v.ν the set ν contains the neighbours of m which may receive
the message v. In rule (Rcv) a receiver gets a message coming from a neighbour
node m, and then evolves into process P , where all the occurrences of the vari-
able x are replaced with the value v. If no message is received in the current time
interval, the node n will continue with process Q, according to the rule (σ-Rcv).

5

Table 4 LTS - Transmission, internal actions, and time passing
m ∈ ν

−
−−−−−−→ m[P ]ν

(Snd)

m[!hvi.P ]ν m!vBν
m /∈ nds(M )
m?v−−−−→ M
M

(RcvEnb)

(Rcv)

(RcvPar)

n[b?(x).PcQ]ν m?v−−−−→ n[{v/x}P ]ν
m?v−−−−→ N0

M

m?v−−−−→ M0 N
M | N
ν0 := ν\nds(N )

m?v−−−−→ M0 | N0

M

(Bcast)

m!vBν
−−−−−−→ M0 N

m?v−−−−→ N0
m!vBν0
−−−−−−−→ M0 | N0

M | N

(Tau)

(σ-nil)

τ−−→ m[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ n[nil]ν

n[nil]ν

(σ-Rcv)

(σ-Par)

−
n[b?(x).PcQ]ν
σ−−→ M0 N
M | N

M

σ−−→ M0 | N0

σ−−→ n[Q]ν
σ−−→ N0

(TauPar)

M
M | N

(Delay)

n[σ.P ]ν

τ−−→ M0
τ−−→ M0 | N
−
σ−−→ n[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ 0

(σ-Tau)

(σ-0)

0

σ−−→ m[Q]ν

In rule (RcvPar) we model the composition of two networks receiving the same
message from the same transmitter. Rule (RcvEnb) says that every node can syn-
chronise with an external transmitter m. This rule, together with rule (RcvPar),
serves to model message loss. Rule (Bcast) models the propagation of messages on
the broadcast channel. Note that in rule (Bcast) we loose track of those neighbours
of m that are in N. Rule (Tau) models local computations. Rule (TauPar) serves
to propagate internal computations on parallel components. The remaining rules
model the passage of time. Rule (Delay) model the delay of a time unit. Rules
(σ-nil) and (σ-0) are straightforward. Rules (σ-Rcv) models timeout on receivers.
Similarly, (σ-Tau) models timeout on internal activities. Rule (σ-Par) models time
synchronisation between parallel components. Rules (Bcast) and (TauPar) have their
symmetric counterpart.

In Table 5 we report the obvious rules for nodes containing matching, recursion
and deduction processes (we recall that only guarded recursion is allowed). In the
sequel, we use the metavariable λ to range over the labels: m!v.ν, m?v, τ, and σ.

The LTS-based semantics is consistent with the reduction semantics.

τ−−→≡ M0 or M

m!vBν
−−−−−−→≡ M0, for some m, v, ν.

Theorem 1 (Harmony Theorem).

– If M _ M0 then either M

σ−−_ M0 then M

m!vBν
−−−−−−→ M0 or M
σ−−→ M0 then M

– If M
– If M
– If M

σ−−→≡ M0.

τ−−→ M0 then M _ M0.
σ−−_ M0.

6

Table 5 LTS - Matching, recursion and deduction

(Then)

n[P ]ν

λ−−→ n[P 0]ν

n[[v = v]P ; Q]ν

λ−−→ n[P 0]ν

(Else)

λ−−→ n[Q0]ν
n[Q]ν
n[[v1 = v2]P ; Q]ν

v1 6= v2
λ−−→ n[Q0]ν

(Rec)

n[{˜v/˜x}P ]ν

λ−−→ n[P 0]ν H(˜x) def= P

n[Hh˜vi]ν

λ−−→ n[P 0]ν

(Dtt)

n[{v/x}P ]ν λ−−→ n[P 0]ν v1 . . . vn ‘r v
n[[v1 . . . vn ‘r x]P ; Q]ν
λ−−→ n[P 0]ν

(Dﬀ)

n[Q]ν λ−−→ n[Q0]ν
n[[v1 . . . vn ‘r x]P ; Q]ν

6 ∃ v. v1 . . . vn ‘r v
λ−−→ n[Q0]ν

4.1 Behavioural Semantics

We use our LTS to deﬁne a standard notion of timed labelled bisimilarity. In general,
a bisimulation describes how two terms (in our case networks) can mimic each other
actions. Since we are focusing on weak equivalences we have to distinguish between
transmissions which may be observed and transmissions which may not be observed
by the environment. Thus, we extend the set of rules of Table 4 with the following
two rules:

(Shh)

M

m!v.∅−−−−−→ M0
τ−−→ M0
M

M

(Obs)

m!v.ν

−−−−−−→ M0
M

!v.ν−−−−→ M0

ν 6= ∅

Rule (Shh) models transmissions that cannot be observed because none of the poten-
tial receivers is in the environment. Rule (Obs) models a transmission of a message
v that can be received (and hence observed) by those nodes of the environment
contained in ν. The name of the transmitter is removed as in real networks the
identity of the transmitter can only be ensured by using appropriate authentica-
tion protocols. Notice that in a derivation tree the rule (Obs) can only be applied
at top-level.
In the rest of the paper, the metavariable α ranges over the following actions:
!v.ν, m?v, τ, and σ. We adopt the standard notation for weak transitions: =⇒
ˆα==⇒
denotes the reﬂexive and transitive closure of
denotes =⇒ if α = τ and α==⇒ otherwise.
Deﬁnition 2 (Bi-similarity). A relation R over well-formed networks is a simu-
lation if M R N implies that whenever M
α−−→ M0 there is N0 such that N ˆα==⇒ N0
and M0 R N0. A relation R is called bisimulation if both R and its converse are
simulations. We say that M and N are similar, written M . N if there is a simu-
lation R such that M R N. We say that M and N are bisimilar, written M ≈ N,
if there is a bisimulation R such that M R N.
Our notions of similarity and bisimilarity between networks are congruence, as they
are preserved by parallel composition. We only report the result for bisimilarity.
Theorem 2 (≈ is a congruence). Let M and N be two well-formed networks
such that M ≈ N. Then M | O ≈ N | O for all networks O such that M | O and
N | O are well-formed.

α==⇒ denotes =⇒ α−−→ =⇒;

τ−−→;

7

5 A Framework for the Analysis of Wireless Network

Security Protocols

In order to perform a security analysis of wireless network security protocols, we
adapt a general schema for the deﬁnition of timed security properties, called Timed
Generalized Non-Deducibility on Compositions (tGNDC ) [10], a real-time general-
isation of Generalised Non-Deducibility on Compositions (GNDC ) [17]. The main
idea is the following: a system M is tGN DC α
/ if and only if for every attacker ATT
the composition of the system M with ATT satisﬁes the timed speciﬁcation α(M),
with respect the timed behavioural relation /. The preorder / that we will be using
in the following analysis is the similarity relation .. An attacker is a network, with
some constrains on the data known initially, which tries to attack a protocol by
stealing and faking information transmitted on the communication channel. Given
a network M, we call ID(M) the set of messages (closed values) that appears in
M.1 In our setting, a generic attacker of a network M is a collection of nodes in
the environment of M, with current knowledge Φ:

n∈Env(M ) n[Pn]nds(M ) s.t. ID(Pn) ⊆ D(Φ) for all n.

AT T (Φ, M) def= Q

Deﬁnition 3 (tGNDC). Let M be a network, Φ0 the initial knowledge of the
attacker, and α a function between networks deﬁning the property speciﬁcation for
M as the network α(M). We say that M is tGN DC α. if and only if it holds that
M | AT T (Φ0, M) . α(M).

In order to prove that a network is tGN DC α., we need a timed notion of term
stability [10]. Intuitively, a network M is said to be time-dependent stable if the
attacker cannot increase its knowledge when M runs in the space of a time interval.
This requires the notion of execution trace. A trace is a sequence of labelled transi-
tions, that we will denote in the standard way. If A is sequence of labels α1α2 . . . αn,
we write M A==⇒ M0 to mean M =⇒ α1−−−→ =⇒ ··· =⇒ αn−−−→ =⇒ M0. Let #σ(A) be the
number of occurrences of σ actions in the sequence A.

Deﬁnition 4. We say that a network M is time-dependent stable wrt a sequence
of knowledges {Φj}j≥0, if whenever M | AT T (Φ0, M) A==⇒ M0 | AT T (Φ0, M0) and
#σ(A) = i, then D(Φ0) ⊆ D(Φi).

When two or more networks are time-dependent stable with respect a certain
sequence of knowledges {Φj}j≥0, and they enjoy a certain tGNDC property, then
the following compositionality property holds.
Proposition 5. Let {Φj}j≥0 be a sequence of knowledges, and {Mr}1≤r≤n a set
of time-dependent stable subnetworks, with respect to {Φi}i≥0, such that Mr ∈
, for 1≤r≤n. It follows that:
tGN DC αr(Mr)
1. M1 | . . . | Mn is time-dependent stable;
2. M1 | . . . | Mn ∈ tGN DC α1(M1)|...|αn(Mn)

.

.

.

1 This function can be easily deﬁned along the lines of [10].

8

As in [10], we formalise two useful timed properties for security protocols in
terms of use tGN DC α
/ : timed integrity, which guarantees that only fresh packets are
authenticated, and timed agreement, for which agreement must be reached within a
certain deadline, otherwise authentications does not hold. More precisely, a protocol
is said to enjoy the timed integrity property if, whenever a packet p is authenticated
during the time interval i, then this packet was sent at most i − δ time intervals
before. A protocol is said to enjoy the timed agreement property if, whenever a
responder n has completed a run of the protocol, apparently with an initiator m,
then the latter has initiated the protocol, apparently with the former, at most δ
time intervals before, and the two agents agreed on a set of data d.

6 The µTESLA protocol

The µTESLA protocol was designed by Perrig et al. [14] to provide authenti-
cated broadcast for sensor networks. µTESLA calculates the Message Authenti-
cation Code (MAC) for every packet pi that it is transmitted by using a diﬀerent
key ki. These keys are generated with a public one-way function F such that, if
k0, k1, . . . , kn are the keys used in the transmission, F (ki) = ki−1, for 1 ≤ i ≤ n.
The transmission time is split into time intervals and each key is tied to one of
them. In each time interval one or more packets are deployed by the sender, each
one containing the payload and the MAC calculated with the key bound to that in-
terval. When a new interval starts, the key tied to the previous interval is disclosed
to all receivers, so that they can authenticate all the packets previously received.
Sender and receivers are loosely time synchronised on the key disclosure time to
prevent malicious nodes to forge packets with modiﬁed payloads. Nodes discard
packets containing MACs calculated with already disclosed keys, as those packets
could come from an attacker. This key-chain mechanism together with the one-way
function F , provides two major advantages: (i) it allows to calculate lost keys by
simply applying F to the last received key, as many times as necessary; (ii) every
node can authenticate the most recent key ki by means of the last received key kl
(stored in the node memory) and the function F ; once authenticated, ki replaces
kl in the node memory. The protocol works under the assumption that all nodes
share an initial key k0, before the protocol starts.

In Table 6 we provide a speciﬁcation of the µTESLA protocol in tcryptoCWS.
Besides the deduction rules for dealing with pairs, we require a deduction rule to
build MACs: v1 v2 ‘mac mac(v1, v2). Our encoding contains a few simpliﬁcations
with respect to the original protocol. First of all, there is only one packet sent per
time interval, and the sender dispatches one packet and one key alternately. This
yields a simpler and easier to read model. Second, our speciﬁcation does not account
for bootstrapping new receivers on the ﬂy.

Let us proceed with the description of our encoding. We essentially deﬁne two
i , where i is the index number of
kinds of processes: senders, Si, and receivers, Rkl
the current key, and kl is the last authenticated key. Since, we bind one packet with
one key, i also refers to the index number of packets. So, a network starting the
protocol can be represented as:

µTESLA def= m[S1]νm | n1[Rk0

1 ]νn1 | . . . | nk[Rk0

1 ]νnk

9

Table 6 µTESLA speciﬁcation
Sender:

Si

def= [xi ki ‘mac mi]
[mi xi ‘pair pi]
!hpii.σ.
!hkii.σ.
Si+1

Receiver:

Rkl
i

Qkl
i

P kl
i

T kl
i
U ki
i

Z ki
i

def= b?(p).σ.P kl

def= b?(k).σ.Rkl

i

i cQkl
i+1cRkl

i+1

def= b?(k).T kl

i cRkl

i+1

i

def= [F i−l(k) = kl]U ki
def= [p ‘fst m]
[p ‘snd x]
[x k ‘mac m0]
[m = m0]Z ki
def= !hauthii.σ.Rki

i

i+1

; σ.Rki
i+1

Calculate MAC using payload and key,
build a packet with mac and payload,
broadcast packet pi, synchronise,
broadcast key ki, synchronise,
and go to next sending state.

Receive a packet, synchronise, and go to P kl
i
if timeout go to Qkl
i .
Receive a key, synchronise, and
go to next receiving state.
Receive a key k and move to state T kl
i
if timeout go to next receiving state.

;

;

; σ.Rkl

i+1 Check key k using F and the stored key kl,

extract MAC from packet p,
extract payload from packet p,
calculate mac for packet p,
verify if it matches with the received one,

if so, authenticate packet i, synchronise,
go to next receiving state, and store ki.

where m is the transmitter and ni are the receivers. Formally, {n1, . . . , nk} ⊆ νm,
and m ∈ νnj , for 1≤j≤k. For veriﬁcation reasons we assume that the environment
contains a fresh node test, unknown to the attacker, to test successful packet au-
thentication. For simplicity, we assume that this node cannot transmit but it can
only receive messages. Thus, test ∈ νm and test ∈ νnj , for 1≤j≤k.

6.1 Security analysis

Let us prove that µTESLA enjoys timed integrity. In particular, we prove that
receivers authenticate only packets that have been sent in the previous time interval
(δ = 1), in the correct order, even in the presence of the intruder. The key point is
that even if the intruder acquires shared keys then it is “too late” to break integrity,
i.e. to authenticate packets older than δ. Let us deﬁne the timed integrity property
via an abstraction of the protocol with no possible intruders:

α(µTESLA) def= m[S1]test | n1[ ˆR1]test | . . . | nk[ ˆR1]test

Here, S1 is the process deﬁned in Table 6, while ˆRi
Obviously, here we abstract on receivers.

def= σ.bτ.!hauthii.σ. ˆRi+1c ˆRi+1.

Let us demonstrate that α(µTESLA) enjoys timed integrity with δ = 1.

Lemma 1. – If m[S1]test A==⇒ m!pi.test
– If nj[ ˆR1]test A==⇒ nj !authi.test

−−−−−−−−→ then #σ(A) = 2(i − 1).

−−−−−−−−−−→, for some 1≤j≤k, then #σ(A) = 2(i − 1) + 1.

10

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

Table 3 Structural Congruence

if Ah˜vi def= P ∧ | ˜x |=| ˜v |

if v1 . . . vn ‘r v
if

6 ∃ v. v1 . . . vn ‘r v

if v1 6= v2

n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[P ]ν
n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[Q]ν
n[[v = v]P ; Q]ν ≡ n[P ]ν
n[[v1 = v2]P ; Q]ν ≡ n[Q]ν
n[Ah˜vi]ν ≡ n[{v/x}P ]ν
M | N ≡ N | M
(M | N ) | M0 ≡ M | (N | M0)
M | 0 ≡ M
M ≡ M
M ≡ N implies N ≡ M
M ≡ M0 ∧ M0 ≡ M00 implies M ≡ M00
M ≡ N implies M | M0 ≡ N | M0 , for all M0

(Struct DedT)
(Struct DedF)
(Struct Then)
(Struct Else)

(Struct Rec)
(Struct Par Comm)
(Struct Par Assoc)
(Struct Zero Par)
(Struct Reﬂ)
(Struct Symm)
(Struct Trans)
(Struct Ctx Par)

3 Time properties

Proposition 2 formalises the deterministic nature of time passing: a network can
reach at most one new state by executing the action σ.

Proposition 2 (Time Determinism). Let M be a well-formed network. If M
M0 and M

σ−−_ M00 then M0 ≡ M00

σ−−_

The maximal progress property [13] says that processes communicate as soon

as a possibility of communication arises.
Proposition 3 (Maximal Progress). Let M be a well-formed network. If M ≡
m[!hvi.P ]ν | N then M

σ−−_ M0 for no network M0.

Patience guarantees that a process will wait indeﬁnitely until it can communi-
cate [13]. In our setting, this means that if no transmissions can start then it must
be possible to execute a σ-action to let time pass.

Proposition 4 (Patience). Let M ≡ Q

i∈I mi[Pi]νi be a well-formed network,
such that for all i ∈ I it holds that mi[Pi]νi 6≡ mi[!hvi.Qi]νi, then there is a network
N such that M

σ−−_ N.

4 Labelled Transition Semantics

In Table 4, we provide a Labelled Transition System (LTS) for our calculus. In
rule (Snd) a sender dispatches its message to its neighbours ν, and then continues
as P . In the label m!v.ν the set ν contains the neighbours of m which may receive
the message v. In rule (Rcv) a receiver gets a message coming from a neighbour
node m, and then evolves into process P , where all the occurrences of the vari-
able x are replaced with the value v. If no message is received in the current time
interval, the node n will continue with process Q, according to the rule (σ-Rcv).

5

Table 4 LTS - Transmission, internal actions, and time passing
m ∈ ν

−
−−−−−−→ m[P ]ν

(Snd)

m[!hvi.P ]ν m!vBν
m /∈ nds(M )
m?v−−−−→ M
M

(RcvEnb)

(Rcv)

(RcvPar)

n[b?(x).PcQ]ν m?v−−−−→ n[{v/x}P ]ν
m?v−−−−→ N0

M

m?v−−−−→ M0 N
M | N
ν0 := ν\nds(N )

m?v−−−−→ M0 | N0

M

(Bcast)

m!vBν
−−−−−−→ M0 N

m?v−−−−→ N0
m!vBν0
−−−−−−−→ M0 | N0

M | N

(Tau)

(σ-nil)

τ−−→ m[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ n[nil]ν

n[nil]ν

(σ-Rcv)

(σ-Par)

−
n[b?(x).PcQ]ν
σ−−→ M0 N
M | N

M

σ−−→ M0 | N0

σ−−→ n[Q]ν
σ−−→ N0

(TauPar)

M
M | N

(Delay)

n[σ.P ]ν

τ−−→ M0
τ−−→ M0 | N
−
σ−−→ n[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ 0

(σ-Tau)

(σ-0)

0

σ−−→ m[Q]ν

In rule (RcvPar) we model the composition of two networks receiving the same
message from the same transmitter. Rule (RcvEnb) says that every node can syn-
chronise with an external transmitter m. This rule, together with rule (RcvPar),
serves to model message loss. Rule (Bcast) models the propagation of messages on
the broadcast channel. Note that in rule (Bcast) we loose track of those neighbours
of m that are in N. Rule (Tau) models local computations. Rule (TauPar) serves
to propagate internal computations on parallel components. The remaining rules
model the passage of time. Rule (Delay) model the delay of a time unit. Rules
(σ-nil) and (σ-0) are straightforward. Rules (σ-Rcv) models timeout on receivers.
Similarly, (σ-Tau) models timeout on internal activities. Rule (σ-Par) models time
synchronisation between parallel components. Rules (Bcast) and (TauPar) have their
symmetric counterpart.

In Table 5 we report the obvious rules for nodes containing matching, recursion
and deduction processes (we recall that only guarded recursion is allowed). In the
sequel, we use the metavariable λ to range over the labels: m!v.ν, m?v, τ, and σ.

The LTS-based semantics is consistent with the reduction semantics.

τ−−→≡ M0 or M

m!vBν
−−−−−−→≡ M0, for some m, v, ν.

Theorem 1 (Harmony Theorem).

– If M _ M0 then either M

σ−−_ M0 then M

m!vBν
−−−−−−→ M0 or M
σ−−→ M0 then M

– If M
– If M
– If M

σ−−→≡ M0.

τ−−→ M0 then M _ M0.
σ−−_ M0.

6

Table 5 LTS - Matching, recursion and deduction

(Then)

n[P ]ν

λ−−→ n[P 0]ν

n[[v = v]P ; Q]ν

λ−−→ n[P 0]ν

(Else)

λ−−→ n[Q0]ν
n[Q]ν
n[[v1 = v2]P ; Q]ν

v1 6= v2
λ−−→ n[Q0]ν

(Rec)

n[{˜v/˜x}P ]ν

λ−−→ n[P 0]ν H(˜x) def= P

n[Hh˜vi]ν

λ−−→ n[P 0]ν

(Dtt)

n[{v/x}P ]ν λ−−→ n[P 0]ν v1 . . . vn ‘r v
n[[v1 . . . vn ‘r x]P ; Q]ν
λ−−→ n[P 0]ν

(Dﬀ)

n[Q]ν λ−−→ n[Q0]ν
n[[v1 . . . vn ‘r x]P ; Q]ν

6 ∃ v. v1 . . . vn ‘r v
λ−−→ n[Q0]ν

4.1 Behavioural Semantics

We use our LTS to deﬁne a standard notion of timed labelled bisimilarity. In general,
a bisimulation describes how two terms (in our case networks) can mimic each other
actions. Since we are focusing on weak equivalences we have to distinguish between
transmissions which may be observed and transmissions which may not be observed
by the environment. Thus, we extend the set of rules of Table 4 with the following
two rules:

(Shh)

M

m!v.∅−−−−−→ M0
τ−−→ M0
M

M

(Obs)

m!v.ν

−−−−−−→ M0
M

!v.ν−−−−→ M0

ν 6= ∅

Rule (Shh) models transmissions that cannot be observed because none of the poten-
tial receivers is in the environment. Rule (Obs) models a transmission of a message
v that can be received (and hence observed) by those nodes of the environment
contained in ν. The name of the transmitter is removed as in real networks the
identity of the transmitter can only be ensured by using appropriate authentica-
tion protocols. Notice that in a derivation tree the rule (Obs) can only be applied
at top-level.
In the rest of the paper, the metavariable α ranges over the following actions:
!v.ν, m?v, τ, and σ. We adopt the standard notation for weak transitions: =⇒
ˆα==⇒
denotes the reﬂexive and transitive closure of
denotes =⇒ if α = τ and α==⇒ otherwise.
Deﬁnition 2 (Bi-similarity). A relation R over well-formed networks is a simu-
lation if M R N implies that whenever M
α−−→ M0 there is N0 such that N ˆα==⇒ N0
and M0 R N0. A relation R is called bisimulation if both R and its converse are
simulations. We say that M and N are similar, written M . N if there is a simu-
lation R such that M R N. We say that M and N are bisimilar, written M ≈ N,
if there is a bisimulation R such that M R N.
Our notions of similarity and bisimilarity between networks are congruence, as they
are preserved by parallel composition. We only report the result for bisimilarity.
Theorem 2 (≈ is a congruence). Let M and N be two well-formed networks
such that M ≈ N. Then M | O ≈ N | O for all networks O such that M | O and
N | O are well-formed.

α==⇒ denotes =⇒ α−−→ =⇒;

τ−−→;

7

5 A Framework for the Analysis of Wireless Network

Security Protocols

In order to perform a security analysis of wireless network security protocols, we
adapt a general schema for the deﬁnition of timed security properties, called Timed
Generalized Non-Deducibility on Compositions (tGNDC ) [10], a real-time general-
isation of Generalised Non-Deducibility on Compositions (GNDC ) [17]. The main
idea is the following: a system M is tGN DC α
/ if and only if for every attacker ATT
the composition of the system M with ATT satisﬁes the timed speciﬁcation α(M),
with respect the timed behavioural relation /. The preorder / that we will be using
in the following analysis is the similarity relation .. An attacker is a network, with
some constrains on the data known initially, which tries to attack a protocol by
stealing and faking information transmitted on the communication channel. Given
a network M, we call ID(M) the set of messages (closed values) that appears in
M.1 In our setting, a generic attacker of a network M is a collection of nodes in
the environment of M, with current knowledge Φ:

n∈Env(M ) n[Pn]nds(M ) s.t. ID(Pn) ⊆ D(Φ) for all n.

AT T (Φ, M) def= Q

Deﬁnition 3 (tGNDC). Let M be a network, Φ0 the initial knowledge of the
attacker, and α a function between networks deﬁning the property speciﬁcation for
M as the network α(M). We say that M is tGN DC α. if and only if it holds that
M | AT T (Φ0, M) . α(M).

In order to prove that a network is tGN DC α., we need a timed notion of term
stability [10]. Intuitively, a network M is said to be time-dependent stable if the
attacker cannot increase its knowledge when M runs in the space of a time interval.
This requires the notion of execution trace. A trace is a sequence of labelled transi-
tions, that we will denote in the standard way. If A is sequence of labels α1α2 . . . αn,
we write M A==⇒ M0 to mean M =⇒ α1−−−→ =⇒ ··· =⇒ αn−−−→ =⇒ M0. Let #σ(A) be the
number of occurrences of σ actions in the sequence A.

Deﬁnition 4. We say that a network M is time-dependent stable wrt a sequence
of knowledges {Φj}j≥0, if whenever M | AT T (Φ0, M) A==⇒ M0 | AT T (Φ0, M0) and
#σ(A) = i, then D(Φ0) ⊆ D(Φi).

When two or more networks are time-dependent stable with respect a certain
sequence of knowledges {Φj}j≥0, and they enjoy a certain tGNDC property, then
the following compositionality property holds.
Proposition 5. Let {Φj}j≥0 be a sequence of knowledges, and {Mr}1≤r≤n a set
of time-dependent stable subnetworks, with respect to {Φi}i≥0, such that Mr ∈
, for 1≤r≤n. It follows that:
tGN DC αr(Mr)
1. M1 | . . . | Mn is time-dependent stable;
2. M1 | . . . | Mn ∈ tGN DC α1(M1)|...|αn(Mn)

.

.

.

1 This function can be easily deﬁned along the lines of [10].

8

As in [10], we formalise two useful timed properties for security protocols in
terms of use tGN DC α
/ : timed integrity, which guarantees that only fresh packets are
authenticated, and timed agreement, for which agreement must be reached within a
certain deadline, otherwise authentications does not hold. More precisely, a protocol
is said to enjoy the timed integrity property if, whenever a packet p is authenticated
during the time interval i, then this packet was sent at most i − δ time intervals
before. A protocol is said to enjoy the timed agreement property if, whenever a
responder n has completed a run of the protocol, apparently with an initiator m,
then the latter has initiated the protocol, apparently with the former, at most δ
time intervals before, and the two agents agreed on a set of data d.

6 The µTESLA protocol

The µTESLA protocol was designed by Perrig et al. [14] to provide authenti-
cated broadcast for sensor networks. µTESLA calculates the Message Authenti-
cation Code (MAC) for every packet pi that it is transmitted by using a diﬀerent
key ki. These keys are generated with a public one-way function F such that, if
k0, k1, . . . , kn are the keys used in the transmission, F (ki) = ki−1, for 1 ≤ i ≤ n.
The transmission time is split into time intervals and each key is tied to one of
them. In each time interval one or more packets are deployed by the sender, each
one containing the payload and the MAC calculated with the key bound to that in-
terval. When a new interval starts, the key tied to the previous interval is disclosed
to all receivers, so that they can authenticate all the packets previously received.
Sender and receivers are loosely time synchronised on the key disclosure time to
prevent malicious nodes to forge packets with modiﬁed payloads. Nodes discard
packets containing MACs calculated with already disclosed keys, as those packets
could come from an attacker. This key-chain mechanism together with the one-way
function F , provides two major advantages: (i) it allows to calculate lost keys by
simply applying F to the last received key, as many times as necessary; (ii) every
node can authenticate the most recent key ki by means of the last received key kl
(stored in the node memory) and the function F ; once authenticated, ki replaces
kl in the node memory. The protocol works under the assumption that all nodes
share an initial key k0, before the protocol starts.

In Table 6 we provide a speciﬁcation of the µTESLA protocol in tcryptoCWS.
Besides the deduction rules for dealing with pairs, we require a deduction rule to
build MACs: v1 v2 ‘mac mac(v1, v2). Our encoding contains a few simpliﬁcations
with respect to the original protocol. First of all, there is only one packet sent per
time interval, and the sender dispatches one packet and one key alternately. This
yields a simpler and easier to read model. Second, our speciﬁcation does not account
for bootstrapping new receivers on the ﬂy.

Let us proceed with the description of our encoding. We essentially deﬁne two
i , where i is the index number of
kinds of processes: senders, Si, and receivers, Rkl
the current key, and kl is the last authenticated key. Since, we bind one packet with
one key, i also refers to the index number of packets. So, a network starting the
protocol can be represented as:

µTESLA def= m[S1]νm | n1[Rk0

1 ]νn1 | . . . | nk[Rk0

1 ]νnk

9

Table 6 µTESLA speciﬁcation
Sender:

Si

def= [xi ki ‘mac mi]
[mi xi ‘pair pi]
!hpii.σ.
!hkii.σ.
Si+1

Receiver:

Rkl
i

Qkl
i

P kl
i

T kl
i
U ki
i

Z ki
i

def= b?(p).σ.P kl

def= b?(k).σ.Rkl

i

i cQkl
i+1cRkl

i+1

def= b?(k).T kl

i cRkl

i+1

i

def= [F i−l(k) = kl]U ki
def= [p ‘fst m]
[p ‘snd x]
[x k ‘mac m0]
[m = m0]Z ki
def= !hauthii.σ.Rki

i

i+1

; σ.Rki
i+1

Calculate MAC using payload and key,
build a packet with mac and payload,
broadcast packet pi, synchronise,
broadcast key ki, synchronise,
and go to next sending state.

Receive a packet, synchronise, and go to P kl
i
if timeout go to Qkl
i .
Receive a key, synchronise, and
go to next receiving state.
Receive a key k and move to state T kl
i
if timeout go to next receiving state.

;

;

; σ.Rkl

i+1 Check key k using F and the stored key kl,

extract MAC from packet p,
extract payload from packet p,
calculate mac for packet p,
verify if it matches with the received one,

if so, authenticate packet i, synchronise,
go to next receiving state, and store ki.

where m is the transmitter and ni are the receivers. Formally, {n1, . . . , nk} ⊆ νm,
and m ∈ νnj , for 1≤j≤k. For veriﬁcation reasons we assume that the environment
contains a fresh node test, unknown to the attacker, to test successful packet au-
thentication. For simplicity, we assume that this node cannot transmit but it can
only receive messages. Thus, test ∈ νm and test ∈ νnj , for 1≤j≤k.

6.1 Security analysis

Let us prove that µTESLA enjoys timed integrity. In particular, we prove that
receivers authenticate only packets that have been sent in the previous time interval
(δ = 1), in the correct order, even in the presence of the intruder. The key point is
that even if the intruder acquires shared keys then it is “too late” to break integrity,
i.e. to authenticate packets older than δ. Let us deﬁne the timed integrity property
via an abstraction of the protocol with no possible intruders:

α(µTESLA) def= m[S1]test | n1[ ˆR1]test | . . . | nk[ ˆR1]test

Here, S1 is the process deﬁned in Table 6, while ˆRi
Obviously, here we abstract on receivers.

def= σ.bτ.!hauthii.σ. ˆRi+1c ˆRi+1.

Let us demonstrate that α(µTESLA) enjoys timed integrity with δ = 1.

Lemma 1. – If m[S1]test A==⇒ m!pi.test
– If nj[ ˆR1]test A==⇒ nj !authi.test

−−−−−−−−→ then #σ(A) = 2(i − 1).

−−−−−−−−−−→, for some 1≤j≤k, then #σ(A) = 2(i − 1) + 1.

10

Proposition 6. If α(µTESLA) A==⇒ m!pi.test

−−−−−−−−−−→ then #σ(B)=1.
It should be noticed than any formulation of timed agreement for µTESLA
would actually coincide with timed integrity. Thus, Proposition 6 also demonstrates
that α(µTESLA) enjoys timed agreement, with δ = 1.

−−−−−−−−→ B==⇒ nr!authi.test

Now, we prove that µTESLA satisﬁes our timed properties. By Proposition 5, it
is enough to prove the result for each component. In particular, we notice that the
nodes m[S1]νm and nj[R1]νnj , for 1≤j≤k, are time-dependent stable with respect
to the following sequence of knowledges:

Φ0 = {p1}
Φ1 = Φ0 ∪ {k1}
. . .
Φi = Φi−1 ∪ {pj+1} if
Φi = Φi−1 ∪ {kj+1}
if

i = 2j,
i = 2j + 1,

j > 0
j > 0.

Intuitively, Φi consists in Φi−1 together with the set of messages an intruder can
get by eavesdropping on a run of the protocol during the time interval i.
Lemma 2. 1. m[S1]νm ∈ tGN DCm[S1]test
2. nj[R1]νnj ∈ tGN DC nj [ ˆR1]test
By applying Lemma 2 and Proposition 5 we derive the following result.
Theorem 3 (µTESLA Correctness). µTESLA ∈ tGN DC α(µTESLA)

, for 1 ≤ j ≤ k.

.

.

.

.

7 The LEAP+ protocol

The LEAP+ protocol [15] provides a keying framework to establish authenticated
communications. In [15], the authors describe four possible keying mechanisms,
each of them providing a diﬀerent level of security. In our paper, we focus on the
single-hop pairwise shared key mechanism as it is underlying to all other keying
methods. Here, a network controller loads each node with an initial key kIN and
a computational eﬃcient pseudo-random function prf(), before deployment. Then,
each node n derives its master key: kn = prf(kIN, n).

Let us brieﬂy describe the protocol between an initiator node m and a responder
node n. Node m tries to discover its neighbours by broadcasting a hello packet that
contains its identity, m, and a freshly created nonce, ai, where i counts the number
of attempts of the initiator. When n receives the hello packet from m, it computes
its MAC, h = mac(kn, (ai, n)), and sends to m a packet containing h and its identity
n. If node m does not get the authenticated packet from the responder in due time,
it will send a new hello packet with a fresh nonce. When m receives the packet from
n, it tries to authenticate it by using n’s master key and the last created nonce. If
the authentication succeeds, then both nodes proceed in calculating the pairwise
key kmn by using the the function prf() as follows: kmn = prf(kn, m).

In Table 7 we provide a speciﬁcation of LEAP+ in tcryptoCWS. Besides the

standard rules for dealing with pairs, we require the following deduction rules:

(mac)

v1

v2

mac(v1, v2)

v1

v2

prf(v1, v2)

(prf)

11

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

Table 3 Structural Congruence

if Ah˜vi def= P ∧ | ˜x |=| ˜v |

if v1 . . . vn ‘r v
if

6 ∃ v. v1 . . . vn ‘r v

if v1 6= v2

n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[P ]ν
n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[Q]ν
n[[v = v]P ; Q]ν ≡ n[P ]ν
n[[v1 = v2]P ; Q]ν ≡ n[Q]ν
n[Ah˜vi]ν ≡ n[{v/x}P ]ν
M | N ≡ N | M
(M | N ) | M0 ≡ M | (N | M0)
M | 0 ≡ M
M ≡ M
M ≡ N implies N ≡ M
M ≡ M0 ∧ M0 ≡ M00 implies M ≡ M00
M ≡ N implies M | M0 ≡ N | M0 , for all M0

(Struct DedT)
(Struct DedF)
(Struct Then)
(Struct Else)

(Struct Rec)
(Struct Par Comm)
(Struct Par Assoc)
(Struct Zero Par)
(Struct Reﬂ)
(Struct Symm)
(Struct Trans)
(Struct Ctx Par)

3 Time properties

Proposition 2 formalises the deterministic nature of time passing: a network can
reach at most one new state by executing the action σ.

Proposition 2 (Time Determinism). Let M be a well-formed network. If M
M0 and M

σ−−_ M00 then M0 ≡ M00

σ−−_

The maximal progress property [13] says that processes communicate as soon

as a possibility of communication arises.
Proposition 3 (Maximal Progress). Let M be a well-formed network. If M ≡
m[!hvi.P ]ν | N then M

σ−−_ M0 for no network M0.

Patience guarantees that a process will wait indeﬁnitely until it can communi-
cate [13]. In our setting, this means that if no transmissions can start then it must
be possible to execute a σ-action to let time pass.

Proposition 4 (Patience). Let M ≡ Q

i∈I mi[Pi]νi be a well-formed network,
such that for all i ∈ I it holds that mi[Pi]νi 6≡ mi[!hvi.Qi]νi, then there is a network
N such that M

σ−−_ N.

4 Labelled Transition Semantics

In Table 4, we provide a Labelled Transition System (LTS) for our calculus. In
rule (Snd) a sender dispatches its message to its neighbours ν, and then continues
as P . In the label m!v.ν the set ν contains the neighbours of m which may receive
the message v. In rule (Rcv) a receiver gets a message coming from a neighbour
node m, and then evolves into process P , where all the occurrences of the vari-
able x are replaced with the value v. If no message is received in the current time
interval, the node n will continue with process Q, according to the rule (σ-Rcv).

5

Table 4 LTS - Transmission, internal actions, and time passing
m ∈ ν

−
−−−−−−→ m[P ]ν

(Snd)

m[!hvi.P ]ν m!vBν
m /∈ nds(M )
m?v−−−−→ M
M

(RcvEnb)

(Rcv)

(RcvPar)

n[b?(x).PcQ]ν m?v−−−−→ n[{v/x}P ]ν
m?v−−−−→ N0

M

m?v−−−−→ M0 N
M | N
ν0 := ν\nds(N )

m?v−−−−→ M0 | N0

M

(Bcast)

m!vBν
−−−−−−→ M0 N

m?v−−−−→ N0
m!vBν0
−−−−−−−→ M0 | N0

M | N

(Tau)

(σ-nil)

τ−−→ m[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ n[nil]ν

n[nil]ν

(σ-Rcv)

(σ-Par)

−
n[b?(x).PcQ]ν
σ−−→ M0 N
M | N

M

σ−−→ M0 | N0

σ−−→ n[Q]ν
σ−−→ N0

(TauPar)

M
M | N

(Delay)

n[σ.P ]ν

τ−−→ M0
τ−−→ M0 | N
−
σ−−→ n[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ 0

(σ-Tau)

(σ-0)

0

σ−−→ m[Q]ν

In rule (RcvPar) we model the composition of two networks receiving the same
message from the same transmitter. Rule (RcvEnb) says that every node can syn-
chronise with an external transmitter m. This rule, together with rule (RcvPar),
serves to model message loss. Rule (Bcast) models the propagation of messages on
the broadcast channel. Note that in rule (Bcast) we loose track of those neighbours
of m that are in N. Rule (Tau) models local computations. Rule (TauPar) serves
to propagate internal computations on parallel components. The remaining rules
model the passage of time. Rule (Delay) model the delay of a time unit. Rules
(σ-nil) and (σ-0) are straightforward. Rules (σ-Rcv) models timeout on receivers.
Similarly, (σ-Tau) models timeout on internal activities. Rule (σ-Par) models time
synchronisation between parallel components. Rules (Bcast) and (TauPar) have their
symmetric counterpart.

In Table 5 we report the obvious rules for nodes containing matching, recursion
and deduction processes (we recall that only guarded recursion is allowed). In the
sequel, we use the metavariable λ to range over the labels: m!v.ν, m?v, τ, and σ.

The LTS-based semantics is consistent with the reduction semantics.

τ−−→≡ M0 or M

m!vBν
−−−−−−→≡ M0, for some m, v, ν.

Theorem 1 (Harmony Theorem).

– If M _ M0 then either M

σ−−_ M0 then M

m!vBν
−−−−−−→ M0 or M
σ−−→ M0 then M

– If M
– If M
– If M

σ−−→≡ M0.

τ−−→ M0 then M _ M0.
σ−−_ M0.

6

Table 5 LTS - Matching, recursion and deduction

(Then)

n[P ]ν

λ−−→ n[P 0]ν

n[[v = v]P ; Q]ν

λ−−→ n[P 0]ν

(Else)

λ−−→ n[Q0]ν
n[Q]ν
n[[v1 = v2]P ; Q]ν

v1 6= v2
λ−−→ n[Q0]ν

(Rec)

n[{˜v/˜x}P ]ν

λ−−→ n[P 0]ν H(˜x) def= P

n[Hh˜vi]ν

λ−−→ n[P 0]ν

(Dtt)

n[{v/x}P ]ν λ−−→ n[P 0]ν v1 . . . vn ‘r v
n[[v1 . . . vn ‘r x]P ; Q]ν
λ−−→ n[P 0]ν

(Dﬀ)

n[Q]ν λ−−→ n[Q0]ν
n[[v1 . . . vn ‘r x]P ; Q]ν

6 ∃ v. v1 . . . vn ‘r v
λ−−→ n[Q0]ν

4.1 Behavioural Semantics

We use our LTS to deﬁne a standard notion of timed labelled bisimilarity. In general,
a bisimulation describes how two terms (in our case networks) can mimic each other
actions. Since we are focusing on weak equivalences we have to distinguish between
transmissions which may be observed and transmissions which may not be observed
by the environment. Thus, we extend the set of rules of Table 4 with the following
two rules:

(Shh)

M

m!v.∅−−−−−→ M0
τ−−→ M0
M

M

(Obs)

m!v.ν

−−−−−−→ M0
M

!v.ν−−−−→ M0

ν 6= ∅

Rule (Shh) models transmissions that cannot be observed because none of the poten-
tial receivers is in the environment. Rule (Obs) models a transmission of a message
v that can be received (and hence observed) by those nodes of the environment
contained in ν. The name of the transmitter is removed as in real networks the
identity of the transmitter can only be ensured by using appropriate authentica-
tion protocols. Notice that in a derivation tree the rule (Obs) can only be applied
at top-level.
In the rest of the paper, the metavariable α ranges over the following actions:
!v.ν, m?v, τ, and σ. We adopt the standard notation for weak transitions: =⇒
ˆα==⇒
denotes the reﬂexive and transitive closure of
denotes =⇒ if α = τ and α==⇒ otherwise.
Deﬁnition 2 (Bi-similarity). A relation R over well-formed networks is a simu-
lation if M R N implies that whenever M
α−−→ M0 there is N0 such that N ˆα==⇒ N0
and M0 R N0. A relation R is called bisimulation if both R and its converse are
simulations. We say that M and N are similar, written M . N if there is a simu-
lation R such that M R N. We say that M and N are bisimilar, written M ≈ N,
if there is a bisimulation R such that M R N.
Our notions of similarity and bisimilarity between networks are congruence, as they
are preserved by parallel composition. We only report the result for bisimilarity.
Theorem 2 (≈ is a congruence). Let M and N be two well-formed networks
such that M ≈ N. Then M | O ≈ N | O for all networks O such that M | O and
N | O are well-formed.

α==⇒ denotes =⇒ α−−→ =⇒;

τ−−→;

7

5 A Framework for the Analysis of Wireless Network

Security Protocols

In order to perform a security analysis of wireless network security protocols, we
adapt a general schema for the deﬁnition of timed security properties, called Timed
Generalized Non-Deducibility on Compositions (tGNDC ) [10], a real-time general-
isation of Generalised Non-Deducibility on Compositions (GNDC ) [17]. The main
idea is the following: a system M is tGN DC α
/ if and only if for every attacker ATT
the composition of the system M with ATT satisﬁes the timed speciﬁcation α(M),
with respect the timed behavioural relation /. The preorder / that we will be using
in the following analysis is the similarity relation .. An attacker is a network, with
some constrains on the data known initially, which tries to attack a protocol by
stealing and faking information transmitted on the communication channel. Given
a network M, we call ID(M) the set of messages (closed values) that appears in
M.1 In our setting, a generic attacker of a network M is a collection of nodes in
the environment of M, with current knowledge Φ:

n∈Env(M ) n[Pn]nds(M ) s.t. ID(Pn) ⊆ D(Φ) for all n.

AT T (Φ, M) def= Q

Deﬁnition 3 (tGNDC). Let M be a network, Φ0 the initial knowledge of the
attacker, and α a function between networks deﬁning the property speciﬁcation for
M as the network α(M). We say that M is tGN DC α. if and only if it holds that
M | AT T (Φ0, M) . α(M).

In order to prove that a network is tGN DC α., we need a timed notion of term
stability [10]. Intuitively, a network M is said to be time-dependent stable if the
attacker cannot increase its knowledge when M runs in the space of a time interval.
This requires the notion of execution trace. A trace is a sequence of labelled transi-
tions, that we will denote in the standard way. If A is sequence of labels α1α2 . . . αn,
we write M A==⇒ M0 to mean M =⇒ α1−−−→ =⇒ ··· =⇒ αn−−−→ =⇒ M0. Let #σ(A) be the
number of occurrences of σ actions in the sequence A.

Deﬁnition 4. We say that a network M is time-dependent stable wrt a sequence
of knowledges {Φj}j≥0, if whenever M | AT T (Φ0, M) A==⇒ M0 | AT T (Φ0, M0) and
#σ(A) = i, then D(Φ0) ⊆ D(Φi).

When two or more networks are time-dependent stable with respect a certain
sequence of knowledges {Φj}j≥0, and they enjoy a certain tGNDC property, then
the following compositionality property holds.
Proposition 5. Let {Φj}j≥0 be a sequence of knowledges, and {Mr}1≤r≤n a set
of time-dependent stable subnetworks, with respect to {Φi}i≥0, such that Mr ∈
, for 1≤r≤n. It follows that:
tGN DC αr(Mr)
1. M1 | . . . | Mn is time-dependent stable;
2. M1 | . . . | Mn ∈ tGN DC α1(M1)|...|αn(Mn)

.

.

.

1 This function can be easily deﬁned along the lines of [10].

8

As in [10], we formalise two useful timed properties for security protocols in
terms of use tGN DC α
/ : timed integrity, which guarantees that only fresh packets are
authenticated, and timed agreement, for which agreement must be reached within a
certain deadline, otherwise authentications does not hold. More precisely, a protocol
is said to enjoy the timed integrity property if, whenever a packet p is authenticated
during the time interval i, then this packet was sent at most i − δ time intervals
before. A protocol is said to enjoy the timed agreement property if, whenever a
responder n has completed a run of the protocol, apparently with an initiator m,
then the latter has initiated the protocol, apparently with the former, at most δ
time intervals before, and the two agents agreed on a set of data d.

6 The µTESLA protocol

The µTESLA protocol was designed by Perrig et al. [14] to provide authenti-
cated broadcast for sensor networks. µTESLA calculates the Message Authenti-
cation Code (MAC) for every packet pi that it is transmitted by using a diﬀerent
key ki. These keys are generated with a public one-way function F such that, if
k0, k1, . . . , kn are the keys used in the transmission, F (ki) = ki−1, for 1 ≤ i ≤ n.
The transmission time is split into time intervals and each key is tied to one of
them. In each time interval one or more packets are deployed by the sender, each
one containing the payload and the MAC calculated with the key bound to that in-
terval. When a new interval starts, the key tied to the previous interval is disclosed
to all receivers, so that they can authenticate all the packets previously received.
Sender and receivers are loosely time synchronised on the key disclosure time to
prevent malicious nodes to forge packets with modiﬁed payloads. Nodes discard
packets containing MACs calculated with already disclosed keys, as those packets
could come from an attacker. This key-chain mechanism together with the one-way
function F , provides two major advantages: (i) it allows to calculate lost keys by
simply applying F to the last received key, as many times as necessary; (ii) every
node can authenticate the most recent key ki by means of the last received key kl
(stored in the node memory) and the function F ; once authenticated, ki replaces
kl in the node memory. The protocol works under the assumption that all nodes
share an initial key k0, before the protocol starts.

In Table 6 we provide a speciﬁcation of the µTESLA protocol in tcryptoCWS.
Besides the deduction rules for dealing with pairs, we require a deduction rule to
build MACs: v1 v2 ‘mac mac(v1, v2). Our encoding contains a few simpliﬁcations
with respect to the original protocol. First of all, there is only one packet sent per
time interval, and the sender dispatches one packet and one key alternately. This
yields a simpler and easier to read model. Second, our speciﬁcation does not account
for bootstrapping new receivers on the ﬂy.

Let us proceed with the description of our encoding. We essentially deﬁne two
i , where i is the index number of
kinds of processes: senders, Si, and receivers, Rkl
the current key, and kl is the last authenticated key. Since, we bind one packet with
one key, i also refers to the index number of packets. So, a network starting the
protocol can be represented as:

µTESLA def= m[S1]νm | n1[Rk0

1 ]νn1 | . . . | nk[Rk0

1 ]νnk

9

Table 6 µTESLA speciﬁcation
Sender:

Si

def= [xi ki ‘mac mi]
[mi xi ‘pair pi]
!hpii.σ.
!hkii.σ.
Si+1

Receiver:

Rkl
i

Qkl
i

P kl
i

T kl
i
U ki
i

Z ki
i

def= b?(p).σ.P kl

def= b?(k).σ.Rkl

i

i cQkl
i+1cRkl

i+1

def= b?(k).T kl

i cRkl

i+1

i

def= [F i−l(k) = kl]U ki
def= [p ‘fst m]
[p ‘snd x]
[x k ‘mac m0]
[m = m0]Z ki
def= !hauthii.σ.Rki

i

i+1

; σ.Rki
i+1

Calculate MAC using payload and key,
build a packet with mac and payload,
broadcast packet pi, synchronise,
broadcast key ki, synchronise,
and go to next sending state.

Receive a packet, synchronise, and go to P kl
i
if timeout go to Qkl
i .
Receive a key, synchronise, and
go to next receiving state.
Receive a key k and move to state T kl
i
if timeout go to next receiving state.

;

;

; σ.Rkl

i+1 Check key k using F and the stored key kl,

extract MAC from packet p,
extract payload from packet p,
calculate mac for packet p,
verify if it matches with the received one,

if so, authenticate packet i, synchronise,
go to next receiving state, and store ki.

where m is the transmitter and ni are the receivers. Formally, {n1, . . . , nk} ⊆ νm,
and m ∈ νnj , for 1≤j≤k. For veriﬁcation reasons we assume that the environment
contains a fresh node test, unknown to the attacker, to test successful packet au-
thentication. For simplicity, we assume that this node cannot transmit but it can
only receive messages. Thus, test ∈ νm and test ∈ νnj , for 1≤j≤k.

6.1 Security analysis

Let us prove that µTESLA enjoys timed integrity. In particular, we prove that
receivers authenticate only packets that have been sent in the previous time interval
(δ = 1), in the correct order, even in the presence of the intruder. The key point is
that even if the intruder acquires shared keys then it is “too late” to break integrity,
i.e. to authenticate packets older than δ. Let us deﬁne the timed integrity property
via an abstraction of the protocol with no possible intruders:

α(µTESLA) def= m[S1]test | n1[ ˆR1]test | . . . | nk[ ˆR1]test

Here, S1 is the process deﬁned in Table 6, while ˆRi
Obviously, here we abstract on receivers.

def= σ.bτ.!hauthii.σ. ˆRi+1c ˆRi+1.

Let us demonstrate that α(µTESLA) enjoys timed integrity with δ = 1.

Lemma 1. – If m[S1]test A==⇒ m!pi.test
– If nj[ ˆR1]test A==⇒ nj !authi.test

−−−−−−−−→ then #σ(A) = 2(i − 1).

−−−−−−−−−−→, for some 1≤j≤k, then #σ(A) = 2(i − 1) + 1.

10

Proposition 6. If α(µTESLA) A==⇒ m!pi.test

−−−−−−−−−−→ then #σ(B)=1.
It should be noticed than any formulation of timed agreement for µTESLA
would actually coincide with timed integrity. Thus, Proposition 6 also demonstrates
that α(µTESLA) enjoys timed agreement, with δ = 1.

−−−−−−−−→ B==⇒ nr!authi.test

Now, we prove that µTESLA satisﬁes our timed properties. By Proposition 5, it
is enough to prove the result for each component. In particular, we notice that the
nodes m[S1]νm and nj[R1]νnj , for 1≤j≤k, are time-dependent stable with respect
to the following sequence of knowledges:

Φ0 = {p1}
Φ1 = Φ0 ∪ {k1}
. . .
Φi = Φi−1 ∪ {pj+1} if
Φi = Φi−1 ∪ {kj+1}
if

i = 2j,
i = 2j + 1,

j > 0
j > 0.

Intuitively, Φi consists in Φi−1 together with the set of messages an intruder can
get by eavesdropping on a run of the protocol during the time interval i.
Lemma 2. 1. m[S1]νm ∈ tGN DCm[S1]test
2. nj[R1]νnj ∈ tGN DC nj [ ˆR1]test
By applying Lemma 2 and Proposition 5 we derive the following result.
Theorem 3 (µTESLA Correctness). µTESLA ∈ tGN DC α(µTESLA)

, for 1 ≤ j ≤ k.

.

.

.

.

7 The LEAP+ protocol

The LEAP+ protocol [15] provides a keying framework to establish authenticated
communications. In [15], the authors describe four possible keying mechanisms,
each of them providing a diﬀerent level of security. In our paper, we focus on the
single-hop pairwise shared key mechanism as it is underlying to all other keying
methods. Here, a network controller loads each node with an initial key kIN and
a computational eﬃcient pseudo-random function prf(), before deployment. Then,
each node n derives its master key: kn = prf(kIN, n).

Let us brieﬂy describe the protocol between an initiator node m and a responder
node n. Node m tries to discover its neighbours by broadcasting a hello packet that
contains its identity, m, and a freshly created nonce, ai, where i counts the number
of attempts of the initiator. When n receives the hello packet from m, it computes
its MAC, h = mac(kn, (ai, n)), and sends to m a packet containing h and its identity
n. If node m does not get the authenticated packet from the responder in due time,
it will send a new hello packet with a fresh nonce. When m receives the packet from
n, it tries to authenticate it by using n’s master key and the last created nonce. If
the authentication succeeds, then both nodes proceed in calculating the pairwise
key kmn by using the the function prf() as follows: kmn = prf(kn, m).

In Table 7 we provide a speciﬁcation of LEAP+ in tcryptoCWS. Besides the

standard rules for dealing with pairs, we require the following deduction rules:

(mac)

v1

v2

mac(v1, v2)

v1

v2

prf(v1, v2)

(prf)

11

Table 7 LEAP+ speciﬁcation
Sender at node m:

Si

def= [ai−1 m ‘prf ai]
[m ai ‘pair t]
[hello t ‘pair p]
!hpi.σ.P

P def= b?(q).P1cSi+1
P1
P2
P3

def= [q ‘fst n]P2; σ.Si+1
def= [q ‘snd h]P3; σ.Si+1
def= [n ai ‘pair t0]
[kIN n ‘prf kn]
[kn t0 ‘mac h0]
[h0 = h]P4; σ.Si+1

def= [kn m ‘prf kmn]P5
def= σ.OK SND

P4
P5

Receiver at node n:

R def= b?(p).R1cσ.R
R1
R2
R3
R4
R5
R6

def= [p ‘fst p1]R2; σ.σ.R
def= [p ‘snd p2]R3; σ.σ.R
def= [p1 = hello]R4; σ.σ.R
def= [p2 ‘fst m]R5; σ.σ.R
def= [p2 ‘snd a]R6; σ.σ.R
def= [n a ‘pair t]
[kn t ‘mac h]
[n h ‘pair q]
σ.!hqi.R7

def= [kn m ‘prf kmn]R8
def= σ.OK RCV

R7
R8

Build a random nonce ai,
build a pair t with m and the nonce ai,
build hello packet using the pair t,
broadcast the hello, synchronise and move to P.

Wait for response from neighbours,

extract node name n from packet q,

extract MAC h from packet q,
build a pair t0 with n and current nonce ai,
calculate n’s master key kn,
calculate MAC h0 with kn and t0,
if it matches with the received one go to P4,
otherwise steps to next time interval and restart;
calculate the pairwise key kmn,
synchronise, and continue.

Wait for incoming hello packets,

extract the ﬁrst component,

extract the second component,

check if p is a hello packet,

extract the sender name m,

extract the nonce a,

build a pair t with a and n,
calculate MAC h on t with n’s master key kn,
build packet q with node name n and MAC h,
synchronise, broadcast q, and go to R7,
calculate pairwise key kmn,
synchronise and continue.

for calculating MACs and the pseudo random function prf(), respectively. Our
speciﬁcation considers only two nodes, to yield an easier to read model:

LEAP+

def= m[S1]νm | n[R]νn

where m is the initiator and n is the responder, with m ∈ νn and n ∈ νm. This
does not lose any generality with respect to the multiple nodes case. Again, for
veriﬁcation reasons, we assume that the environment contains a fresh node test,
unknown to the attacker, such that test ∈ νm. We recall that the test node cannot
transmits but it can only receive messages.

7.1 Security analysis
In LEAP+, the timed integrity property imposes that the initiator must authenti-
cate only packets sent by the responder in the previous time interval (δ = 1). Let

12

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

Table 3 Structural Congruence

if Ah˜vi def= P ∧ | ˜x |=| ˜v |

if v1 . . . vn ‘r v
if

6 ∃ v. v1 . . . vn ‘r v

if v1 6= v2

n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[P ]ν
n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[Q]ν
n[[v = v]P ; Q]ν ≡ n[P ]ν
n[[v1 = v2]P ; Q]ν ≡ n[Q]ν
n[Ah˜vi]ν ≡ n[{v/x}P ]ν
M | N ≡ N | M
(M | N ) | M0 ≡ M | (N | M0)
M | 0 ≡ M
M ≡ M
M ≡ N implies N ≡ M
M ≡ M0 ∧ M0 ≡ M00 implies M ≡ M00
M ≡ N implies M | M0 ≡ N | M0 , for all M0

(Struct DedT)
(Struct DedF)
(Struct Then)
(Struct Else)

(Struct Rec)
(Struct Par Comm)
(Struct Par Assoc)
(Struct Zero Par)
(Struct Reﬂ)
(Struct Symm)
(Struct Trans)
(Struct Ctx Par)

3 Time properties

Proposition 2 formalises the deterministic nature of time passing: a network can
reach at most one new state by executing the action σ.

Proposition 2 (Time Determinism). Let M be a well-formed network. If M
M0 and M

σ−−_ M00 then M0 ≡ M00

σ−−_

The maximal progress property [13] says that processes communicate as soon

as a possibility of communication arises.
Proposition 3 (Maximal Progress). Let M be a well-formed network. If M ≡
m[!hvi.P ]ν | N then M

σ−−_ M0 for no network M0.

Patience guarantees that a process will wait indeﬁnitely until it can communi-
cate [13]. In our setting, this means that if no transmissions can start then it must
be possible to execute a σ-action to let time pass.

Proposition 4 (Patience). Let M ≡ Q

i∈I mi[Pi]νi be a well-formed network,
such that for all i ∈ I it holds that mi[Pi]νi 6≡ mi[!hvi.Qi]νi, then there is a network
N such that M

σ−−_ N.

4 Labelled Transition Semantics

In Table 4, we provide a Labelled Transition System (LTS) for our calculus. In
rule (Snd) a sender dispatches its message to its neighbours ν, and then continues
as P . In the label m!v.ν the set ν contains the neighbours of m which may receive
the message v. In rule (Rcv) a receiver gets a message coming from a neighbour
node m, and then evolves into process P , where all the occurrences of the vari-
able x are replaced with the value v. If no message is received in the current time
interval, the node n will continue with process Q, according to the rule (σ-Rcv).

5

Table 4 LTS - Transmission, internal actions, and time passing
m ∈ ν

−
−−−−−−→ m[P ]ν

(Snd)

m[!hvi.P ]ν m!vBν
m /∈ nds(M )
m?v−−−−→ M
M

(RcvEnb)

(Rcv)

(RcvPar)

n[b?(x).PcQ]ν m?v−−−−→ n[{v/x}P ]ν
m?v−−−−→ N0

M

m?v−−−−→ M0 N
M | N
ν0 := ν\nds(N )

m?v−−−−→ M0 | N0

M

(Bcast)

m!vBν
−−−−−−→ M0 N

m?v−−−−→ N0
m!vBν0
−−−−−−−→ M0 | N0

M | N

(Tau)

(σ-nil)

τ−−→ m[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ n[nil]ν

n[nil]ν

(σ-Rcv)

(σ-Par)

−
n[b?(x).PcQ]ν
σ−−→ M0 N
M | N

M

σ−−→ M0 | N0

σ−−→ n[Q]ν
σ−−→ N0

(TauPar)

M
M | N

(Delay)

n[σ.P ]ν

τ−−→ M0
τ−−→ M0 | N
−
σ−−→ n[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ 0

(σ-Tau)

(σ-0)

0

σ−−→ m[Q]ν

In rule (RcvPar) we model the composition of two networks receiving the same
message from the same transmitter. Rule (RcvEnb) says that every node can syn-
chronise with an external transmitter m. This rule, together with rule (RcvPar),
serves to model message loss. Rule (Bcast) models the propagation of messages on
the broadcast channel. Note that in rule (Bcast) we loose track of those neighbours
of m that are in N. Rule (Tau) models local computations. Rule (TauPar) serves
to propagate internal computations on parallel components. The remaining rules
model the passage of time. Rule (Delay) model the delay of a time unit. Rules
(σ-nil) and (σ-0) are straightforward. Rules (σ-Rcv) models timeout on receivers.
Similarly, (σ-Tau) models timeout on internal activities. Rule (σ-Par) models time
synchronisation between parallel components. Rules (Bcast) and (TauPar) have their
symmetric counterpart.

In Table 5 we report the obvious rules for nodes containing matching, recursion
and deduction processes (we recall that only guarded recursion is allowed). In the
sequel, we use the metavariable λ to range over the labels: m!v.ν, m?v, τ, and σ.

The LTS-based semantics is consistent with the reduction semantics.

τ−−→≡ M0 or M

m!vBν
−−−−−−→≡ M0, for some m, v, ν.

Theorem 1 (Harmony Theorem).

– If M _ M0 then either M

σ−−_ M0 then M

m!vBν
−−−−−−→ M0 or M
σ−−→ M0 then M

– If M
– If M
– If M

σ−−→≡ M0.

τ−−→ M0 then M _ M0.
σ−−_ M0.

6

Table 5 LTS - Matching, recursion and deduction

(Then)

n[P ]ν

λ−−→ n[P 0]ν

n[[v = v]P ; Q]ν

λ−−→ n[P 0]ν

(Else)

λ−−→ n[Q0]ν
n[Q]ν
n[[v1 = v2]P ; Q]ν

v1 6= v2
λ−−→ n[Q0]ν

(Rec)

n[{˜v/˜x}P ]ν

λ−−→ n[P 0]ν H(˜x) def= P

n[Hh˜vi]ν

λ−−→ n[P 0]ν

(Dtt)

n[{v/x}P ]ν λ−−→ n[P 0]ν v1 . . . vn ‘r v
n[[v1 . . . vn ‘r x]P ; Q]ν
λ−−→ n[P 0]ν

(Dﬀ)

n[Q]ν λ−−→ n[Q0]ν
n[[v1 . . . vn ‘r x]P ; Q]ν

6 ∃ v. v1 . . . vn ‘r v
λ−−→ n[Q0]ν

4.1 Behavioural Semantics

We use our LTS to deﬁne a standard notion of timed labelled bisimilarity. In general,
a bisimulation describes how two terms (in our case networks) can mimic each other
actions. Since we are focusing on weak equivalences we have to distinguish between
transmissions which may be observed and transmissions which may not be observed
by the environment. Thus, we extend the set of rules of Table 4 with the following
two rules:

(Shh)

M

m!v.∅−−−−−→ M0
τ−−→ M0
M

M

(Obs)

m!v.ν

−−−−−−→ M0
M

!v.ν−−−−→ M0

ν 6= ∅

Rule (Shh) models transmissions that cannot be observed because none of the poten-
tial receivers is in the environment. Rule (Obs) models a transmission of a message
v that can be received (and hence observed) by those nodes of the environment
contained in ν. The name of the transmitter is removed as in real networks the
identity of the transmitter can only be ensured by using appropriate authentica-
tion protocols. Notice that in a derivation tree the rule (Obs) can only be applied
at top-level.
In the rest of the paper, the metavariable α ranges over the following actions:
!v.ν, m?v, τ, and σ. We adopt the standard notation for weak transitions: =⇒
ˆα==⇒
denotes the reﬂexive and transitive closure of
denotes =⇒ if α = τ and α==⇒ otherwise.
Deﬁnition 2 (Bi-similarity). A relation R over well-formed networks is a simu-
lation if M R N implies that whenever M
α−−→ M0 there is N0 such that N ˆα==⇒ N0
and M0 R N0. A relation R is called bisimulation if both R and its converse are
simulations. We say that M and N are similar, written M . N if there is a simu-
lation R such that M R N. We say that M and N are bisimilar, written M ≈ N,
if there is a bisimulation R such that M R N.
Our notions of similarity and bisimilarity between networks are congruence, as they
are preserved by parallel composition. We only report the result for bisimilarity.
Theorem 2 (≈ is a congruence). Let M and N be two well-formed networks
such that M ≈ N. Then M | O ≈ N | O for all networks O such that M | O and
N | O are well-formed.

α==⇒ denotes =⇒ α−−→ =⇒;

τ−−→;

7

5 A Framework for the Analysis of Wireless Network

Security Protocols

In order to perform a security analysis of wireless network security protocols, we
adapt a general schema for the deﬁnition of timed security properties, called Timed
Generalized Non-Deducibility on Compositions (tGNDC ) [10], a real-time general-
isation of Generalised Non-Deducibility on Compositions (GNDC ) [17]. The main
idea is the following: a system M is tGN DC α
/ if and only if for every attacker ATT
the composition of the system M with ATT satisﬁes the timed speciﬁcation α(M),
with respect the timed behavioural relation /. The preorder / that we will be using
in the following analysis is the similarity relation .. An attacker is a network, with
some constrains on the data known initially, which tries to attack a protocol by
stealing and faking information transmitted on the communication channel. Given
a network M, we call ID(M) the set of messages (closed values) that appears in
M.1 In our setting, a generic attacker of a network M is a collection of nodes in
the environment of M, with current knowledge Φ:

n∈Env(M ) n[Pn]nds(M ) s.t. ID(Pn) ⊆ D(Φ) for all n.

AT T (Φ, M) def= Q

Deﬁnition 3 (tGNDC). Let M be a network, Φ0 the initial knowledge of the
attacker, and α a function between networks deﬁning the property speciﬁcation for
M as the network α(M). We say that M is tGN DC α. if and only if it holds that
M | AT T (Φ0, M) . α(M).

In order to prove that a network is tGN DC α., we need a timed notion of term
stability [10]. Intuitively, a network M is said to be time-dependent stable if the
attacker cannot increase its knowledge when M runs in the space of a time interval.
This requires the notion of execution trace. A trace is a sequence of labelled transi-
tions, that we will denote in the standard way. If A is sequence of labels α1α2 . . . αn,
we write M A==⇒ M0 to mean M =⇒ α1−−−→ =⇒ ··· =⇒ αn−−−→ =⇒ M0. Let #σ(A) be the
number of occurrences of σ actions in the sequence A.

Deﬁnition 4. We say that a network M is time-dependent stable wrt a sequence
of knowledges {Φj}j≥0, if whenever M | AT T (Φ0, M) A==⇒ M0 | AT T (Φ0, M0) and
#σ(A) = i, then D(Φ0) ⊆ D(Φi).

When two or more networks are time-dependent stable with respect a certain
sequence of knowledges {Φj}j≥0, and they enjoy a certain tGNDC property, then
the following compositionality property holds.
Proposition 5. Let {Φj}j≥0 be a sequence of knowledges, and {Mr}1≤r≤n a set
of time-dependent stable subnetworks, with respect to {Φi}i≥0, such that Mr ∈
, for 1≤r≤n. It follows that:
tGN DC αr(Mr)
1. M1 | . . . | Mn is time-dependent stable;
2. M1 | . . . | Mn ∈ tGN DC α1(M1)|...|αn(Mn)

.

.

.

1 This function can be easily deﬁned along the lines of [10].

8

As in [10], we formalise two useful timed properties for security protocols in
terms of use tGN DC α
/ : timed integrity, which guarantees that only fresh packets are
authenticated, and timed agreement, for which agreement must be reached within a
certain deadline, otherwise authentications does not hold. More precisely, a protocol
is said to enjoy the timed integrity property if, whenever a packet p is authenticated
during the time interval i, then this packet was sent at most i − δ time intervals
before. A protocol is said to enjoy the timed agreement property if, whenever a
responder n has completed a run of the protocol, apparently with an initiator m,
then the latter has initiated the protocol, apparently with the former, at most δ
time intervals before, and the two agents agreed on a set of data d.

6 The µTESLA protocol

The µTESLA protocol was designed by Perrig et al. [14] to provide authenti-
cated broadcast for sensor networks. µTESLA calculates the Message Authenti-
cation Code (MAC) for every packet pi that it is transmitted by using a diﬀerent
key ki. These keys are generated with a public one-way function F such that, if
k0, k1, . . . , kn are the keys used in the transmission, F (ki) = ki−1, for 1 ≤ i ≤ n.
The transmission time is split into time intervals and each key is tied to one of
them. In each time interval one or more packets are deployed by the sender, each
one containing the payload and the MAC calculated with the key bound to that in-
terval. When a new interval starts, the key tied to the previous interval is disclosed
to all receivers, so that they can authenticate all the packets previously received.
Sender and receivers are loosely time synchronised on the key disclosure time to
prevent malicious nodes to forge packets with modiﬁed payloads. Nodes discard
packets containing MACs calculated with already disclosed keys, as those packets
could come from an attacker. This key-chain mechanism together with the one-way
function F , provides two major advantages: (i) it allows to calculate lost keys by
simply applying F to the last received key, as many times as necessary; (ii) every
node can authenticate the most recent key ki by means of the last received key kl
(stored in the node memory) and the function F ; once authenticated, ki replaces
kl in the node memory. The protocol works under the assumption that all nodes
share an initial key k0, before the protocol starts.

In Table 6 we provide a speciﬁcation of the µTESLA protocol in tcryptoCWS.
Besides the deduction rules for dealing with pairs, we require a deduction rule to
build MACs: v1 v2 ‘mac mac(v1, v2). Our encoding contains a few simpliﬁcations
with respect to the original protocol. First of all, there is only one packet sent per
time interval, and the sender dispatches one packet and one key alternately. This
yields a simpler and easier to read model. Second, our speciﬁcation does not account
for bootstrapping new receivers on the ﬂy.

Let us proceed with the description of our encoding. We essentially deﬁne two
i , where i is the index number of
kinds of processes: senders, Si, and receivers, Rkl
the current key, and kl is the last authenticated key. Since, we bind one packet with
one key, i also refers to the index number of packets. So, a network starting the
protocol can be represented as:

µTESLA def= m[S1]νm | n1[Rk0

1 ]νn1 | . . . | nk[Rk0

1 ]νnk

9

Table 6 µTESLA speciﬁcation
Sender:

Si

def= [xi ki ‘mac mi]
[mi xi ‘pair pi]
!hpii.σ.
!hkii.σ.
Si+1

Receiver:

Rkl
i

Qkl
i

P kl
i

T kl
i
U ki
i

Z ki
i

def= b?(p).σ.P kl

def= b?(k).σ.Rkl

i

i cQkl
i+1cRkl

i+1

def= b?(k).T kl

i cRkl

i+1

i

def= [F i−l(k) = kl]U ki
def= [p ‘fst m]
[p ‘snd x]
[x k ‘mac m0]
[m = m0]Z ki
def= !hauthii.σ.Rki

i

i+1

; σ.Rki
i+1

Calculate MAC using payload and key,
build a packet with mac and payload,
broadcast packet pi, synchronise,
broadcast key ki, synchronise,
and go to next sending state.

Receive a packet, synchronise, and go to P kl
i
if timeout go to Qkl
i .
Receive a key, synchronise, and
go to next receiving state.
Receive a key k and move to state T kl
i
if timeout go to next receiving state.

;

;

; σ.Rkl

i+1 Check key k using F and the stored key kl,

extract MAC from packet p,
extract payload from packet p,
calculate mac for packet p,
verify if it matches with the received one,

if so, authenticate packet i, synchronise,
go to next receiving state, and store ki.

where m is the transmitter and ni are the receivers. Formally, {n1, . . . , nk} ⊆ νm,
and m ∈ νnj , for 1≤j≤k. For veriﬁcation reasons we assume that the environment
contains a fresh node test, unknown to the attacker, to test successful packet au-
thentication. For simplicity, we assume that this node cannot transmit but it can
only receive messages. Thus, test ∈ νm and test ∈ νnj , for 1≤j≤k.

6.1 Security analysis

Let us prove that µTESLA enjoys timed integrity. In particular, we prove that
receivers authenticate only packets that have been sent in the previous time interval
(δ = 1), in the correct order, even in the presence of the intruder. The key point is
that even if the intruder acquires shared keys then it is “too late” to break integrity,
i.e. to authenticate packets older than δ. Let us deﬁne the timed integrity property
via an abstraction of the protocol with no possible intruders:

α(µTESLA) def= m[S1]test | n1[ ˆR1]test | . . . | nk[ ˆR1]test

Here, S1 is the process deﬁned in Table 6, while ˆRi
Obviously, here we abstract on receivers.

def= σ.bτ.!hauthii.σ. ˆRi+1c ˆRi+1.

Let us demonstrate that α(µTESLA) enjoys timed integrity with δ = 1.

Lemma 1. – If m[S1]test A==⇒ m!pi.test
– If nj[ ˆR1]test A==⇒ nj !authi.test

−−−−−−−−→ then #σ(A) = 2(i − 1).

−−−−−−−−−−→, for some 1≤j≤k, then #σ(A) = 2(i − 1) + 1.

10

Proposition 6. If α(µTESLA) A==⇒ m!pi.test

−−−−−−−−−−→ then #σ(B)=1.
It should be noticed than any formulation of timed agreement for µTESLA
would actually coincide with timed integrity. Thus, Proposition 6 also demonstrates
that α(µTESLA) enjoys timed agreement, with δ = 1.

−−−−−−−−→ B==⇒ nr!authi.test

Now, we prove that µTESLA satisﬁes our timed properties. By Proposition 5, it
is enough to prove the result for each component. In particular, we notice that the
nodes m[S1]νm and nj[R1]νnj , for 1≤j≤k, are time-dependent stable with respect
to the following sequence of knowledges:

Φ0 = {p1}
Φ1 = Φ0 ∪ {k1}
. . .
Φi = Φi−1 ∪ {pj+1} if
Φi = Φi−1 ∪ {kj+1}
if

i = 2j,
i = 2j + 1,

j > 0
j > 0.

Intuitively, Φi consists in Φi−1 together with the set of messages an intruder can
get by eavesdropping on a run of the protocol during the time interval i.
Lemma 2. 1. m[S1]νm ∈ tGN DCm[S1]test
2. nj[R1]νnj ∈ tGN DC nj [ ˆR1]test
By applying Lemma 2 and Proposition 5 we derive the following result.
Theorem 3 (µTESLA Correctness). µTESLA ∈ tGN DC α(µTESLA)

, for 1 ≤ j ≤ k.

.

.

.

.

7 The LEAP+ protocol

The LEAP+ protocol [15] provides a keying framework to establish authenticated
communications. In [15], the authors describe four possible keying mechanisms,
each of them providing a diﬀerent level of security. In our paper, we focus on the
single-hop pairwise shared key mechanism as it is underlying to all other keying
methods. Here, a network controller loads each node with an initial key kIN and
a computational eﬃcient pseudo-random function prf(), before deployment. Then,
each node n derives its master key: kn = prf(kIN, n).

Let us brieﬂy describe the protocol between an initiator node m and a responder
node n. Node m tries to discover its neighbours by broadcasting a hello packet that
contains its identity, m, and a freshly created nonce, ai, where i counts the number
of attempts of the initiator. When n receives the hello packet from m, it computes
its MAC, h = mac(kn, (ai, n)), and sends to m a packet containing h and its identity
n. If node m does not get the authenticated packet from the responder in due time,
it will send a new hello packet with a fresh nonce. When m receives the packet from
n, it tries to authenticate it by using n’s master key and the last created nonce. If
the authentication succeeds, then both nodes proceed in calculating the pairwise
key kmn by using the the function prf() as follows: kmn = prf(kn, m).

In Table 7 we provide a speciﬁcation of LEAP+ in tcryptoCWS. Besides the

standard rules for dealing with pairs, we require the following deduction rules:

(mac)

v1

v2

mac(v1, v2)

v1

v2

prf(v1, v2)

(prf)

11

Table 7 LEAP+ speciﬁcation
Sender at node m:

Si

def= [ai−1 m ‘prf ai]
[m ai ‘pair t]
[hello t ‘pair p]
!hpi.σ.P

P def= b?(q).P1cSi+1
P1
P2
P3

def= [q ‘fst n]P2; σ.Si+1
def= [q ‘snd h]P3; σ.Si+1
def= [n ai ‘pair t0]
[kIN n ‘prf kn]
[kn t0 ‘mac h0]
[h0 = h]P4; σ.Si+1

def= [kn m ‘prf kmn]P5
def= σ.OK SND

P4
P5

Receiver at node n:

R def= b?(p).R1cσ.R
R1
R2
R3
R4
R5
R6

def= [p ‘fst p1]R2; σ.σ.R
def= [p ‘snd p2]R3; σ.σ.R
def= [p1 = hello]R4; σ.σ.R
def= [p2 ‘fst m]R5; σ.σ.R
def= [p2 ‘snd a]R6; σ.σ.R
def= [n a ‘pair t]
[kn t ‘mac h]
[n h ‘pair q]
σ.!hqi.R7

def= [kn m ‘prf kmn]R8
def= σ.OK RCV

R7
R8

Build a random nonce ai,
build a pair t with m and the nonce ai,
build hello packet using the pair t,
broadcast the hello, synchronise and move to P.

Wait for response from neighbours,

extract node name n from packet q,

extract MAC h from packet q,
build a pair t0 with n and current nonce ai,
calculate n’s master key kn,
calculate MAC h0 with kn and t0,
if it matches with the received one go to P4,
otherwise steps to next time interval and restart;
calculate the pairwise key kmn,
synchronise, and continue.

Wait for incoming hello packets,

extract the ﬁrst component,

extract the second component,

check if p is a hello packet,

extract the sender name m,

extract the nonce a,

build a pair t with a and n,
calculate MAC h on t with n’s master key kn,
build packet q with node name n and MAC h,
synchronise, broadcast q, and go to R7,
calculate pairwise key kmn,
synchronise and continue.

for calculating MACs and the pseudo random function prf(), respectively. Our
speciﬁcation considers only two nodes, to yield an easier to read model:

LEAP+

def= m[S1]νm | n[R]νn

where m is the initiator and n is the responder, with m ∈ νn and n ∈ νm. This
does not lose any generality with respect to the multiple nodes case. Again, for
veriﬁcation reasons, we assume that the environment contains a fresh node test,
unknown to the attacker, such that test ∈ νm. We recall that the test node cannot
transmits but it can only receive messages.

7.1 Security analysis
In LEAP+, the timed integrity property imposes that the initiator must authenti-
cate only packets sent by the responder in the previous time interval (δ = 1). Let

12

+ by replacing the process P5 with P 0

us slightly modify the speciﬁcation of LEAP+ to represent this property. Let us de-
def= σ.[auth t ‘pair q]!hqi.OK SND.
ﬁne LEAP0
Now, the sender process transmit a packet to signal successful authentication. No-
tice that authenticated messages are always sent by the responder between an hello
and authentication message with the same nonce. As a consequence, time integrity
imposes that hello messages and authentication messages with the same nonce must
diﬀer for at most two time intervals.

5

In order to show timed integrity, we specify αint(LEAP0

+) as:

+) def= m[ ˆS1]test (cid:12)(cid:12) n[ ˆR]∅

αint(LEAP0

def= !hpii.σ.bτ.σ.!hqii.OK SNDcdSi+1, for all i, and ˆR def= σ. ˆR, with pi =

where ˆSi
pair(hello, pair(m, ai)) and qi = pair(auth, pair(m, ai)). By construction, αint(LEAP0
+)
satisﬁes timed integrity.

As we did for µTESLA, we use Proposition 5 to break down the proof into
smaller chunks. In particular, we notice that the nodes m[S1]νm and n[R]νn are
time-dependent stable with respect to the sequence {Φi}i≥0, deﬁned as follows:

Φ0 = {a1}
Φ1 = Φ0 ∪ {mac(kn, pair(n, a1))}
. . .
Φi = Φi−1 ∪ {aj+1}
Φi = Φi−1 ∪ {mac(kn, pair(n, aj+1))}
Lemma 3. 1. m[S1]νm ∈ tGN DCm[ ˆS1]test
2. n[R]νn ∈ tGN DC n[ ˆR]∅

.

.

.

if
if

i = 2j,
i = 2j + 1,

j > 0
j > 0.

By applying Lemma 3 and Proposition 5 we derive the following result.
Theorem 4 (LEAP+ Timed integrity). LEAP0

+ ∈ tGN DC αint(LEAP0

+)

.

.

Let us focus now on timed agreement. Again, let us slightly modify the speci-
ﬁcation of LEAP+ to represent timed agreement. We deﬁne LEAP00
+ by replacing
def= σ.[end a ‘pair r]!hri.OK RCV . Now, the
in LEAP+ the process R8 with R0
responder signals the end of the protocol. For simplicity, we use the following ab-
breviation: ri = pair(end, ai). We also require that the node test is among the
neighbours of n, i.e. test ∈ νn, so that end messages can be observed. Now, the
time agreement property for LEAP+ requires that hello packets pi, sent by the
initiator, and end packets ri, sent by the responder, (with the same nonce) must
diﬀer for at most two time intervals (δ = 2).

8

Unfortunately, LEAP00

+ does not satisfy the timed agreement property:

Theorem 5 (LEAP+’s Replay Attack). LEAP00
ment with δ = 2.
Proof. LEAP00

+ has the following trace:

+ does not satisfy time agree-

!p1.test.σ.τ.σ.τ.!p2.test.σ.!q1.test.σ.!r1.test .

13

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

Table 3 Structural Congruence

if Ah˜vi def= P ∧ | ˜x |=| ˜v |

if v1 . . . vn ‘r v
if

6 ∃ v. v1 . . . vn ‘r v

if v1 6= v2

n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[P ]ν
n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[Q]ν
n[[v = v]P ; Q]ν ≡ n[P ]ν
n[[v1 = v2]P ; Q]ν ≡ n[Q]ν
n[Ah˜vi]ν ≡ n[{v/x}P ]ν
M | N ≡ N | M
(M | N ) | M0 ≡ M | (N | M0)
M | 0 ≡ M
M ≡ M
M ≡ N implies N ≡ M
M ≡ M0 ∧ M0 ≡ M00 implies M ≡ M00
M ≡ N implies M | M0 ≡ N | M0 , for all M0

(Struct DedT)
(Struct DedF)
(Struct Then)
(Struct Else)

(Struct Rec)
(Struct Par Comm)
(Struct Par Assoc)
(Struct Zero Par)
(Struct Reﬂ)
(Struct Symm)
(Struct Trans)
(Struct Ctx Par)

3 Time properties

Proposition 2 formalises the deterministic nature of time passing: a network can
reach at most one new state by executing the action σ.

Proposition 2 (Time Determinism). Let M be a well-formed network. If M
M0 and M

σ−−_ M00 then M0 ≡ M00

σ−−_

The maximal progress property [13] says that processes communicate as soon

as a possibility of communication arises.
Proposition 3 (Maximal Progress). Let M be a well-formed network. If M ≡
m[!hvi.P ]ν | N then M

σ−−_ M0 for no network M0.

Patience guarantees that a process will wait indeﬁnitely until it can communi-
cate [13]. In our setting, this means that if no transmissions can start then it must
be possible to execute a σ-action to let time pass.

Proposition 4 (Patience). Let M ≡ Q

i∈I mi[Pi]νi be a well-formed network,
such that for all i ∈ I it holds that mi[Pi]νi 6≡ mi[!hvi.Qi]νi, then there is a network
N such that M

σ−−_ N.

4 Labelled Transition Semantics

In Table 4, we provide a Labelled Transition System (LTS) for our calculus. In
rule (Snd) a sender dispatches its message to its neighbours ν, and then continues
as P . In the label m!v.ν the set ν contains the neighbours of m which may receive
the message v. In rule (Rcv) a receiver gets a message coming from a neighbour
node m, and then evolves into process P , where all the occurrences of the vari-
able x are replaced with the value v. If no message is received in the current time
interval, the node n will continue with process Q, according to the rule (σ-Rcv).

5

Table 4 LTS - Transmission, internal actions, and time passing
m ∈ ν

−
−−−−−−→ m[P ]ν

(Snd)

m[!hvi.P ]ν m!vBν
m /∈ nds(M )
m?v−−−−→ M
M

(RcvEnb)

(Rcv)

(RcvPar)

n[b?(x).PcQ]ν m?v−−−−→ n[{v/x}P ]ν
m?v−−−−→ N0

M

m?v−−−−→ M0 N
M | N
ν0 := ν\nds(N )

m?v−−−−→ M0 | N0

M

(Bcast)

m!vBν
−−−−−−→ M0 N

m?v−−−−→ N0
m!vBν0
−−−−−−−→ M0 | N0

M | N

(Tau)

(σ-nil)

τ−−→ m[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ n[nil]ν

n[nil]ν

(σ-Rcv)

(σ-Par)

−
n[b?(x).PcQ]ν
σ−−→ M0 N
M | N

M

σ−−→ M0 | N0

σ−−→ n[Q]ν
σ−−→ N0

(TauPar)

M
M | N

(Delay)

n[σ.P ]ν

τ−−→ M0
τ−−→ M0 | N
−
σ−−→ n[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ 0

(σ-Tau)

(σ-0)

0

σ−−→ m[Q]ν

In rule (RcvPar) we model the composition of two networks receiving the same
message from the same transmitter. Rule (RcvEnb) says that every node can syn-
chronise with an external transmitter m. This rule, together with rule (RcvPar),
serves to model message loss. Rule (Bcast) models the propagation of messages on
the broadcast channel. Note that in rule (Bcast) we loose track of those neighbours
of m that are in N. Rule (Tau) models local computations. Rule (TauPar) serves
to propagate internal computations on parallel components. The remaining rules
model the passage of time. Rule (Delay) model the delay of a time unit. Rules
(σ-nil) and (σ-0) are straightforward. Rules (σ-Rcv) models timeout on receivers.
Similarly, (σ-Tau) models timeout on internal activities. Rule (σ-Par) models time
synchronisation between parallel components. Rules (Bcast) and (TauPar) have their
symmetric counterpart.

In Table 5 we report the obvious rules for nodes containing matching, recursion
and deduction processes (we recall that only guarded recursion is allowed). In the
sequel, we use the metavariable λ to range over the labels: m!v.ν, m?v, τ, and σ.

The LTS-based semantics is consistent with the reduction semantics.

τ−−→≡ M0 or M

m!vBν
−−−−−−→≡ M0, for some m, v, ν.

Theorem 1 (Harmony Theorem).

– If M _ M0 then either M

σ−−_ M0 then M

m!vBν
−−−−−−→ M0 or M
σ−−→ M0 then M

– If M
– If M
– If M

σ−−→≡ M0.

τ−−→ M0 then M _ M0.
σ−−_ M0.

6

Table 5 LTS - Matching, recursion and deduction

(Then)

n[P ]ν

λ−−→ n[P 0]ν

n[[v = v]P ; Q]ν

λ−−→ n[P 0]ν

(Else)

λ−−→ n[Q0]ν
n[Q]ν
n[[v1 = v2]P ; Q]ν

v1 6= v2
λ−−→ n[Q0]ν

(Rec)

n[{˜v/˜x}P ]ν

λ−−→ n[P 0]ν H(˜x) def= P

n[Hh˜vi]ν

λ−−→ n[P 0]ν

(Dtt)

n[{v/x}P ]ν λ−−→ n[P 0]ν v1 . . . vn ‘r v
n[[v1 . . . vn ‘r x]P ; Q]ν
λ−−→ n[P 0]ν

(Dﬀ)

n[Q]ν λ−−→ n[Q0]ν
n[[v1 . . . vn ‘r x]P ; Q]ν

6 ∃ v. v1 . . . vn ‘r v
λ−−→ n[Q0]ν

4.1 Behavioural Semantics

We use our LTS to deﬁne a standard notion of timed labelled bisimilarity. In general,
a bisimulation describes how two terms (in our case networks) can mimic each other
actions. Since we are focusing on weak equivalences we have to distinguish between
transmissions which may be observed and transmissions which may not be observed
by the environment. Thus, we extend the set of rules of Table 4 with the following
two rules:

(Shh)

M

m!v.∅−−−−−→ M0
τ−−→ M0
M

M

(Obs)

m!v.ν

−−−−−−→ M0
M

!v.ν−−−−→ M0

ν 6= ∅

Rule (Shh) models transmissions that cannot be observed because none of the poten-
tial receivers is in the environment. Rule (Obs) models a transmission of a message
v that can be received (and hence observed) by those nodes of the environment
contained in ν. The name of the transmitter is removed as in real networks the
identity of the transmitter can only be ensured by using appropriate authentica-
tion protocols. Notice that in a derivation tree the rule (Obs) can only be applied
at top-level.
In the rest of the paper, the metavariable α ranges over the following actions:
!v.ν, m?v, τ, and σ. We adopt the standard notation for weak transitions: =⇒
ˆα==⇒
denotes the reﬂexive and transitive closure of
denotes =⇒ if α = τ and α==⇒ otherwise.
Deﬁnition 2 (Bi-similarity). A relation R over well-formed networks is a simu-
lation if M R N implies that whenever M
α−−→ M0 there is N0 such that N ˆα==⇒ N0
and M0 R N0. A relation R is called bisimulation if both R and its converse are
simulations. We say that M and N are similar, written M . N if there is a simu-
lation R such that M R N. We say that M and N are bisimilar, written M ≈ N,
if there is a bisimulation R such that M R N.
Our notions of similarity and bisimilarity between networks are congruence, as they
are preserved by parallel composition. We only report the result for bisimilarity.
Theorem 2 (≈ is a congruence). Let M and N be two well-formed networks
such that M ≈ N. Then M | O ≈ N | O for all networks O such that M | O and
N | O are well-formed.

α==⇒ denotes =⇒ α−−→ =⇒;

τ−−→;

7

5 A Framework for the Analysis of Wireless Network

Security Protocols

In order to perform a security analysis of wireless network security protocols, we
adapt a general schema for the deﬁnition of timed security properties, called Timed
Generalized Non-Deducibility on Compositions (tGNDC ) [10], a real-time general-
isation of Generalised Non-Deducibility on Compositions (GNDC ) [17]. The main
idea is the following: a system M is tGN DC α
/ if and only if for every attacker ATT
the composition of the system M with ATT satisﬁes the timed speciﬁcation α(M),
with respect the timed behavioural relation /. The preorder / that we will be using
in the following analysis is the similarity relation .. An attacker is a network, with
some constrains on the data known initially, which tries to attack a protocol by
stealing and faking information transmitted on the communication channel. Given
a network M, we call ID(M) the set of messages (closed values) that appears in
M.1 In our setting, a generic attacker of a network M is a collection of nodes in
the environment of M, with current knowledge Φ:

n∈Env(M ) n[Pn]nds(M ) s.t. ID(Pn) ⊆ D(Φ) for all n.

AT T (Φ, M) def= Q

Deﬁnition 3 (tGNDC). Let M be a network, Φ0 the initial knowledge of the
attacker, and α a function between networks deﬁning the property speciﬁcation for
M as the network α(M). We say that M is tGN DC α. if and only if it holds that
M | AT T (Φ0, M) . α(M).

In order to prove that a network is tGN DC α., we need a timed notion of term
stability [10]. Intuitively, a network M is said to be time-dependent stable if the
attacker cannot increase its knowledge when M runs in the space of a time interval.
This requires the notion of execution trace. A trace is a sequence of labelled transi-
tions, that we will denote in the standard way. If A is sequence of labels α1α2 . . . αn,
we write M A==⇒ M0 to mean M =⇒ α1−−−→ =⇒ ··· =⇒ αn−−−→ =⇒ M0. Let #σ(A) be the
number of occurrences of σ actions in the sequence A.

Deﬁnition 4. We say that a network M is time-dependent stable wrt a sequence
of knowledges {Φj}j≥0, if whenever M | AT T (Φ0, M) A==⇒ M0 | AT T (Φ0, M0) and
#σ(A) = i, then D(Φ0) ⊆ D(Φi).

When two or more networks are time-dependent stable with respect a certain
sequence of knowledges {Φj}j≥0, and they enjoy a certain tGNDC property, then
the following compositionality property holds.
Proposition 5. Let {Φj}j≥0 be a sequence of knowledges, and {Mr}1≤r≤n a set
of time-dependent stable subnetworks, with respect to {Φi}i≥0, such that Mr ∈
, for 1≤r≤n. It follows that:
tGN DC αr(Mr)
1. M1 | . . . | Mn is time-dependent stable;
2. M1 | . . . | Mn ∈ tGN DC α1(M1)|...|αn(Mn)

.

.

.

1 This function can be easily deﬁned along the lines of [10].

8

As in [10], we formalise two useful timed properties for security protocols in
terms of use tGN DC α
/ : timed integrity, which guarantees that only fresh packets are
authenticated, and timed agreement, for which agreement must be reached within a
certain deadline, otherwise authentications does not hold. More precisely, a protocol
is said to enjoy the timed integrity property if, whenever a packet p is authenticated
during the time interval i, then this packet was sent at most i − δ time intervals
before. A protocol is said to enjoy the timed agreement property if, whenever a
responder n has completed a run of the protocol, apparently with an initiator m,
then the latter has initiated the protocol, apparently with the former, at most δ
time intervals before, and the two agents agreed on a set of data d.

6 The µTESLA protocol

The µTESLA protocol was designed by Perrig et al. [14] to provide authenti-
cated broadcast for sensor networks. µTESLA calculates the Message Authenti-
cation Code (MAC) for every packet pi that it is transmitted by using a diﬀerent
key ki. These keys are generated with a public one-way function F such that, if
k0, k1, . . . , kn are the keys used in the transmission, F (ki) = ki−1, for 1 ≤ i ≤ n.
The transmission time is split into time intervals and each key is tied to one of
them. In each time interval one or more packets are deployed by the sender, each
one containing the payload and the MAC calculated with the key bound to that in-
terval. When a new interval starts, the key tied to the previous interval is disclosed
to all receivers, so that they can authenticate all the packets previously received.
Sender and receivers are loosely time synchronised on the key disclosure time to
prevent malicious nodes to forge packets with modiﬁed payloads. Nodes discard
packets containing MACs calculated with already disclosed keys, as those packets
could come from an attacker. This key-chain mechanism together with the one-way
function F , provides two major advantages: (i) it allows to calculate lost keys by
simply applying F to the last received key, as many times as necessary; (ii) every
node can authenticate the most recent key ki by means of the last received key kl
(stored in the node memory) and the function F ; once authenticated, ki replaces
kl in the node memory. The protocol works under the assumption that all nodes
share an initial key k0, before the protocol starts.

In Table 6 we provide a speciﬁcation of the µTESLA protocol in tcryptoCWS.
Besides the deduction rules for dealing with pairs, we require a deduction rule to
build MACs: v1 v2 ‘mac mac(v1, v2). Our encoding contains a few simpliﬁcations
with respect to the original protocol. First of all, there is only one packet sent per
time interval, and the sender dispatches one packet and one key alternately. This
yields a simpler and easier to read model. Second, our speciﬁcation does not account
for bootstrapping new receivers on the ﬂy.

Let us proceed with the description of our encoding. We essentially deﬁne two
i , where i is the index number of
kinds of processes: senders, Si, and receivers, Rkl
the current key, and kl is the last authenticated key. Since, we bind one packet with
one key, i also refers to the index number of packets. So, a network starting the
protocol can be represented as:

µTESLA def= m[S1]νm | n1[Rk0

1 ]νn1 | . . . | nk[Rk0

1 ]νnk

9

Table 6 µTESLA speciﬁcation
Sender:

Si

def= [xi ki ‘mac mi]
[mi xi ‘pair pi]
!hpii.σ.
!hkii.σ.
Si+1

Receiver:

Rkl
i

Qkl
i

P kl
i

T kl
i
U ki
i

Z ki
i

def= b?(p).σ.P kl

def= b?(k).σ.Rkl

i

i cQkl
i+1cRkl

i+1

def= b?(k).T kl

i cRkl

i+1

i

def= [F i−l(k) = kl]U ki
def= [p ‘fst m]
[p ‘snd x]
[x k ‘mac m0]
[m = m0]Z ki
def= !hauthii.σ.Rki

i

i+1

; σ.Rki
i+1

Calculate MAC using payload and key,
build a packet with mac and payload,
broadcast packet pi, synchronise,
broadcast key ki, synchronise,
and go to next sending state.

Receive a packet, synchronise, and go to P kl
i
if timeout go to Qkl
i .
Receive a key, synchronise, and
go to next receiving state.
Receive a key k and move to state T kl
i
if timeout go to next receiving state.

;

;

; σ.Rkl

i+1 Check key k using F and the stored key kl,

extract MAC from packet p,
extract payload from packet p,
calculate mac for packet p,
verify if it matches with the received one,

if so, authenticate packet i, synchronise,
go to next receiving state, and store ki.

where m is the transmitter and ni are the receivers. Formally, {n1, . . . , nk} ⊆ νm,
and m ∈ νnj , for 1≤j≤k. For veriﬁcation reasons we assume that the environment
contains a fresh node test, unknown to the attacker, to test successful packet au-
thentication. For simplicity, we assume that this node cannot transmit but it can
only receive messages. Thus, test ∈ νm and test ∈ νnj , for 1≤j≤k.

6.1 Security analysis

Let us prove that µTESLA enjoys timed integrity. In particular, we prove that
receivers authenticate only packets that have been sent in the previous time interval
(δ = 1), in the correct order, even in the presence of the intruder. The key point is
that even if the intruder acquires shared keys then it is “too late” to break integrity,
i.e. to authenticate packets older than δ. Let us deﬁne the timed integrity property
via an abstraction of the protocol with no possible intruders:

α(µTESLA) def= m[S1]test | n1[ ˆR1]test | . . . | nk[ ˆR1]test

Here, S1 is the process deﬁned in Table 6, while ˆRi
Obviously, here we abstract on receivers.

def= σ.bτ.!hauthii.σ. ˆRi+1c ˆRi+1.

Let us demonstrate that α(µTESLA) enjoys timed integrity with δ = 1.

Lemma 1. – If m[S1]test A==⇒ m!pi.test
– If nj[ ˆR1]test A==⇒ nj !authi.test

−−−−−−−−→ then #σ(A) = 2(i − 1).

−−−−−−−−−−→, for some 1≤j≤k, then #σ(A) = 2(i − 1) + 1.

10

Proposition 6. If α(µTESLA) A==⇒ m!pi.test

−−−−−−−−−−→ then #σ(B)=1.
It should be noticed than any formulation of timed agreement for µTESLA
would actually coincide with timed integrity. Thus, Proposition 6 also demonstrates
that α(µTESLA) enjoys timed agreement, with δ = 1.

−−−−−−−−→ B==⇒ nr!authi.test

Now, we prove that µTESLA satisﬁes our timed properties. By Proposition 5, it
is enough to prove the result for each component. In particular, we notice that the
nodes m[S1]νm and nj[R1]νnj , for 1≤j≤k, are time-dependent stable with respect
to the following sequence of knowledges:

Φ0 = {p1}
Φ1 = Φ0 ∪ {k1}
. . .
Φi = Φi−1 ∪ {pj+1} if
Φi = Φi−1 ∪ {kj+1}
if

i = 2j,
i = 2j + 1,

j > 0
j > 0.

Intuitively, Φi consists in Φi−1 together with the set of messages an intruder can
get by eavesdropping on a run of the protocol during the time interval i.
Lemma 2. 1. m[S1]νm ∈ tGN DCm[S1]test
2. nj[R1]νnj ∈ tGN DC nj [ ˆR1]test
By applying Lemma 2 and Proposition 5 we derive the following result.
Theorem 3 (µTESLA Correctness). µTESLA ∈ tGN DC α(µTESLA)

, for 1 ≤ j ≤ k.

.

.

.

.

7 The LEAP+ protocol

The LEAP+ protocol [15] provides a keying framework to establish authenticated
communications. In [15], the authors describe four possible keying mechanisms,
each of them providing a diﬀerent level of security. In our paper, we focus on the
single-hop pairwise shared key mechanism as it is underlying to all other keying
methods. Here, a network controller loads each node with an initial key kIN and
a computational eﬃcient pseudo-random function prf(), before deployment. Then,
each node n derives its master key: kn = prf(kIN, n).

Let us brieﬂy describe the protocol between an initiator node m and a responder
node n. Node m tries to discover its neighbours by broadcasting a hello packet that
contains its identity, m, and a freshly created nonce, ai, where i counts the number
of attempts of the initiator. When n receives the hello packet from m, it computes
its MAC, h = mac(kn, (ai, n)), and sends to m a packet containing h and its identity
n. If node m does not get the authenticated packet from the responder in due time,
it will send a new hello packet with a fresh nonce. When m receives the packet from
n, it tries to authenticate it by using n’s master key and the last created nonce. If
the authentication succeeds, then both nodes proceed in calculating the pairwise
key kmn by using the the function prf() as follows: kmn = prf(kn, m).

In Table 7 we provide a speciﬁcation of LEAP+ in tcryptoCWS. Besides the

standard rules for dealing with pairs, we require the following deduction rules:

(mac)

v1

v2

mac(v1, v2)

v1

v2

prf(v1, v2)

(prf)

11

Table 7 LEAP+ speciﬁcation
Sender at node m:

Si

def= [ai−1 m ‘prf ai]
[m ai ‘pair t]
[hello t ‘pair p]
!hpi.σ.P

P def= b?(q).P1cSi+1
P1
P2
P3

def= [q ‘fst n]P2; σ.Si+1
def= [q ‘snd h]P3; σ.Si+1
def= [n ai ‘pair t0]
[kIN n ‘prf kn]
[kn t0 ‘mac h0]
[h0 = h]P4; σ.Si+1

def= [kn m ‘prf kmn]P5
def= σ.OK SND

P4
P5

Receiver at node n:

R def= b?(p).R1cσ.R
R1
R2
R3
R4
R5
R6

def= [p ‘fst p1]R2; σ.σ.R
def= [p ‘snd p2]R3; σ.σ.R
def= [p1 = hello]R4; σ.σ.R
def= [p2 ‘fst m]R5; σ.σ.R
def= [p2 ‘snd a]R6; σ.σ.R
def= [n a ‘pair t]
[kn t ‘mac h]
[n h ‘pair q]
σ.!hqi.R7

def= [kn m ‘prf kmn]R8
def= σ.OK RCV

R7
R8

Build a random nonce ai,
build a pair t with m and the nonce ai,
build hello packet using the pair t,
broadcast the hello, synchronise and move to P.

Wait for response from neighbours,

extract node name n from packet q,

extract MAC h from packet q,
build a pair t0 with n and current nonce ai,
calculate n’s master key kn,
calculate MAC h0 with kn and t0,
if it matches with the received one go to P4,
otherwise steps to next time interval and restart;
calculate the pairwise key kmn,
synchronise, and continue.

Wait for incoming hello packets,

extract the ﬁrst component,

extract the second component,

check if p is a hello packet,

extract the sender name m,

extract the nonce a,

build a pair t with a and n,
calculate MAC h on t with n’s master key kn,
build packet q with node name n and MAC h,
synchronise, broadcast q, and go to R7,
calculate pairwise key kmn,
synchronise and continue.

for calculating MACs and the pseudo random function prf(), respectively. Our
speciﬁcation considers only two nodes, to yield an easier to read model:

LEAP+

def= m[S1]νm | n[R]νn

where m is the initiator and n is the responder, with m ∈ νn and n ∈ νm. This
does not lose any generality with respect to the multiple nodes case. Again, for
veriﬁcation reasons, we assume that the environment contains a fresh node test,
unknown to the attacker, such that test ∈ νm. We recall that the test node cannot
transmits but it can only receive messages.

7.1 Security analysis
In LEAP+, the timed integrity property imposes that the initiator must authenti-
cate only packets sent by the responder in the previous time interval (δ = 1). Let

12

+ by replacing the process P5 with P 0

us slightly modify the speciﬁcation of LEAP+ to represent this property. Let us de-
def= σ.[auth t ‘pair q]!hqi.OK SND.
ﬁne LEAP0
Now, the sender process transmit a packet to signal successful authentication. No-
tice that authenticated messages are always sent by the responder between an hello
and authentication message with the same nonce. As a consequence, time integrity
imposes that hello messages and authentication messages with the same nonce must
diﬀer for at most two time intervals.

5

In order to show timed integrity, we specify αint(LEAP0

+) as:

+) def= m[ ˆS1]test (cid:12)(cid:12) n[ ˆR]∅

αint(LEAP0

def= !hpii.σ.bτ.σ.!hqii.OK SNDcdSi+1, for all i, and ˆR def= σ. ˆR, with pi =

where ˆSi
pair(hello, pair(m, ai)) and qi = pair(auth, pair(m, ai)). By construction, αint(LEAP0
+)
satisﬁes timed integrity.

As we did for µTESLA, we use Proposition 5 to break down the proof into
smaller chunks. In particular, we notice that the nodes m[S1]νm and n[R]νn are
time-dependent stable with respect to the sequence {Φi}i≥0, deﬁned as follows:

Φ0 = {a1}
Φ1 = Φ0 ∪ {mac(kn, pair(n, a1))}
. . .
Φi = Φi−1 ∪ {aj+1}
Φi = Φi−1 ∪ {mac(kn, pair(n, aj+1))}
Lemma 3. 1. m[S1]νm ∈ tGN DCm[ ˆS1]test
2. n[R]νn ∈ tGN DC n[ ˆR]∅

.

.

.

if
if

i = 2j,
i = 2j + 1,

j > 0
j > 0.

By applying Lemma 3 and Proposition 5 we derive the following result.
Theorem 4 (LEAP+ Timed integrity). LEAP0

+ ∈ tGN DC αint(LEAP0

+)

.

.

Let us focus now on timed agreement. Again, let us slightly modify the speci-
ﬁcation of LEAP+ to represent timed agreement. We deﬁne LEAP00
+ by replacing
def= σ.[end a ‘pair r]!hri.OK RCV . Now, the
in LEAP+ the process R8 with R0
responder signals the end of the protocol. For simplicity, we use the following ab-
breviation: ri = pair(end, ai). We also require that the node test is among the
neighbours of n, i.e. test ∈ νn, so that end messages can be observed. Now, the
time agreement property for LEAP+ requires that hello packets pi, sent by the
initiator, and end packets ri, sent by the responder, (with the same nonce) must
diﬀer for at most two time intervals (δ = 2).

8

Unfortunately, LEAP00

+ does not satisfy the timed agreement property:

Theorem 5 (LEAP+’s Replay Attack). LEAP00
ment with δ = 2.
Proof. LEAP00

+ has the following trace:

+ does not satisfy time agree-

!p1.test.σ.τ.σ.τ.!p2.test.σ.!q1.test.σ.!r1.test .

13

In this trace, the transmission of packets p1 and r1 are divided by four σ-actions.
This denotes a replay attack. More precisely, if we write AT T (Φi) as an abbreviation
for AT T (LEAP 00

+, Φi), we have the following:
m[S1]νm | n[R]νn | AT T (Φ0)
m[σ.P ]νm | n[R]νn | AT T (Φ0)
m[P ]νm | n[σ.R]νn | AT T (Φ1)
m[{p1/q}P1]νm | n[σ.R]νn | AT T (Φ1)
m[S2]νm | n[R]νn | AT T (Φ2)
m[S2]νm | n[σ.!hq1i.R8]νn | AT T (Φ2)
m[σ.P ]νm | n[σ.!hq1i.R8]νn | AT T (Φ2)
m[P ]νm | n[!hq1i.R8]νn | AT T (Φ3)
m[{q1/q}P1]νm | n[R8]νn | AT T (Φ3)
m[S3]νm | n[!hr1i.OK RCV ]νn | AT T (Φ4)

!p1.test

−−−−−−−→
σ−−→
τ−−→
σ−−→
τ−−→
−−−−−−−→
σ−−→
−−−−−−−→
σ−−→
−−−−−−−→

!p2.test

!q1.test

!r1.test

In the ﬁrst time interval the initiator broadcasts the hello packet p1 which is lost
by the responder and grasped by the attacker. Both nodes move to the second
time interval (σ-action). In this time interval, the attacker replay the packet p1
(τ-action), which is received by the initiator m. This packet however was not what
m was expecting. Thus, the network moves to the next time interval (σ-action)
where m goes to the next starting process S2 and n to initial receiving process
R. In the third time interval, the attacker broadcasts again the packet p1 which is
successfully received by node n (τ-action), while node m starts again the protocol
with a new packet p2 and a fresh nonce a2 (!p2.test-action). However, packet p2
is not received by n which is busy in processing p1. Then, the network moves to
the next time interval (σ-action). In the fourth time interval n sends its reply to
the packet p1 (!q1.test-action). Node m does not accept the packet q1 because it
contains an old nonce. The network moves to the next time interval, in which n
broadcasts its end packet r1 (!r1.test-action) and calculate the pairwise key kmn,
while m keeps broadcasting new hello packets. So, agreement can not be reached.

8 Conclusions, Related and Future Work

We have proposed a time broadcasting calculus for wireless network security proto-
cols. Our calculus comes with a well-deﬁned operational semantics and a bisimulation-
based behavioural semantics. We have adapted Gorrieri and Martinelli’s tGNDC
framework to formally study the wireless network security protocols µTESLA and
LEAP+. The design of our calculus has been inspired by tCryptoSPA [10], a timed
cryptographic variant of Milner’s CCS. The tGNDC schema for tCryptoSPA, has
already been used by Gorrieri, Martinelli and Petrocchi [10,11] to study the WMF
and the µTESLA protocol. In particular, since they used tCryptoSPA, the speciﬁ-
cation of µTESLA was much more involved and the abstraction for timed integrity
was less intuitive.

Several process calculi for wireless systems have been proposed [2,3,4,5,6,7,8,9].
Among these, Nanz and Hankin [3] have designed a calculus for mobile ad hoc
networks for speciﬁcation and security analysis of communication protocols. The

14

A Calculus for the Analysis of Wireless Network

Security Protocols?

Francesco Ballardin and Massimo Merro

Dipartimento di Informatica, Universit`a degli Studi di Verona, Italy

Abstract We propose a timed broadcasting calculus for wireless systems.
The operational semantics of our calculus is given both in terms of a Reduc-
tion Semantics and in terms of a Labelled Transition Semantics. We prove
that the two semantics coincide. The labelled transition system is used to
derive a standard notion of (weak) bi-similarity which is proved to be a con-
gruence. We use our simulation theory to adapt Gorrieri and Martinelli’s
tGNDC scheme to investigate, in our setting, the safety of non-trivial wire-
less network security protocols.

1

Introduction

Communication technologies such as WiFi, Bluetooth, and Homeplug are widely
diﬀused and rely on short-range networking for disparate wireless devices in home
and oﬃce environments. Larger wireless networks such as cellular, sensor and ve-
hicular ad hoc networks are also becoming more and more popular.

In order to design secure wireless networks, several aspects have to be consid-
ered [1]: key establishment, secrecy, authentication, and privacy. Key establishment
is at the core of any security framework. Traditional solutions for data secrecy and
authentication rely on cryptographic protocols, which typically use either public
key or symmetric key algorithms. However, in many wireless systems (such as sen-
sor networks and vehicular ad hoc networks) resource limitations and/or real-time
constrains impose to use symmetric key algorithms.

In the last four years, a number of distributed process calculi have been proposed
for modelling diﬀerent aspects of wireless systems [2,3,4,5,6,7,8,9]. However, none
of this calculi deal with security protocols. On the other hand, process algebras,
such as CryptoCCS and tCryptoSPA [10] have already been used in [10,11] to study
network security protocols, also in a wireless scenario. These calculi are extensions
of Milner’s CCS [12], where node distribution, local broadcast communication, and
message loss are not primitives but they are codiﬁed in terms of point-to-point
transmission and a (discrete) notion of time.

We propose a simple timed broadcasting process calculus, called tcryptoCWS,
for modelling wireless network security protocols. As usual in wireless systems,
our broadcast communications span over a limited area, called transmission range.
The time model we use is known as the ﬁctitious clock approach (see e.g. [13]).
A global clock is supposed to be updated whenever all nodes agree on this, by
globally synchronising on a special action σ. All the other actions are assumed to
take no time. This is reasonable if we choose a time unit such that the actual time

? This work was partially supported by the PRIN 2007 project “SOFT”.

Table 1 The Syntax
Networks:

M, N ::= 0

Processes:

P, Q ::= nil

˛˛ M1 | M2
˛˛ n[P ]ν
˛˛
˛˛
˛˛
˛˛ σ.P
˛˛
˛˛
˛˛ Hh˜ui

!hui.P
b?(x).PcQ
bτ.PcQ

[u1 = u2]P ; Q
[u1 . . . un ‘r x]P ; Q

empty network
parallel composition
node

termination
broadcast
receiver with timeout
internal with timeout
delay
matching
deduction
recursion

of an action is negligible with respect to the time unit. The operational semantics
of the calculus is given both in terms of a reduction semantics and in terms of a
labelled transition semantics. The two operational semantics are proved to coincide.
The calculus enjoys standard time properties, such as: time determinism, maximal
progress and patience [13]. The labelled transition semantics is used to derive a
standard notion of (weak) bi-similarity which is proved to be a congruence.

As a main application, we provide a clear and formal speciﬁcation of two wire-
less network security protocols: (i) µTESLA [14], a well-known protocol to achieve
authenticated broadcast in wireless sensor networks; (ii) Localized Encryption and
Authentication Protocol (LEAP+) [15], a key management protocol intended for
large-scale wireless sensor networks.

We use our simulation theory, to adapt Gorrieri and Martinelli’s Timed Gen-
eralized Non-Deducibility on Compositions (tGNDC) scheme [10,11], a well-known
general framework for the deﬁnition of timed security properties. In particular, we
concentrate on two properties: timed integrity, which guarantees on the freshness of
authenticated packets; and timed agreement, for which agreement between initiator
and responder must be reached within a certain deadline. We formally prove that
the µTESLA protocol enjoys both timed integrity and timed agreement. We then
prove that the single-hop pairwise shared key mechanism of the LEAP+ protocol
enjoys timed integrity, while it does not respect timed agreement. When showing
that timed agreement fails, we provide an execution trace in which the attacker
performs a replay attack, despite the security assessment of [15]. To our knowledge
this is the ﬁrst formalisation of a replay attack to LEAP+, in a timed scenario.

2 The Calculus

In Table 1, we deﬁne the syntax of tcryptoCWS in a two-level structure, a lower
one for processes and an upper one for networks. We use letters a, b, c, . . . for logical
names, x, y, z for variables, u for messages, and v and w for closed values, i.e. values
that do not contain free variables. We write Fi to denote constructors for messages.

2

The syntax and the semantics of tcryptoCWS are parametric with respect to
a given decidable inference system. Inference systems consist of a set of rules to
model the operations on messages by using constructors. For instance, the rules

(pair)

v1

v2

pair(v1, v2)

(fst)

pair(v1, v2)

v1

(snd)

pair(v1, v2)

v2

allow us to deal with pairs of values. An instance of the application of rule r to closed
messages vi is denoted as v1 . . . vk ‘r v0. Given an inference system, a deduction
function D is deﬁned such that, if Φ is a ﬁnite set of closed messages, then D(Φ)
is the set of closed messages that can be deduced from Φ by applying instances of
the rules of the inference system.

allel composition of two sub-networks M1 and M2. We writeQ

Networks in tcryptoCWS are collections of nodes (which represent devices) run-
ning in parallel and using a unique common channel to communicate with each
other. The symbol 0 denotes the empty network, while M1 | M2 represents the par-
i∈I Mi to mean the
parallel composition of all Mi, for i ∈ I. We assume that all nodes have the same
transmission range (this is a quite common assumption in ad hoc networks [16]).
The communication paradigm is local broadcast; only nodes located in the range of
the transmitter may receive data. We write n[P ]ν for a node named n (the device
network address) executing the sequential process P . The tag ν contains (the names
of) the neighbours of n.
Processes are sequential and live within the nodes. The symbol nil denotes the
skip process. The sender process !hvi.P allows to broadcast the value v. The process
b?(x).PcQ denotes a receiver with timeout. Intuitively, this process either receives
a value, in the current time interval, and then continues as P , or it idles for one
time unit, and then continues as Q. Upon successful reception the variable x of
P is instantiated with the received message. Similarly, the process bτ.PcQ denotes
a process that either perform an internal action, in the current time interval, and
then continues as P , or it idles for one time unit, and then continues as Q. The
process σ.P models sleeping for one time unit. Process [v1 = v2]P ; Q behaves as
P if v1 = v2, and as Q otherwise. Sometime, we will write [v1 = v2]P to mean
[v1 = v2]P ; nil. Process [v1 . . . vk ‘r x]P ; Q is the inference construct. It tries to
infer a message w from the set of premises {v1 . . . , vk} through an application of
rule ‘r; if it succeeds, then it behaves as P (where w replaces x), otherwise it
behaves as Q. As in the matching construct, we will write [v1 . . . vn ‘r x]P to
mean [v1 . . . vn ‘r x]P ; nil. In processes σ.P,b?(x).P1cP2, bτ.P1cP2 and !hvi.P the
occurrences of P , P1 and P2 are said to be guarded. We write Hh˜vi to denote a
process deﬁned via an equation H(˜x) = P , with | ˜x |=| ˜v |, where ˜x contains all
variables that appear free in P . Deﬁning equations provide guarded recursion, since
P may contain only guarded occurrences of process identiﬁers, such as H itself. We
assume there are no free variables in our networks. The absence of free variables
in networks is trivially maintained as the network evolves. We write {v/x}P for the
substitution of the variable x with the value v in P .
Given a network M, nds(M) returns the names of M. If m ∈ nds(M), the
function ngh(m, M) returns the set of the neighbours of m in M. Thus, for M =
m[P ]ν | N it holds that ngh(m, M) = ν. We write Env(M) to mean all the nodes of
the environment reachable by the network M. The formal deﬁnition is: Env(M) =
∪m∈nds(M )ngh(m, M)\nds(M).

3

Table 2 Reduction Semantics

(R-Bcast)

(R-Internal)

(R-Struct1)

i∈I ni[{v/xi}Pi]νi

−

∀i ∈ I ni ∈ ν m ∈ νi

i∈I ni[b?(xi).PicQi]νi _ m[P ]ν |Q
M _ M0
M | N _ M0 | N
j∈J nj[b. . .cQj]νj |Q
j∈J nj[Qj]νj |Q

m[!hvi.P ]ν |Q
m[bτ.PcQ]ν _ m[P ]ν
Q
i∈I ni[σ.Pi]νi |Q
Q
i∈I ni[Pi]νi |Q
M ≡ N N _ N0 N0 ≡ M0
M _ M0

(R-Struct2)

M ≡ N N
M

(R-Par)

−

(R-Sigma)

k∈K nk[nil]νk
k∈K nk[nil]νk

σ−−_
σ−−_ N0 N0 ≡ M0
σ−−_ M0

The dynamics of the calculus is given in terms of a timed reduction relation
described in Table 2. As usual in process calculi, the reduction semantics relies on
an auxiliary relation, ≡, called structural congruence, deﬁned in Table 3. Basically,
≡ brings the participants of a potential interaction into contiguous positions. In
our case, for convenience, structural congruence also takes into account matching
and deduction; we recall that our inference systems are always decidable.

The computation proceeds in lock-step: between global synchronisation, denoted

with σ−−_, all nodes proceeds asynchronously by performing actions with no dura-
tion, denoted with_. Rule (R-Bcast) models the broadcast of a message v. Com-

munication proceeds even if there are no listeners: transmission is a non-blocking
action. Moreover, communication is lossy as some receivers within the range of the
transmitter might not receive the message. This may be due to several reasons such
as signal interferences or the presence of obstacles. Rule (R-Internal) models local
computations. Rules (R-Par), (R-Struct1) and (R-Struct2) are standard in process

calculi. Rule (R-Sigma) models the passage of time. We write _? to denote the
reﬂexive and transitive closure of_.

The syntax presented in Table 1 allows to derive inconsistent networks. We rule
out networks containing two nodes with the same name. As all nodes have the same
transmission range the neighbouring relation is symmetric. Furthermore, in order
to guarantee clock synchronisation, we impose network connectivity.

Deﬁnition 1 (Well-formedness). M is said to be well-formed if
– whenever M ≡ M1 | m1[P1]ν1 | m2[P2]ν2 it holds that m1 6= m2;
– whenever M ≡ N | m1[P1]ν1 | m2[P2]ν2 with m1 ∈ ν2 it holds that m2 ∈ ν1;
– for all m, n ∈ nds(M) there are m1, . . . , mk ∈ nds(M), such that m=m1, n=mk,

νj = ngh(mj, M), for 1≤j≤k, and mi ∈ νi+1, for 1≤i≤k−1.

Network well-formedness is preserved at run time.

Proposition 1. Let M be a well-formed network. If M _ M0 or M

M0 is a well-formed network.

σ−−_ M0 then

4

Table 3 Structural Congruence

if Ah˜vi def= P ∧ | ˜x |=| ˜v |

if v1 . . . vn ‘r v
if

6 ∃ v. v1 . . . vn ‘r v

if v1 6= v2

n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[P ]ν
n[[v1 . . . vn ‘r v]P ; Q]ν ≡ n[Q]ν
n[[v = v]P ; Q]ν ≡ n[P ]ν
n[[v1 = v2]P ; Q]ν ≡ n[Q]ν
n[Ah˜vi]ν ≡ n[{v/x}P ]ν
M | N ≡ N | M
(M | N ) | M0 ≡ M | (N | M0)
M | 0 ≡ M
M ≡ M
M ≡ N implies N ≡ M
M ≡ M0 ∧ M0 ≡ M00 implies M ≡ M00
M ≡ N implies M | M0 ≡ N | M0 , for all M0

(Struct DedT)
(Struct DedF)
(Struct Then)
(Struct Else)

(Struct Rec)
(Struct Par Comm)
(Struct Par Assoc)
(Struct Zero Par)
(Struct Reﬂ)
(Struct Symm)
(Struct Trans)
(Struct Ctx Par)

3 Time properties

Proposition 2 formalises the deterministic nature of time passing: a network can
reach at most one new state by executing the action σ.

Proposition 2 (Time Determinism). Let M be a well-formed network. If M
M0 and M

σ−−_ M00 then M0 ≡ M00

σ−−_

The maximal progress property [13] says that processes communicate as soon

as a possibility of communication arises.
Proposition 3 (Maximal Progress). Let M be a well-formed network. If M ≡
m[!hvi.P ]ν | N then M

σ−−_ M0 for no network M0.

Patience guarantees that a process will wait indeﬁnitely until it can communi-
cate [13]. In our setting, this means that if no transmissions can start then it must
be possible to execute a σ-action to let time pass.

Proposition 4 (Patience). Let M ≡ Q

i∈I mi[Pi]νi be a well-formed network,
such that for all i ∈ I it holds that mi[Pi]νi 6≡ mi[!hvi.Qi]νi, then there is a network
N such that M

σ−−_ N.

4 Labelled Transition Semantics

In Table 4, we provide a Labelled Transition System (LTS) for our calculus. In
rule (Snd) a sender dispatches its message to its neighbours ν, and then continues
as P . In the label m!v.ν the set ν contains the neighbours of m which may receive
the message v. In rule (Rcv) a receiver gets a message coming from a neighbour
node m, and then evolves into process P , where all the occurrences of the vari-
able x are replaced with the value v. If no message is received in the current time
interval, the node n will continue with process Q, according to the rule (σ-Rcv).

5

Table 4 LTS - Transmission, internal actions, and time passing
m ∈ ν

−
−−−−−−→ m[P ]ν

(Snd)

m[!hvi.P ]ν m!vBν
m /∈ nds(M )
m?v−−−−→ M
M

(RcvEnb)

(Rcv)

(RcvPar)

n[b?(x).PcQ]ν m?v−−−−→ n[{v/x}P ]ν
m?v−−−−→ N0

M

m?v−−−−→ M0 N
M | N
ν0 := ν\nds(N )

m?v−−−−→ M0 | N0

M

(Bcast)

m!vBν
−−−−−−→ M0 N

m?v−−−−→ N0
m!vBν0
−−−−−−−→ M0 | N0

M | N

(Tau)

(σ-nil)

τ−−→ m[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ n[nil]ν

n[nil]ν

(σ-Rcv)

(σ-Par)

−
n[b?(x).PcQ]ν
σ−−→ M0 N
M | N

M

σ−−→ M0 | N0

σ−−→ n[Q]ν
σ−−→ N0

(TauPar)

M
M | N

(Delay)

n[σ.P ]ν

τ−−→ M0
τ−−→ M0 | N
−
σ−−→ n[P ]ν

−
m[bτ.PcQ]ν
−
σ−−→ 0

(σ-Tau)

(σ-0)

0

σ−−→ m[Q]ν

In rule (RcvPar) we model the composition of two networks receiving the same
message from the same transmitter. Rule (RcvEnb) says that every node can syn-
chronise with an external transmitter m. This rule, together with rule (RcvPar),
serves to model message loss. Rule (Bcast) models the propagation of messages on
the broadcast channel. Note that in rule (Bcast) we loose track of those neighbours
of m that are in N. Rule (Tau) models local computations. Rule (TauPar) serves
to propagate internal computations on parallel components. The remaining rules
model the passage of time. Rule (Delay) model the delay of a time unit. Rules
(σ-nil) and (σ-0) are straightforward. Rules (σ-Rcv) models timeout on receivers.
Similarly, (σ-Tau) models timeout on internal activities. Rule (σ-Par) models time
synchronisation between parallel components. Rules (Bcast) and (TauPar) have their
symmetric counterpart.

In Table 5 we report the obvious rules for nodes containing matching, recursion
and deduction processes (we recall that only guarded recursion is allowed). In the
sequel, we use the metavariable λ to range over the labels: m!v.ν, m?v, τ, and σ.

The LTS-based semantics is consistent with the reduction semantics.

τ−−→≡ M0 or M

m!vBν
−−−−−−→≡ M0, for some m, v, ν.

Theorem 1 (Harmony Theorem).

– If M _ M0 then either M

σ−−_ M0 then M

m!vBν
−−−−−−→ M0 or M
σ−−→ M0 then M

– If M
– If M
– If M

σ−−→≡ M0.

τ−−→ M0 then M _ M0.
σ−−_ M0.

6

Table 5 LTS - Matching, recursion and deduction

(Then)

n[P ]ν

λ−−→ n[P 0]ν

n[[v = v]P ; Q]ν

λ−−→ n[P 0]ν

(Else)

λ−−→ n[Q0]ν
n[Q]ν
n[[v1 = v2]P ; Q]ν

v1 6= v2
λ−−→ n[Q0]ν

(Rec)

n[{˜v/˜x}P ]ν

λ−−→ n[P 0]ν H(˜x) def= P

n[Hh˜vi]ν

λ−−→ n[P 0]ν

(Dtt)

n[{v/x}P ]ν λ−−→ n[P 0]ν v1 . . . vn ‘r v
n[[v1 . . . vn ‘r x]P ; Q]ν
λ−−→ n[P 0]ν

(Dﬀ)

n[Q]ν λ−−→ n[Q0]ν
n[[v1 . . . vn ‘r x]P ; Q]ν

6 ∃ v. v1 . . . vn ‘r v
λ−−→ n[Q0]ν

4.1 Behavioural Semantics

We use our LTS to deﬁne a standard notion of timed labelled bisimilarity. In general,
a bisimulation describes how two terms (in our case networks) can mimic each other
actions. Since we are focusing on weak equivalences we have to distinguish between
transmissions which may be observed and transmissions which may not be observed
by the environment. Thus, we extend the set of rules of Table 4 with the following
two rules:

(Shh)

M

m!v.∅−−−−−→ M0
τ−−→ M0
M

M

(Obs)

m!v.ν

−−−−−−→ M0
M

!v.ν−−−−→ M0

ν 6= ∅

Rule (Shh) models transmissions that cannot be observed because none of the poten-
tial receivers is in the environment. Rule (Obs) models a transmission of a message
v that can be received (and hence observed) by those nodes of the environment
contained in ν. The name of the transmitter is removed as in real networks the
identity of the transmitter can only be ensured by using appropriate authentica-
tion protocols. Notice that in a derivation tree the rule (Obs) can only be applied
at top-level.
In the rest of the paper, the metavariable α ranges over the following actions:
!v.ν, m?v, τ, and σ. We adopt the standard notation for weak transitions: =⇒
ˆα==⇒
denotes the reﬂexive and transitive closure of
denotes =⇒ if α = τ and α==⇒ otherwise.
Deﬁnition 2 (Bi-similarity). A relation R over well-formed networks is a simu-
lation if M R N implies that whenever M
α−−→ M0 there is N0 such that N ˆα==⇒ N0
and M0 R N0. A relation R is called bisimulation if both R and its converse are
simulations. We say that M and N are similar, written M . N if there is a simu-
lation R such that M R N. We say that M and N are bisimilar, written M ≈ N,
if there is a bisimulation R such that M R N.
Our notions of similarity and bisimilarity between networks are congruence, as they
are preserved by parallel composition. We only report the result for bisimilarity.
Theorem 2 (≈ is a congruence). Let M and N be two well-formed networks
such that M ≈ N. Then M | O ≈ N | O for all networks O such that M | O and
N | O are well-formed.

α==⇒ denotes =⇒ α−−→ =⇒;

τ−−→;

7

5 A Framework for the Analysis of Wireless Network

Security Protocols

In order to perform a security analysis of wireless network security protocols, we
adapt a general schema for the deﬁnition of timed security properties, called Timed
Generalized Non-Deducibility on Compositions (tGNDC ) [10], a real-time general-
isation of Generalised Non-Deducibility on Compositions (GNDC ) [17]. The main
idea is the following: a system M is tGN DC α
/ if and only if for every attacker ATT
the composition of the system M with ATT satisﬁes the timed speciﬁcation α(M),
with respect the timed behavioural relation /. The preorder / that we will be using
in the following analysis is the similarity relation .. An attacker is a network, with
some constrains on the data known initially, which tries to attack a protocol by
stealing and faking information transmitted on the communication channel. Given
a network M, we call ID(M) the set of messages (closed values) that appears in
M.1 In our setting, a generic attacker of a network M is a collection of nodes in
the environment of M, with current knowledge Φ:

n∈Env(M ) n[Pn]nds(M ) s.t. ID(Pn) ⊆ D(Φ) for all n.

AT T (Φ, M) def= Q

Deﬁnition 3 (tGNDC). Let M be a network, Φ0 the initial knowledge of the
attacker, and α a function between networks deﬁning the property speciﬁcation for
M as the network α(M). We say that M is tGN DC α. if and only if it holds that
M | AT T (Φ0, M) . α(M).

In order to prove that a network is tGN DC α., we need a timed notion of term
stability [10]. Intuitively, a network M is said to be time-dependent stable if the
attacker cannot increase its knowledge when M runs in the space of a time interval.
This requires the notion of execution trace. A trace is a sequence of labelled transi-
tions, that we will denote in the standard way. If A is sequence of labels α1α2 . . . αn,
we write M A==⇒ M0 to mean M =⇒ α1−−−→ =⇒ ··· =⇒ αn−−−→ =⇒ M0. Let #σ(A) be the
number of occurrences of σ actions in the sequence A.

Deﬁnition 4. We say that a network M is time-dependent stable wrt a sequence
of knowledges {Φj}j≥0, if whenever M | AT T (Φ0, M) A==⇒ M0 | AT T (Φ0, M0) and
#σ(A) = i, then D(Φ0) ⊆ D(Φi).

When two or more networks are time-dependent stable with respect a certain
sequence of knowledges {Φj}j≥0, and they enjoy a certain tGNDC property, then
the following compositionality property holds.
Proposition 5. Let {Φj}j≥0 be a sequence of knowledges, and {Mr}1≤r≤n a set
of time-dependent stable subnetworks, with respect to {Φi}i≥0, such that Mr ∈
, for 1≤r≤n. It follows that:
tGN DC αr(Mr)
1. M1 | . . . | Mn is time-dependent stable;
2. M1 | . . . | Mn ∈ tGN DC α1(M1)|...|αn(Mn)

.

.

.

1 This function can be easily deﬁned along the lines of [10].

8

As in [10], we formalise two useful timed properties for security protocols in
terms of use tGN DC α
/ : timed integrity, which guarantees that only fresh packets are
authenticated, and timed agreement, for which agreement must be reached within a
certain deadline, otherwise authentications does not hold. More precisely, a protocol
is said to enjoy the timed integrity property if, whenever a packet p is authenticated
during the time interval i, then this packet was sent at most i − δ time intervals
before. A protocol is said to enjoy the timed agreement property if, whenever a
responder n has completed a run of the protocol, apparently with an initiator m,
then the latter has initiated the protocol, apparently with the former, at most δ
time intervals before, and the two agents agreed on a set of data d.

6 The µTESLA protocol

The µTESLA protocol was designed by Perrig et al. [14] to provide authenti-
cated broadcast for sensor networks. µTESLA calculates the Message Authenti-
cation Code (MAC) for every packet pi that it is transmitted by using a diﬀerent
key ki. These keys are generated with a public one-way function F such that, if
k0, k1, . . . , kn are the keys used in the transmission, F (ki) = ki−1, for 1 ≤ i ≤ n.
The transmission time is split into time intervals and each key is tied to one of
them. In each time interval one or more packets are deployed by the sender, each
one containing the payload and the MAC calculated with the key bound to that in-
terval. When a new interval starts, the key tied to the previous interval is disclosed
to all receivers, so that they can authenticate all the packets previously received.
Sender and receivers are loosely time synchronised on the key disclosure time to
prevent malicious nodes to forge packets with modiﬁed payloads. Nodes discard
packets containing MACs calculated with already disclosed keys, as those packets
could come from an attacker. This key-chain mechanism together with the one-way
function F , provides two major advantages: (i) it allows to calculate lost keys by
simply applying F to the last received key, as many times as necessary; (ii) every
node can authenticate the most recent key ki by means of the last received key kl
(stored in the node memory) and the function F ; once authenticated, ki replaces
kl in the node memory. The protocol works under the assumption that all nodes
share an initial key k0, before the protocol starts.

In Table 6 we provide a speciﬁcation of the µTESLA protocol in tcryptoCWS.
Besides the deduction rules for dealing with pairs, we require a deduction rule to
build MACs: v1 v2 ‘mac mac(v1, v2). Our encoding contains a few simpliﬁcations
with respect to the original protocol. First of all, there is only one packet sent per
time interval, and the sender dispatches one packet and one key alternately. This
yields a simpler and easier to read model. Second, our speciﬁcation does not account
for bootstrapping new receivers on the ﬂy.

Let us proceed with the description of our encoding. We essentially deﬁne two
i , where i is the index number of
kinds of processes: senders, Si, and receivers, Rkl
the current key, and kl is the last authenticated key. Since, we bind one packet with
one key, i also refers to the index number of packets. So, a network starting the
protocol can be represented as:

µTESLA def= m[S1]νm | n1[Rk0

1 ]νn1 | . . . | nk[Rk0

1 ]νnk

9

Table 6 µTESLA speciﬁcation
Sender:

Si

def= [xi ki ‘mac mi]
[mi xi ‘pair pi]
!hpii.σ.
!hkii.σ.
Si+1

Receiver:

Rkl
i

Qkl
i

P kl
i

T kl
i
U ki
i

Z ki
i

def= b?(p).σ.P kl

def= b?(k).σ.Rkl

i

i cQkl
i+1cRkl

i+1

def= b?(k).T kl

i cRkl

i+1

i

def= [F i−l(k) = kl]U ki
def= [p ‘fst m]
[p ‘snd x]
[x k ‘mac m0]
[m = m0]Z ki
def= !hauthii.σ.Rki

i

i+1

; σ.Rki
i+1

Calculate MAC using payload and key,
build a packet with mac and payload,
broadcast packet pi, synchronise,
broadcast key ki, synchronise,
and go to next sending state.

Receive a packet, synchronise, and go to P kl
i
if timeout go to Qkl
i .
Receive a key, synchronise, and
go to next receiving state.
Receive a key k and move to state T kl
i
if timeout go to next receiving state.

;

;

; σ.Rkl

i+1 Check key k using F and the stored key kl,

extract MAC from packet p,
extract payload from packet p,
calculate mac for packet p,
verify if it matches with the received one,

if so, authenticate packet i, synchronise,
go to next receiving state, and store ki.

where m is the transmitter and ni are the receivers. Formally, {n1, . . . , nk} ⊆ νm,
and m ∈ νnj , for 1≤j≤k. For veriﬁcation reasons we assume that the environment
contains a fresh node test, unknown to the attacker, to test successful packet au-
thentication. For simplicity, we assume that this node cannot transmit but it can
only receive messages. Thus, test ∈ νm and test ∈ νnj , for 1≤j≤k.

6.1 Security analysis

Let us prove that µTESLA enjoys timed integrity. In particular, we prove that
receivers authenticate only packets that have been sent in the previous time interval
(δ = 1), in the correct order, even in the presence of the intruder. The key point is
that even if the intruder acquires shared keys then it is “too late” to break integrity,
i.e. to authenticate packets older than δ. Let us deﬁne the timed integrity property
via an abstraction of the protocol with no possible intruders:

α(µTESLA) def= m[S1]test | n1[ ˆR1]test | . . . | nk[ ˆR1]test

Here, S1 is the process deﬁned in Table 6, while ˆRi
Obviously, here we abstract on receivers.

def= σ.bτ.!hauthii.σ. ˆRi+1c ˆRi+1.

Let us demonstrate that α(µTESLA) enjoys timed integrity with δ = 1.

Lemma 1. – If m[S1]test A==⇒ m!pi.test
– If nj[ ˆR1]test A==⇒ nj !authi.test

−−−−−−−−→ then #σ(A) = 2(i − 1).

−−−−−−−−−−→, for some 1≤j≤k, then #σ(A) = 2(i − 1) + 1.

10

Proposition 6. If α(µTESLA) A==⇒ m!pi.test

−−−−−−−−−−→ then #σ(B)=1.
It should be noticed than any formulation of timed agreement for µTESLA
would actually coincide with timed integrity. Thus, Proposition 6 also demonstrates
that α(µTESLA) enjoys timed agreement, with δ = 1.

−−−−−−−−→ B==⇒ nr!authi.test

Now, we prove that µTESLA satisﬁes our timed properties. By Proposition 5, it
is enough to prove the result for each component. In particular, we notice that the
nodes m[S1]νm and nj[R1]νnj , for 1≤j≤k, are time-dependent stable with respect
to the following sequence of knowledges:

Φ0 = {p1}
Φ1 = Φ0 ∪ {k1}
. . .
Φi = Φi−1 ∪ {pj+1} if
Φi = Φi−1 ∪ {kj+1}
if

i = 2j,
i = 2j + 1,

j > 0
j > 0.

Intuitively, Φi consists in Φi−1 together with the set of messages an intruder can
get by eavesdropping on a run of the protocol during the time interval i.
Lemma 2. 1. m[S1]νm ∈ tGN DCm[S1]test
2. nj[R1]νnj ∈ tGN DC nj [ ˆR1]test
By applying Lemma 2 and Proposition 5 we derive the following result.
Theorem 3 (µTESLA Correctness). µTESLA ∈ tGN DC α(µTESLA)

, for 1 ≤ j ≤ k.

.

.

.

.

7 The LEAP+ protocol

The LEAP+ protocol [15] provides a keying framework to establish authenticated
communications. In [15], the authors describe four possible keying mechanisms,
each of them providing a diﬀerent level of security. In our paper, we focus on the
single-hop pairwise shared key mechanism as it is underlying to all other keying
methods. Here, a network controller loads each node with an initial key kIN and
a computational eﬃcient pseudo-random function prf(), before deployment. Then,
each node n derives its master key: kn = prf(kIN, n).

Let us brieﬂy describe the protocol between an initiator node m and a responder
node n. Node m tries to discover its neighbours by broadcasting a hello packet that
contains its identity, m, and a freshly created nonce, ai, where i counts the number
of attempts of the initiator. When n receives the hello packet from m, it computes
its MAC, h = mac(kn, (ai, n)), and sends to m a packet containing h and its identity
n. If node m does not get the authenticated packet from the responder in due time,
it will send a new hello packet with a fresh nonce. When m receives the packet from
n, it tries to authenticate it by using n’s master key and the last created nonce. If
the authentication succeeds, then both nodes proceed in calculating the pairwise
key kmn by using the the function prf() as follows: kmn = prf(kn, m).

In Table 7 we provide a speciﬁcation of LEAP+ in tcryptoCWS. Besides the

standard rules for dealing with pairs, we require the following deduction rules:

(mac)

v1

v2

mac(v1, v2)

v1

v2

prf(v1, v2)

(prf)

11

Table 7 LEAP+ speciﬁcation
Sender at node m:

Si

def= [ai−1 m ‘prf ai]
[m ai ‘pair t]
[hello t ‘pair p]
!hpi.σ.P

P def= b?(q).P1cSi+1
P1
P2
P3

def= [q ‘fst n]P2; σ.Si+1
def= [q ‘snd h]P3; σ.Si+1
def= [n ai ‘pair t0]
[kIN n ‘prf kn]
[kn t0 ‘mac h0]
[h0 = h]P4; σ.Si+1

def= [kn m ‘prf kmn]P5
def= σ.OK SND

P4
P5

Receiver at node n:

R def= b?(p).R1cσ.R
R1
R2
R3
R4
R5
R6

def= [p ‘fst p1]R2; σ.σ.R
def= [p ‘snd p2]R3; σ.σ.R
def= [p1 = hello]R4; σ.σ.R
def= [p2 ‘fst m]R5; σ.σ.R
def= [p2 ‘snd a]R6; σ.σ.R
def= [n a ‘pair t]
[kn t ‘mac h]
[n h ‘pair q]
σ.!hqi.R7

def= [kn m ‘prf kmn]R8
def= σ.OK RCV

R7
R8

Build a random nonce ai,
build a pair t with m and the nonce ai,
build hello packet using the pair t,
broadcast the hello, synchronise and move to P.

Wait for response from neighbours,

extract node name n from packet q,

extract MAC h from packet q,
build a pair t0 with n and current nonce ai,
calculate n’s master key kn,
calculate MAC h0 with kn and t0,
if it matches with the received one go to P4,
otherwise steps to next time interval and restart;
calculate the pairwise key kmn,
synchronise, and continue.

Wait for incoming hello packets,

extract the ﬁrst component,

extract the second component,

check if p is a hello packet,

extract the sender name m,

extract the nonce a,

build a pair t with a and n,
calculate MAC h on t with n’s master key kn,
build packet q with node name n and MAC h,
synchronise, broadcast q, and go to R7,
calculate pairwise key kmn,
synchronise and continue.

for calculating MACs and the pseudo random function prf(), respectively. Our
speciﬁcation considers only two nodes, to yield an easier to read model:

LEAP+

def= m[S1]νm | n[R]νn

where m is the initiator and n is the responder, with m ∈ νn and n ∈ νm. This
does not lose any generality with respect to the multiple nodes case. Again, for
veriﬁcation reasons, we assume that the environment contains a fresh node test,
unknown to the attacker, such that test ∈ νm. We recall that the test node cannot
transmits but it can only receive messages.

7.1 Security analysis
In LEAP+, the timed integrity property imposes that the initiator must authenti-
cate only packets sent by the responder in the previous time interval (δ = 1). Let

12

+ by replacing the process P5 with P 0

us slightly modify the speciﬁcation of LEAP+ to represent this property. Let us de-
def= σ.[auth t ‘pair q]!hqi.OK SND.
ﬁne LEAP0
Now, the sender process transmit a packet to signal successful authentication. No-
tice that authenticated messages are always sent by the responder between an hello
and authentication message with the same nonce. As a consequence, time integrity
imposes that hello messages and authentication messages with the same nonce must
diﬀer for at most two time intervals.

5

In order to show timed integrity, we specify αint(LEAP0

+) as:

+) def= m[ ˆS1]test (cid:12)(cid:12) n[ ˆR]∅

αint(LEAP0

def= !hpii.σ.bτ.σ.!hqii.OK SNDcdSi+1, for all i, and ˆR def= σ. ˆR, with pi =

where ˆSi
pair(hello, pair(m, ai)) and qi = pair(auth, pair(m, ai)). By construction, αint(LEAP0
+)
satisﬁes timed integrity.

As we did for µTESLA, we use Proposition 5 to break down the proof into
smaller chunks. In particular, we notice that the nodes m[S1]νm and n[R]νn are
time-dependent stable with respect to the sequence {Φi}i≥0, deﬁned as follows:

Φ0 = {a1}
Φ1 = Φ0 ∪ {mac(kn, pair(n, a1))}
. . .
Φi = Φi−1 ∪ {aj+1}
Φi = Φi−1 ∪ {mac(kn, pair(n, aj+1))}
Lemma 3. 1. m[S1]νm ∈ tGN DCm[ ˆS1]test
2. n[R]νn ∈ tGN DC n[ ˆR]∅

.

.

.

if
if

i = 2j,
i = 2j + 1,

j > 0
j > 0.

By applying Lemma 3 and Proposition 5 we derive the following result.
Theorem 4 (LEAP+ Timed integrity). LEAP0

+ ∈ tGN DC αint(LEAP0

+)

.

.

Let us focus now on timed agreement. Again, let us slightly modify the speci-
ﬁcation of LEAP+ to represent timed agreement. We deﬁne LEAP00
+ by replacing
def= σ.[end a ‘pair r]!hri.OK RCV . Now, the
in LEAP+ the process R8 with R0
responder signals the end of the protocol. For simplicity, we use the following ab-
breviation: ri = pair(end, ai). We also require that the node test is among the
neighbours of n, i.e. test ∈ νn, so that end messages can be observed. Now, the
time agreement property for LEAP+ requires that hello packets pi, sent by the
initiator, and end packets ri, sent by the responder, (with the same nonce) must
diﬀer for at most two time intervals (δ = 2).

8

Unfortunately, LEAP00

+ does not satisfy the timed agreement property:

Theorem 5 (LEAP+’s Replay Attack). LEAP00
ment with δ = 2.
Proof. LEAP00

+ has the following trace:

+ does not satisfy time agree-

!p1.test.σ.τ.σ.τ.!p2.test.σ.!q1.test.σ.!r1.test .

13

In this trace, the transmission of packets p1 and r1 are divided by four σ-actions.
This denotes a replay attack. More precisely, if we write AT T (Φi) as an abbreviation
for AT T (LEAP 00

+, Φi), we have the following:
m[S1]νm | n[R]νn | AT T (Φ0)
m[σ.P ]νm | n[R]νn | AT T (Φ0)
m[P ]νm | n[σ.R]νn | AT T (Φ1)
m[{p1/q}P1]νm | n[σ.R]νn | AT T (Φ1)
m[S2]νm | n[R]νn | AT T (Φ2)
m[S2]νm | n[σ.!hq1i.R8]νn | AT T (Φ2)
m[σ.P ]νm | n[σ.!hq1i.R8]νn | AT T (Φ2)
m[P ]νm | n[!hq1i.R8]νn | AT T (Φ3)
m[{q1/q}P1]νm | n[R8]νn | AT T (Φ3)
m[S3]νm | n[!hr1i.OK RCV ]νn | AT T (Φ4)

!p1.test

−−−−−−−→
σ−−→
τ−−→
σ−−→
τ−−→
−−−−−−−→
σ−−→
−−−−−−−→
σ−−→
−−−−−−−→

!p2.test

!q1.test

!r1.test

In the ﬁrst time interval the initiator broadcasts the hello packet p1 which is lost
by the responder and grasped by the attacker. Both nodes move to the second
time interval (σ-action). In this time interval, the attacker replay the packet p1
(τ-action), which is received by the initiator m. This packet however was not what
m was expecting. Thus, the network moves to the next time interval (σ-action)
where m goes to the next starting process S2 and n to initial receiving process
R. In the third time interval, the attacker broadcasts again the packet p1 which is
successfully received by node n (τ-action), while node m starts again the protocol
with a new packet p2 and a fresh nonce a2 (!p2.test-action). However, packet p2
is not received by n which is busy in processing p1. Then, the network moves to
the next time interval (σ-action). In the fourth time interval n sends its reply to
the packet p1 (!q1.test-action). Node m does not accept the packet q1 because it
contains an old nonce. The network moves to the next time interval, in which n
broadcasts its end packet r1 (!r1.test-action) and calculate the pairwise key kmn,
while m keeps broadcasting new hello packets. So, agreement can not be reached.

8 Conclusions, Related and Future Work

We have proposed a time broadcasting calculus for wireless network security proto-
cols. Our calculus comes with a well-deﬁned operational semantics and a bisimulation-
based behavioural semantics. We have adapted Gorrieri and Martinelli’s tGNDC
framework to formally study the wireless network security protocols µTESLA and
LEAP+. The design of our calculus has been inspired by tCryptoSPA [10], a timed
cryptographic variant of Milner’s CCS. The tGNDC schema for tCryptoSPA, has
already been used by Gorrieri, Martinelli and Petrocchi [10,11] to study the WMF
and the µTESLA protocol. In particular, since they used tCryptoSPA, the speciﬁ-
cation of µTESLA was much more involved and the abstraction for timed integrity
was less intuitive.

Several process calculi for wireless systems have been proposed [2,3,4,5,6,7,8,9].
Among these, Nanz and Hankin [3] have designed a calculus for mobile ad hoc
networks for speciﬁcation and security analysis of communication protocols. The

14

authors provide a decision procedure to check security against ﬁxed intruders known
in advance.

It is our intention to apply our framework to study the correctness of a wide
range of wireless network security protocols, as for instance, MiniSec [18], and
evolutions of LEAP+, such as R-LEAP+ [19] and LEAP++ [20].

References

1. Perrig, A., Stankovic, J.A., Wagner, D.: Security in wireless sensor networks. Com-

mununication ACM 47(6) (2004) 53–57

2. Lanese, I., Sangiorgi, D.: An Operational Semantics for a Calculus for Wireless Sys-

tems. Theoretical Computer Science 411 (2010) 1928–1948

3. Nanz, S., Hankin, C.: A Framework for Security Analysis of Mobile Wireless Networks.

Theoretical Computer Science 367(1-2) (2006) 203–227

4. Singh, A., Ramakrishnan, C.R., Smolka, S.A.: A Process Calculus for Mobile Ad
Hoc Networks. In: COORDINATION. Volume 5052 of Lecture Notes in Computer
Science., Springer (2008) 296–314

5. Merro, M.: An Observational Theory for Mobile Ad Hoc Networks (full paper). In-

formation and Computation 207(2) (2009) 194–208

6. Godskesen, J.: A Calculus for Mobile Ad Hoc Networks.

In: COORDINATION.

Volume 4467 of Lecture Notes in Computer Science., Springer (2007) 132–150

7. Ghassemi, F., Fokkink, W., Movaghar, A.: Equational Reasoning on Ad Hoc networks.
In: FSEN. Volume 5961 of Lecture Notes in Computer Science., Springer (2009) 113–
128

8. Merro, M., Sibilio, E.: A Timed Calculus for Wireless Systems. In: FSEN. Volume

5961 of Lecture Notes in Computer Science., Springer (2010) 228–243

9. Godskesen, J.C., Nanz, S.: Mobility Models and Behavioural Equivalence for Wireless
Networks. In: COORDINATION. Volume 5521 of Lecture Notes in Computer Science.,
Springer (2009) 106–122

10. Gorrieri, R., Martinelli, F.: A simple framework for real-time cryptographic protocol
analysis with compositional proof rules. Sci. Comput. Program. 50(1-3) (2004) 23–49
11. Gorrieri, R., Martinelli, F., Petrocchi, M.: Formal models and analysis of secure
multicast in wired and wireless networks. J. Autom. Reasoning 41(3-4) (2008) 325–
364

12. Milner, R.: Communication and Concurrency. Prentice Hall (1989)
13. Hennessy, M., Regan, T.: A Process Algebra for Timed Systems. Information and

Computation 117(2) (1995) 221–239

14. Perrig, A., Szewczyk, R., Tygar, J.D., Wen, V., Culler, D.: Spins: Security Protocols

for Sensor Networks. Wireless Networks 8(5) (2002) 521–534

15. Zhu, S., Setia, S., Jajodia, S.: Leap+: Eﬃcient security mechanisms for large-scale
distributed sensor networks. ACM Transactions on Sensor Networks 2(4) (2006) 500–
528

16. Misra, S., Woungag, I.: Guide to Wireless Ad Hoc Networks. Computer Communi-

cations and Networks. Springer London (2009)

17. Focardi, R., Martinelli, F.: A uniform approach for the deﬁnition of security properties.
In: World Congress on Formal Methods. Volume 1708 of Lecture Notes in Computer
Science., Springer (1999) 794–813

18. Luk, M., Mezzour, G., Perrig, A., Gligor, V.: Minisec: a secure sensor network com-

munication architecture. In: IPSN. (2007) 479–488

19. Blackshear, S., Verma, R.: R-Leap+: randomizing Leap+ key distribution to resist

replay and jamming attacks. In: SAC, ACM Press (2010) 1985–1992

20. Lim, C.H.: Leap++: A robust key establishment scheme for wireless sensor networks.

In: ICDCS, IEEE Computer Society (2008) 376–381

15

