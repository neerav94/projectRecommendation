Insecurity of An Anonymous Authentication For
Privacy-preserving IoT Target-driven Applications

Xi-Jun Lin

∗
and Lin Sun

†

November 28, 2013

Abstract: The Internet of Things (IoT) will be formed by smart objects and services
interacting autonomously and in real-time. Recently, Alcaide et al. proposed a fully decen-
tralized anonymous authentication protocol for privacy-preserving IoT target-driven appli-
cations. Their system is set up by an ad-hoc community of decentralized founding nodes.
Nodes can interact, being participants of cyberphysical systems, preserving full anonymity.
In this study, we point out that their protocol is insecure. The adversary can cheat the
data collectors by impersonating a legitimate user.

Key words: Anonymous credential system; Fully decentralized protocol; Threshold

cryptography; Zero-knowledge proof of knowledge; Smart community

1 Introduction

The Internet of Things (IoT) will be formed by smart objects and services interacting
autonomously and in real-time. Recently, Alcaide et al. [1] proposed a fully decentralized
anonymous authentication protocol for privacy-preserving IoT target-driven applications.
Their system is set up by an ad-hoc community of decentralized founding nodes. Nodes
can interact, being participants of cyberphysical systems, preserving full anonymity.

In Alcaide et al.’s protocol, two roles are deﬁned for participant nodes: Users and Data
Collectors. Users are the nodes originating the data. They can anonymously and unlinkably
authenticate themselves in front of data collectors proving possession of a valid Anonymous
Access Credential (AAC) encoding a particular set of attributes. Data collectors are entities
responsible for the collection of data from authorized users. Therefore, before collecting the
data, the data collector must verify that the user holds a valid AAC encoding a particular
set of attributes.

The main characteristics of their protocol are:
(cid:15) The protocol does not rely on any central organization.
(cid:15) The users of the system jointly generate and distribute a private key that is used in
a (t, n)-threshold fashion. This allows up to t nodes to be compromised without the
key being compromised.

∗

X.J.Lin is with the Department of Computer Sciences and Technology, Ocean University of China.

Qingdao 266100, P.R.China. email: linxj77@163.com

†

L. Sun is with the College of Liberal Arts, Qingdao University. Qingdao 266071, P.R.China. email:

sunlin9@126.com

1

Insecurity of An Anonymous Authentication For
Privacy-preserving IoT Target-driven Applications

Xi-Jun Lin

∗
and Lin Sun

†

November 28, 2013

Abstract: The Internet of Things (IoT) will be formed by smart objects and services
interacting autonomously and in real-time. Recently, Alcaide et al. proposed a fully decen-
tralized anonymous authentication protocol for privacy-preserving IoT target-driven appli-
cations. Their system is set up by an ad-hoc community of decentralized founding nodes.
Nodes can interact, being participants of cyberphysical systems, preserving full anonymity.
In this study, we point out that their protocol is insecure. The adversary can cheat the
data collectors by impersonating a legitimate user.

Key words: Anonymous credential system; Fully decentralized protocol; Threshold

cryptography; Zero-knowledge proof of knowledge; Smart community

1 Introduction

The Internet of Things (IoT) will be formed by smart objects and services interacting
autonomously and in real-time. Recently, Alcaide et al. [1] proposed a fully decentralized
anonymous authentication protocol for privacy-preserving IoT target-driven applications.
Their system is set up by an ad-hoc community of decentralized founding nodes. Nodes
can interact, being participants of cyberphysical systems, preserving full anonymity.

In Alcaide et al.’s protocol, two roles are deﬁned for participant nodes: Users and Data
Collectors. Users are the nodes originating the data. They can anonymously and unlinkably
authenticate themselves in front of data collectors proving possession of a valid Anonymous
Access Credential (AAC) encoding a particular set of attributes. Data collectors are entities
responsible for the collection of data from authorized users. Therefore, before collecting the
data, the data collector must verify that the user holds a valid AAC encoding a particular
set of attributes.

The main characteristics of their protocol are:
(cid:15) The protocol does not rely on any central organization.
(cid:15) The users of the system jointly generate and distribute a private key that is used in
a (t, n)-threshold fashion. This allows up to t nodes to be compromised without the
key being compromised.

∗

X.J.Lin is with the Department of Computer Sciences and Technology, Ocean University of China.

Qingdao 266100, P.R.China. email: linxj77@163.com

†

L. Sun is with the College of Liberal Arts, Qingdao University. Qingdao 266071, P.R.China. email:

sunlin9@126.com

1

(cid:15) Users of the system can obtain an AAC encoding a set of certiﬁed attributes and
use such an AAC to anonymously and unlinkably authenticate themselves to data
collector entities.

(cid:15) Data collectors can anonymously authenticate users by means of attribute-based
boolean formulas, which can be deﬁned and modiﬁed by the data collector itself at
any time.

Without loss of generality, their protocol is described assuming that users are authenti-
cated based on only two attributes (x1, x2), which can be derived from a standard certiﬁcate
˜x signed by some trusted external entity (i.e., a certiﬁcation authority). In the protocol,
once veriﬁed, the attributes (x1, x2) will be encoded into an AAC so that the user can prove
possession of those attributes without disclosing their actual value.

Any linear boolean formula (or a conjunction of formulas) can be used to anonymously
authenticate users as legitimate participants. Such a formula can be represented as the
function ΦR(x1, x2). As mentioned before, users can prove that the attributes x1 and x2,
encoded in a AAC, satisfy ΦR(x1, x2) = 1 without revealing the actual attribute values.

In this study, we point out that their protocol is insecure. The adversary can cheat the

data collectors by impersonating a legitimate user.

2 Alcaide et al.’s Protocol

Their protocol consists of three phases: Set-Up (where all parameters are generated),
User Registration (users obtain AAC) and Credential Proving (users prove possession of a
valid AAC to a data collector).

2.1 Set-Up

In this phase, a community of n users, fUi : i = 1,(cid:1)(cid:1)(cid:1) , ng, known as founders, comes
together to generate all protocol parameters. As a result of this phase, each founder Ui

holds two tuples:

(cid:15) a public tuple:

P ubi = (N, ε, V1, V2, V3, e, g, s, c, g1, g2, g3, q, h1, h2, h3, h4, h5, h6)

equal for all founders.

(cid:15) a private tuple:

P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i)

diﬀerent for each founder Ui.

(N, ε, V1, V2, V3, d, v1, v2, v3) are generated by the founders in a joint and decentralized
manner, where d = ε
(mod ϕ(N )) and N = 4p1p2 +
2p1 + 2p2 + 1 such that (p1, p2) are Sophie Germain primes. q is a prime picked by a

−1
, v2 = V
2

, v3 = V

−1, v1 = V

−1
1

−1
3

2

Insecurity of An Anonymous Authentication For
Privacy-preserving IoT Target-driven Applications

Xi-Jun Lin

∗
and Lin Sun

†

November 28, 2013

Abstract: The Internet of Things (IoT) will be formed by smart objects and services
interacting autonomously and in real-time. Recently, Alcaide et al. proposed a fully decen-
tralized anonymous authentication protocol for privacy-preserving IoT target-driven appli-
cations. Their system is set up by an ad-hoc community of decentralized founding nodes.
Nodes can interact, being participants of cyberphysical systems, preserving full anonymity.
In this study, we point out that their protocol is insecure. The adversary can cheat the
data collectors by impersonating a legitimate user.

Key words: Anonymous credential system; Fully decentralized protocol; Threshold

cryptography; Zero-knowledge proof of knowledge; Smart community

1 Introduction

The Internet of Things (IoT) will be formed by smart objects and services interacting
autonomously and in real-time. Recently, Alcaide et al. [1] proposed a fully decentralized
anonymous authentication protocol for privacy-preserving IoT target-driven applications.
Their system is set up by an ad-hoc community of decentralized founding nodes. Nodes
can interact, being participants of cyberphysical systems, preserving full anonymity.

In Alcaide et al.’s protocol, two roles are deﬁned for participant nodes: Users and Data
Collectors. Users are the nodes originating the data. They can anonymously and unlinkably
authenticate themselves in front of data collectors proving possession of a valid Anonymous
Access Credential (AAC) encoding a particular set of attributes. Data collectors are entities
responsible for the collection of data from authorized users. Therefore, before collecting the
data, the data collector must verify that the user holds a valid AAC encoding a particular
set of attributes.

The main characteristics of their protocol are:
(cid:15) The protocol does not rely on any central organization.
(cid:15) The users of the system jointly generate and distribute a private key that is used in
a (t, n)-threshold fashion. This allows up to t nodes to be compromised without the
key being compromised.

∗

X.J.Lin is with the Department of Computer Sciences and Technology, Ocean University of China.

Qingdao 266100, P.R.China. email: linxj77@163.com

†

L. Sun is with the College of Liberal Arts, Qingdao University. Qingdao 266071, P.R.China. email:

sunlin9@126.com

1

(cid:15) Users of the system can obtain an AAC encoding a set of certiﬁed attributes and
use such an AAC to anonymously and unlinkably authenticate themselves to data
collector entities.

(cid:15) Data collectors can anonymously authenticate users by means of attribute-based
boolean formulas, which can be deﬁned and modiﬁed by the data collector itself at
any time.

Without loss of generality, their protocol is described assuming that users are authenti-
cated based on only two attributes (x1, x2), which can be derived from a standard certiﬁcate
˜x signed by some trusted external entity (i.e., a certiﬁcation authority). In the protocol,
once veriﬁed, the attributes (x1, x2) will be encoded into an AAC so that the user can prove
possession of those attributes without disclosing their actual value.

Any linear boolean formula (or a conjunction of formulas) can be used to anonymously
authenticate users as legitimate participants. Such a formula can be represented as the
function ΦR(x1, x2). As mentioned before, users can prove that the attributes x1 and x2,
encoded in a AAC, satisfy ΦR(x1, x2) = 1 without revealing the actual attribute values.

In this study, we point out that their protocol is insecure. The adversary can cheat the

data collectors by impersonating a legitimate user.

2 Alcaide et al.’s Protocol

Their protocol consists of three phases: Set-Up (where all parameters are generated),
User Registration (users obtain AAC) and Credential Proving (users prove possession of a
valid AAC to a data collector).

2.1 Set-Up

In this phase, a community of n users, fUi : i = 1,(cid:1)(cid:1)(cid:1) , ng, known as founders, comes
together to generate all protocol parameters. As a result of this phase, each founder Ui

holds two tuples:

(cid:15) a public tuple:

P ubi = (N, ε, V1, V2, V3, e, g, s, c, g1, g2, g3, q, h1, h2, h3, h4, h5, h6)

equal for all founders.

(cid:15) a private tuple:

P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i)

diﬀerent for each founder Ui.

(N, ε, V1, V2, V3, d, v1, v2, v3) are generated by the founders in a joint and decentralized
manner, where d = ε
(mod ϕ(N )) and N = 4p1p2 +
2p1 + 2p2 + 1 such that (p1, p2) are Sophie Germain primes. q is a prime picked by a

−1
, v2 = V
2

, v3 = V

−1, v1 = V

−1
1

−1
3

2

super node such that Nj(q (cid:0) 1). (e, g, c, h1,(cid:1)(cid:1)(cid:1) , h6) are picked by the super node randomly
and broadcasted to the founders. s = gd, g1 = gv
3 (mod N ) are also
broadcasted by the super node so that every founder holds them.
P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i) are shares that the founder Ui holds of the secret

1, g2 = gv

2, g3 = gv

values (p1, p2, ϕ(N ), d, v1, v2, v3) respectively.

At the end of this phase, the founders have computed the necessary cryptographic ma-

terial to create AACs for valid data holders later on.

The detail of this phase which has nothing to do with our attack is omitted here.

2.2 User Registration

In this phase, a new user Unew, holding a valid certiﬁcate ˜x, obtains the necessary material
from (t + 1) founders to construct its own Anonymous Access Credential AACnew, a token
that encodes Unew’s attributes (x1, x2) 2 Ze and allows Unew to anonymously and unlinkably
prove to the data collector to be a legitimate participant. Before Unew can participate in
the system, it needs to obtain the protocol public parameters. In order to do that, Unew
simply requests the tuple P ubi from some founder Ui and makes P ubnew = P ubi.
The process that Unew must follow to construct AACnew is described as follows.
(cid:15) Unew picks x3 2R Z∗

e such that gcd(x3, ε) = 1 and x 2R Z∗

3 xe (mod N ). Then, it picks b (cid:17) c (mod N ) randomly, and then sends (˜x, a

N , and then computes
, b)

′

= gx3

′
a
to the founders.

′

, b), each founder Ui veriﬁes ˜x and extracts the attributes (x1, x2)

(cid:15) After receiving (˜x, a
from ˜x. Then, it computes a = gx1
thermore, it signs m with its private tuple P rivi and sends σi(m) to Unew.
(cid:15) After receiving (t + 1) partial signatures σi(m) from the founders, Unew generates

(mod N ) and m = (a + b) (mod N ). Fur-

′
1 gx2
2 a

the signature v = σ(m). Then,
(mod N ) and m =
(a + b) (mod N ), and then checks whether the equation v" = m (mod N ) holds.
If the equation holds, Unew obtains its own Anonymous Access Credential AACnew =
(x1, x2, x3, x, v).

it computes a = gx1

1 gx2
2 a

′

AACnew must be kept secretly at all times, only randomized versions of it will be used
in the Credential Proving phase. It should be noted that Unew must show its certiﬁcate to

the founders.

2.3 Credential Proving

When a user U interacts with a data collector R, U must anonymously and unlinkably
prove to R that it holds the appropriate attributes to satisfy the boolean formula ΦR that
R uses to authenticate legitimate participants.
As the process that U must follow to accomplish such a proof is the key part of the

anonymous credential system. Each of the sub-processes is given as follows.

1. Session values and commitments: every time that U wants to authenticate to
the data collector R, U must generate and commit a set of session values, which are
secret random values used during a particular authentication operation. This process
is given as follows.

3

Insecurity of An Anonymous Authentication For
Privacy-preserving IoT Target-driven Applications

Xi-Jun Lin

∗
and Lin Sun

†

November 28, 2013

Abstract: The Internet of Things (IoT) will be formed by smart objects and services
interacting autonomously and in real-time. Recently, Alcaide et al. proposed a fully decen-
tralized anonymous authentication protocol for privacy-preserving IoT target-driven appli-
cations. Their system is set up by an ad-hoc community of decentralized founding nodes.
Nodes can interact, being participants of cyberphysical systems, preserving full anonymity.
In this study, we point out that their protocol is insecure. The adversary can cheat the
data collectors by impersonating a legitimate user.

Key words: Anonymous credential system; Fully decentralized protocol; Threshold

cryptography; Zero-knowledge proof of knowledge; Smart community

1 Introduction

The Internet of Things (IoT) will be formed by smart objects and services interacting
autonomously and in real-time. Recently, Alcaide et al. [1] proposed a fully decentralized
anonymous authentication protocol for privacy-preserving IoT target-driven applications.
Their system is set up by an ad-hoc community of decentralized founding nodes. Nodes
can interact, being participants of cyberphysical systems, preserving full anonymity.

In Alcaide et al.’s protocol, two roles are deﬁned for participant nodes: Users and Data
Collectors. Users are the nodes originating the data. They can anonymously and unlinkably
authenticate themselves in front of data collectors proving possession of a valid Anonymous
Access Credential (AAC) encoding a particular set of attributes. Data collectors are entities
responsible for the collection of data from authorized users. Therefore, before collecting the
data, the data collector must verify that the user holds a valid AAC encoding a particular
set of attributes.

The main characteristics of their protocol are:
(cid:15) The protocol does not rely on any central organization.
(cid:15) The users of the system jointly generate and distribute a private key that is used in
a (t, n)-threshold fashion. This allows up to t nodes to be compromised without the
key being compromised.

∗

X.J.Lin is with the Department of Computer Sciences and Technology, Ocean University of China.

Qingdao 266100, P.R.China. email: linxj77@163.com

†

L. Sun is with the College of Liberal Arts, Qingdao University. Qingdao 266071, P.R.China. email:

sunlin9@126.com

1

(cid:15) Users of the system can obtain an AAC encoding a set of certiﬁed attributes and
use such an AAC to anonymously and unlinkably authenticate themselves to data
collector entities.

(cid:15) Data collectors can anonymously authenticate users by means of attribute-based
boolean formulas, which can be deﬁned and modiﬁed by the data collector itself at
any time.

Without loss of generality, their protocol is described assuming that users are authenti-
cated based on only two attributes (x1, x2), which can be derived from a standard certiﬁcate
˜x signed by some trusted external entity (i.e., a certiﬁcation authority). In the protocol,
once veriﬁed, the attributes (x1, x2) will be encoded into an AAC so that the user can prove
possession of those attributes without disclosing their actual value.

Any linear boolean formula (or a conjunction of formulas) can be used to anonymously
authenticate users as legitimate participants. Such a formula can be represented as the
function ΦR(x1, x2). As mentioned before, users can prove that the attributes x1 and x2,
encoded in a AAC, satisfy ΦR(x1, x2) = 1 without revealing the actual attribute values.

In this study, we point out that their protocol is insecure. The adversary can cheat the

data collectors by impersonating a legitimate user.

2 Alcaide et al.’s Protocol

Their protocol consists of three phases: Set-Up (where all parameters are generated),
User Registration (users obtain AAC) and Credential Proving (users prove possession of a
valid AAC to a data collector).

2.1 Set-Up

In this phase, a community of n users, fUi : i = 1,(cid:1)(cid:1)(cid:1) , ng, known as founders, comes
together to generate all protocol parameters. As a result of this phase, each founder Ui

holds two tuples:

(cid:15) a public tuple:

P ubi = (N, ε, V1, V2, V3, e, g, s, c, g1, g2, g3, q, h1, h2, h3, h4, h5, h6)

equal for all founders.

(cid:15) a private tuple:

P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i)

diﬀerent for each founder Ui.

(N, ε, V1, V2, V3, d, v1, v2, v3) are generated by the founders in a joint and decentralized
manner, where d = ε
(mod ϕ(N )) and N = 4p1p2 +
2p1 + 2p2 + 1 such that (p1, p2) are Sophie Germain primes. q is a prime picked by a

−1
, v2 = V
2

, v3 = V

−1, v1 = V

−1
1

−1
3

2

super node such that Nj(q (cid:0) 1). (e, g, c, h1,(cid:1)(cid:1)(cid:1) , h6) are picked by the super node randomly
and broadcasted to the founders. s = gd, g1 = gv
3 (mod N ) are also
broadcasted by the super node so that every founder holds them.
P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i) are shares that the founder Ui holds of the secret

1, g2 = gv

2, g3 = gv

values (p1, p2, ϕ(N ), d, v1, v2, v3) respectively.

At the end of this phase, the founders have computed the necessary cryptographic ma-

terial to create AACs for valid data holders later on.

The detail of this phase which has nothing to do with our attack is omitted here.

2.2 User Registration

In this phase, a new user Unew, holding a valid certiﬁcate ˜x, obtains the necessary material
from (t + 1) founders to construct its own Anonymous Access Credential AACnew, a token
that encodes Unew’s attributes (x1, x2) 2 Ze and allows Unew to anonymously and unlinkably
prove to the data collector to be a legitimate participant. Before Unew can participate in
the system, it needs to obtain the protocol public parameters. In order to do that, Unew
simply requests the tuple P ubi from some founder Ui and makes P ubnew = P ubi.
The process that Unew must follow to construct AACnew is described as follows.
(cid:15) Unew picks x3 2R Z∗

e such that gcd(x3, ε) = 1 and x 2R Z∗

3 xe (mod N ). Then, it picks b (cid:17) c (mod N ) randomly, and then sends (˜x, a

N , and then computes
, b)

′

= gx3

′
a
to the founders.

′

, b), each founder Ui veriﬁes ˜x and extracts the attributes (x1, x2)

(cid:15) After receiving (˜x, a
from ˜x. Then, it computes a = gx1
thermore, it signs m with its private tuple P rivi and sends σi(m) to Unew.
(cid:15) After receiving (t + 1) partial signatures σi(m) from the founders, Unew generates

(mod N ) and m = (a + b) (mod N ). Fur-

′
1 gx2
2 a

the signature v = σ(m). Then,
(mod N ) and m =
(a + b) (mod N ), and then checks whether the equation v" = m (mod N ) holds.
If the equation holds, Unew obtains its own Anonymous Access Credential AACnew =
(x1, x2, x3, x, v).

it computes a = gx1

1 gx2
2 a

′

AACnew must be kept secretly at all times, only randomized versions of it will be used
in the Credential Proving phase. It should be noted that Unew must show its certiﬁcate to

the founders.

2.3 Credential Proving

When a user U interacts with a data collector R, U must anonymously and unlinkably
prove to R that it holds the appropriate attributes to satisfy the boolean formula ΦR that
R uses to authenticate legitimate participants.
As the process that U must follow to accomplish such a proof is the key part of the

anonymous credential system. Each of the sub-processes is given as follows.

1. Session values and commitments: every time that U wants to authenticate to
the data collector R, U must generate and commit a set of session values, which are
secret random values used during a particular authentication operation. This process
is given as follows.

3

(a) U picks y 2R Ze, and then computes

ˆv = syv
(mod N )
ˆm = gym (mod N )
ˆa = gya (mod N )
ˆb = gyb
(mod N )

Then, it picks w1, w2, w3 2 ZN and computes

1 hw1
¯m = h ^m
2
3hw2
¯a = h^a
4
¯b = h^b
5hw3
6
¯c = ¯m¯a¯b

(mod q)
(mod q)
(mod q)

(mod q)

(In the original paper, ¯a = h^a
Theorem 2 [1], we correct this typo by replacing it with ¯a = h^a

(b) U sends and commits the session values (ˆa, ¯m, ¯b, ¯c) to R.

2hw2
3

(mod q). According to the Appendix A.2-

3hw2
4

(mod q).)

2. Zero-Knowledge Proofs of Knowledge (ZKPoKs): once U has committed some
set of values, U and R engage in a series of four ZKPoKs:
In order to authenticate U, every operation that R performs at the end of each ZKPoK
must succeed. Whatever data R collects from U must follow these authentication sub-
process.

(cid:15) ZKPoK1: The objective of this ZKPoK is to prove that the private attributes
(x1, x2) that U holds in its AAC satisfy the boolean formula ΦR(x1, x2). Note
that ΦR can be any linear boolean formula; however, for simplicity reasons, as
an example, the authors use:

ΦR(x1, x2) = 1 , αx1 + β = x2 : (α, β) 2 Z

α, β being chosen by data collector R.
Consequently, U must prove, in a zero-knowledge manner, possession of AAC
encoding attributes (x1, x2) such that αx1 + β = x2. This ZKPoK is given as
follows.
{ U picks r
′
y, r
′
′
1gr
2 )r
y (g1g(cid:11)
{ R picks and responds γ 2R Z2t to U.
{ U computes

2R Ze and r
′
3
e (mod N ) to R.

N , then computes and sends t

′ 2R Z∗

′
1, r
′
′
3 r
3

gr

=

′

2 )((cid:13)x1+r

′
1)diveg((cid:13)x3+r

3

′
3)dive

′

x(cid:13)r

(mod N )

{ R checks whether the equation (ˆag

−(cid:12)
2 )(cid:13)t

′

′
= gs
y (g1g(cid:11)

2 )s

′

′
1gs

′
3 s
3

e (mod N ) hold-

′
′
y = γy + r
s
′
′
y
s
1 = γx1 + r
′
′
1
3 = γx3 + r
s
3
′
′
y)dive(g1g(cid:11)
= g((cid:13)y+r
s
) to R.
′
′
y, s
It sends (s

(mod e)
(mod e)
(mod e)

′
3, s

′
1, s

s.

4

Insecurity of An Anonymous Authentication For
Privacy-preserving IoT Target-driven Applications

Xi-Jun Lin

∗
and Lin Sun

†

November 28, 2013

Abstract: The Internet of Things (IoT) will be formed by smart objects and services
interacting autonomously and in real-time. Recently, Alcaide et al. proposed a fully decen-
tralized anonymous authentication protocol for privacy-preserving IoT target-driven appli-
cations. Their system is set up by an ad-hoc community of decentralized founding nodes.
Nodes can interact, being participants of cyberphysical systems, preserving full anonymity.
In this study, we point out that their protocol is insecure. The adversary can cheat the
data collectors by impersonating a legitimate user.

Key words: Anonymous credential system; Fully decentralized protocol; Threshold

cryptography; Zero-knowledge proof of knowledge; Smart community

1 Introduction

The Internet of Things (IoT) will be formed by smart objects and services interacting
autonomously and in real-time. Recently, Alcaide et al. [1] proposed a fully decentralized
anonymous authentication protocol for privacy-preserving IoT target-driven applications.
Their system is set up by an ad-hoc community of decentralized founding nodes. Nodes
can interact, being participants of cyberphysical systems, preserving full anonymity.

In Alcaide et al.’s protocol, two roles are deﬁned for participant nodes: Users and Data
Collectors. Users are the nodes originating the data. They can anonymously and unlinkably
authenticate themselves in front of data collectors proving possession of a valid Anonymous
Access Credential (AAC) encoding a particular set of attributes. Data collectors are entities
responsible for the collection of data from authorized users. Therefore, before collecting the
data, the data collector must verify that the user holds a valid AAC encoding a particular
set of attributes.

The main characteristics of their protocol are:
(cid:15) The protocol does not rely on any central organization.
(cid:15) The users of the system jointly generate and distribute a private key that is used in
a (t, n)-threshold fashion. This allows up to t nodes to be compromised without the
key being compromised.

∗

X.J.Lin is with the Department of Computer Sciences and Technology, Ocean University of China.

Qingdao 266100, P.R.China. email: linxj77@163.com

†

L. Sun is with the College of Liberal Arts, Qingdao University. Qingdao 266071, P.R.China. email:

sunlin9@126.com

1

(cid:15) Users of the system can obtain an AAC encoding a set of certiﬁed attributes and
use such an AAC to anonymously and unlinkably authenticate themselves to data
collector entities.

(cid:15) Data collectors can anonymously authenticate users by means of attribute-based
boolean formulas, which can be deﬁned and modiﬁed by the data collector itself at
any time.

Without loss of generality, their protocol is described assuming that users are authenti-
cated based on only two attributes (x1, x2), which can be derived from a standard certiﬁcate
˜x signed by some trusted external entity (i.e., a certiﬁcation authority). In the protocol,
once veriﬁed, the attributes (x1, x2) will be encoded into an AAC so that the user can prove
possession of those attributes without disclosing their actual value.

Any linear boolean formula (or a conjunction of formulas) can be used to anonymously
authenticate users as legitimate participants. Such a formula can be represented as the
function ΦR(x1, x2). As mentioned before, users can prove that the attributes x1 and x2,
encoded in a AAC, satisfy ΦR(x1, x2) = 1 without revealing the actual attribute values.

In this study, we point out that their protocol is insecure. The adversary can cheat the

data collectors by impersonating a legitimate user.

2 Alcaide et al.’s Protocol

Their protocol consists of three phases: Set-Up (where all parameters are generated),
User Registration (users obtain AAC) and Credential Proving (users prove possession of a
valid AAC to a data collector).

2.1 Set-Up

In this phase, a community of n users, fUi : i = 1,(cid:1)(cid:1)(cid:1) , ng, known as founders, comes
together to generate all protocol parameters. As a result of this phase, each founder Ui

holds two tuples:

(cid:15) a public tuple:

P ubi = (N, ε, V1, V2, V3, e, g, s, c, g1, g2, g3, q, h1, h2, h3, h4, h5, h6)

equal for all founders.

(cid:15) a private tuple:

P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i)

diﬀerent for each founder Ui.

(N, ε, V1, V2, V3, d, v1, v2, v3) are generated by the founders in a joint and decentralized
manner, where d = ε
(mod ϕ(N )) and N = 4p1p2 +
2p1 + 2p2 + 1 such that (p1, p2) are Sophie Germain primes. q is a prime picked by a

−1
, v2 = V
2

, v3 = V

−1, v1 = V

−1
1

−1
3

2

super node such that Nj(q (cid:0) 1). (e, g, c, h1,(cid:1)(cid:1)(cid:1) , h6) are picked by the super node randomly
and broadcasted to the founders. s = gd, g1 = gv
3 (mod N ) are also
broadcasted by the super node so that every founder holds them.
P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i) are shares that the founder Ui holds of the secret

1, g2 = gv

2, g3 = gv

values (p1, p2, ϕ(N ), d, v1, v2, v3) respectively.

At the end of this phase, the founders have computed the necessary cryptographic ma-

terial to create AACs for valid data holders later on.

The detail of this phase which has nothing to do with our attack is omitted here.

2.2 User Registration

In this phase, a new user Unew, holding a valid certiﬁcate ˜x, obtains the necessary material
from (t + 1) founders to construct its own Anonymous Access Credential AACnew, a token
that encodes Unew’s attributes (x1, x2) 2 Ze and allows Unew to anonymously and unlinkably
prove to the data collector to be a legitimate participant. Before Unew can participate in
the system, it needs to obtain the protocol public parameters. In order to do that, Unew
simply requests the tuple P ubi from some founder Ui and makes P ubnew = P ubi.
The process that Unew must follow to construct AACnew is described as follows.
(cid:15) Unew picks x3 2R Z∗

e such that gcd(x3, ε) = 1 and x 2R Z∗

3 xe (mod N ). Then, it picks b (cid:17) c (mod N ) randomly, and then sends (˜x, a

N , and then computes
, b)

′

= gx3

′
a
to the founders.

′

, b), each founder Ui veriﬁes ˜x and extracts the attributes (x1, x2)

(cid:15) After receiving (˜x, a
from ˜x. Then, it computes a = gx1
thermore, it signs m with its private tuple P rivi and sends σi(m) to Unew.
(cid:15) After receiving (t + 1) partial signatures σi(m) from the founders, Unew generates

(mod N ) and m = (a + b) (mod N ). Fur-

′
1 gx2
2 a

the signature v = σ(m). Then,
(mod N ) and m =
(a + b) (mod N ), and then checks whether the equation v" = m (mod N ) holds.
If the equation holds, Unew obtains its own Anonymous Access Credential AACnew =
(x1, x2, x3, x, v).

it computes a = gx1

1 gx2
2 a

′

AACnew must be kept secretly at all times, only randomized versions of it will be used
in the Credential Proving phase. It should be noted that Unew must show its certiﬁcate to

the founders.

2.3 Credential Proving

When a user U interacts with a data collector R, U must anonymously and unlinkably
prove to R that it holds the appropriate attributes to satisfy the boolean formula ΦR that
R uses to authenticate legitimate participants.
As the process that U must follow to accomplish such a proof is the key part of the

anonymous credential system. Each of the sub-processes is given as follows.

1. Session values and commitments: every time that U wants to authenticate to
the data collector R, U must generate and commit a set of session values, which are
secret random values used during a particular authentication operation. This process
is given as follows.

3

(a) U picks y 2R Ze, and then computes

ˆv = syv
(mod N )
ˆm = gym (mod N )
ˆa = gya (mod N )
ˆb = gyb
(mod N )

Then, it picks w1, w2, w3 2 ZN and computes

1 hw1
¯m = h ^m
2
3hw2
¯a = h^a
4
¯b = h^b
5hw3
6
¯c = ¯m¯a¯b

(mod q)
(mod q)
(mod q)

(mod q)

(In the original paper, ¯a = h^a
Theorem 2 [1], we correct this typo by replacing it with ¯a = h^a

(b) U sends and commits the session values (ˆa, ¯m, ¯b, ¯c) to R.

2hw2
3

(mod q). According to the Appendix A.2-

3hw2
4

(mod q).)

2. Zero-Knowledge Proofs of Knowledge (ZKPoKs): once U has committed some
set of values, U and R engage in a series of four ZKPoKs:
In order to authenticate U, every operation that R performs at the end of each ZKPoK
must succeed. Whatever data R collects from U must follow these authentication sub-
process.

(cid:15) ZKPoK1: The objective of this ZKPoK is to prove that the private attributes
(x1, x2) that U holds in its AAC satisfy the boolean formula ΦR(x1, x2). Note
that ΦR can be any linear boolean formula; however, for simplicity reasons, as
an example, the authors use:

ΦR(x1, x2) = 1 , αx1 + β = x2 : (α, β) 2 Z

α, β being chosen by data collector R.
Consequently, U must prove, in a zero-knowledge manner, possession of AAC
encoding attributes (x1, x2) such that αx1 + β = x2. This ZKPoK is given as
follows.
{ U picks r
′
y, r
′
′
1gr
2 )r
y (g1g(cid:11)
{ R picks and responds γ 2R Z2t to U.
{ U computes

2R Ze and r
′
3
e (mod N ) to R.

N , then computes and sends t

′ 2R Z∗

′
1, r
′
′
3 r
3

gr

=

′

2 )((cid:13)x1+r

′
1)diveg((cid:13)x3+r

3

′
3)dive

′

x(cid:13)r

(mod N )

{ R checks whether the equation (ˆag

−(cid:12)
2 )(cid:13)t

′

′
= gs
y (g1g(cid:11)

2 )s

′

′
1gs

′
3 s
3

e (mod N ) hold-

′
′
y = γy + r
s
′
′
y
s
1 = γx1 + r
′
′
1
3 = γx3 + r
s
3
′
′
y)dive(g1g(cid:11)
= g((cid:13)y+r
s
) to R.
′
′
y, s
It sends (s

(mod e)
(mod e)
(mod e)

′
3, s

′
1, s

s.

4

(cid:15) ZKPoK2: The goal of this ZKPoK is to prove that all session value commitments
generated by U are valid. For that matter, U must prove, in a zero-knowledge
manner, knowledge of the secret tuple (y, ˆa, ˆb, ˆm). This ZKPoK is given as fol-
lows.
{ U picks r
{ R picks and responds γ 2R Zq to U.
{ U computes

2R Zq. Then, it computes and sends t

′
1, r
(mod q) to R.

= (h1h5)r

′
2 hr
1

′
2, r

′
^bhr

, r

′
^b

′
3

′

′
4 hr
2

′
3
6

′
′
= γˆb + r
s
^b
^b
′
′
1 = γw1 + r
s
′
′
1
2 = γw2 + r
s
′
′
2
3 = γw3 + r
s
3

, s

holds.

′
1, s

′
2, s

′
1, s

′
3, s

′

) is sent to

3) to R. (In the original paper, (s
′
′
′
It sends (s
y, s
R, we correct this typo by replacing it with (s
^b
′
′
′
′
1, s
2, s
, s
3).)
^b
′
′
′
−^a)(cid:13)t
2 hs
^bhs
= (h1h5)s
1

{ R checks whether the equation (¯c(h1h3)

(mod q)
(cid:15) ZKPoK3: The objective of this ZKPoK is to prove that the signature v encoded
in U’s AAC is valid. In order to do that, U proves, in a zero-knowledge manner,
knowledge of the ε-th root of the h1-part, which is equivalent to proving that ˆv
is the ε-th root of ˆm. This ZKPoK given below must be executed L times.
{ U picks r
{ R picks and responds γ 2R f0, 1g to U.
{ U preforms as follows.

2R ZN . Then, it computes and sends t

′
"
1 hr
1

(mod q) to

′
4 hs
2

= hr

′
1, r

R.

′
3
6

′
2
2

′
2

′

−1 (mod N ) and s

′
′
2 = r
2

(cid:0) w1(r
′
1ˆv

−1)"

′
1 = r

′
′
′
2.
2 = r
1 and s
If γ = 0, let s
′
′
If γ = 1, it computes s
1 = r
1ˆv
(mod N ).
U sends (s
′
1, s

2) to R.
′
{ R performs as follows.

′
If γ = 0, it checks whether the equation t
′
If γ = 1, it checks whether the equation t

′
"
1 hs
1
′
"
1 hs
1

′
2
2
′
2
2

= hs
= ¯ms

(mod q) holds.

(mod q) holds.

(cid:15) ZKPoK4: The goal of this ZKPoK is to prove that U knows the session value
y involved in ZKPoK1 - 3. For that matter, U must prove, in a zero-knowledge
manner, knowledge of the discrete logarithm with base g of the h5-part. This
ZKPoK given below must be executed L times.
{ U picks r

2R ZN . Then, it computes and sends t
′

′
5 hr
1

(mod q) to
, we correct this typo by

is used to compute t

= hgr

′
1, r

′
2
6

′
2

′

′

R. (In the original paper, g
replacing it with g.)
{ R picks and responds γ 2R f0, 1g to U.
{ U preforms as follows.

If γ = 0, let s
If γ = 1, it computes s
U sends (s
′
1, s

′
1 = r
2) to R.
′

′
′
2 = r
1 and s

′
′
1 = r
1

′
2.
(cid:0) y and s
′
′
2 = r
2

(cid:0) w3c

−1gs

′
1.

5

Insecurity of An Anonymous Authentication For
Privacy-preserving IoT Target-driven Applications

Xi-Jun Lin

∗
and Lin Sun

†

November 28, 2013

Abstract: The Internet of Things (IoT) will be formed by smart objects and services
interacting autonomously and in real-time. Recently, Alcaide et al. proposed a fully decen-
tralized anonymous authentication protocol for privacy-preserving IoT target-driven appli-
cations. Their system is set up by an ad-hoc community of decentralized founding nodes.
Nodes can interact, being participants of cyberphysical systems, preserving full anonymity.
In this study, we point out that their protocol is insecure. The adversary can cheat the
data collectors by impersonating a legitimate user.

Key words: Anonymous credential system; Fully decentralized protocol; Threshold

cryptography; Zero-knowledge proof of knowledge; Smart community

1 Introduction

The Internet of Things (IoT) will be formed by smart objects and services interacting
autonomously and in real-time. Recently, Alcaide et al. [1] proposed a fully decentralized
anonymous authentication protocol for privacy-preserving IoT target-driven applications.
Their system is set up by an ad-hoc community of decentralized founding nodes. Nodes
can interact, being participants of cyberphysical systems, preserving full anonymity.

In Alcaide et al.’s protocol, two roles are deﬁned for participant nodes: Users and Data
Collectors. Users are the nodes originating the data. They can anonymously and unlinkably
authenticate themselves in front of data collectors proving possession of a valid Anonymous
Access Credential (AAC) encoding a particular set of attributes. Data collectors are entities
responsible for the collection of data from authorized users. Therefore, before collecting the
data, the data collector must verify that the user holds a valid AAC encoding a particular
set of attributes.

The main characteristics of their protocol are:
(cid:15) The protocol does not rely on any central organization.
(cid:15) The users of the system jointly generate and distribute a private key that is used in
a (t, n)-threshold fashion. This allows up to t nodes to be compromised without the
key being compromised.

∗

X.J.Lin is with the Department of Computer Sciences and Technology, Ocean University of China.

Qingdao 266100, P.R.China. email: linxj77@163.com

†

L. Sun is with the College of Liberal Arts, Qingdao University. Qingdao 266071, P.R.China. email:

sunlin9@126.com

1

(cid:15) Users of the system can obtain an AAC encoding a set of certiﬁed attributes and
use such an AAC to anonymously and unlinkably authenticate themselves to data
collector entities.

(cid:15) Data collectors can anonymously authenticate users by means of attribute-based
boolean formulas, which can be deﬁned and modiﬁed by the data collector itself at
any time.

Without loss of generality, their protocol is described assuming that users are authenti-
cated based on only two attributes (x1, x2), which can be derived from a standard certiﬁcate
˜x signed by some trusted external entity (i.e., a certiﬁcation authority). In the protocol,
once veriﬁed, the attributes (x1, x2) will be encoded into an AAC so that the user can prove
possession of those attributes without disclosing their actual value.

Any linear boolean formula (or a conjunction of formulas) can be used to anonymously
authenticate users as legitimate participants. Such a formula can be represented as the
function ΦR(x1, x2). As mentioned before, users can prove that the attributes x1 and x2,
encoded in a AAC, satisfy ΦR(x1, x2) = 1 without revealing the actual attribute values.

In this study, we point out that their protocol is insecure. The adversary can cheat the

data collectors by impersonating a legitimate user.

2 Alcaide et al.’s Protocol

Their protocol consists of three phases: Set-Up (where all parameters are generated),
User Registration (users obtain AAC) and Credential Proving (users prove possession of a
valid AAC to a data collector).

2.1 Set-Up

In this phase, a community of n users, fUi : i = 1,(cid:1)(cid:1)(cid:1) , ng, known as founders, comes
together to generate all protocol parameters. As a result of this phase, each founder Ui

holds two tuples:

(cid:15) a public tuple:

P ubi = (N, ε, V1, V2, V3, e, g, s, c, g1, g2, g3, q, h1, h2, h3, h4, h5, h6)

equal for all founders.

(cid:15) a private tuple:

P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i)

diﬀerent for each founder Ui.

(N, ε, V1, V2, V3, d, v1, v2, v3) are generated by the founders in a joint and decentralized
manner, where d = ε
(mod ϕ(N )) and N = 4p1p2 +
2p1 + 2p2 + 1 such that (p1, p2) are Sophie Germain primes. q is a prime picked by a

−1
, v2 = V
2

, v3 = V

−1, v1 = V

−1
1

−1
3

2

super node such that Nj(q (cid:0) 1). (e, g, c, h1,(cid:1)(cid:1)(cid:1) , h6) are picked by the super node randomly
and broadcasted to the founders. s = gd, g1 = gv
3 (mod N ) are also
broadcasted by the super node so that every founder holds them.
P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i) are shares that the founder Ui holds of the secret

1, g2 = gv

2, g3 = gv

values (p1, p2, ϕ(N ), d, v1, v2, v3) respectively.

At the end of this phase, the founders have computed the necessary cryptographic ma-

terial to create AACs for valid data holders later on.

The detail of this phase which has nothing to do with our attack is omitted here.

2.2 User Registration

In this phase, a new user Unew, holding a valid certiﬁcate ˜x, obtains the necessary material
from (t + 1) founders to construct its own Anonymous Access Credential AACnew, a token
that encodes Unew’s attributes (x1, x2) 2 Ze and allows Unew to anonymously and unlinkably
prove to the data collector to be a legitimate participant. Before Unew can participate in
the system, it needs to obtain the protocol public parameters. In order to do that, Unew
simply requests the tuple P ubi from some founder Ui and makes P ubnew = P ubi.
The process that Unew must follow to construct AACnew is described as follows.
(cid:15) Unew picks x3 2R Z∗

e such that gcd(x3, ε) = 1 and x 2R Z∗

3 xe (mod N ). Then, it picks b (cid:17) c (mod N ) randomly, and then sends (˜x, a

N , and then computes
, b)

′

= gx3

′
a
to the founders.

′

, b), each founder Ui veriﬁes ˜x and extracts the attributes (x1, x2)

(cid:15) After receiving (˜x, a
from ˜x. Then, it computes a = gx1
thermore, it signs m with its private tuple P rivi and sends σi(m) to Unew.
(cid:15) After receiving (t + 1) partial signatures σi(m) from the founders, Unew generates

(mod N ) and m = (a + b) (mod N ). Fur-

′
1 gx2
2 a

the signature v = σ(m). Then,
(mod N ) and m =
(a + b) (mod N ), and then checks whether the equation v" = m (mod N ) holds.
If the equation holds, Unew obtains its own Anonymous Access Credential AACnew =
(x1, x2, x3, x, v).

it computes a = gx1

1 gx2
2 a

′

AACnew must be kept secretly at all times, only randomized versions of it will be used
in the Credential Proving phase. It should be noted that Unew must show its certiﬁcate to

the founders.

2.3 Credential Proving

When a user U interacts with a data collector R, U must anonymously and unlinkably
prove to R that it holds the appropriate attributes to satisfy the boolean formula ΦR that
R uses to authenticate legitimate participants.
As the process that U must follow to accomplish such a proof is the key part of the

anonymous credential system. Each of the sub-processes is given as follows.

1. Session values and commitments: every time that U wants to authenticate to
the data collector R, U must generate and commit a set of session values, which are
secret random values used during a particular authentication operation. This process
is given as follows.

3

(a) U picks y 2R Ze, and then computes

ˆv = syv
(mod N )
ˆm = gym (mod N )
ˆa = gya (mod N )
ˆb = gyb
(mod N )

Then, it picks w1, w2, w3 2 ZN and computes

1 hw1
¯m = h ^m
2
3hw2
¯a = h^a
4
¯b = h^b
5hw3
6
¯c = ¯m¯a¯b

(mod q)
(mod q)
(mod q)

(mod q)

(In the original paper, ¯a = h^a
Theorem 2 [1], we correct this typo by replacing it with ¯a = h^a

(b) U sends and commits the session values (ˆa, ¯m, ¯b, ¯c) to R.

2hw2
3

(mod q). According to the Appendix A.2-

3hw2
4

(mod q).)

2. Zero-Knowledge Proofs of Knowledge (ZKPoKs): once U has committed some
set of values, U and R engage in a series of four ZKPoKs:
In order to authenticate U, every operation that R performs at the end of each ZKPoK
must succeed. Whatever data R collects from U must follow these authentication sub-
process.

(cid:15) ZKPoK1: The objective of this ZKPoK is to prove that the private attributes
(x1, x2) that U holds in its AAC satisfy the boolean formula ΦR(x1, x2). Note
that ΦR can be any linear boolean formula; however, for simplicity reasons, as
an example, the authors use:

ΦR(x1, x2) = 1 , αx1 + β = x2 : (α, β) 2 Z

α, β being chosen by data collector R.
Consequently, U must prove, in a zero-knowledge manner, possession of AAC
encoding attributes (x1, x2) such that αx1 + β = x2. This ZKPoK is given as
follows.
{ U picks r
′
y, r
′
′
1gr
2 )r
y (g1g(cid:11)
{ R picks and responds γ 2R Z2t to U.
{ U computes

2R Ze and r
′
3
e (mod N ) to R.

N , then computes and sends t

′ 2R Z∗

′
1, r
′
′
3 r
3

gr

=

′

2 )((cid:13)x1+r

′
1)diveg((cid:13)x3+r

3

′
3)dive

′

x(cid:13)r

(mod N )

{ R checks whether the equation (ˆag

−(cid:12)
2 )(cid:13)t

′

′
= gs
y (g1g(cid:11)

2 )s

′

′
1gs

′
3 s
3

e (mod N ) hold-

′
′
y = γy + r
s
′
′
y
s
1 = γx1 + r
′
′
1
3 = γx3 + r
s
3
′
′
y)dive(g1g(cid:11)
= g((cid:13)y+r
s
) to R.
′
′
y, s
It sends (s

(mod e)
(mod e)
(mod e)

′
3, s

′
1, s

s.

4

(cid:15) ZKPoK2: The goal of this ZKPoK is to prove that all session value commitments
generated by U are valid. For that matter, U must prove, in a zero-knowledge
manner, knowledge of the secret tuple (y, ˆa, ˆb, ˆm). This ZKPoK is given as fol-
lows.
{ U picks r
{ R picks and responds γ 2R Zq to U.
{ U computes

2R Zq. Then, it computes and sends t

′
1, r
(mod q) to R.

= (h1h5)r

′
2 hr
1

′
2, r

′
^bhr

, r

′
^b

′
3

′

′
4 hr
2

′
3
6

′
′
= γˆb + r
s
^b
^b
′
′
1 = γw1 + r
s
′
′
1
2 = γw2 + r
s
′
′
2
3 = γw3 + r
s
3

, s

holds.

′
1, s

′
2, s

′
1, s

′
3, s

′

) is sent to

3) to R. (In the original paper, (s
′
′
′
It sends (s
y, s
R, we correct this typo by replacing it with (s
^b
′
′
′
′
1, s
2, s
, s
3).)
^b
′
′
′
−^a)(cid:13)t
2 hs
^bhs
= (h1h5)s
1

{ R checks whether the equation (¯c(h1h3)

(mod q)
(cid:15) ZKPoK3: The objective of this ZKPoK is to prove that the signature v encoded
in U’s AAC is valid. In order to do that, U proves, in a zero-knowledge manner,
knowledge of the ε-th root of the h1-part, which is equivalent to proving that ˆv
is the ε-th root of ˆm. This ZKPoK given below must be executed L times.
{ U picks r
{ R picks and responds γ 2R f0, 1g to U.
{ U preforms as follows.

2R ZN . Then, it computes and sends t

′
"
1 hr
1

(mod q) to

′
4 hs
2

= hr

′
1, r

R.

′
3
6

′
2
2

′
2

′

−1 (mod N ) and s

′
′
2 = r
2

(cid:0) w1(r
′
1ˆv

−1)"

′
1 = r

′
′
′
2.
2 = r
1 and s
If γ = 0, let s
′
′
If γ = 1, it computes s
1 = r
1ˆv
(mod N ).
U sends (s
′
1, s

2) to R.
′
{ R performs as follows.

′
If γ = 0, it checks whether the equation t
′
If γ = 1, it checks whether the equation t

′
"
1 hs
1
′
"
1 hs
1

′
2
2
′
2
2

= hs
= ¯ms

(mod q) holds.

(mod q) holds.

(cid:15) ZKPoK4: The goal of this ZKPoK is to prove that U knows the session value
y involved in ZKPoK1 - 3. For that matter, U must prove, in a zero-knowledge
manner, knowledge of the discrete logarithm with base g of the h5-part. This
ZKPoK given below must be executed L times.
{ U picks r

2R ZN . Then, it computes and sends t
′

′
5 hr
1

(mod q) to
, we correct this typo by

is used to compute t

= hgr

′
1, r

′
2
6

′
2

′

′

R. (In the original paper, g
replacing it with g.)
{ R picks and responds γ 2R f0, 1g to U.
{ U preforms as follows.

If γ = 0, let s
If γ = 1, it computes s
U sends (s
′
1, s

′
1 = r
2) to R.
′

′
′
2 = r
1 and s

′
′
1 = r
1

′
2.
(cid:0) y and s
′
′
2 = r
2

(cid:0) w3c

−1gs

′
1.

5

{ R performs as follows.

If γ = 0, it checks whether the equation t
original paper, g
it with g.)

(mod q) holds. (In the
is used in the equation, we correct this typo by replacing

′

′
If γ = 1, it checks whether the equation t

= (¯bc

′
′
−1)gs
1 hs
2
6

(mod q) holds.

′

′
′
= hgs
5 hs
1
2
6

Note that, if and only if the authentication of user U succeeds (i.e., all ZKPoK1 - 4
are successful), the data collector R collects data from U.

3 Cryptanalysis

In this section, we present an attack to point out that an adversary A can cheat the data
collector by impersonating a legitimate user. In our attack, A needs not compromise user
nodes.
It should be noted that if and only if A processes all ZKPoK1-4 with a data collector R
successfully, A can cheat R into collecting data from it.
Suppose that the public parameters are (N, ε, V1, V2, V3, e, g, s, c, g1, g2, g3, q, h1, h2, h3, h4,
h5, h6), and R’s data collection policy is the equation ΦR(x1, x2) = 1 , αx1 + β = x2 :
(α, β) 2 Z.
In the Credential Proving phase, the adversary A interacts with R anonymously and

unlinkably as follows.

1. Session values and commitments: A picks y 2R Ze, ˆv, a 2R Z∗

N and w, w1, w3 2R

ZN . Then, it computes

−(cid:12)
(cid:15) ˆa = g
2 ae (mod N )
(cid:15) ¯m = h ^m
1 hw1
2
(cid:15) ¯b = h^b
5hw3
6
(cid:15) ¯c = (h1h3)^a(h1h5)w (mod q)

(mod q), where ˆm = ˆv" (mod N )

(mod q), where ˆb = gyc (mod N )

A sends and commits the session values (ˆa, ¯m, ¯b, ¯c) to R.

2. Zero-Knowledge Proofs of Knowledge(ZKPoKs): once A has committed its

session values, A and R engage in ZKPoK1-4 as follows.
′

′
′
′
1gs
y (g1g(cid:11)
2 )s
(mod N ).
3
to R. After receiving γ from R, A computes s
′
3
= a(cid:13) (mod N ),
′
y, s

2R Z∗
) to R.

e, and computes t

= gs

′

Then, it sends t
and then sends (s

(cid:15) ZKPoK1: A picks s
′
′
′
y, s
1, s
3
′
′
′
3, s
1, s
−(cid:12)
2 ae (mod N ), t
Correctness: Since ˆa = g
a(cid:13) (mod N ), we have that

(mod N ) and s

′
= gs
y (g1g(cid:11)

′
′
1gs
2 )s
3
3

′

=

′

−(cid:12)
2 )(cid:13)t

(ˆag

′

−(cid:12)
2 )(cid:13)t

′

−(cid:12)
2 ae)g
= ((g
′
= ae(cid:13)t
= ae(cid:13)gs
′
= gs
y (g1g(cid:11)

′
′
′
1gs
2 )s
y (g1g(cid:11)
3
3
′
′
′
1gs
e
2 )s
3 s
3

(mod N )

Hence, ZKPoK1 is preformed successfully.

6

Insecurity of An Anonymous Authentication For
Privacy-preserving IoT Target-driven Applications

Xi-Jun Lin

∗
and Lin Sun

†

November 28, 2013

Abstract: The Internet of Things (IoT) will be formed by smart objects and services
interacting autonomously and in real-time. Recently, Alcaide et al. proposed a fully decen-
tralized anonymous authentication protocol for privacy-preserving IoT target-driven appli-
cations. Their system is set up by an ad-hoc community of decentralized founding nodes.
Nodes can interact, being participants of cyberphysical systems, preserving full anonymity.
In this study, we point out that their protocol is insecure. The adversary can cheat the
data collectors by impersonating a legitimate user.

Key words: Anonymous credential system; Fully decentralized protocol; Threshold

cryptography; Zero-knowledge proof of knowledge; Smart community

1 Introduction

The Internet of Things (IoT) will be formed by smart objects and services interacting
autonomously and in real-time. Recently, Alcaide et al. [1] proposed a fully decentralized
anonymous authentication protocol for privacy-preserving IoT target-driven applications.
Their system is set up by an ad-hoc community of decentralized founding nodes. Nodes
can interact, being participants of cyberphysical systems, preserving full anonymity.

In Alcaide et al.’s protocol, two roles are deﬁned for participant nodes: Users and Data
Collectors. Users are the nodes originating the data. They can anonymously and unlinkably
authenticate themselves in front of data collectors proving possession of a valid Anonymous
Access Credential (AAC) encoding a particular set of attributes. Data collectors are entities
responsible for the collection of data from authorized users. Therefore, before collecting the
data, the data collector must verify that the user holds a valid AAC encoding a particular
set of attributes.

The main characteristics of their protocol are:
(cid:15) The protocol does not rely on any central organization.
(cid:15) The users of the system jointly generate and distribute a private key that is used in
a (t, n)-threshold fashion. This allows up to t nodes to be compromised without the
key being compromised.

∗

X.J.Lin is with the Department of Computer Sciences and Technology, Ocean University of China.

Qingdao 266100, P.R.China. email: linxj77@163.com

†

L. Sun is with the College of Liberal Arts, Qingdao University. Qingdao 266071, P.R.China. email:

sunlin9@126.com

1

(cid:15) Users of the system can obtain an AAC encoding a set of certiﬁed attributes and
use such an AAC to anonymously and unlinkably authenticate themselves to data
collector entities.

(cid:15) Data collectors can anonymously authenticate users by means of attribute-based
boolean formulas, which can be deﬁned and modiﬁed by the data collector itself at
any time.

Without loss of generality, their protocol is described assuming that users are authenti-
cated based on only two attributes (x1, x2), which can be derived from a standard certiﬁcate
˜x signed by some trusted external entity (i.e., a certiﬁcation authority). In the protocol,
once veriﬁed, the attributes (x1, x2) will be encoded into an AAC so that the user can prove
possession of those attributes without disclosing their actual value.

Any linear boolean formula (or a conjunction of formulas) can be used to anonymously
authenticate users as legitimate participants. Such a formula can be represented as the
function ΦR(x1, x2). As mentioned before, users can prove that the attributes x1 and x2,
encoded in a AAC, satisfy ΦR(x1, x2) = 1 without revealing the actual attribute values.

In this study, we point out that their protocol is insecure. The adversary can cheat the

data collectors by impersonating a legitimate user.

2 Alcaide et al.’s Protocol

Their protocol consists of three phases: Set-Up (where all parameters are generated),
User Registration (users obtain AAC) and Credential Proving (users prove possession of a
valid AAC to a data collector).

2.1 Set-Up

In this phase, a community of n users, fUi : i = 1,(cid:1)(cid:1)(cid:1) , ng, known as founders, comes
together to generate all protocol parameters. As a result of this phase, each founder Ui

holds two tuples:

(cid:15) a public tuple:

P ubi = (N, ε, V1, V2, V3, e, g, s, c, g1, g2, g3, q, h1, h2, h3, h4, h5, h6)

equal for all founders.

(cid:15) a private tuple:

P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i)

diﬀerent for each founder Ui.

(N, ε, V1, V2, V3, d, v1, v2, v3) are generated by the founders in a joint and decentralized
manner, where d = ε
(mod ϕ(N )) and N = 4p1p2 +
2p1 + 2p2 + 1 such that (p1, p2) are Sophie Germain primes. q is a prime picked by a

−1
, v2 = V
2

, v3 = V

−1, v1 = V

−1
1

−1
3

2

super node such that Nj(q (cid:0) 1). (e, g, c, h1,(cid:1)(cid:1)(cid:1) , h6) are picked by the super node randomly
and broadcasted to the founders. s = gd, g1 = gv
3 (mod N ) are also
broadcasted by the super node so that every founder holds them.
P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i) are shares that the founder Ui holds of the secret

1, g2 = gv

2, g3 = gv

values (p1, p2, ϕ(N ), d, v1, v2, v3) respectively.

At the end of this phase, the founders have computed the necessary cryptographic ma-

terial to create AACs for valid data holders later on.

The detail of this phase which has nothing to do with our attack is omitted here.

2.2 User Registration

In this phase, a new user Unew, holding a valid certiﬁcate ˜x, obtains the necessary material
from (t + 1) founders to construct its own Anonymous Access Credential AACnew, a token
that encodes Unew’s attributes (x1, x2) 2 Ze and allows Unew to anonymously and unlinkably
prove to the data collector to be a legitimate participant. Before Unew can participate in
the system, it needs to obtain the protocol public parameters. In order to do that, Unew
simply requests the tuple P ubi from some founder Ui and makes P ubnew = P ubi.
The process that Unew must follow to construct AACnew is described as follows.
(cid:15) Unew picks x3 2R Z∗

e such that gcd(x3, ε) = 1 and x 2R Z∗

3 xe (mod N ). Then, it picks b (cid:17) c (mod N ) randomly, and then sends (˜x, a

N , and then computes
, b)

′

= gx3

′
a
to the founders.

′

, b), each founder Ui veriﬁes ˜x and extracts the attributes (x1, x2)

(cid:15) After receiving (˜x, a
from ˜x. Then, it computes a = gx1
thermore, it signs m with its private tuple P rivi and sends σi(m) to Unew.
(cid:15) After receiving (t + 1) partial signatures σi(m) from the founders, Unew generates

(mod N ) and m = (a + b) (mod N ). Fur-

′
1 gx2
2 a

the signature v = σ(m). Then,
(mod N ) and m =
(a + b) (mod N ), and then checks whether the equation v" = m (mod N ) holds.
If the equation holds, Unew obtains its own Anonymous Access Credential AACnew =
(x1, x2, x3, x, v).

it computes a = gx1

1 gx2
2 a

′

AACnew must be kept secretly at all times, only randomized versions of it will be used
in the Credential Proving phase. It should be noted that Unew must show its certiﬁcate to

the founders.

2.3 Credential Proving

When a user U interacts with a data collector R, U must anonymously and unlinkably
prove to R that it holds the appropriate attributes to satisfy the boolean formula ΦR that
R uses to authenticate legitimate participants.
As the process that U must follow to accomplish such a proof is the key part of the

anonymous credential system. Each of the sub-processes is given as follows.

1. Session values and commitments: every time that U wants to authenticate to
the data collector R, U must generate and commit a set of session values, which are
secret random values used during a particular authentication operation. This process
is given as follows.

3

(a) U picks y 2R Ze, and then computes

ˆv = syv
(mod N )
ˆm = gym (mod N )
ˆa = gya (mod N )
ˆb = gyb
(mod N )

Then, it picks w1, w2, w3 2 ZN and computes

1 hw1
¯m = h ^m
2
3hw2
¯a = h^a
4
¯b = h^b
5hw3
6
¯c = ¯m¯a¯b

(mod q)
(mod q)
(mod q)

(mod q)

(In the original paper, ¯a = h^a
Theorem 2 [1], we correct this typo by replacing it with ¯a = h^a

(b) U sends and commits the session values (ˆa, ¯m, ¯b, ¯c) to R.

2hw2
3

(mod q). According to the Appendix A.2-

3hw2
4

(mod q).)

2. Zero-Knowledge Proofs of Knowledge (ZKPoKs): once U has committed some
set of values, U and R engage in a series of four ZKPoKs:
In order to authenticate U, every operation that R performs at the end of each ZKPoK
must succeed. Whatever data R collects from U must follow these authentication sub-
process.

(cid:15) ZKPoK1: The objective of this ZKPoK is to prove that the private attributes
(x1, x2) that U holds in its AAC satisfy the boolean formula ΦR(x1, x2). Note
that ΦR can be any linear boolean formula; however, for simplicity reasons, as
an example, the authors use:

ΦR(x1, x2) = 1 , αx1 + β = x2 : (α, β) 2 Z

α, β being chosen by data collector R.
Consequently, U must prove, in a zero-knowledge manner, possession of AAC
encoding attributes (x1, x2) such that αx1 + β = x2. This ZKPoK is given as
follows.
{ U picks r
′
y, r
′
′
1gr
2 )r
y (g1g(cid:11)
{ R picks and responds γ 2R Z2t to U.
{ U computes

2R Ze and r
′
3
e (mod N ) to R.

N , then computes and sends t

′ 2R Z∗

′
1, r
′
′
3 r
3

gr

=

′

2 )((cid:13)x1+r

′
1)diveg((cid:13)x3+r

3

′
3)dive

′

x(cid:13)r

(mod N )

{ R checks whether the equation (ˆag

−(cid:12)
2 )(cid:13)t

′

′
= gs
y (g1g(cid:11)

2 )s

′

′
1gs

′
3 s
3

e (mod N ) hold-

′
′
y = γy + r
s
′
′
y
s
1 = γx1 + r
′
′
1
3 = γx3 + r
s
3
′
′
y)dive(g1g(cid:11)
= g((cid:13)y+r
s
) to R.
′
′
y, s
It sends (s

(mod e)
(mod e)
(mod e)

′
3, s

′
1, s

s.

4

(cid:15) ZKPoK2: The goal of this ZKPoK is to prove that all session value commitments
generated by U are valid. For that matter, U must prove, in a zero-knowledge
manner, knowledge of the secret tuple (y, ˆa, ˆb, ˆm). This ZKPoK is given as fol-
lows.
{ U picks r
{ R picks and responds γ 2R Zq to U.
{ U computes

2R Zq. Then, it computes and sends t

′
1, r
(mod q) to R.

= (h1h5)r

′
2 hr
1

′
2, r

′
^bhr

, r

′
^b

′
3

′

′
4 hr
2

′
3
6

′
′
= γˆb + r
s
^b
^b
′
′
1 = γw1 + r
s
′
′
1
2 = γw2 + r
s
′
′
2
3 = γw3 + r
s
3

, s

holds.

′
1, s

′
2, s

′
1, s

′
3, s

′

) is sent to

3) to R. (In the original paper, (s
′
′
′
It sends (s
y, s
R, we correct this typo by replacing it with (s
^b
′
′
′
′
1, s
2, s
, s
3).)
^b
′
′
′
−^a)(cid:13)t
2 hs
^bhs
= (h1h5)s
1

{ R checks whether the equation (¯c(h1h3)

(mod q)
(cid:15) ZKPoK3: The objective of this ZKPoK is to prove that the signature v encoded
in U’s AAC is valid. In order to do that, U proves, in a zero-knowledge manner,
knowledge of the ε-th root of the h1-part, which is equivalent to proving that ˆv
is the ε-th root of ˆm. This ZKPoK given below must be executed L times.
{ U picks r
{ R picks and responds γ 2R f0, 1g to U.
{ U preforms as follows.

2R ZN . Then, it computes and sends t

′
"
1 hr
1

(mod q) to

′
4 hs
2

= hr

′
1, r

R.

′
3
6

′
2
2

′
2

′

−1 (mod N ) and s

′
′
2 = r
2

(cid:0) w1(r
′
1ˆv

−1)"

′
1 = r

′
′
′
2.
2 = r
1 and s
If γ = 0, let s
′
′
If γ = 1, it computes s
1 = r
1ˆv
(mod N ).
U sends (s
′
1, s

2) to R.
′
{ R performs as follows.

′
If γ = 0, it checks whether the equation t
′
If γ = 1, it checks whether the equation t

′
"
1 hs
1
′
"
1 hs
1

′
2
2
′
2
2

= hs
= ¯ms

(mod q) holds.

(mod q) holds.

(cid:15) ZKPoK4: The goal of this ZKPoK is to prove that U knows the session value
y involved in ZKPoK1 - 3. For that matter, U must prove, in a zero-knowledge
manner, knowledge of the discrete logarithm with base g of the h5-part. This
ZKPoK given below must be executed L times.
{ U picks r

2R ZN . Then, it computes and sends t
′

′
5 hr
1

(mod q) to
, we correct this typo by

is used to compute t

= hgr

′
1, r

′
2
6

′
2

′

′

R. (In the original paper, g
replacing it with g.)
{ R picks and responds γ 2R f0, 1g to U.
{ U preforms as follows.

If γ = 0, let s
If γ = 1, it computes s
U sends (s
′
1, s

′
1 = r
2) to R.
′

′
′
2 = r
1 and s

′
′
1 = r
1

′
2.
(cid:0) y and s
′
′
2 = r
2

(cid:0) w3c

−1gs

′
1.

5

{ R performs as follows.

If γ = 0, it checks whether the equation t
original paper, g
it with g.)

(mod q) holds. (In the
is used in the equation, we correct this typo by replacing

′

′
If γ = 1, it checks whether the equation t

= (¯bc

′
′
−1)gs
1 hs
2
6

(mod q) holds.

′

′
′
= hgs
5 hs
1
2
6

Note that, if and only if the authentication of user U succeeds (i.e., all ZKPoK1 - 4
are successful), the data collector R collects data from U.

3 Cryptanalysis

In this section, we present an attack to point out that an adversary A can cheat the data
collector by impersonating a legitimate user. In our attack, A needs not compromise user
nodes.
It should be noted that if and only if A processes all ZKPoK1-4 with a data collector R
successfully, A can cheat R into collecting data from it.
Suppose that the public parameters are (N, ε, V1, V2, V3, e, g, s, c, g1, g2, g3, q, h1, h2, h3, h4,
h5, h6), and R’s data collection policy is the equation ΦR(x1, x2) = 1 , αx1 + β = x2 :
(α, β) 2 Z.
In the Credential Proving phase, the adversary A interacts with R anonymously and

unlinkably as follows.

1. Session values and commitments: A picks y 2R Ze, ˆv, a 2R Z∗

N and w, w1, w3 2R

ZN . Then, it computes

−(cid:12)
(cid:15) ˆa = g
2 ae (mod N )
(cid:15) ¯m = h ^m
1 hw1
2
(cid:15) ¯b = h^b
5hw3
6
(cid:15) ¯c = (h1h3)^a(h1h5)w (mod q)

(mod q), where ˆm = ˆv" (mod N )

(mod q), where ˆb = gyc (mod N )

A sends and commits the session values (ˆa, ¯m, ¯b, ¯c) to R.

2. Zero-Knowledge Proofs of Knowledge(ZKPoKs): once A has committed its

session values, A and R engage in ZKPoK1-4 as follows.
′

′
′
′
1gs
y (g1g(cid:11)
2 )s
(mod N ).
3
to R. After receiving γ from R, A computes s
′
3
= a(cid:13) (mod N ),
′
y, s

2R Z∗
) to R.

e, and computes t

= gs

′

Then, it sends t
and then sends (s

(cid:15) ZKPoK1: A picks s
′
′
′
y, s
1, s
3
′
′
′
3, s
1, s
−(cid:12)
2 ae (mod N ), t
Correctness: Since ˆa = g
a(cid:13) (mod N ), we have that

(mod N ) and s

′
= gs
y (g1g(cid:11)

′
′
1gs
2 )s
3
3

′

=

′

−(cid:12)
2 )(cid:13)t

(ˆag

′

−(cid:12)
2 )(cid:13)t

′

−(cid:12)
2 ae)g
= ((g
′
= ae(cid:13)t
= ae(cid:13)gs
′
= gs
y (g1g(cid:11)

′
′
′
1gs
2 )s
y (g1g(cid:11)
3
3
′
′
′
1gs
e
2 )s
3 s
3

(mod N )

Hence, ZKPoK1 is preformed successfully.

6

′
(cid:15) ZKPoK2: A picks s
= hs
2 hs
1
to R. After receiving γ from R, A computes s
′
3) to R.
^b
′

2R Z, and computes t
′

it sends t
′
′
′
1, s
(s
2, s
^b

′
2, s

′
1, s

, s

′
3

′

′
3
6

′
4 hs
(mod q). Then,
2
= wγ, and then sends

′

= hs

′
2 hs
1

′
4 hs
2

′
3
6

(mod q) and

Correctness: Since ¯c = (h1h3)^a(h1h5)w (mod q), t
′
s
^b

= wγ, we have that

(¯c(h1h3)

−^a)(cid:13)t

′

−^a)(cid:13)t

′

= ((h1h3)^a(h1h5)w(h1h3)
′
= (h1h5)w(cid:13)t
′
′
′
4 hs
= (h1h5)w(cid:13)hs
2 hs
3
2
1
6
′
′
′
′
2 hs
^bhs
4 hs
= (h1h5)s
3
2
1
6

(mod q)

Hence, ZKPoK2 is preformed successfully.

(cid:15) ZKPoK3: A picks r

′
1, r

′
2

2R ZN and computes t

′

′

to R. After receiving γ 2 f0, 1g from R, A performs as follows.

sends t

′
"
1 hr
1

′
2
2

= hr

(mod q). Then, it

′
′
1 and s
2 = r
′
1ˆv

′
′
−1 (mod N ) and s
2 = r
2

′
2.

(cid:0) w1(r

′
1ˆv

−1)" (mod N )

′
1 = r
(a) if γ = 0, let s
′
(b) if γ = 1, let s
1 = r
2) to R.
A sends (s
′
′
1, s
′
Correctness: Since t
(mod N ), we have that
′
"
1 hr
1

= hr

(a) if γ = 0, t
(b) if γ = 1, we have that

= hr

′

′
"
1 hr
1

′
2
2

′
2 = hs
2

′
"
1 hs
1

′
2
2

(mod q)

(mod q) and ¯m = h ^m

1 hw1
2

(mod q), where ˆm = ˆv"

"

"

′
′
′
′
1 hs
1 hs
1 hw1
2 )s
¯ms
2 = (h ^m
2
2
2
′
−1)"hr
1 hw1
1 ^v
2 )(r
= (h ^m
′
−1)"hr
′
1 ^v
1 )(r
= (h ^m
2
2
′
′
−1)"hr
= (h^v"
1 )(r
1 ^v
2
2
′
′
"
1 hr
= hr
2
1
′
2
= t

(mod q)

′
2
2

Hence, ZKPoK3 is preformed successfully.

−w1(r

′
1 ^v

−1)"

(cid:15) ZKPoK4: A picks r

′
1, r

′
2

2R ZN and computes t

′

′

to R. After receiving γ 2 f0, 1g from R, A performs as follows.

sends t

= hgr

′
5 hr
1

′
2
6

(mod q). Then, it

(cid:0) w3c

−1gs
′
1

′
2

′
′
′
′
1 = r
2 = r
1 and s
(a) if γ = 0, let s
2.
(cid:0) y and s
′
′
′
(b) if γ = 1, let s
1 = r
2 = r
1
2) to R.
A sends (s
′
′
1, s
′
Correctness: Since t
(mod N ), we have that
′
5 hr
1

′
′
6 = hgs
5 hs
1
2

(a) if γ = 0, t
(b) if γ = 1, we have that

′
5 hr
1

= hgr

= hgr

′
2
6

′
2
6

′

(mod q)

(mod q) and ¯b = h^b

5hw3
6

(mod q), where ˆb = gyc

7

Insecurity of An Anonymous Authentication For
Privacy-preserving IoT Target-driven Applications

Xi-Jun Lin

∗
and Lin Sun

†

November 28, 2013

Abstract: The Internet of Things (IoT) will be formed by smart objects and services
interacting autonomously and in real-time. Recently, Alcaide et al. proposed a fully decen-
tralized anonymous authentication protocol for privacy-preserving IoT target-driven appli-
cations. Their system is set up by an ad-hoc community of decentralized founding nodes.
Nodes can interact, being participants of cyberphysical systems, preserving full anonymity.
In this study, we point out that their protocol is insecure. The adversary can cheat the
data collectors by impersonating a legitimate user.

Key words: Anonymous credential system; Fully decentralized protocol; Threshold

cryptography; Zero-knowledge proof of knowledge; Smart community

1 Introduction

The Internet of Things (IoT) will be formed by smart objects and services interacting
autonomously and in real-time. Recently, Alcaide et al. [1] proposed a fully decentralized
anonymous authentication protocol for privacy-preserving IoT target-driven applications.
Their system is set up by an ad-hoc community of decentralized founding nodes. Nodes
can interact, being participants of cyberphysical systems, preserving full anonymity.

In Alcaide et al.’s protocol, two roles are deﬁned for participant nodes: Users and Data
Collectors. Users are the nodes originating the data. They can anonymously and unlinkably
authenticate themselves in front of data collectors proving possession of a valid Anonymous
Access Credential (AAC) encoding a particular set of attributes. Data collectors are entities
responsible for the collection of data from authorized users. Therefore, before collecting the
data, the data collector must verify that the user holds a valid AAC encoding a particular
set of attributes.

The main characteristics of their protocol are:
(cid:15) The protocol does not rely on any central organization.
(cid:15) The users of the system jointly generate and distribute a private key that is used in
a (t, n)-threshold fashion. This allows up to t nodes to be compromised without the
key being compromised.

∗

X.J.Lin is with the Department of Computer Sciences and Technology, Ocean University of China.

Qingdao 266100, P.R.China. email: linxj77@163.com

†

L. Sun is with the College of Liberal Arts, Qingdao University. Qingdao 266071, P.R.China. email:

sunlin9@126.com

1

(cid:15) Users of the system can obtain an AAC encoding a set of certiﬁed attributes and
use such an AAC to anonymously and unlinkably authenticate themselves to data
collector entities.

(cid:15) Data collectors can anonymously authenticate users by means of attribute-based
boolean formulas, which can be deﬁned and modiﬁed by the data collector itself at
any time.

Without loss of generality, their protocol is described assuming that users are authenti-
cated based on only two attributes (x1, x2), which can be derived from a standard certiﬁcate
˜x signed by some trusted external entity (i.e., a certiﬁcation authority). In the protocol,
once veriﬁed, the attributes (x1, x2) will be encoded into an AAC so that the user can prove
possession of those attributes without disclosing their actual value.

Any linear boolean formula (or a conjunction of formulas) can be used to anonymously
authenticate users as legitimate participants. Such a formula can be represented as the
function ΦR(x1, x2). As mentioned before, users can prove that the attributes x1 and x2,
encoded in a AAC, satisfy ΦR(x1, x2) = 1 without revealing the actual attribute values.

In this study, we point out that their protocol is insecure. The adversary can cheat the

data collectors by impersonating a legitimate user.

2 Alcaide et al.’s Protocol

Their protocol consists of three phases: Set-Up (where all parameters are generated),
User Registration (users obtain AAC) and Credential Proving (users prove possession of a
valid AAC to a data collector).

2.1 Set-Up

In this phase, a community of n users, fUi : i = 1,(cid:1)(cid:1)(cid:1) , ng, known as founders, comes
together to generate all protocol parameters. As a result of this phase, each founder Ui

holds two tuples:

(cid:15) a public tuple:

P ubi = (N, ε, V1, V2, V3, e, g, s, c, g1, g2, g3, q, h1, h2, h3, h4, h5, h6)

equal for all founders.

(cid:15) a private tuple:

P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i)

diﬀerent for each founder Ui.

(N, ε, V1, V2, V3, d, v1, v2, v3) are generated by the founders in a joint and decentralized
manner, where d = ε
(mod ϕ(N )) and N = 4p1p2 +
2p1 + 2p2 + 1 such that (p1, p2) are Sophie Germain primes. q is a prime picked by a

−1
, v2 = V
2

, v3 = V

−1, v1 = V

−1
1

−1
3

2

super node such that Nj(q (cid:0) 1). (e, g, c, h1,(cid:1)(cid:1)(cid:1) , h6) are picked by the super node randomly
and broadcasted to the founders. s = gd, g1 = gv
3 (mod N ) are also
broadcasted by the super node so that every founder holds them.
P rivi = (p1i, p2i, ϕi(N ), di, v1i, v2i, v3i) are shares that the founder Ui holds of the secret

1, g2 = gv

2, g3 = gv

values (p1, p2, ϕ(N ), d, v1, v2, v3) respectively.

At the end of this phase, the founders have computed the necessary cryptographic ma-

terial to create AACs for valid data holders later on.

The detail of this phase which has nothing to do with our attack is omitted here.

2.2 User Registration

In this phase, a new user Unew, holding a valid certiﬁcate ˜x, obtains the necessary material
from (t + 1) founders to construct its own Anonymous Access Credential AACnew, a token
that encodes Unew’s attributes (x1, x2) 2 Ze and allows Unew to anonymously and unlinkably
prove to the data collector to be a legitimate participant. Before Unew can participate in
the system, it needs to obtain the protocol public parameters. In order to do that, Unew
simply requests the tuple P ubi from some founder Ui and makes P ubnew = P ubi.
The process that Unew must follow to construct AACnew is described as follows.
(cid:15) Unew picks x3 2R Z∗

e such that gcd(x3, ε) = 1 and x 2R Z∗

3 xe (mod N ). Then, it picks b (cid:17) c (mod N ) randomly, and then sends (˜x, a

N , and then computes
, b)

′

= gx3

′
a
to the founders.

′

, b), each founder Ui veriﬁes ˜x and extracts the attributes (x1, x2)

(cid:15) After receiving (˜x, a
from ˜x. Then, it computes a = gx1
thermore, it signs m with its private tuple P rivi and sends σi(m) to Unew.
(cid:15) After receiving (t + 1) partial signatures σi(m) from the founders, Unew generates

(mod N ) and m = (a + b) (mod N ). Fur-

′
1 gx2
2 a

the signature v = σ(m). Then,
(mod N ) and m =
(a + b) (mod N ), and then checks whether the equation v" = m (mod N ) holds.
If the equation holds, Unew obtains its own Anonymous Access Credential AACnew =
(x1, x2, x3, x, v).

it computes a = gx1

1 gx2
2 a

′

AACnew must be kept secretly at all times, only randomized versions of it will be used
in the Credential Proving phase. It should be noted that Unew must show its certiﬁcate to

the founders.

2.3 Credential Proving

When a user U interacts with a data collector R, U must anonymously and unlinkably
prove to R that it holds the appropriate attributes to satisfy the boolean formula ΦR that
R uses to authenticate legitimate participants.
As the process that U must follow to accomplish such a proof is the key part of the

anonymous credential system. Each of the sub-processes is given as follows.

1. Session values and commitments: every time that U wants to authenticate to
the data collector R, U must generate and commit a set of session values, which are
secret random values used during a particular authentication operation. This process
is given as follows.

3

(a) U picks y 2R Ze, and then computes

ˆv = syv
(mod N )
ˆm = gym (mod N )
ˆa = gya (mod N )
ˆb = gyb
(mod N )

Then, it picks w1, w2, w3 2 ZN and computes

1 hw1
¯m = h ^m
2
3hw2
¯a = h^a
4
¯b = h^b
5hw3
6
¯c = ¯m¯a¯b

(mod q)
(mod q)
(mod q)

(mod q)

(In the original paper, ¯a = h^a
Theorem 2 [1], we correct this typo by replacing it with ¯a = h^a

(b) U sends and commits the session values (ˆa, ¯m, ¯b, ¯c) to R.

2hw2
3

(mod q). According to the Appendix A.2-

3hw2
4

(mod q).)

2. Zero-Knowledge Proofs of Knowledge (ZKPoKs): once U has committed some
set of values, U and R engage in a series of four ZKPoKs:
In order to authenticate U, every operation that R performs at the end of each ZKPoK
must succeed. Whatever data R collects from U must follow these authentication sub-
process.

(cid:15) ZKPoK1: The objective of this ZKPoK is to prove that the private attributes
(x1, x2) that U holds in its AAC satisfy the boolean formula ΦR(x1, x2). Note
that ΦR can be any linear boolean formula; however, for simplicity reasons, as
an example, the authors use:

ΦR(x1, x2) = 1 , αx1 + β = x2 : (α, β) 2 Z

α, β being chosen by data collector R.
Consequently, U must prove, in a zero-knowledge manner, possession of AAC
encoding attributes (x1, x2) such that αx1 + β = x2. This ZKPoK is given as
follows.
{ U picks r
′
y, r
′
′
1gr
2 )r
y (g1g(cid:11)
{ R picks and responds γ 2R Z2t to U.
{ U computes

2R Ze and r
′
3
e (mod N ) to R.

N , then computes and sends t

′ 2R Z∗

′
1, r
′
′
3 r
3

gr

=

′

2 )((cid:13)x1+r

′
1)diveg((cid:13)x3+r

3

′
3)dive

′

x(cid:13)r

(mod N )

{ R checks whether the equation (ˆag

−(cid:12)
2 )(cid:13)t

′

′
= gs
y (g1g(cid:11)

2 )s

′

′
1gs

′
3 s
3

e (mod N ) hold-

′
′
y = γy + r
s
′
′
y
s
1 = γx1 + r
′
′
1
3 = γx3 + r
s
3
′
′
y)dive(g1g(cid:11)
= g((cid:13)y+r
s
) to R.
′
′
y, s
It sends (s

(mod e)
(mod e)
(mod e)

′
3, s

′
1, s

s.

4

(cid:15) ZKPoK2: The goal of this ZKPoK is to prove that all session value commitments
generated by U are valid. For that matter, U must prove, in a zero-knowledge
manner, knowledge of the secret tuple (y, ˆa, ˆb, ˆm). This ZKPoK is given as fol-
lows.
{ U picks r
{ R picks and responds γ 2R Zq to U.
{ U computes

2R Zq. Then, it computes and sends t

′
1, r
(mod q) to R.

= (h1h5)r

′
2 hr
1

′
2, r

′
^bhr

, r

′
^b

′
3

′

′
4 hr
2

′
3
6

′
′
= γˆb + r
s
^b
^b
′
′
1 = γw1 + r
s
′
′
1
2 = γw2 + r
s
′
′
2
3 = γw3 + r
s
3

, s

holds.

′
1, s

′
2, s

′
1, s

′
3, s

′

) is sent to

3) to R. (In the original paper, (s
′
′
′
It sends (s
y, s
R, we correct this typo by replacing it with (s
^b
′
′
′
′
1, s
2, s
, s
3).)
^b
′
′
′
−^a)(cid:13)t
2 hs
^bhs
= (h1h5)s
1

{ R checks whether the equation (¯c(h1h3)

(mod q)
(cid:15) ZKPoK3: The objective of this ZKPoK is to prove that the signature v encoded
in U’s AAC is valid. In order to do that, U proves, in a zero-knowledge manner,
knowledge of the ε-th root of the h1-part, which is equivalent to proving that ˆv
is the ε-th root of ˆm. This ZKPoK given below must be executed L times.
{ U picks r
{ R picks and responds γ 2R f0, 1g to U.
{ U preforms as follows.

2R ZN . Then, it computes and sends t

′
"
1 hr
1

(mod q) to

′
4 hs
2

= hr

′
1, r

R.

′
3
6

′
2
2

′
2

′

−1 (mod N ) and s

′
′
2 = r
2

(cid:0) w1(r
′
1ˆv

−1)"

′
1 = r

′
′
′
2.
2 = r
1 and s
If γ = 0, let s
′
′
If γ = 1, it computes s
1 = r
1ˆv
(mod N ).
U sends (s
′
1, s

2) to R.
′
{ R performs as follows.

′
If γ = 0, it checks whether the equation t
′
If γ = 1, it checks whether the equation t

′
"
1 hs
1
′
"
1 hs
1

′
2
2
′
2
2

= hs
= ¯ms

(mod q) holds.

(mod q) holds.

(cid:15) ZKPoK4: The goal of this ZKPoK is to prove that U knows the session value
y involved in ZKPoK1 - 3. For that matter, U must prove, in a zero-knowledge
manner, knowledge of the discrete logarithm with base g of the h5-part. This
ZKPoK given below must be executed L times.
{ U picks r

2R ZN . Then, it computes and sends t
′

′
5 hr
1

(mod q) to
, we correct this typo by

is used to compute t

= hgr

′
1, r

′
2
6

′
2

′

′

R. (In the original paper, g
replacing it with g.)
{ R picks and responds γ 2R f0, 1g to U.
{ U preforms as follows.

If γ = 0, let s
If γ = 1, it computes s
U sends (s
′
1, s

′
1 = r
2) to R.
′

′
′
2 = r
1 and s

′
′
1 = r
1

′
2.
(cid:0) y and s
′
′
2 = r
2

(cid:0) w3c

−1gs

′
1.

5

{ R performs as follows.

If γ = 0, it checks whether the equation t
original paper, g
it with g.)

(mod q) holds. (In the
is used in the equation, we correct this typo by replacing

′

′
If γ = 1, it checks whether the equation t

= (¯bc

′
′
−1)gs
1 hs
2
6

(mod q) holds.

′

′
′
= hgs
5 hs
1
2
6

Note that, if and only if the authentication of user U succeeds (i.e., all ZKPoK1 - 4
are successful), the data collector R collects data from U.

3 Cryptanalysis

In this section, we present an attack to point out that an adversary A can cheat the data
collector by impersonating a legitimate user. In our attack, A needs not compromise user
nodes.
It should be noted that if and only if A processes all ZKPoK1-4 with a data collector R
successfully, A can cheat R into collecting data from it.
Suppose that the public parameters are (N, ε, V1, V2, V3, e, g, s, c, g1, g2, g3, q, h1, h2, h3, h4,
h5, h6), and R’s data collection policy is the equation ΦR(x1, x2) = 1 , αx1 + β = x2 :
(α, β) 2 Z.
In the Credential Proving phase, the adversary A interacts with R anonymously and

unlinkably as follows.

1. Session values and commitments: A picks y 2R Ze, ˆv, a 2R Z∗

N and w, w1, w3 2R

ZN . Then, it computes

−(cid:12)
(cid:15) ˆa = g
2 ae (mod N )
(cid:15) ¯m = h ^m
1 hw1
2
(cid:15) ¯b = h^b
5hw3
6
(cid:15) ¯c = (h1h3)^a(h1h5)w (mod q)

(mod q), where ˆm = ˆv" (mod N )

(mod q), where ˆb = gyc (mod N )

A sends and commits the session values (ˆa, ¯m, ¯b, ¯c) to R.

2. Zero-Knowledge Proofs of Knowledge(ZKPoKs): once A has committed its

session values, A and R engage in ZKPoK1-4 as follows.
′

′
′
′
1gs
y (g1g(cid:11)
2 )s
(mod N ).
3
to R. After receiving γ from R, A computes s
′
3
= a(cid:13) (mod N ),
′
y, s

2R Z∗
) to R.

e, and computes t

= gs

′

Then, it sends t
and then sends (s

(cid:15) ZKPoK1: A picks s
′
′
′
y, s
1, s
3
′
′
′
3, s
1, s
−(cid:12)
2 ae (mod N ), t
Correctness: Since ˆa = g
a(cid:13) (mod N ), we have that

(mod N ) and s

′
= gs
y (g1g(cid:11)

′
′
1gs
2 )s
3
3

′

=

′

−(cid:12)
2 )(cid:13)t

(ˆag

′

−(cid:12)
2 )(cid:13)t

′

−(cid:12)
2 ae)g
= ((g
′
= ae(cid:13)t
= ae(cid:13)gs
′
= gs
y (g1g(cid:11)

′
′
′
1gs
2 )s
y (g1g(cid:11)
3
3
′
′
′
1gs
e
2 )s
3 s
3

(mod N )

Hence, ZKPoK1 is preformed successfully.

6

′
(cid:15) ZKPoK2: A picks s
= hs
2 hs
1
to R. After receiving γ from R, A computes s
′
3) to R.
^b
′

2R Z, and computes t
′

it sends t
′
′
′
1, s
(s
2, s
^b

′
2, s

′
1, s

, s

′
3

′

′
3
6

′
4 hs
(mod q). Then,
2
= wγ, and then sends

′

= hs

′
2 hs
1

′
4 hs
2

′
3
6

(mod q) and

Correctness: Since ¯c = (h1h3)^a(h1h5)w (mod q), t
′
s
^b

= wγ, we have that

(¯c(h1h3)

−^a)(cid:13)t

′

−^a)(cid:13)t

′

= ((h1h3)^a(h1h5)w(h1h3)
′
= (h1h5)w(cid:13)t
′
′
′
4 hs
= (h1h5)w(cid:13)hs
2 hs
3
2
1
6
′
′
′
′
2 hs
^bhs
4 hs
= (h1h5)s
3
2
1
6

(mod q)

Hence, ZKPoK2 is preformed successfully.

(cid:15) ZKPoK3: A picks r

′
1, r

′
2

2R ZN and computes t

′

′

to R. After receiving γ 2 f0, 1g from R, A performs as follows.

sends t

′
"
1 hr
1

′
2
2

= hr

(mod q). Then, it

′
′
1 and s
2 = r
′
1ˆv

′
′
−1 (mod N ) and s
2 = r
2

′
2.

(cid:0) w1(r

′
1ˆv

−1)" (mod N )

′
1 = r
(a) if γ = 0, let s
′
(b) if γ = 1, let s
1 = r
2) to R.
A sends (s
′
′
1, s
′
Correctness: Since t
(mod N ), we have that
′
"
1 hr
1

= hr

(a) if γ = 0, t
(b) if γ = 1, we have that

= hr

′

′
"
1 hr
1

′
2
2

′
2 = hs
2

′
"
1 hs
1

′
2
2

(mod q)

(mod q) and ¯m = h ^m

1 hw1
2

(mod q), where ˆm = ˆv"

"

"

′
′
′
′
1 hs
1 hs
1 hw1
2 )s
¯ms
2 = (h ^m
2
2
2
′
−1)"hr
1 hw1
1 ^v
2 )(r
= (h ^m
′
−1)"hr
′
1 ^v
1 )(r
= (h ^m
2
2
′
′
−1)"hr
= (h^v"
1 )(r
1 ^v
2
2
′
′
"
1 hr
= hr
2
1
′
2
= t

(mod q)

′
2
2

Hence, ZKPoK3 is preformed successfully.

−w1(r

′
1 ^v

−1)"

(cid:15) ZKPoK4: A picks r

′
1, r

′
2

2R ZN and computes t

′

′

to R. After receiving γ 2 f0, 1g from R, A performs as follows.

sends t

= hgr

′
5 hr
1

′
2
6

(mod q). Then, it

(cid:0) w3c

−1gs
′
1

′
2

′
′
′
′
1 = r
2 = r
1 and s
(a) if γ = 0, let s
2.
(cid:0) y and s
′
′
′
(b) if γ = 1, let s
1 = r
2 = r
1
2) to R.
A sends (s
′
′
1, s
′
Correctness: Since t
(mod N ), we have that
′
5 hr
1

′
′
6 = hgs
5 hs
1
2

(a) if γ = 0, t
(b) if γ = 1, we have that

′
5 hr
1

= hgr

= hgr

′
2
6

′
2
6

′

(mod q)

(mod q) and ¯b = h^b

5hw3
6

(mod q), where ˆb = gyc

7

−w3c

′
−1gs
1

−1)gs

(¯bc

′
′
1 hs
6 = ((h^b
2
= ((h^b
^bc
5

′
′
−1)gs
1 hs
5hw3
6 )c
2
6
′
′
−1)gs
1 hr
5hw3
6 )c
2
6
′
′
−1gs
hr
1
2
6
′
−1gs
1
′
hr
2
6
′
−y)
1
′
2
6

′
hr
2
6

′
hr
2
6

(mod q)

5

= h
= h(gyc)c
′
= hgygs
1
= hgy+(r
5
′
= hgr
5 hr
1
= t

5

′

Hence, ZKPoK4 is preformed successfully.

Since all ZKPoK1-4 are successful, R authenticates the adversary A as a legitimate
user, and then collects data from it. Hence, the protocol is broken.

2

′

Another main ﬂaw of Alcaide et al.’s protocol is given below.

In User Registration phase, since the new user Unew sends its certiﬁcate ˜x in plaintext
to the founders, ˜x can be captured by A. Then, A sends (˜x, a
, b) to the founders by
impersonating Unew, where a
and b are computed by A itself. Since the founders are user
nodes, it is reasonable to assume that they are stateless. Hence, they do not know whether
˜x belongs to a user who has already received its AAC. So A can obtain (t + 1) partial
signatures from the founders, then it can construct a valid AAC. That is, once a user’s
certiﬁcate is sent in plaintext in User Registration phase, the adversary A can obtain this
certiﬁcate and forge a valid AAC by impersonating this user. With this AAC, A can cheat
the data collectors in Credentail Proving phase.

2

′

4 Conclusion

Recently, Alcaide et al. proposed a fully decentralized anonymous authentication pro-
tocol for privacy-preserving IoT target-driven applications. Their system is set up by an
ad-hoc community of decentralized founding nodes. Nodes can interact, being participants
of cyberphysical systems, preserving full anonymity. In this study, we point out that their
protocol is insecure. The adversary can cheat the data collectors by impersonating a legit-
imate user.

References

[1] A.Alcaide, E.Palomar, J.Montero-Castillo and A.Ribagorda. Anonymous authentication
for privacy-preserving IoT target-driven applications. Computers & Security. 37 (2013).
pp:111-123.

8

